schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

type AffectedAssignment {
  adjusted_eft_date: String!
  id: String!
  new_consultant_id: String!
  original_consultant_id: String!
  payroll_date_id: String!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type CommitPayrollAssignmentsOutput {
  affected_assignments: [AffectedAssignment!]
  errors: [String!]
  message: String
  success: Boolean!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input PayrollAssignmentInput {
  date: String!
  fromConsultantId: String!
  payrollId: String!
  toConsultantId: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Scalar _Any"""
scalar _Any

"""A union of all types that use the @key directive"""
union _Entity = adjustment_rules | client_external_systems | clients | external_systems | holidays | leave | notes | payroll_cycles | payroll_date_types | payroll_dates | payrolls | users | work_schedule

type _Service {
  """SDL representation of schema"""
  sdl: String!
}

"""
columns and relationships of "adjustment_rules"
"""
type adjustment_rules {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid!

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid!

  """Unique identifier for the adjustment rule"""
  id: uuid!

  """An object relationship"""
  payroll_cycle: payroll_cycles!

  """An object relationship"""
  payroll_date_type: payroll_date_types!

  """Code/formula used to calculate date adjustments"""
  rule_code: String!

  """Human-readable description of the adjustment rule"""
  rule_description: String!

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "adjustment_rules"
"""
type adjustment_rules_aggregate {
  aggregate: adjustment_rules_aggregate_fields
  nodes: [adjustment_rules!]!
}

input adjustment_rules_aggregate_bool_exp {
  count: adjustment_rules_aggregate_bool_exp_count
}

input adjustment_rules_aggregate_bool_exp_count {
  arguments: [adjustment_rules_select_column!]
  distinct: Boolean
  filter: adjustment_rules_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "adjustment_rules"
"""
type adjustment_rules_aggregate_fields {
  count(columns: [adjustment_rules_select_column!], distinct: Boolean): Int!
  max: adjustment_rules_max_fields
  min: adjustment_rules_min_fields
}

"""
order by aggregate values of table "adjustment_rules"
"""
input adjustment_rules_aggregate_order_by {
  count: order_by
  max: adjustment_rules_max_order_by
  min: adjustment_rules_min_order_by
}

"""
input type for inserting array relation for remote table "adjustment_rules"
"""
input adjustment_rules_arr_rel_insert_input {
  data: [adjustment_rules_insert_input!]!

  """upsert condition"""
  on_conflict: adjustment_rules_on_conflict
}

"""
Boolean expression to filter rows from the table "adjustment_rules". All fields are combined with a logical 'AND'.
"""
input adjustment_rules_bool_exp {
  _and: [adjustment_rules_bool_exp!]
  _not: adjustment_rules_bool_exp
  _or: [adjustment_rules_bool_exp!]
  created_at: timestamptz_comparison_exp
  cycle_id: uuid_comparison_exp
  date_type_id: uuid_comparison_exp
  id: uuid_comparison_exp
  payroll_cycle: payroll_cycles_bool_exp
  payroll_date_type: payroll_date_types_bool_exp
  rule_code: String_comparison_exp
  rule_description: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "adjustment_rules"
"""
enum adjustment_rules_constraint {
  """
  unique or primary key constraint on columns "date_type_id", "cycle_id"
  """
  adjustment_rules_cycle_id_date_type_id_key

  """
  unique or primary key constraint on columns "id"
  """
  adjustment_rules_pkey
}

"""
input type for inserting data into table "adjustment_rules"
"""
input adjustment_rules_insert_input {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid
  payroll_cycle: payroll_cycles_obj_rel_insert_input
  payroll_date_type: payroll_date_types_obj_rel_insert_input

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type adjustment_rules_max_fields {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "adjustment_rules"
"""
input adjustment_rules_max_order_by {
  """Timestamp when the rule was created"""
  created_at: order_by

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: order_by

  """Reference to the payroll date type this rule affects"""
  date_type_id: order_by

  """Unique identifier for the adjustment rule"""
  id: order_by

  """Code/formula used to calculate date adjustments"""
  rule_code: order_by

  """Human-readable description of the adjustment rule"""
  rule_description: order_by

  """Timestamp when the rule was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type adjustment_rules_min_fields {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "adjustment_rules"
"""
input adjustment_rules_min_order_by {
  """Timestamp when the rule was created"""
  created_at: order_by

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: order_by

  """Reference to the payroll date type this rule affects"""
  date_type_id: order_by

  """Unique identifier for the adjustment rule"""
  id: order_by

  """Code/formula used to calculate date adjustments"""
  rule_code: order_by

  """Human-readable description of the adjustment rule"""
  rule_description: order_by

  """Timestamp when the rule was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "adjustment_rules"
"""
type adjustment_rules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [adjustment_rules!]!
}

"""
on_conflict condition type for table "adjustment_rules"
"""
input adjustment_rules_on_conflict {
  constraint: adjustment_rules_constraint!
  update_columns: [adjustment_rules_update_column!]! = []
  where: adjustment_rules_bool_exp
}

"""Ordering options when selecting data from "adjustment_rules"."""
input adjustment_rules_order_by {
  created_at: order_by
  cycle_id: order_by
  date_type_id: order_by
  id: order_by
  payroll_cycle: payroll_cycles_order_by
  payroll_date_type: payroll_date_types_order_by
  rule_code: order_by
  rule_description: order_by
  updated_at: order_by
}

"""primary key columns input for table: adjustment_rules"""
input adjustment_rules_pk_columns_input {
  """Unique identifier for the adjustment rule"""
  id: uuid!
}

"""
select columns of table "adjustment_rules"
"""
enum adjustment_rules_select_column {
  """column name"""
  created_at

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  id

  """column name"""
  rule_code

  """column name"""
  rule_description

  """column name"""
  updated_at
}

"""
input type for updating data in table "adjustment_rules"
"""
input adjustment_rules_set_input {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "adjustment_rules"
"""
input adjustment_rules_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: adjustment_rules_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input adjustment_rules_stream_cursor_value_input {
  """Timestamp when the rule was created"""
  created_at: timestamptz

  """Reference to the payroll cycle this rule applies to"""
  cycle_id: uuid

  """Reference to the payroll date type this rule affects"""
  date_type_id: uuid

  """Unique identifier for the adjustment rule"""
  id: uuid

  """Code/formula used to calculate date adjustments"""
  rule_code: String

  """Human-readable description of the adjustment rule"""
  rule_description: String

  """Timestamp when the rule was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "adjustment_rules"
"""
enum adjustment_rules_update_column {
  """column name"""
  created_at

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  id

  """column name"""
  rule_code

  """column name"""
  rule_description

  """column name"""
  updated_at
}

input adjustment_rules_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: adjustment_rules_set_input

  """filter the rows which have to be updated"""
  where: adjustment_rules_bool_exp!
}

"""
columns and relationships of "app_settings"
"""
type app_settings {
  """Unique identifier for application setting"""
  id: String!

  """JSON structure containing application permission configurations"""
  permissions(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "app_settings"
"""
type app_settings_aggregate {
  aggregate: app_settings_aggregate_fields
  nodes: [app_settings!]!
}

"""
aggregate fields of "app_settings"
"""
type app_settings_aggregate_fields {
  count(columns: [app_settings_select_column!], distinct: Boolean): Int!
  max: app_settings_max_fields
  min: app_settings_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input app_settings_append_input {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Boolean expression to filter rows from the table "app_settings". All fields are combined with a logical 'AND'.
"""
input app_settings_bool_exp {
  _and: [app_settings_bool_exp!]
  _not: app_settings_bool_exp
  _or: [app_settings_bool_exp!]
  id: String_comparison_exp
  permissions: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "app_settings"
"""
enum app_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input app_settings_delete_at_path_input {
  """JSON structure containing application permission configurations"""
  permissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input app_settings_delete_elem_input {
  """JSON structure containing application permission configurations"""
  permissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input app_settings_delete_key_input {
  """JSON structure containing application permission configurations"""
  permissions: String
}

"""
input type for inserting data into table "app_settings"
"""
input app_settings_insert_input {
  """Unique identifier for application setting"""
  id: String

  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""aggregate max on columns"""
type app_settings_max_fields {
  """Unique identifier for application setting"""
  id: String
}

"""aggregate min on columns"""
type app_settings_min_fields {
  """Unique identifier for application setting"""
  id: String
}

"""
response of any mutation on the table "app_settings"
"""
type app_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [app_settings!]!
}

"""
on_conflict condition type for table "app_settings"
"""
input app_settings_on_conflict {
  constraint: app_settings_constraint!
  update_columns: [app_settings_update_column!]! = []
  where: app_settings_bool_exp
}

"""Ordering options when selecting data from "app_settings"."""
input app_settings_order_by {
  id: order_by
  permissions: order_by
}

"""primary key columns input for table: app_settings"""
input app_settings_pk_columns_input {
  """Unique identifier for application setting"""
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input app_settings_prepend_input {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
select columns of table "app_settings"
"""
enum app_settings_select_column {
  """column name"""
  id

  """column name"""
  permissions
}

"""
input type for updating data in table "app_settings"
"""
input app_settings_set_input {
  """Unique identifier for application setting"""
  id: String

  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Streaming cursor of the table "app_settings"
"""
input app_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: app_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input app_settings_stream_cursor_value_input {
  """Unique identifier for application setting"""
  id: String

  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
update columns of table "app_settings"
"""
enum app_settings_update_column {
  """column name"""
  id

  """column name"""
  permissions
}

input app_settings_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: app_settings_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: app_settings_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: app_settings_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: app_settings_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: app_settings_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: app_settings_set_input

  """filter the rows which have to be updated"""
  where: app_settings_bool_exp!
}

"""
columns and relationships of "billing_event_log"
"""
type billing_event_log {
  """An object relationship"""
  billing_invoice: billing_invoice
  created_at: timestamptz
  created_by: uuid
  event_type: String!
  id: uuid!
  invoice_id: uuid
  message: String

  """An object relationship"""
  user: users
}

"""
aggregated selection of "billing_event_log"
"""
type billing_event_log_aggregate {
  aggregate: billing_event_log_aggregate_fields
  nodes: [billing_event_log!]!
}

input billing_event_log_aggregate_bool_exp {
  count: billing_event_log_aggregate_bool_exp_count
}

input billing_event_log_aggregate_bool_exp_count {
  arguments: [billing_event_log_select_column!]
  distinct: Boolean
  filter: billing_event_log_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_event_log"
"""
type billing_event_log_aggregate_fields {
  count(columns: [billing_event_log_select_column!], distinct: Boolean): Int!
  max: billing_event_log_max_fields
  min: billing_event_log_min_fields
}

"""
order by aggregate values of table "billing_event_log"
"""
input billing_event_log_aggregate_order_by {
  count: order_by
  max: billing_event_log_max_order_by
  min: billing_event_log_min_order_by
}

"""
input type for inserting array relation for remote table "billing_event_log"
"""
input billing_event_log_arr_rel_insert_input {
  data: [billing_event_log_insert_input!]!

  """upsert condition"""
  on_conflict: billing_event_log_on_conflict
}

"""
Boolean expression to filter rows from the table "billing_event_log". All fields are combined with a logical 'AND'.
"""
input billing_event_log_bool_exp {
  _and: [billing_event_log_bool_exp!]
  _not: billing_event_log_bool_exp
  _or: [billing_event_log_bool_exp!]
  billing_invoice: billing_invoice_bool_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  event_type: String_comparison_exp
  id: uuid_comparison_exp
  invoice_id: uuid_comparison_exp
  message: String_comparison_exp
  user: users_bool_exp
}

"""
unique or primary key constraints on table "billing_event_log"
"""
enum billing_event_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_event_log_pkey
}

"""
input type for inserting data into table "billing_event_log"
"""
input billing_event_log_insert_input {
  billing_invoice: billing_invoice_obj_rel_insert_input
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
  user: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type billing_event_log_max_fields {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
order by max() on columns of table "billing_event_log"
"""
input billing_event_log_max_order_by {
  created_at: order_by
  created_by: order_by
  event_type: order_by
  id: order_by
  invoice_id: order_by
  message: order_by
}

"""aggregate min on columns"""
type billing_event_log_min_fields {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
order by min() on columns of table "billing_event_log"
"""
input billing_event_log_min_order_by {
  created_at: order_by
  created_by: order_by
  event_type: order_by
  id: order_by
  invoice_id: order_by
  message: order_by
}

"""
response of any mutation on the table "billing_event_log"
"""
type billing_event_log_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [billing_event_log!]!
}

"""
on_conflict condition type for table "billing_event_log"
"""
input billing_event_log_on_conflict {
  constraint: billing_event_log_constraint!
  update_columns: [billing_event_log_update_column!]! = []
  where: billing_event_log_bool_exp
}

"""Ordering options when selecting data from "billing_event_log"."""
input billing_event_log_order_by {
  billing_invoice: billing_invoice_order_by
  created_at: order_by
  created_by: order_by
  event_type: order_by
  id: order_by
  invoice_id: order_by
  message: order_by
  user: users_order_by
}

"""primary key columns input for table: billing_event_log"""
input billing_event_log_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_event_log"
"""
enum billing_event_log_select_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  message
}

"""
input type for updating data in table "billing_event_log"
"""
input billing_event_log_set_input {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
Streaming cursor of the table "billing_event_log"
"""
input billing_event_log_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: billing_event_log_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input billing_event_log_stream_cursor_value_input {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
update columns of table "billing_event_log"
"""
enum billing_event_log_update_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  event_type

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  message
}

input billing_event_log_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: billing_event_log_set_input

  """filter the rows which have to be updated"""
  where: billing_event_log_bool_exp!
}

"""
columns and relationships of "billing_invoice"
"""
type billing_invoice {
  """An array relationship"""
  billing_event_logs(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!

  """An aggregate relationship"""
  billing_event_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!

  """An array relationship"""
  billing_invoice_items(
    """distinct select on columns"""
    distinct_on: [billing_invoice_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_item_order_by!]

    """filter the rows returned"""
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!

  """An aggregate relationship"""
  billing_invoice_items_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoice_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_item_order_by!]

    """filter the rows returned"""
    where: billing_invoice_item_bool_exp
  ): billing_invoice_item_aggregate!
  billing_period_end: date!
  billing_period_start: date!

  """An object relationship"""
  client: clients!
  client_id: uuid!
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid!
  issued_date: date
  notes: String
  status: String!
  total_amount: numeric!
  updated_at: timestamptz
}

"""
aggregated selection of "billing_invoice"
"""
type billing_invoice_aggregate {
  aggregate: billing_invoice_aggregate_fields
  nodes: [billing_invoice!]!
}

input billing_invoice_aggregate_bool_exp {
  count: billing_invoice_aggregate_bool_exp_count
}

input billing_invoice_aggregate_bool_exp_count {
  arguments: [billing_invoice_select_column!]
  distinct: Boolean
  filter: billing_invoice_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_invoice"
"""
type billing_invoice_aggregate_fields {
  avg: billing_invoice_avg_fields
  count(columns: [billing_invoice_select_column!], distinct: Boolean): Int!
  max: billing_invoice_max_fields
  min: billing_invoice_min_fields
  stddev: billing_invoice_stddev_fields
  stddev_pop: billing_invoice_stddev_pop_fields
  stddev_samp: billing_invoice_stddev_samp_fields
  sum: billing_invoice_sum_fields
  var_pop: billing_invoice_var_pop_fields
  var_samp: billing_invoice_var_samp_fields
  variance: billing_invoice_variance_fields
}

"""
order by aggregate values of table "billing_invoice"
"""
input billing_invoice_aggregate_order_by {
  avg: billing_invoice_avg_order_by
  count: order_by
  max: billing_invoice_max_order_by
  min: billing_invoice_min_order_by
  stddev: billing_invoice_stddev_order_by
  stddev_pop: billing_invoice_stddev_pop_order_by
  stddev_samp: billing_invoice_stddev_samp_order_by
  sum: billing_invoice_sum_order_by
  var_pop: billing_invoice_var_pop_order_by
  var_samp: billing_invoice_var_samp_order_by
  variance: billing_invoice_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_invoice"
"""
input billing_invoice_arr_rel_insert_input {
  data: [billing_invoice_insert_input!]!

  """upsert condition"""
  on_conflict: billing_invoice_on_conflict
}

"""aggregate avg on columns"""
type billing_invoice_avg_fields {
  total_amount: Float
}

"""
order by avg() on columns of table "billing_invoice"
"""
input billing_invoice_avg_order_by {
  total_amount: order_by
}

"""
Boolean expression to filter rows from the table "billing_invoice". All fields are combined with a logical 'AND'.
"""
input billing_invoice_bool_exp {
  _and: [billing_invoice_bool_exp!]
  _not: billing_invoice_bool_exp
  _or: [billing_invoice_bool_exp!]
  billing_event_logs: billing_event_log_bool_exp
  billing_event_logs_aggregate: billing_event_log_aggregate_bool_exp
  billing_invoice_items: billing_invoice_item_bool_exp
  billing_invoice_items_aggregate: billing_invoice_item_aggregate_bool_exp
  billing_period_end: date_comparison_exp
  billing_period_start: date_comparison_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  due_date: date_comparison_exp
  id: uuid_comparison_exp
  issued_date: date_comparison_exp
  notes: String_comparison_exp
  status: String_comparison_exp
  total_amount: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "billing_invoice"
"""
enum billing_invoice_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoice_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoice"
"""
input billing_invoice_inc_input {
  total_amount: numeric
}

"""
input type for inserting data into table "billing_invoice"
"""
input billing_invoice_insert_input {
  billing_event_logs: billing_event_log_arr_rel_insert_input
  billing_invoice_items: billing_invoice_item_arr_rel_insert_input
  billing_period_end: date
  billing_period_start: date
  client: clients_obj_rel_insert_input
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
columns and relationships of "billing_invoice_item"
"""
type billing_invoice_item {
  amount: numeric
  created_at: timestamptz
  description: String!
  id: uuid!
  invoice_id: uuid!

  """An object relationship"""
  parent_invoice: billing_invoice!
  quantity: Int!
  unit_price: numeric!
  updated_at: timestamptz
}

"""
aggregated selection of "billing_invoice_item"
"""
type billing_invoice_item_aggregate {
  aggregate: billing_invoice_item_aggregate_fields
  nodes: [billing_invoice_item!]!
}

input billing_invoice_item_aggregate_bool_exp {
  count: billing_invoice_item_aggregate_bool_exp_count
}

input billing_invoice_item_aggregate_bool_exp_count {
  arguments: [billing_invoice_item_select_column!]
  distinct: Boolean
  filter: billing_invoice_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_invoice_item"
"""
type billing_invoice_item_aggregate_fields {
  avg: billing_invoice_item_avg_fields
  count(columns: [billing_invoice_item_select_column!], distinct: Boolean): Int!
  max: billing_invoice_item_max_fields
  min: billing_invoice_item_min_fields
  stddev: billing_invoice_item_stddev_fields
  stddev_pop: billing_invoice_item_stddev_pop_fields
  stddev_samp: billing_invoice_item_stddev_samp_fields
  sum: billing_invoice_item_sum_fields
  var_pop: billing_invoice_item_var_pop_fields
  var_samp: billing_invoice_item_var_samp_fields
  variance: billing_invoice_item_variance_fields
}

"""
order by aggregate values of table "billing_invoice_item"
"""
input billing_invoice_item_aggregate_order_by {
  avg: billing_invoice_item_avg_order_by
  count: order_by
  max: billing_invoice_item_max_order_by
  min: billing_invoice_item_min_order_by
  stddev: billing_invoice_item_stddev_order_by
  stddev_pop: billing_invoice_item_stddev_pop_order_by
  stddev_samp: billing_invoice_item_stddev_samp_order_by
  sum: billing_invoice_item_sum_order_by
  var_pop: billing_invoice_item_var_pop_order_by
  var_samp: billing_invoice_item_var_samp_order_by
  variance: billing_invoice_item_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_invoice_item"
"""
input billing_invoice_item_arr_rel_insert_input {
  data: [billing_invoice_item_insert_input!]!

  """upsert condition"""
  on_conflict: billing_invoice_item_on_conflict
}

"""aggregate avg on columns"""
type billing_invoice_item_avg_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by avg() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_avg_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Boolean expression to filter rows from the table "billing_invoice_item". All fields are combined with a logical 'AND'.
"""
input billing_invoice_item_bool_exp {
  _and: [billing_invoice_item_bool_exp!]
  _not: billing_invoice_item_bool_exp
  _or: [billing_invoice_item_bool_exp!]
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  invoice_id: uuid_comparison_exp
  parent_invoice: billing_invoice_bool_exp
  quantity: Int_comparison_exp
  unit_price: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "billing_invoice_item"
"""
enum billing_invoice_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoice_item_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoice_item"
"""
input billing_invoice_item_inc_input {
  quantity: Int
  unit_price: numeric
}

"""
input type for inserting data into table "billing_invoice_item"
"""
input billing_invoice_item_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  parent_invoice: billing_invoice_obj_rel_insert_input
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""aggregate max on columns"""
type billing_invoice_item_max_fields {
  amount: numeric
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""
order by max() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_max_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  quantity: order_by
  unit_price: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type billing_invoice_item_min_fields {
  amount: numeric
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""
order by min() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_min_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  quantity: order_by
  unit_price: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "billing_invoice_item"
"""
type billing_invoice_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [billing_invoice_item!]!
}

"""
on_conflict condition type for table "billing_invoice_item"
"""
input billing_invoice_item_on_conflict {
  constraint: billing_invoice_item_constraint!
  update_columns: [billing_invoice_item_update_column!]! = []
  where: billing_invoice_item_bool_exp
}

"""Ordering options when selecting data from "billing_invoice_item"."""
input billing_invoice_item_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  parent_invoice: billing_invoice_order_by
  quantity: order_by
  unit_price: order_by
  updated_at: order_by
}

"""primary key columns input for table: billing_invoice_item"""
input billing_invoice_item_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_invoice_item"
"""
enum billing_invoice_item_select_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  quantity

  """column name"""
  unit_price

  """column name"""
  updated_at
}

"""
input type for updating data in table "billing_invoice_item"
"""
input billing_invoice_item_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type billing_invoice_item_stddev_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_stddev_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate stddev_pop on columns"""
type billing_invoice_item_stddev_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_pop() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_stddev_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate stddev_samp on columns"""
type billing_invoice_item_stddev_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_samp() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_stddev_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Streaming cursor of the table "billing_invoice_item"
"""
input billing_invoice_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: billing_invoice_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input billing_invoice_item_stream_cursor_value_input {
  amount: numeric
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type billing_invoice_item_sum_fields {
  amount: numeric
  quantity: Int
  unit_price: numeric
}

"""
order by sum() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_sum_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
update columns of table "billing_invoice_item"
"""
enum billing_invoice_item_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  quantity

  """column name"""
  unit_price

  """column name"""
  updated_at
}

input billing_invoice_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billing_invoice_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: billing_invoice_item_set_input

  """filter the rows which have to be updated"""
  where: billing_invoice_item_bool_exp!
}

"""aggregate var_pop on columns"""
type billing_invoice_item_var_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_pop() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_var_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate var_samp on columns"""
type billing_invoice_item_var_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_samp() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_var_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate variance on columns"""
type billing_invoice_item_variance_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by variance() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_variance_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate max on columns"""
type billing_invoice_max_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
order by max() on columns of table "billing_invoice"
"""
input billing_invoice_max_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  currency: order_by
  due_date: order_by
  id: order_by
  issued_date: order_by
  notes: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type billing_invoice_min_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
order by min() on columns of table "billing_invoice"
"""
input billing_invoice_min_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  currency: order_by
  due_date: order_by
  id: order_by
  issued_date: order_by
  notes: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "billing_invoice"
"""
type billing_invoice_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [billing_invoice!]!
}

"""
input type for inserting object relation for remote table "billing_invoice"
"""
input billing_invoice_obj_rel_insert_input {
  data: billing_invoice_insert_input!

  """upsert condition"""
  on_conflict: billing_invoice_on_conflict
}

"""
on_conflict condition type for table "billing_invoice"
"""
input billing_invoice_on_conflict {
  constraint: billing_invoice_constraint!
  update_columns: [billing_invoice_update_column!]! = []
  where: billing_invoice_bool_exp
}

"""Ordering options when selecting data from "billing_invoice"."""
input billing_invoice_order_by {
  billing_event_logs_aggregate: billing_event_log_aggregate_order_by
  billing_invoice_items_aggregate: billing_invoice_item_aggregate_order_by
  billing_period_end: order_by
  billing_period_start: order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  currency: order_by
  due_date: order_by
  id: order_by
  issued_date: order_by
  notes: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""primary key columns input for table: billing_invoice"""
input billing_invoice_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_invoice"
"""
enum billing_invoice_select_column {
  """column name"""
  billing_period_end

  """column name"""
  billing_period_start

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  issued_date

  """column name"""
  notes

  """column name"""
  status

  """column name"""
  total_amount

  """column name"""
  updated_at
}

"""
input type for updating data in table "billing_invoice"
"""
input billing_invoice_set_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type billing_invoice_stddev_fields {
  total_amount: Float
}

"""
order by stddev() on columns of table "billing_invoice"
"""
input billing_invoice_stddev_order_by {
  total_amount: order_by
}

"""aggregate stddev_pop on columns"""
type billing_invoice_stddev_pop_fields {
  total_amount: Float
}

"""
order by stddev_pop() on columns of table "billing_invoice"
"""
input billing_invoice_stddev_pop_order_by {
  total_amount: order_by
}

"""aggregate stddev_samp on columns"""
type billing_invoice_stddev_samp_fields {
  total_amount: Float
}

"""
order by stddev_samp() on columns of table "billing_invoice"
"""
input billing_invoice_stddev_samp_order_by {
  total_amount: order_by
}

"""
Streaming cursor of the table "billing_invoice"
"""
input billing_invoice_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: billing_invoice_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input billing_invoice_stream_cursor_value_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type billing_invoice_sum_fields {
  total_amount: numeric
}

"""
order by sum() on columns of table "billing_invoice"
"""
input billing_invoice_sum_order_by {
  total_amount: order_by
}

"""
update columns of table "billing_invoice"
"""
enum billing_invoice_update_column {
  """column name"""
  billing_period_end

  """column name"""
  billing_period_start

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  due_date

  """column name"""
  id

  """column name"""
  issued_date

  """column name"""
  notes

  """column name"""
  status

  """column name"""
  total_amount

  """column name"""
  updated_at
}

input billing_invoice_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billing_invoice_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: billing_invoice_set_input

  """filter the rows which have to be updated"""
  where: billing_invoice_bool_exp!
}

"""aggregate var_pop on columns"""
type billing_invoice_var_pop_fields {
  total_amount: Float
}

"""
order by var_pop() on columns of table "billing_invoice"
"""
input billing_invoice_var_pop_order_by {
  total_amount: order_by
}

"""aggregate var_samp on columns"""
type billing_invoice_var_samp_fields {
  total_amount: Float
}

"""
order by var_samp() on columns of table "billing_invoice"
"""
input billing_invoice_var_samp_order_by {
  total_amount: order_by
}

"""aggregate variance on columns"""
type billing_invoice_variance_fields {
  total_amount: Float
}

"""
order by variance() on columns of table "billing_invoice"
"""
input billing_invoice_variance_order_by {
  total_amount: order_by
}

"""
columns and relationships of "billing_invoices"
"""
type billing_invoices {
  """An array relationship"""
  billing_items(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): [billing_items!]!

  """An aggregate relationship"""
  billing_items_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): billing_items_aggregate!
  billing_period_end: date!
  billing_period_start: date!

  """An object relationship"""
  client: clients
  client_id: uuid
  created_at: timestamp
  id: uuid!
  invoice_number: String!
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
aggregated selection of "billing_invoices"
"""
type billing_invoices_aggregate {
  aggregate: billing_invoices_aggregate_fields
  nodes: [billing_invoices!]!
}

input billing_invoices_aggregate_bool_exp {
  count: billing_invoices_aggregate_bool_exp_count
}

input billing_invoices_aggregate_bool_exp_count {
  arguments: [billing_invoices_select_column!]
  distinct: Boolean
  filter: billing_invoices_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_invoices"
"""
type billing_invoices_aggregate_fields {
  avg: billing_invoices_avg_fields
  count(columns: [billing_invoices_select_column!], distinct: Boolean): Int!
  max: billing_invoices_max_fields
  min: billing_invoices_min_fields
  stddev: billing_invoices_stddev_fields
  stddev_pop: billing_invoices_stddev_pop_fields
  stddev_samp: billing_invoices_stddev_samp_fields
  sum: billing_invoices_sum_fields
  var_pop: billing_invoices_var_pop_fields
  var_samp: billing_invoices_var_samp_fields
  variance: billing_invoices_variance_fields
}

"""
order by aggregate values of table "billing_invoices"
"""
input billing_invoices_aggregate_order_by {
  avg: billing_invoices_avg_order_by
  count: order_by
  max: billing_invoices_max_order_by
  min: billing_invoices_min_order_by
  stddev: billing_invoices_stddev_order_by
  stddev_pop: billing_invoices_stddev_pop_order_by
  stddev_samp: billing_invoices_stddev_samp_order_by
  sum: billing_invoices_sum_order_by
  var_pop: billing_invoices_var_pop_order_by
  var_samp: billing_invoices_var_samp_order_by
  variance: billing_invoices_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_invoices"
"""
input billing_invoices_arr_rel_insert_input {
  data: [billing_invoices_insert_input!]!

  """upsert condition"""
  on_conflict: billing_invoices_on_conflict
}

"""aggregate avg on columns"""
type billing_invoices_avg_fields {
  total_amount: Float
}

"""
order by avg() on columns of table "billing_invoices"
"""
input billing_invoices_avg_order_by {
  total_amount: order_by
}

"""
Boolean expression to filter rows from the table "billing_invoices". All fields are combined with a logical 'AND'.
"""
input billing_invoices_bool_exp {
  _and: [billing_invoices_bool_exp!]
  _not: billing_invoices_bool_exp
  _or: [billing_invoices_bool_exp!]
  billing_items: billing_items_bool_exp
  billing_items_aggregate: billing_items_aggregate_bool_exp
  billing_period_end: date_comparison_exp
  billing_period_start: date_comparison_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  invoice_number: String_comparison_exp
  status: String_comparison_exp
  total_amount: numeric_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "billing_invoices"
"""
enum billing_invoices_constraint {
  """
  unique or primary key constraint on columns "invoice_number"
  """
  billing_invoices_invoice_number_key

  """
  unique or primary key constraint on columns "id"
  """
  billing_invoices_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoices"
"""
input billing_invoices_inc_input {
  total_amount: numeric
}

"""
input type for inserting data into table "billing_invoices"
"""
input billing_invoices_insert_input {
  billing_items: billing_items_arr_rel_insert_input
  billing_period_end: date
  billing_period_start: date
  client: clients_obj_rel_insert_input
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""aggregate max on columns"""
type billing_invoices_max_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
order by max() on columns of table "billing_invoices"
"""
input billing_invoices_max_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  id: order_by
  invoice_number: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type billing_invoices_min_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
order by min() on columns of table "billing_invoices"
"""
input billing_invoices_min_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  id: order_by
  invoice_number: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "billing_invoices"
"""
type billing_invoices_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [billing_invoices!]!
}

"""
input type for inserting object relation for remote table "billing_invoices"
"""
input billing_invoices_obj_rel_insert_input {
  data: billing_invoices_insert_input!

  """upsert condition"""
  on_conflict: billing_invoices_on_conflict
}

"""
on_conflict condition type for table "billing_invoices"
"""
input billing_invoices_on_conflict {
  constraint: billing_invoices_constraint!
  update_columns: [billing_invoices_update_column!]! = []
  where: billing_invoices_bool_exp
}

"""Ordering options when selecting data from "billing_invoices"."""
input billing_invoices_order_by {
  billing_items_aggregate: billing_items_aggregate_order_by
  billing_period_end: order_by
  billing_period_start: order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  id: order_by
  invoice_number: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""primary key columns input for table: billing_invoices"""
input billing_invoices_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_invoices"
"""
enum billing_invoices_select_column {
  """column name"""
  billing_period_end

  """column name"""
  billing_period_start

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  invoice_number

  """column name"""
  status

  """column name"""
  total_amount

  """column name"""
  updated_at
}

"""
input type for updating data in table "billing_invoices"
"""
input billing_invoices_set_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""aggregate stddev on columns"""
type billing_invoices_stddev_fields {
  total_amount: Float
}

"""
order by stddev() on columns of table "billing_invoices"
"""
input billing_invoices_stddev_order_by {
  total_amount: order_by
}

"""aggregate stddev_pop on columns"""
type billing_invoices_stddev_pop_fields {
  total_amount: Float
}

"""
order by stddev_pop() on columns of table "billing_invoices"
"""
input billing_invoices_stddev_pop_order_by {
  total_amount: order_by
}

"""aggregate stddev_samp on columns"""
type billing_invoices_stddev_samp_fields {
  total_amount: Float
}

"""
order by stddev_samp() on columns of table "billing_invoices"
"""
input billing_invoices_stddev_samp_order_by {
  total_amount: order_by
}

"""
Streaming cursor of the table "billing_invoices"
"""
input billing_invoices_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: billing_invoices_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input billing_invoices_stream_cursor_value_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""aggregate sum on columns"""
type billing_invoices_sum_fields {
  total_amount: numeric
}

"""
order by sum() on columns of table "billing_invoices"
"""
input billing_invoices_sum_order_by {
  total_amount: order_by
}

"""
update columns of table "billing_invoices"
"""
enum billing_invoices_update_column {
  """column name"""
  billing_period_end

  """column name"""
  billing_period_start

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  invoice_number

  """column name"""
  status

  """column name"""
  total_amount

  """column name"""
  updated_at
}

input billing_invoices_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billing_invoices_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: billing_invoices_set_input

  """filter the rows which have to be updated"""
  where: billing_invoices_bool_exp!
}

"""aggregate var_pop on columns"""
type billing_invoices_var_pop_fields {
  total_amount: Float
}

"""
order by var_pop() on columns of table "billing_invoices"
"""
input billing_invoices_var_pop_order_by {
  total_amount: order_by
}

"""aggregate var_samp on columns"""
type billing_invoices_var_samp_fields {
  total_amount: Float
}

"""
order by var_samp() on columns of table "billing_invoices"
"""
input billing_invoices_var_samp_order_by {
  total_amount: order_by
}

"""aggregate variance on columns"""
type billing_invoices_variance_fields {
  total_amount: Float
}

"""
order by variance() on columns of table "billing_invoices"
"""
input billing_invoices_variance_order_by {
  total_amount: order_by
}

"""
columns and relationships of "billing_items"
"""
type billing_items {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid!
  invoice_id: uuid

  """An object relationship"""
  invoice_reference: billing_invoices

  """An object relationship"""
  payroll: payrolls
  payroll_id: uuid
  quantity: Int!
  unit_price: numeric!
}

"""
aggregated selection of "billing_items"
"""
type billing_items_aggregate {
  aggregate: billing_items_aggregate_fields
  nodes: [billing_items!]!
}

input billing_items_aggregate_bool_exp {
  count: billing_items_aggregate_bool_exp_count
}

input billing_items_aggregate_bool_exp_count {
  arguments: [billing_items_select_column!]
  distinct: Boolean
  filter: billing_items_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_items"
"""
type billing_items_aggregate_fields {
  avg: billing_items_avg_fields
  count(columns: [billing_items_select_column!], distinct: Boolean): Int!
  max: billing_items_max_fields
  min: billing_items_min_fields
  stddev: billing_items_stddev_fields
  stddev_pop: billing_items_stddev_pop_fields
  stddev_samp: billing_items_stddev_samp_fields
  sum: billing_items_sum_fields
  var_pop: billing_items_var_pop_fields
  var_samp: billing_items_var_samp_fields
  variance: billing_items_variance_fields
}

"""
order by aggregate values of table "billing_items"
"""
input billing_items_aggregate_order_by {
  avg: billing_items_avg_order_by
  count: order_by
  max: billing_items_max_order_by
  min: billing_items_min_order_by
  stddev: billing_items_stddev_order_by
  stddev_pop: billing_items_stddev_pop_order_by
  stddev_samp: billing_items_stddev_samp_order_by
  sum: billing_items_sum_order_by
  var_pop: billing_items_var_pop_order_by
  var_samp: billing_items_var_samp_order_by
  variance: billing_items_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_items"
"""
input billing_items_arr_rel_insert_input {
  data: [billing_items_insert_input!]!

  """upsert condition"""
  on_conflict: billing_items_on_conflict
}

"""aggregate avg on columns"""
type billing_items_avg_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by avg() on columns of table "billing_items"
"""
input billing_items_avg_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Boolean expression to filter rows from the table "billing_items". All fields are combined with a logical 'AND'.
"""
input billing_items_bool_exp {
  _and: [billing_items_bool_exp!]
  _not: billing_items_bool_exp
  _or: [billing_items_bool_exp!]
  amount: numeric_comparison_exp
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  invoice_id: uuid_comparison_exp
  invoice_reference: billing_invoices_bool_exp
  payroll: payrolls_bool_exp
  payroll_id: uuid_comparison_exp
  quantity: Int_comparison_exp
  unit_price: numeric_comparison_exp
}

"""
unique or primary key constraints on table "billing_items"
"""
enum billing_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_items_pkey
}

"""
input type for incrementing numeric columns in table "billing_items"
"""
input billing_items_inc_input {
  quantity: Int
  unit_price: numeric
}

"""
input type for inserting data into table "billing_items"
"""
input billing_items_insert_input {
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  invoice_reference: billing_invoices_obj_rel_insert_input
  payroll: payrolls_obj_rel_insert_input
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""aggregate max on columns"""
type billing_items_max_fields {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""
order by max() on columns of table "billing_items"
"""
input billing_items_max_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  payroll_id: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate min on columns"""
type billing_items_min_fields {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""
order by min() on columns of table "billing_items"
"""
input billing_items_min_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  payroll_id: order_by
  quantity: order_by
  unit_price: order_by
}

"""
response of any mutation on the table "billing_items"
"""
type billing_items_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [billing_items!]!
}

"""
on_conflict condition type for table "billing_items"
"""
input billing_items_on_conflict {
  constraint: billing_items_constraint!
  update_columns: [billing_items_update_column!]! = []
  where: billing_items_bool_exp
}

"""Ordering options when selecting data from "billing_items"."""
input billing_items_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  invoice_reference: billing_invoices_order_by
  payroll: payrolls_order_by
  payroll_id: order_by
  quantity: order_by
  unit_price: order_by
}

"""primary key columns input for table: billing_items"""
input billing_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_items"
"""
enum billing_items_select_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  payroll_id

  """column name"""
  quantity

  """column name"""
  unit_price
}

"""
input type for updating data in table "billing_items"
"""
input billing_items_set_input {
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""aggregate stddev on columns"""
type billing_items_stddev_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev() on columns of table "billing_items"
"""
input billing_items_stddev_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate stddev_pop on columns"""
type billing_items_stddev_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_pop() on columns of table "billing_items"
"""
input billing_items_stddev_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate stddev_samp on columns"""
type billing_items_stddev_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_samp() on columns of table "billing_items"
"""
input billing_items_stddev_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Streaming cursor of the table "billing_items"
"""
input billing_items_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: billing_items_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input billing_items_stream_cursor_value_input {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""aggregate sum on columns"""
type billing_items_sum_fields {
  amount: numeric
  quantity: Int
  unit_price: numeric
}

"""
order by sum() on columns of table "billing_items"
"""
input billing_items_sum_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
update columns of table "billing_items"
"""
enum billing_items_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  invoice_id

  """column name"""
  payroll_id

  """column name"""
  quantity

  """column name"""
  unit_price
}

input billing_items_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billing_items_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: billing_items_set_input

  """filter the rows which have to be updated"""
  where: billing_items_bool_exp!
}

"""aggregate var_pop on columns"""
type billing_items_var_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_pop() on columns of table "billing_items"
"""
input billing_items_var_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate var_samp on columns"""
type billing_items_var_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_samp() on columns of table "billing_items"
"""
input billing_items_var_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""aggregate variance on columns"""
type billing_items_variance_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by variance() on columns of table "billing_items"
"""
input billing_items_variance_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
columns and relationships of "billing_plan"
"""
type billing_plan {
  """An array relationship"""
  client_billing_assignments(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!

  """An aggregate relationship"""
  client_billing_assignments_aggregate(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!
  created_at: timestamptz
  currency: String!
  description: String
  id: uuid!
  name: String!
  rate_per_payroll: numeric!
  updated_at: timestamptz
}

"""
aggregated selection of "billing_plan"
"""
type billing_plan_aggregate {
  aggregate: billing_plan_aggregate_fields
  nodes: [billing_plan!]!
}

"""
aggregate fields of "billing_plan"
"""
type billing_plan_aggregate_fields {
  avg: billing_plan_avg_fields
  count(columns: [billing_plan_select_column!], distinct: Boolean): Int!
  max: billing_plan_max_fields
  min: billing_plan_min_fields
  stddev: billing_plan_stddev_fields
  stddev_pop: billing_plan_stddev_pop_fields
  stddev_samp: billing_plan_stddev_samp_fields
  sum: billing_plan_sum_fields
  var_pop: billing_plan_var_pop_fields
  var_samp: billing_plan_var_samp_fields
  variance: billing_plan_variance_fields
}

"""aggregate avg on columns"""
type billing_plan_avg_fields {
  rate_per_payroll: Float
}

"""
Boolean expression to filter rows from the table "billing_plan". All fields are combined with a logical 'AND'.
"""
input billing_plan_bool_exp {
  _and: [billing_plan_bool_exp!]
  _not: billing_plan_bool_exp
  _or: [billing_plan_bool_exp!]
  client_billing_assignments: client_billing_assignment_bool_exp
  client_billing_assignments_aggregate: client_billing_assignment_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  rate_per_payroll: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "billing_plan"
"""
enum billing_plan_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_plan_pkey
}

"""
input type for incrementing numeric columns in table "billing_plan"
"""
input billing_plan_inc_input {
  rate_per_payroll: numeric
}

"""
input type for inserting data into table "billing_plan"
"""
input billing_plan_insert_input {
  client_billing_assignments: client_billing_assignment_arr_rel_insert_input
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""aggregate max on columns"""
type billing_plan_max_fields {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""aggregate min on columns"""
type billing_plan_min_fields {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""
response of any mutation on the table "billing_plan"
"""
type billing_plan_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [billing_plan!]!
}

"""
input type for inserting object relation for remote table "billing_plan"
"""
input billing_plan_obj_rel_insert_input {
  data: billing_plan_insert_input!

  """upsert condition"""
  on_conflict: billing_plan_on_conflict
}

"""
on_conflict condition type for table "billing_plan"
"""
input billing_plan_on_conflict {
  constraint: billing_plan_constraint!
  update_columns: [billing_plan_update_column!]! = []
  where: billing_plan_bool_exp
}

"""Ordering options when selecting data from "billing_plan"."""
input billing_plan_order_by {
  client_billing_assignments_aggregate: client_billing_assignment_aggregate_order_by
  created_at: order_by
  currency: order_by
  description: order_by
  id: order_by
  name: order_by
  rate_per_payroll: order_by
  updated_at: order_by
}

"""primary key columns input for table: billing_plan"""
input billing_plan_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_plan"
"""
enum billing_plan_select_column {
  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  rate_per_payroll

  """column name"""
  updated_at
}

"""
input type for updating data in table "billing_plan"
"""
input billing_plan_set_input {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type billing_plan_stddev_fields {
  rate_per_payroll: Float
}

"""aggregate stddev_pop on columns"""
type billing_plan_stddev_pop_fields {
  rate_per_payroll: Float
}

"""aggregate stddev_samp on columns"""
type billing_plan_stddev_samp_fields {
  rate_per_payroll: Float
}

"""
Streaming cursor of the table "billing_plan"
"""
input billing_plan_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: billing_plan_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input billing_plan_stream_cursor_value_input {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type billing_plan_sum_fields {
  rate_per_payroll: numeric
}

"""
update columns of table "billing_plan"
"""
enum billing_plan_update_column {
  """column name"""
  created_at

  """column name"""
  currency

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  rate_per_payroll

  """column name"""
  updated_at
}

input billing_plan_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billing_plan_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: billing_plan_set_input

  """filter the rows which have to be updated"""
  where: billing_plan_bool_exp!
}

"""aggregate var_pop on columns"""
type billing_plan_var_pop_fields {
  rate_per_payroll: Float
}

"""aggregate var_samp on columns"""
type billing_plan_var_samp_fields {
  rate_per_payroll: Float
}

"""aggregate variance on columns"""
type billing_plan_variance_fields {
  rate_per_payroll: Float
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "client_billing_assignment"
"""
type client_billing_assignment {
  """An object relationship"""
  billing_plan: billing_plan!
  billing_plan_id: uuid!

  """An object relationship"""
  client: clients!
  client_id: uuid!
  created_at: timestamptz
  end_date: date
  id: uuid!
  is_active: Boolean
  start_date: date!
  updated_at: timestamptz
}

"""
aggregated selection of "client_billing_assignment"
"""
type client_billing_assignment_aggregate {
  aggregate: client_billing_assignment_aggregate_fields
  nodes: [client_billing_assignment!]!
}

input client_billing_assignment_aggregate_bool_exp {
  bool_and: client_billing_assignment_aggregate_bool_exp_bool_and
  bool_or: client_billing_assignment_aggregate_bool_exp_bool_or
  count: client_billing_assignment_aggregate_bool_exp_count
}

input client_billing_assignment_aggregate_bool_exp_bool_and {
  arguments: client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: client_billing_assignment_bool_exp
  predicate: Boolean_comparison_exp!
}

input client_billing_assignment_aggregate_bool_exp_bool_or {
  arguments: client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: client_billing_assignment_bool_exp
  predicate: Boolean_comparison_exp!
}

input client_billing_assignment_aggregate_bool_exp_count {
  arguments: [client_billing_assignment_select_column!]
  distinct: Boolean
  filter: client_billing_assignment_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "client_billing_assignment"
"""
type client_billing_assignment_aggregate_fields {
  count(columns: [client_billing_assignment_select_column!], distinct: Boolean): Int!
  max: client_billing_assignment_max_fields
  min: client_billing_assignment_min_fields
}

"""
order by aggregate values of table "client_billing_assignment"
"""
input client_billing_assignment_aggregate_order_by {
  count: order_by
  max: client_billing_assignment_max_order_by
  min: client_billing_assignment_min_order_by
}

"""
input type for inserting array relation for remote table "client_billing_assignment"
"""
input client_billing_assignment_arr_rel_insert_input {
  data: [client_billing_assignment_insert_input!]!

  """upsert condition"""
  on_conflict: client_billing_assignment_on_conflict
}

"""
Boolean expression to filter rows from the table "client_billing_assignment". All fields are combined with a logical 'AND'.
"""
input client_billing_assignment_bool_exp {
  _and: [client_billing_assignment_bool_exp!]
  _not: client_billing_assignment_bool_exp
  _or: [client_billing_assignment_bool_exp!]
  billing_plan: billing_plan_bool_exp
  billing_plan_id: uuid_comparison_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  start_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "client_billing_assignment"
"""
enum client_billing_assignment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  client_billing_assignment_pkey
}

"""
input type for inserting data into table "client_billing_assignment"
"""
input client_billing_assignment_insert_input {
  billing_plan: billing_plan_obj_rel_insert_input
  billing_plan_id: uuid
  client: clients_obj_rel_insert_input
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  is_active: Boolean
  start_date: date
  updated_at: timestamptz
}

"""aggregate max on columns"""
type client_billing_assignment_max_fields {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  start_date: date
  updated_at: timestamptz
}

"""
order by max() on columns of table "client_billing_assignment"
"""
input client_billing_assignment_max_order_by {
  billing_plan_id: order_by
  client_id: order_by
  created_at: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type client_billing_assignment_min_fields {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  start_date: date
  updated_at: timestamptz
}

"""
order by min() on columns of table "client_billing_assignment"
"""
input client_billing_assignment_min_order_by {
  billing_plan_id: order_by
  client_id: order_by
  created_at: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "client_billing_assignment"
"""
type client_billing_assignment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [client_billing_assignment!]!
}

"""
on_conflict condition type for table "client_billing_assignment"
"""
input client_billing_assignment_on_conflict {
  constraint: client_billing_assignment_constraint!
  update_columns: [client_billing_assignment_update_column!]! = []
  where: client_billing_assignment_bool_exp
}

"""Ordering options when selecting data from "client_billing_assignment"."""
input client_billing_assignment_order_by {
  billing_plan: billing_plan_order_by
  billing_plan_id: order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  end_date: order_by
  id: order_by
  is_active: order_by
  start_date: order_by
  updated_at: order_by
}

"""primary key columns input for table: client_billing_assignment"""
input client_billing_assignment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "client_billing_assignment"
"""
enum client_billing_assignment_select_column {
  """column name"""
  billing_plan_id

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  start_date

  """column name"""
  updated_at
}

"""
select "client_billing_assignment_aggregate_bool_exp_bool_and_arguments_columns" columns of table "client_billing_assignment"
"""
enum client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "client_billing_assignment_aggregate_bool_exp_bool_or_arguments_columns" columns of table "client_billing_assignment"
"""
enum client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "client_billing_assignment"
"""
input client_billing_assignment_set_input {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  is_active: Boolean
  start_date: date
  updated_at: timestamptz
}

"""
Streaming cursor of the table "client_billing_assignment"
"""
input client_billing_assignment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: client_billing_assignment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input client_billing_assignment_stream_cursor_value_input {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  is_active: Boolean
  start_date: date
  updated_at: timestamptz
}

"""
update columns of table "client_billing_assignment"
"""
enum client_billing_assignment_update_column {
  """column name"""
  billing_plan_id

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  start_date

  """column name"""
  updated_at
}

input client_billing_assignment_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: client_billing_assignment_set_input

  """filter the rows which have to be updated"""
  where: client_billing_assignment_bool_exp!
}

"""
columns and relationships of "client_external_systems"
"""
type client_external_systems {
  """An object relationship"""
  client: clients!

  """Reference to the client"""
  client_id: uuid!

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """An object relationship"""
  external_system: external_systems!

  """Unique identifier for the client-system mapping"""
  id: uuid!

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid!

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "client_external_systems"
"""
type client_external_systems_aggregate {
  aggregate: client_external_systems_aggregate_fields
  nodes: [client_external_systems!]!
}

input client_external_systems_aggregate_bool_exp {
  count: client_external_systems_aggregate_bool_exp_count
}

input client_external_systems_aggregate_bool_exp_count {
  arguments: [client_external_systems_select_column!]
  distinct: Boolean
  filter: client_external_systems_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "client_external_systems"
"""
type client_external_systems_aggregate_fields {
  count(columns: [client_external_systems_select_column!], distinct: Boolean): Int!
  max: client_external_systems_max_fields
  min: client_external_systems_min_fields
}

"""
order by aggregate values of table "client_external_systems"
"""
input client_external_systems_aggregate_order_by {
  count: order_by
  max: client_external_systems_max_order_by
  min: client_external_systems_min_order_by
}

"""
input type for inserting array relation for remote table "client_external_systems"
"""
input client_external_systems_arr_rel_insert_input {
  data: [client_external_systems_insert_input!]!

  """upsert condition"""
  on_conflict: client_external_systems_on_conflict
}

"""
Boolean expression to filter rows from the table "client_external_systems". All fields are combined with a logical 'AND'.
"""
input client_external_systems_bool_exp {
  _and: [client_external_systems_bool_exp!]
  _not: client_external_systems_bool_exp
  _or: [client_external_systems_bool_exp!]
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  external_system: external_systems_bool_exp
  id: uuid_comparison_exp
  system_client_id: String_comparison_exp
  system_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "client_external_systems"
"""
enum client_external_systems_constraint {
  """
  unique or primary key constraint on columns "client_id", "system_id"
  """
  client_external_systems_client_id_system_id_key

  """
  unique or primary key constraint on columns "id"
  """
  client_external_systems_pkey
}

"""
input type for inserting data into table "client_external_systems"
"""
input client_external_systems_insert_input {
  client: clients_obj_rel_insert_input

  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz
  external_system: external_systems_obj_rel_insert_input

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type client_external_systems_max_fields {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "client_external_systems"
"""
input client_external_systems_max_order_by {
  """Reference to the client"""
  client_id: order_by

  """Timestamp when the mapping was created"""
  created_at: order_by

  """Unique identifier for the client-system mapping"""
  id: order_by

  """Client identifier in the external system"""
  system_client_id: order_by

  """Reference to the external system"""
  system_id: order_by

  """Timestamp when the mapping was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type client_external_systems_min_fields {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "client_external_systems"
"""
input client_external_systems_min_order_by {
  """Reference to the client"""
  client_id: order_by

  """Timestamp when the mapping was created"""
  created_at: order_by

  """Unique identifier for the client-system mapping"""
  id: order_by

  """Client identifier in the external system"""
  system_client_id: order_by

  """Reference to the external system"""
  system_id: order_by

  """Timestamp when the mapping was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "client_external_systems"
"""
type client_external_systems_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [client_external_systems!]!
}

"""
on_conflict condition type for table "client_external_systems"
"""
input client_external_systems_on_conflict {
  constraint: client_external_systems_constraint!
  update_columns: [client_external_systems_update_column!]! = []
  where: client_external_systems_bool_exp
}

"""Ordering options when selecting data from "client_external_systems"."""
input client_external_systems_order_by {
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  external_system: external_systems_order_by
  id: order_by
  system_client_id: order_by
  system_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: client_external_systems"""
input client_external_systems_pk_columns_input {
  """Unique identifier for the client-system mapping"""
  id: uuid!
}

"""
select columns of table "client_external_systems"
"""
enum client_external_systems_select_column {
  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  system_client_id

  """column name"""
  system_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "client_external_systems"
"""
input client_external_systems_set_input {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "client_external_systems"
"""
input client_external_systems_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: client_external_systems_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input client_external_systems_stream_cursor_value_input {
  """Reference to the client"""
  client_id: uuid

  """Timestamp when the mapping was created"""
  created_at: timestamptz

  """Unique identifier for the client-system mapping"""
  id: uuid

  """Client identifier in the external system"""
  system_client_id: String

  """Reference to the external system"""
  system_id: uuid

  """Timestamp when the mapping was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "client_external_systems"
"""
enum client_external_systems_update_column {
  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  system_client_id

  """column name"""
  system_id

  """column name"""
  updated_at
}

input client_external_systems_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: client_external_systems_set_input

  """filter the rows which have to be updated"""
  where: client_external_systems_bool_exp!
}

"""
columns and relationships of "clients"
"""
type clients {
  """Whether the client is currently active"""
  active: Boolean

  """An array relationship"""
  billing_invoices(
    """distinct select on columns"""
    distinct_on: [billing_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_order_by!]

    """filter the rows returned"""
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!

  """An aggregate relationship"""
  billing_invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_order_by!]

    """filter the rows returned"""
    where: billing_invoice_bool_exp
  ): billing_invoice_aggregate!

  """An array relationship"""
  client_billing_assignments(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!

  """An aggregate relationship"""
  client_billing_assignments_aggregate(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!

  """An array relationship"""
  client_billing_invoices(
    """distinct select on columns"""
    distinct_on: [billing_invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoices_order_by!]

    """filter the rows returned"""
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!

  """An aggregate relationship"""
  client_billing_invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoices_order_by!]

    """filter the rows returned"""
    where: billing_invoices_bool_exp
  ): billing_invoices_aggregate!

  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid!

  """Client company name"""
  name: String!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "clients"
"""
type clients_aggregate {
  aggregate: clients_aggregate_fields
  nodes: [clients!]!
}

input clients_aggregate_bool_exp {
  bool_and: clients_aggregate_bool_exp_bool_and
  bool_or: clients_aggregate_bool_exp_bool_or
  count: clients_aggregate_bool_exp_count
}

input clients_aggregate_bool_exp_bool_and {
  arguments: clients_select_column_clients_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Boolean_comparison_exp!
}

input clients_aggregate_bool_exp_bool_or {
  arguments: clients_select_column_clients_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Boolean_comparison_exp!
}

input clients_aggregate_bool_exp_count {
  arguments: [clients_select_column!]
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "clients"
"""
type clients_aggregate_fields {
  count(columns: [clients_select_column!], distinct: Boolean): Int!
  max: clients_max_fields
  min: clients_min_fields
}

"""
order by aggregate values of table "clients"
"""
input clients_aggregate_order_by {
  count: order_by
  max: clients_max_order_by
  min: clients_min_order_by
}

"""
input type for inserting array relation for remote table "clients"
"""
input clients_arr_rel_insert_input {
  data: [clients_insert_input!]!

  """upsert condition"""
  on_conflict: clients_on_conflict
}

"""
Boolean expression to filter rows from the table "clients". All fields are combined with a logical 'AND'.
"""
input clients_bool_exp {
  _and: [clients_bool_exp!]
  _not: clients_bool_exp
  _or: [clients_bool_exp!]
  active: Boolean_comparison_exp
  billing_invoices: billing_invoice_bool_exp
  billing_invoices_aggregate: billing_invoice_aggregate_bool_exp
  client_billing_assignments: client_billing_assignment_bool_exp
  client_billing_assignments_aggregate: client_billing_assignment_aggregate_bool_exp
  client_billing_invoices: billing_invoices_bool_exp
  client_billing_invoices_aggregate: billing_invoices_aggregate_bool_exp
  client_external_systems: client_external_systems_bool_exp
  client_external_systems_aggregate: client_external_systems_aggregate_bool_exp
  contact_email: String_comparison_exp
  contact_person: String_comparison_exp
  contact_phone: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "clients"
"""
enum clients_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  clients_pkey
}

"""
input type for inserting data into table "clients"
"""
input clients_insert_input {
  """Whether the client is currently active"""
  active: Boolean
  billing_invoices: billing_invoice_arr_rel_insert_input
  client_billing_assignments: client_billing_assignment_arr_rel_insert_input
  client_billing_invoices: billing_invoices_arr_rel_insert_input
  client_external_systems: client_external_systems_arr_rel_insert_input

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String
  payrolls: payrolls_arr_rel_insert_input

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type clients_max_fields {
  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "clients"
"""
input clients_max_order_by {
  """Email address for the client contact"""
  contact_email: order_by

  """Primary contact person at the client"""
  contact_person: order_by

  """Phone number for the client contact"""
  contact_phone: order_by

  """Timestamp when the client was created"""
  created_at: order_by

  """Unique identifier for the client"""
  id: order_by

  """Client company name"""
  name: order_by

  """Timestamp when the client was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type clients_min_fields {
  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "clients"
"""
input clients_min_order_by {
  """Email address for the client contact"""
  contact_email: order_by

  """Primary contact person at the client"""
  contact_person: order_by

  """Phone number for the client contact"""
  contact_phone: order_by

  """Timestamp when the client was created"""
  created_at: order_by

  """Unique identifier for the client"""
  id: order_by

  """Client company name"""
  name: order_by

  """Timestamp when the client was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "clients"
"""
type clients_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [clients!]!
}

"""
input type for inserting object relation for remote table "clients"
"""
input clients_obj_rel_insert_input {
  data: clients_insert_input!

  """upsert condition"""
  on_conflict: clients_on_conflict
}

"""
on_conflict condition type for table "clients"
"""
input clients_on_conflict {
  constraint: clients_constraint!
  update_columns: [clients_update_column!]! = []
  where: clients_bool_exp
}

"""Ordering options when selecting data from "clients"."""
input clients_order_by {
  active: order_by
  billing_invoices_aggregate: billing_invoice_aggregate_order_by
  client_billing_assignments_aggregate: client_billing_assignment_aggregate_order_by
  client_billing_invoices_aggregate: billing_invoices_aggregate_order_by
  client_external_systems_aggregate: client_external_systems_aggregate_order_by
  contact_email: order_by
  contact_person: order_by
  contact_phone: order_by
  created_at: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: clients"""
input clients_pk_columns_input {
  """Unique identifier for the client"""
  id: uuid!
}

"""
select columns of table "clients"
"""
enum clients_select_column {
  """column name"""
  active

  """column name"""
  contact_email

  """column name"""
  contact_person

  """column name"""
  contact_phone

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
select "clients_aggregate_bool_exp_bool_and_arguments_columns" columns of table "clients"
"""
enum clients_select_column_clients_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  active
}

"""
select "clients_aggregate_bool_exp_bool_or_arguments_columns" columns of table "clients"
"""
enum clients_select_column_clients_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  active
}

"""
input type for updating data in table "clients"
"""
input clients_set_input {
  """Whether the client is currently active"""
  active: Boolean

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "clients"
"""
input clients_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: clients_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input clients_stream_cursor_value_input {
  """Whether the client is currently active"""
  active: Boolean

  """Email address for the client contact"""
  contact_email: String

  """Primary contact person at the client"""
  contact_person: String

  """Phone number for the client contact"""
  contact_phone: String

  """Timestamp when the client was created"""
  created_at: timestamptz

  """Unique identifier for the client"""
  id: uuid

  """Client company name"""
  name: String

  """Timestamp when the client was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "clients"
"""
enum clients_update_column {
  """column name"""
  active

  """column name"""
  contact_email

  """column name"""
  contact_person

  """column name"""
  contact_phone

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input clients_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: clients_set_input

  """filter the rows which have to be updated"""
  where: clients_bool_exp!
}

input create_payroll_version_args {
  p_created_by_user_id: uuid
  p_go_live_date: date
  p_new_backup_consultant_user_id: uuid
  p_new_client_id: uuid
  p_new_cycle_id: uuid
  p_new_date_type_id: uuid
  p_new_date_value: Int
  p_new_manager_user_id: uuid
  p_new_name: String
  p_new_primary_consultant_user_id: uuid
  p_original_payroll_id: uuid
  p_version_reason: String
}

"""
columns and relationships of "current_payrolls"
"""
type current_payrolls {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""
aggregated selection of "current_payrolls"
"""
type current_payrolls_aggregate {
  aggregate: current_payrolls_aggregate_fields
  nodes: [current_payrolls!]!
}

"""
aggregate fields of "current_payrolls"
"""
type current_payrolls_aggregate_fields {
  avg: current_payrolls_avg_fields
  count(columns: [current_payrolls_select_column!], distinct: Boolean): Int!
  max: current_payrolls_max_fields
  min: current_payrolls_min_fields
  stddev: current_payrolls_stddev_fields
  stddev_pop: current_payrolls_stddev_pop_fields
  stddev_samp: current_payrolls_stddev_samp_fields
  sum: current_payrolls_sum_fields
  var_pop: current_payrolls_var_pop_fields
  var_samp: current_payrolls_var_samp_fields
  variance: current_payrolls_variance_fields
}

"""aggregate avg on columns"""
type current_payrolls_avg_fields {
  date_value: Float
  version_number: Float
}

"""
Boolean expression to filter rows from the table "current_payrolls". All fields are combined with a logical 'AND'.
"""
input current_payrolls_bool_exp {
  _and: [current_payrolls_bool_exp!]
  _not: current_payrolls_bool_exp
  _or: [current_payrolls_bool_exp!]
  backup_consultant_user_id: uuid_comparison_exp
  client_id: uuid_comparison_exp
  client_name: String_comparison_exp
  created_at: timestamptz_comparison_exp
  cycle_id: uuid_comparison_exp
  date_type_id: uuid_comparison_exp
  date_value: Int_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  manager_user_id: uuid_comparison_exp
  name: String_comparison_exp
  parent_payroll_id: uuid_comparison_exp
  payroll_cycle_name: payroll_cycle_type_comparison_exp
  payroll_date_type_name: payroll_date_type_comparison_exp
  primary_consultant_user_id: uuid_comparison_exp
  superseded_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
  version_number: Int_comparison_exp
  version_reason: String_comparison_exp
}

"""aggregate max on columns"""
type current_payrolls_max_fields {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""aggregate min on columns"""
type current_payrolls_min_fields {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""Ordering options when selecting data from "current_payrolls"."""
input current_payrolls_order_by {
  backup_consultant_user_id: order_by
  client_id: order_by
  client_name: order_by
  created_at: order_by
  cycle_id: order_by
  date_type_id: order_by
  date_value: order_by
  go_live_date: order_by
  id: order_by
  manager_user_id: order_by
  name: order_by
  parent_payroll_id: order_by
  payroll_cycle_name: order_by
  payroll_date_type_name: order_by
  primary_consultant_user_id: order_by
  superseded_date: order_by
  updated_at: order_by
  version_number: order_by
  version_reason: order_by
}

"""
select columns of table "current_payrolls"
"""
enum current_payrolls_select_column {
  """column name"""
  backup_consultant_user_id

  """column name"""
  client_id

  """column name"""
  client_name

  """column name"""
  created_at

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  date_value

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  manager_user_id

  """column name"""
  name

  """column name"""
  parent_payroll_id

  """column name"""
  payroll_cycle_name

  """column name"""
  payroll_date_type_name

  """column name"""
  primary_consultant_user_id

  """column name"""
  superseded_date

  """column name"""
  updated_at

  """column name"""
  version_number

  """column name"""
  version_reason
}

"""aggregate stddev on columns"""
type current_payrolls_stddev_fields {
  date_value: Float
  version_number: Float
}

"""aggregate stddev_pop on columns"""
type current_payrolls_stddev_pop_fields {
  date_value: Float
  version_number: Float
}

"""aggregate stddev_samp on columns"""
type current_payrolls_stddev_samp_fields {
  date_value: Float
  version_number: Float
}

"""
Streaming cursor of the table "current_payrolls"
"""
input current_payrolls_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: current_payrolls_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input current_payrolls_stream_cursor_value_input {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""aggregate sum on columns"""
type current_payrolls_sum_fields {
  date_value: Int
  version_number: Int
}

"""aggregate var_pop on columns"""
type current_payrolls_var_pop_fields {
  date_value: Float
  version_number: Float
}

"""aggregate var_samp on columns"""
type current_payrolls_var_samp_fields {
  date_value: Float
  version_number: Float
}

"""aggregate variance on columns"""
type current_payrolls_variance_fields {
  date_value: Float
  version_number: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "external_systems"
"""
type external_systems {
  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid!

  """Name of the external system"""
  name: String!

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String!
}

"""
aggregated selection of "external_systems"
"""
type external_systems_aggregate {
  aggregate: external_systems_aggregate_fields
  nodes: [external_systems!]!
}

"""
aggregate fields of "external_systems"
"""
type external_systems_aggregate_fields {
  count(columns: [external_systems_select_column!], distinct: Boolean): Int!
  max: external_systems_max_fields
  min: external_systems_min_fields
}

"""
Boolean expression to filter rows from the table "external_systems". All fields are combined with a logical 'AND'.
"""
input external_systems_bool_exp {
  _and: [external_systems_bool_exp!]
  _not: external_systems_bool_exp
  _or: [external_systems_bool_exp!]
  client_external_systems: client_external_systems_bool_exp
  client_external_systems_aggregate: client_external_systems_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "external_systems"
"""
enum external_systems_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  external_systems_pkey
}

"""
input type for inserting data into table "external_systems"
"""
input external_systems_insert_input {
  client_external_systems: client_external_systems_arr_rel_insert_input

  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""aggregate max on columns"""
type external_systems_max_fields {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""aggregate min on columns"""
type external_systems_min_fields {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""
response of any mutation on the table "external_systems"
"""
type external_systems_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [external_systems!]!
}

"""
input type for inserting object relation for remote table "external_systems"
"""
input external_systems_obj_rel_insert_input {
  data: external_systems_insert_input!

  """upsert condition"""
  on_conflict: external_systems_on_conflict
}

"""
on_conflict condition type for table "external_systems"
"""
input external_systems_on_conflict {
  constraint: external_systems_constraint!
  update_columns: [external_systems_update_column!]! = []
  where: external_systems_bool_exp
}

"""Ordering options when selecting data from "external_systems"."""
input external_systems_order_by {
  client_external_systems_aggregate: client_external_systems_aggregate_order_by
  created_at: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  url: order_by
}

"""primary key columns input for table: external_systems"""
input external_systems_pk_columns_input {
  """Unique identifier for the external system"""
  id: uuid!
}

"""
select columns of table "external_systems"
"""
enum external_systems_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  url
}

"""
input type for updating data in table "external_systems"
"""
input external_systems_set_input {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""
Streaming cursor of the table "external_systems"
"""
input external_systems_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: external_systems_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input external_systems_stream_cursor_value_input {
  """Timestamp when the system was created"""
  created_at: timestamptz

  """Description of the external system and its purpose"""
  description: String

  """Path or reference to the system icon"""
  icon: String

  """Unique identifier for the external system"""
  id: uuid

  """Name of the external system"""
  name: String

  """Timestamp when the system was last updated"""
  updated_at: timestamptz

  """URL endpoint for the external system"""
  url: String
}

"""
update columns of table "external_systems"
"""
enum external_systems_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  icon

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at

  """column name"""
  url
}

input external_systems_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: external_systems_set_input

  """filter the rows which have to be updated"""
  where: external_systems_bool_exp!
}

"""
columns and relationships of "feature_flags"
"""
type feature_flags {
  """JSON array of roles that can access this feature"""
  allowed_roles(
    """JSON select path"""
    path: String
  ): jsonb!

  """Name of the feature controlled by this flag"""
  feature_name: String!

  """Unique identifier for the feature flag"""
  id: uuid!

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "feature_flags"
"""
type feature_flags_aggregate {
  aggregate: feature_flags_aggregate_fields
  nodes: [feature_flags!]!
}

"""
aggregate fields of "feature_flags"
"""
type feature_flags_aggregate_fields {
  count(columns: [feature_flags_select_column!], distinct: Boolean): Int!
  max: feature_flags_max_fields
  min: feature_flags_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input feature_flags_append_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb
}

"""
Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'.
"""
input feature_flags_bool_exp {
  _and: [feature_flags_bool_exp!]
  _not: feature_flags_bool_exp
  _or: [feature_flags_bool_exp!]
  allowed_roles: jsonb_comparison_exp
  feature_name: String_comparison_exp
  id: uuid_comparison_exp
  is_enabled: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "feature_flags"
"""
enum feature_flags_constraint {
  """
  unique or primary key constraint on columns "feature_name"
  """
  feature_flags_feature_name_key

  """
  unique or primary key constraint on columns "id"
  """
  feature_flags_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input feature_flags_delete_at_path_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input feature_flags_delete_elem_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input feature_flags_delete_key_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: String
}

"""
input type for inserting data into table "feature_flags"
"""
input feature_flags_insert_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb

  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type feature_flags_max_fields {
  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type feature_flags_min_fields {
  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "feature_flags"
"""
type feature_flags_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [feature_flags!]!
}

"""
on_conflict condition type for table "feature_flags"
"""
input feature_flags_on_conflict {
  constraint: feature_flags_constraint!
  update_columns: [feature_flags_update_column!]! = []
  where: feature_flags_bool_exp
}

"""Ordering options when selecting data from "feature_flags"."""
input feature_flags_order_by {
  allowed_roles: order_by
  feature_name: order_by
  id: order_by
  is_enabled: order_by
  updated_at: order_by
}

"""primary key columns input for table: feature_flags"""
input feature_flags_pk_columns_input {
  """Unique identifier for the feature flag"""
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input feature_flags_prepend_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb
}

"""
select columns of table "feature_flags"
"""
enum feature_flags_select_column {
  """column name"""
  allowed_roles

  """column name"""
  feature_name

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  updated_at
}

"""
input type for updating data in table "feature_flags"
"""
input feature_flags_set_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb

  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "feature_flags"
"""
input feature_flags_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: feature_flags_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input feature_flags_stream_cursor_value_input {
  """JSON array of roles that can access this feature"""
  allowed_roles: jsonb

  """Name of the feature controlled by this flag"""
  feature_name: String

  """Unique identifier for the feature flag"""
  id: uuid

  """Whether the feature is currently enabled"""
  is_enabled: Boolean

  """Timestamp when the feature flag was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "feature_flags"
"""
enum feature_flags_update_column {
  """column name"""
  allowed_roles

  """column name"""
  feature_name

  """column name"""
  id

  """column name"""
  is_enabled

  """column name"""
  updated_at
}

input feature_flags_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: feature_flags_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: feature_flags_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: feature_flags_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: feature_flags_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: feature_flags_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: feature_flags_set_input

  """filter the rows which have to be updated"""
  where: feature_flags_bool_exp!
}

input generate_payroll_dates_args {
  p_end_date: date
  p_max_dates: Int
  p_payroll_id: uuid
  p_start_date: date
}

"""
columns and relationships of "holidays"
"""
type holidays {
  """ISO country code where the holiday is observed"""
  country_code: bpchar!

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date!

  """Unique identifier for the holiday"""
  id: uuid!

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String!

  """Name of the holiday in English"""
  name: String!

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]!

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "holidays"
"""
type holidays_aggregate {
  aggregate: holidays_aggregate_fields
  nodes: [holidays!]!
}

"""
aggregate fields of "holidays"
"""
type holidays_aggregate_fields {
  avg: holidays_avg_fields
  count(columns: [holidays_select_column!], distinct: Boolean): Int!
  max: holidays_max_fields
  min: holidays_min_fields
  stddev: holidays_stddev_fields
  stddev_pop: holidays_stddev_pop_fields
  stddev_samp: holidays_stddev_samp_fields
  sum: holidays_sum_fields
  var_pop: holidays_var_pop_fields
  var_samp: holidays_var_samp_fields
  variance: holidays_variance_fields
}

"""aggregate avg on columns"""
type holidays_avg_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""
Boolean expression to filter rows from the table "holidays". All fields are combined with a logical 'AND'.
"""
input holidays_bool_exp {
  _and: [holidays_bool_exp!]
  _not: holidays_bool_exp
  _or: [holidays_bool_exp!]
  country_code: bpchar_comparison_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  id: uuid_comparison_exp
  is_fixed: Boolean_comparison_exp
  is_global: Boolean_comparison_exp
  launch_year: Int_comparison_exp
  local_name: String_comparison_exp
  name: String_comparison_exp
  region: String_array_comparison_exp
  types: String_array_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "holidays"
"""
enum holidays_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  holidays_pkey
}

"""
input type for incrementing numeric columns in table "holidays"
"""
input holidays_inc_input {
  """First year when the holiday was observed"""
  launch_year: Int
}

"""
input type for inserting data into table "holidays"
"""
input holidays_insert_input {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type holidays_max_fields {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type holidays_min_fields {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "holidays"
"""
type holidays_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [holidays!]!
}

"""
on_conflict condition type for table "holidays"
"""
input holidays_on_conflict {
  constraint: holidays_constraint!
  update_columns: [holidays_update_column!]! = []
  where: holidays_bool_exp
}

"""Ordering options when selecting data from "holidays"."""
input holidays_order_by {
  country_code: order_by
  created_at: order_by
  date: order_by
  id: order_by
  is_fixed: order_by
  is_global: order_by
  launch_year: order_by
  local_name: order_by
  name: order_by
  region: order_by
  types: order_by
  updated_at: order_by
}

"""primary key columns input for table: holidays"""
input holidays_pk_columns_input {
  """Unique identifier for the holiday"""
  id: uuid!
}

"""
select columns of table "holidays"
"""
enum holidays_select_column {
  """column name"""
  country_code

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  is_fixed

  """column name"""
  is_global

  """column name"""
  launch_year

  """column name"""
  local_name

  """column name"""
  name

  """column name"""
  region

  """column name"""
  types

  """column name"""
  updated_at
}

"""
input type for updating data in table "holidays"
"""
input holidays_set_input {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type holidays_stddev_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate stddev_pop on columns"""
type holidays_stddev_pop_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate stddev_samp on columns"""
type holidays_stddev_samp_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""
Streaming cursor of the table "holidays"
"""
input holidays_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: holidays_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input holidays_stream_cursor_value_input {
  """ISO country code where the holiday is observed"""
  country_code: bpchar

  """Timestamp when the holiday record was created"""
  created_at: timestamptz

  """Date of the holiday"""
  date: date

  """Unique identifier for the holiday"""
  id: uuid

  """Whether the holiday occurs on the same date each year"""
  is_fixed: Boolean

  """Whether the holiday is observed globally"""
  is_global: Boolean

  """First year when the holiday was observed"""
  launch_year: Int

  """Name of the holiday in local language"""
  local_name: String

  """Name of the holiday in English"""
  name: String

  """Array of regions within the country where the holiday applies"""
  region: [String!]

  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]

  """Timestamp when the holiday record was last updated"""
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type holidays_sum_fields {
  """First year when the holiday was observed"""
  launch_year: Int
}

"""
update columns of table "holidays"
"""
enum holidays_update_column {
  """column name"""
  country_code

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  is_fixed

  """column name"""
  is_global

  """column name"""
  launch_year

  """column name"""
  local_name

  """column name"""
  name

  """column name"""
  region

  """column name"""
  types

  """column name"""
  updated_at
}

input holidays_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: holidays_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: holidays_set_input

  """filter the rows which have to be updated"""
  where: holidays_bool_exp!
}

"""aggregate var_pop on columns"""
type holidays_var_pop_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate var_samp on columns"""
type holidays_var_samp_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

"""aggregate variance on columns"""
type holidays_variance_fields {
  """First year when the holiday was observed"""
  launch_year: Float
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "latest_payroll_version_results"
"""
type latest_payroll_version_results {
  active: Boolean!
  go_live_date: date
  id: uuid!
  name: String!
  payroll_id: uuid!
  queried_at: timestamptz
  version_number: Int!
}

"""
aggregated selection of "latest_payroll_version_results"
"""
type latest_payroll_version_results_aggregate {
  aggregate: latest_payroll_version_results_aggregate_fields
  nodes: [latest_payroll_version_results!]!
}

"""
aggregate fields of "latest_payroll_version_results"
"""
type latest_payroll_version_results_aggregate_fields {
  avg: latest_payroll_version_results_avg_fields
  count(columns: [latest_payroll_version_results_select_column!], distinct: Boolean): Int!
  max: latest_payroll_version_results_max_fields
  min: latest_payroll_version_results_min_fields
  stddev: latest_payroll_version_results_stddev_fields
  stddev_pop: latest_payroll_version_results_stddev_pop_fields
  stddev_samp: latest_payroll_version_results_stddev_samp_fields
  sum: latest_payroll_version_results_sum_fields
  var_pop: latest_payroll_version_results_var_pop_fields
  var_samp: latest_payroll_version_results_var_samp_fields
  variance: latest_payroll_version_results_variance_fields
}

"""aggregate avg on columns"""
type latest_payroll_version_results_avg_fields {
  version_number: Float
}

"""
Boolean expression to filter rows from the table "latest_payroll_version_results". All fields are combined with a logical 'AND'.
"""
input latest_payroll_version_results_bool_exp {
  _and: [latest_payroll_version_results_bool_exp!]
  _not: latest_payroll_version_results_bool_exp
  _or: [latest_payroll_version_results_bool_exp!]
  active: Boolean_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  payroll_id: uuid_comparison_exp
  queried_at: timestamptz_comparison_exp
  version_number: Int_comparison_exp
}

"""
unique or primary key constraints on table "latest_payroll_version_results"
"""
enum latest_payroll_version_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  latest_payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "latest_payroll_version_results"
"""
input latest_payroll_version_results_inc_input {
  version_number: Int
}

"""
input type for inserting data into table "latest_payroll_version_results"
"""
input latest_payroll_version_results_insert_input {
  active: Boolean
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""aggregate max on columns"""
type latest_payroll_version_results_max_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""aggregate min on columns"""
type latest_payroll_version_results_min_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""
response of any mutation on the table "latest_payroll_version_results"
"""
type latest_payroll_version_results_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [latest_payroll_version_results!]!
}

"""
on_conflict condition type for table "latest_payroll_version_results"
"""
input latest_payroll_version_results_on_conflict {
  constraint: latest_payroll_version_results_constraint!
  update_columns: [latest_payroll_version_results_update_column!]! = []
  where: latest_payroll_version_results_bool_exp
}

"""
Ordering options when selecting data from "latest_payroll_version_results".
"""
input latest_payroll_version_results_order_by {
  active: order_by
  go_live_date: order_by
  id: order_by
  name: order_by
  payroll_id: order_by
  queried_at: order_by
  version_number: order_by
}

"""primary key columns input for table: latest_payroll_version_results"""
input latest_payroll_version_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "latest_payroll_version_results"
"""
enum latest_payroll_version_results_select_column {
  """column name"""
  active

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  payroll_id

  """column name"""
  queried_at

  """column name"""
  version_number
}

"""
input type for updating data in table "latest_payroll_version_results"
"""
input latest_payroll_version_results_set_input {
  active: Boolean
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""aggregate stddev on columns"""
type latest_payroll_version_results_stddev_fields {
  version_number: Float
}

"""aggregate stddev_pop on columns"""
type latest_payroll_version_results_stddev_pop_fields {
  version_number: Float
}

"""aggregate stddev_samp on columns"""
type latest_payroll_version_results_stddev_samp_fields {
  version_number: Float
}

"""
Streaming cursor of the table "latest_payroll_version_results"
"""
input latest_payroll_version_results_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: latest_payroll_version_results_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input latest_payroll_version_results_stream_cursor_value_input {
  active: Boolean
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""aggregate sum on columns"""
type latest_payroll_version_results_sum_fields {
  version_number: Int
}

"""
update columns of table "latest_payroll_version_results"
"""
enum latest_payroll_version_results_update_column {
  """column name"""
  active

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  payroll_id

  """column name"""
  queried_at

  """column name"""
  version_number
}

input latest_payroll_version_results_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: latest_payroll_version_results_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: latest_payroll_version_results_set_input

  """filter the rows which have to be updated"""
  where: latest_payroll_version_results_bool_exp!
}

"""aggregate var_pop on columns"""
type latest_payroll_version_results_var_pop_fields {
  version_number: Float
}

"""aggregate var_samp on columns"""
type latest_payroll_version_results_var_samp_fields {
  version_number: Float
}

"""aggregate variance on columns"""
type latest_payroll_version_results_variance_fields {
  version_number: Float
}

"""
columns and relationships of "leave"
"""
type leave {
  """Last day of the leave period"""
  end_date: date!

  """Unique identifier for the leave record"""
  id: uuid!

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String!

  """An object relationship"""
  leave_user: users!

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date!

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """An object relationship"""
  user: users!

  """Reference to the user taking leave"""
  user_id: uuid!
}

"""
aggregated selection of "leave"
"""
type leave_aggregate {
  aggregate: leave_aggregate_fields
  nodes: [leave!]!
}

input leave_aggregate_bool_exp {
  count: leave_aggregate_bool_exp_count
}

input leave_aggregate_bool_exp_count {
  arguments: [leave_select_column!]
  distinct: Boolean
  filter: leave_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leave"
"""
type leave_aggregate_fields {
  count(columns: [leave_select_column!], distinct: Boolean): Int!
  max: leave_max_fields
  min: leave_min_fields
}

"""
order by aggregate values of table "leave"
"""
input leave_aggregate_order_by {
  count: order_by
  max: leave_max_order_by
  min: leave_min_order_by
}

"""
input type for inserting array relation for remote table "leave"
"""
input leave_arr_rel_insert_input {
  data: [leave_insert_input!]!

  """upsert condition"""
  on_conflict: leave_on_conflict
}

"""
Boolean expression to filter rows from the table "leave". All fields are combined with a logical 'AND'.
"""
input leave_bool_exp {
  _and: [leave_bool_exp!]
  _not: leave_bool_exp
  _or: [leave_bool_exp!]
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  leave_type: String_comparison_exp
  leave_user: users_bool_exp
  reason: String_comparison_exp
  start_date: date_comparison_exp
  status: leave_status_enum_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "leave"
"""
enum leave_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_pkey
}

"""
input type for inserting data into table "leave"
"""
input leave_insert_input {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String
  leave_user: users_obj_rel_insert_input

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  user: users_obj_rel_insert_input

  """Reference to the user taking leave"""
  user_id: uuid
}

"""aggregate max on columns"""
type leave_max_fields {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

"""
order by max() on columns of table "leave"
"""
input leave_max_order_by {
  """Last day of the leave period"""
  end_date: order_by

  """Unique identifier for the leave record"""
  id: order_by

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: order_by

  """Reason provided for the leave request"""
  reason: order_by

  """First day of the leave period"""
  start_date: order_by

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: order_by

  """Reference to the user taking leave"""
  user_id: order_by
}

"""aggregate min on columns"""
type leave_min_fields {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

"""
order by min() on columns of table "leave"
"""
input leave_min_order_by {
  """Last day of the leave period"""
  end_date: order_by

  """Unique identifier for the leave record"""
  id: order_by

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: order_by

  """Reason provided for the leave request"""
  reason: order_by

  """First day of the leave period"""
  start_date: order_by

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: order_by

  """Reference to the user taking leave"""
  user_id: order_by
}

"""
response of any mutation on the table "leave"
"""
type leave_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [leave!]!
}

"""
on_conflict condition type for table "leave"
"""
input leave_on_conflict {
  constraint: leave_constraint!
  update_columns: [leave_update_column!]! = []
  where: leave_bool_exp
}

"""Ordering options when selecting data from "leave"."""
input leave_order_by {
  end_date: order_by
  id: order_by
  leave_type: order_by
  leave_user: users_order_by
  reason: order_by
  start_date: order_by
  status: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: leave"""
input leave_pk_columns_input {
  """Unique identifier for the leave record"""
  id: uuid!
}

"""
select columns of table "leave"
"""
enum leave_select_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  reason

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  user_id
}

"""
input type for updating data in table "leave"
"""
input leave_set_input {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

scalar leave_status_enum

"""
Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'.
"""
input leave_status_enum_comparison_exp {
  _eq: leave_status_enum
  _gt: leave_status_enum
  _gte: leave_status_enum
  _in: [leave_status_enum!]
  _is_null: Boolean
  _lt: leave_status_enum
  _lte: leave_status_enum
  _neq: leave_status_enum
  _nin: [leave_status_enum!]
}

"""
Streaming cursor of the table "leave"
"""
input leave_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: leave_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input leave_stream_cursor_value_input {
  """Last day of the leave period"""
  end_date: date

  """Unique identifier for the leave record"""
  id: uuid

  """Type of leave (vacation, sick, personal, etc.)"""
  leave_type: String

  """Reason provided for the leave request"""
  reason: String

  """First day of the leave period"""
  start_date: date

  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum

  """Reference to the user taking leave"""
  user_id: uuid
}

"""
update columns of table "leave"
"""
enum leave_update_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  leave_type

  """column name"""
  reason

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  user_id
}

input leave_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: leave_set_input

  """filter the rows which have to be updated"""
  where: leave_bool_exp!
}

"""mutation root"""
type mutation_root {
  commitPayrollAssignments(changes: [PayrollAssignmentInput!]!): CommitPayrollAssignmentsOutput

  """
  delete data from the table: "adjustment_rules"
  """
  delete_adjustment_rules(
    """filter the rows which have to be deleted"""
    where: adjustment_rules_bool_exp!
  ): adjustment_rules_mutation_response

  """
  delete single row from the table: "adjustment_rules"
  """
  delete_adjustment_rules_by_pk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustment_rules

  """
  delete data from the table: "app_settings"
  """
  delete_app_settings(
    """filter the rows which have to be deleted"""
    where: app_settings_bool_exp!
  ): app_settings_mutation_response

  """
  delete single row from the table: "app_settings"
  """
  delete_app_settings_by_pk(
    """Unique identifier for application setting"""
    id: String!
  ): app_settings

  """
  delete data from the table: "billing_event_log"
  """
  delete_billing_event_log(
    """filter the rows which have to be deleted"""
    where: billing_event_log_bool_exp!
  ): billing_event_log_mutation_response

  """
  delete single row from the table: "billing_event_log"
  """
  delete_billing_event_log_by_pk(id: uuid!): billing_event_log

  """
  delete data from the table: "billing_invoice"
  """
  delete_billing_invoice(
    """filter the rows which have to be deleted"""
    where: billing_invoice_bool_exp!
  ): billing_invoice_mutation_response

  """
  delete single row from the table: "billing_invoice"
  """
  delete_billing_invoice_by_pk(id: uuid!): billing_invoice

  """
  delete data from the table: "billing_invoice_item"
  """
  delete_billing_invoice_item(
    """filter the rows which have to be deleted"""
    where: billing_invoice_item_bool_exp!
  ): billing_invoice_item_mutation_response

  """
  delete single row from the table: "billing_invoice_item"
  """
  delete_billing_invoice_item_by_pk(id: uuid!): billing_invoice_item

  """
  delete data from the table: "billing_invoices"
  """
  delete_billing_invoices(
    """filter the rows which have to be deleted"""
    where: billing_invoices_bool_exp!
  ): billing_invoices_mutation_response

  """
  delete single row from the table: "billing_invoices"
  """
  delete_billing_invoices_by_pk(id: uuid!): billing_invoices

  """
  delete data from the table: "billing_items"
  """
  delete_billing_items(
    """filter the rows which have to be deleted"""
    where: billing_items_bool_exp!
  ): billing_items_mutation_response

  """
  delete single row from the table: "billing_items"
  """
  delete_billing_items_by_pk(id: uuid!): billing_items

  """
  delete data from the table: "billing_plan"
  """
  delete_billing_plan(
    """filter the rows which have to be deleted"""
    where: billing_plan_bool_exp!
  ): billing_plan_mutation_response

  """
  delete single row from the table: "billing_plan"
  """
  delete_billing_plan_by_pk(id: uuid!): billing_plan

  """
  delete data from the table: "client_billing_assignment"
  """
  delete_client_billing_assignment(
    """filter the rows which have to be deleted"""
    where: client_billing_assignment_bool_exp!
  ): client_billing_assignment_mutation_response

  """
  delete single row from the table: "client_billing_assignment"
  """
  delete_client_billing_assignment_by_pk(id: uuid!): client_billing_assignment

  """
  delete data from the table: "client_external_systems"
  """
  delete_client_external_systems(
    """filter the rows which have to be deleted"""
    where: client_external_systems_bool_exp!
  ): client_external_systems_mutation_response

  """
  delete single row from the table: "client_external_systems"
  """
  delete_client_external_systems_by_pk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): client_external_systems

  """
  delete data from the table: "clients"
  """
  delete_clients(
    """filter the rows which have to be deleted"""
    where: clients_bool_exp!
  ): clients_mutation_response

  """
  delete single row from the table: "clients"
  """
  delete_clients_by_pk(
    """Unique identifier for the client"""
    id: uuid!
  ): clients

  """
  delete data from the table: "external_systems"
  """
  delete_external_systems(
    """filter the rows which have to be deleted"""
    where: external_systems_bool_exp!
  ): external_systems_mutation_response

  """
  delete single row from the table: "external_systems"
  """
  delete_external_systems_by_pk(
    """Unique identifier for the external system"""
    id: uuid!
  ): external_systems

  """
  delete data from the table: "feature_flags"
  """
  delete_feature_flags(
    """filter the rows which have to be deleted"""
    where: feature_flags_bool_exp!
  ): feature_flags_mutation_response

  """
  delete single row from the table: "feature_flags"
  """
  delete_feature_flags_by_pk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): feature_flags

  """
  delete data from the table: "holidays"
  """
  delete_holidays(
    """filter the rows which have to be deleted"""
    where: holidays_bool_exp!
  ): holidays_mutation_response

  """
  delete single row from the table: "holidays"
  """
  delete_holidays_by_pk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays

  """
  delete data from the table: "latest_payroll_version_results"
  """
  delete_latest_payroll_version_results(
    """filter the rows which have to be deleted"""
    where: latest_payroll_version_results_bool_exp!
  ): latest_payroll_version_results_mutation_response

  """
  delete single row from the table: "latest_payroll_version_results"
  """
  delete_latest_payroll_version_results_by_pk(id: uuid!): latest_payroll_version_results

  """
  delete data from the table: "leave"
  """
  delete_leave(
    """filter the rows which have to be deleted"""
    where: leave_bool_exp!
  ): leave_mutation_response

  """
  delete single row from the table: "leave"
  """
  delete_leave_by_pk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave

  """
  delete data from the table: "neon_auth.users_sync"
  """
  delete_neon_auth_users_sync(
    """filter the rows which have to be deleted"""
    where: neon_auth_users_sync_bool_exp!
  ): neon_auth_users_sync_mutation_response

  """
  delete single row from the table: "neon_auth.users_sync"
  """
  delete_neon_auth_users_sync_by_pk(
    """Unique identifier from the authentication provider"""
    id: String!
  ): neon_auth_users_sync

  """
  delete data from the table: "notes"
  """
  delete_notes(
    """filter the rows which have to be deleted"""
    where: notes_bool_exp!
  ): notes_mutation_response

  """
  delete single row from the table: "notes"
  """
  delete_notes_by_pk(
    """Unique identifier for the note"""
    id: uuid!
  ): notes

  """
  delete data from the table: "payroll_activation_results"
  """
  delete_payroll_activation_results(
    """filter the rows which have to be deleted"""
    where: payroll_activation_results_bool_exp!
  ): payroll_activation_results_mutation_response

  """
  delete single row from the table: "payroll_activation_results"
  """
  delete_payroll_activation_results_by_pk(id: uuid!): payroll_activation_results

  """
  delete data from the table: "payroll_cycles"
  """
  delete_payroll_cycles(
    """filter the rows which have to be deleted"""
    where: payroll_cycles_bool_exp!
  ): payroll_cycles_mutation_response

  """
  delete single row from the table: "payroll_cycles"
  """
  delete_payroll_cycles_by_pk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payroll_cycles

  """
  delete data from the table: "payroll_date_types"
  """
  delete_payroll_date_types(
    """filter the rows which have to be deleted"""
    where: payroll_date_types_bool_exp!
  ): payroll_date_types_mutation_response

  """
  delete single row from the table: "payroll_date_types"
  """
  delete_payroll_date_types_by_pk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payroll_date_types

  """
  delete data from the table: "payroll_dates"
  """
  delete_payroll_dates(
    """filter the rows which have to be deleted"""
    where: payroll_dates_bool_exp!
  ): payroll_dates_mutation_response

  """
  delete single row from the table: "payroll_dates"
  """
  delete_payroll_dates_by_pk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payroll_dates

  """
  delete data from the table: "payroll_version_history_results"
  """
  delete_payroll_version_history_results(
    """filter the rows which have to be deleted"""
    where: payroll_version_history_results_bool_exp!
  ): payroll_version_history_results_mutation_response

  """
  delete single row from the table: "payroll_version_history_results"
  """
  delete_payroll_version_history_results_by_pk(id: uuid!): payroll_version_history_results

  """
  delete data from the table: "payroll_version_results"
  """
  delete_payroll_version_results(
    """filter the rows which have to be deleted"""
    where: payroll_version_results_bool_exp!
  ): payroll_version_results_mutation_response

  """
  delete single row from the table: "payroll_version_results"
  """
  delete_payroll_version_results_by_pk(id: uuid!): payroll_version_results

  """
  delete data from the table: "payrolls"
  """
  delete_payrolls(
    """filter the rows which have to be deleted"""
    where: payrolls_bool_exp!
  ): payrolls_mutation_response

  """
  delete single row from the table: "payrolls"
  """
  delete_payrolls_by_pk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls

  """
  delete data from the table: "permissions"
  """
  delete_permissions(
    """filter the rows which have to be deleted"""
    where: permissions_bool_exp!
  ): permissions_mutation_response

  """
  delete single row from the table: "permissions"
  """
  delete_permissions_by_pk(id: uuid!): permissions

  """
  delete data from the table: "resources"
  """
  delete_resources(
    """filter the rows which have to be deleted"""
    where: resources_bool_exp!
  ): resources_mutation_response

  """
  delete single row from the table: "resources"
  """
  delete_resources_by_pk(id: uuid!): resources

  """
  delete data from the table: "role_permissions"
  """
  delete_role_permissions(
    """filter the rows which have to be deleted"""
    where: role_permissions_bool_exp!
  ): role_permissions_mutation_response

  """
  delete single row from the table: "role_permissions"
  """
  delete_role_permissions_by_pk(id: uuid!): role_permissions

  """
  delete data from the table: "roles"
  """
  delete_roles(
    """filter the rows which have to be deleted"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  delete single row from the table: "roles"
  """
  delete_roles_by_pk(id: uuid!): roles

  """
  delete data from the table: "user_roles"
  """
  delete_user_roles(
    """filter the rows which have to be deleted"""
    where: user_roles_bool_exp!
  ): user_roles_mutation_response

  """
  delete single row from the table: "user_roles"
  """
  delete_user_roles_by_pk(id: uuid!): user_roles

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(
    """Unique identifier for the user"""
    id: uuid!
  ): users

  """
  delete data from the table: "users_role_backup"
  """
  delete_users_role_backup(
    """filter the rows which have to be deleted"""
    where: users_role_backup_bool_exp!
  ): users_role_backup_mutation_response

  """
  delete data from the table: "work_schedule"
  """
  delete_work_schedule(
    """filter the rows which have to be deleted"""
    where: work_schedule_bool_exp!
  ): work_schedule_mutation_response

  """
  delete single row from the table: "work_schedule"
  """
  delete_work_schedule_by_pk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): work_schedule

  """
  insert data into the table: "adjustment_rules"
  """
  insert_adjustment_rules(
    """the rows to be inserted"""
    objects: [adjustment_rules_insert_input!]!

    """upsert condition"""
    on_conflict: adjustment_rules_on_conflict
  ): adjustment_rules_mutation_response

  """
  insert a single row into the table: "adjustment_rules"
  """
  insert_adjustment_rules_one(
    """the row to be inserted"""
    object: adjustment_rules_insert_input!

    """upsert condition"""
    on_conflict: adjustment_rules_on_conflict
  ): adjustment_rules

  """
  insert data into the table: "app_settings"
  """
  insert_app_settings(
    """the rows to be inserted"""
    objects: [app_settings_insert_input!]!

    """upsert condition"""
    on_conflict: app_settings_on_conflict
  ): app_settings_mutation_response

  """
  insert a single row into the table: "app_settings"
  """
  insert_app_settings_one(
    """the row to be inserted"""
    object: app_settings_insert_input!

    """upsert condition"""
    on_conflict: app_settings_on_conflict
  ): app_settings

  """
  insert data into the table: "billing_event_log"
  """
  insert_billing_event_log(
    """the rows to be inserted"""
    objects: [billing_event_log_insert_input!]!

    """upsert condition"""
    on_conflict: billing_event_log_on_conflict
  ): billing_event_log_mutation_response

  """
  insert a single row into the table: "billing_event_log"
  """
  insert_billing_event_log_one(
    """the row to be inserted"""
    object: billing_event_log_insert_input!

    """upsert condition"""
    on_conflict: billing_event_log_on_conflict
  ): billing_event_log

  """
  insert data into the table: "billing_invoice"
  """
  insert_billing_invoice(
    """the rows to be inserted"""
    objects: [billing_invoice_insert_input!]!

    """upsert condition"""
    on_conflict: billing_invoice_on_conflict
  ): billing_invoice_mutation_response

  """
  insert data into the table: "billing_invoice_item"
  """
  insert_billing_invoice_item(
    """the rows to be inserted"""
    objects: [billing_invoice_item_insert_input!]!

    """upsert condition"""
    on_conflict: billing_invoice_item_on_conflict
  ): billing_invoice_item_mutation_response

  """
  insert a single row into the table: "billing_invoice_item"
  """
  insert_billing_invoice_item_one(
    """the row to be inserted"""
    object: billing_invoice_item_insert_input!

    """upsert condition"""
    on_conflict: billing_invoice_item_on_conflict
  ): billing_invoice_item

  """
  insert a single row into the table: "billing_invoice"
  """
  insert_billing_invoice_one(
    """the row to be inserted"""
    object: billing_invoice_insert_input!

    """upsert condition"""
    on_conflict: billing_invoice_on_conflict
  ): billing_invoice

  """
  insert data into the table: "billing_invoices"
  """
  insert_billing_invoices(
    """the rows to be inserted"""
    objects: [billing_invoices_insert_input!]!

    """upsert condition"""
    on_conflict: billing_invoices_on_conflict
  ): billing_invoices_mutation_response

  """
  insert a single row into the table: "billing_invoices"
  """
  insert_billing_invoices_one(
    """the row to be inserted"""
    object: billing_invoices_insert_input!

    """upsert condition"""
    on_conflict: billing_invoices_on_conflict
  ): billing_invoices

  """
  insert data into the table: "billing_items"
  """
  insert_billing_items(
    """the rows to be inserted"""
    objects: [billing_items_insert_input!]!

    """upsert condition"""
    on_conflict: billing_items_on_conflict
  ): billing_items_mutation_response

  """
  insert a single row into the table: "billing_items"
  """
  insert_billing_items_one(
    """the row to be inserted"""
    object: billing_items_insert_input!

    """upsert condition"""
    on_conflict: billing_items_on_conflict
  ): billing_items

  """
  insert data into the table: "billing_plan"
  """
  insert_billing_plan(
    """the rows to be inserted"""
    objects: [billing_plan_insert_input!]!

    """upsert condition"""
    on_conflict: billing_plan_on_conflict
  ): billing_plan_mutation_response

  """
  insert a single row into the table: "billing_plan"
  """
  insert_billing_plan_one(
    """the row to be inserted"""
    object: billing_plan_insert_input!

    """upsert condition"""
    on_conflict: billing_plan_on_conflict
  ): billing_plan

  """
  insert data into the table: "client_billing_assignment"
  """
  insert_client_billing_assignment(
    """the rows to be inserted"""
    objects: [client_billing_assignment_insert_input!]!

    """upsert condition"""
    on_conflict: client_billing_assignment_on_conflict
  ): client_billing_assignment_mutation_response

  """
  insert a single row into the table: "client_billing_assignment"
  """
  insert_client_billing_assignment_one(
    """the row to be inserted"""
    object: client_billing_assignment_insert_input!

    """upsert condition"""
    on_conflict: client_billing_assignment_on_conflict
  ): client_billing_assignment

  """
  insert data into the table: "client_external_systems"
  """
  insert_client_external_systems(
    """the rows to be inserted"""
    objects: [client_external_systems_insert_input!]!

    """upsert condition"""
    on_conflict: client_external_systems_on_conflict
  ): client_external_systems_mutation_response

  """
  insert a single row into the table: "client_external_systems"
  """
  insert_client_external_systems_one(
    """the row to be inserted"""
    object: client_external_systems_insert_input!

    """upsert condition"""
    on_conflict: client_external_systems_on_conflict
  ): client_external_systems

  """
  insert data into the table: "clients"
  """
  insert_clients(
    """the rows to be inserted"""
    objects: [clients_insert_input!]!

    """upsert condition"""
    on_conflict: clients_on_conflict
  ): clients_mutation_response

  """
  insert a single row into the table: "clients"
  """
  insert_clients_one(
    """the row to be inserted"""
    object: clients_insert_input!

    """upsert condition"""
    on_conflict: clients_on_conflict
  ): clients

  """
  insert data into the table: "external_systems"
  """
  insert_external_systems(
    """the rows to be inserted"""
    objects: [external_systems_insert_input!]!

    """upsert condition"""
    on_conflict: external_systems_on_conflict
  ): external_systems_mutation_response

  """
  insert a single row into the table: "external_systems"
  """
  insert_external_systems_one(
    """the row to be inserted"""
    object: external_systems_insert_input!

    """upsert condition"""
    on_conflict: external_systems_on_conflict
  ): external_systems

  """
  insert data into the table: "feature_flags"
  """
  insert_feature_flags(
    """the rows to be inserted"""
    objects: [feature_flags_insert_input!]!

    """upsert condition"""
    on_conflict: feature_flags_on_conflict
  ): feature_flags_mutation_response

  """
  insert a single row into the table: "feature_flags"
  """
  insert_feature_flags_one(
    """the row to be inserted"""
    object: feature_flags_insert_input!

    """upsert condition"""
    on_conflict: feature_flags_on_conflict
  ): feature_flags

  """
  insert data into the table: "holidays"
  """
  insert_holidays(
    """the rows to be inserted"""
    objects: [holidays_insert_input!]!

    """upsert condition"""
    on_conflict: holidays_on_conflict
  ): holidays_mutation_response

  """
  insert a single row into the table: "holidays"
  """
  insert_holidays_one(
    """the row to be inserted"""
    object: holidays_insert_input!

    """upsert condition"""
    on_conflict: holidays_on_conflict
  ): holidays

  """
  insert data into the table: "latest_payroll_version_results"
  """
  insert_latest_payroll_version_results(
    """the rows to be inserted"""
    objects: [latest_payroll_version_results_insert_input!]!

    """upsert condition"""
    on_conflict: latest_payroll_version_results_on_conflict
  ): latest_payroll_version_results_mutation_response

  """
  insert a single row into the table: "latest_payroll_version_results"
  """
  insert_latest_payroll_version_results_one(
    """the row to be inserted"""
    object: latest_payroll_version_results_insert_input!

    """upsert condition"""
    on_conflict: latest_payroll_version_results_on_conflict
  ): latest_payroll_version_results

  """
  insert data into the table: "leave"
  """
  insert_leave(
    """the rows to be inserted"""
    objects: [leave_insert_input!]!

    """upsert condition"""
    on_conflict: leave_on_conflict
  ): leave_mutation_response

  """
  insert a single row into the table: "leave"
  """
  insert_leave_one(
    """the row to be inserted"""
    object: leave_insert_input!

    """upsert condition"""
    on_conflict: leave_on_conflict
  ): leave

  """
  insert data into the table: "neon_auth.users_sync"
  """
  insert_neon_auth_users_sync(
    """the rows to be inserted"""
    objects: [neon_auth_users_sync_insert_input!]!

    """upsert condition"""
    on_conflict: neon_auth_users_sync_on_conflict
  ): neon_auth_users_sync_mutation_response

  """
  insert a single row into the table: "neon_auth.users_sync"
  """
  insert_neon_auth_users_sync_one(
    """the row to be inserted"""
    object: neon_auth_users_sync_insert_input!

    """upsert condition"""
    on_conflict: neon_auth_users_sync_on_conflict
  ): neon_auth_users_sync

  """
  insert data into the table: "notes"
  """
  insert_notes(
    """the rows to be inserted"""
    objects: [notes_insert_input!]!

    """upsert condition"""
    on_conflict: notes_on_conflict
  ): notes_mutation_response

  """
  insert a single row into the table: "notes"
  """
  insert_notes_one(
    """the row to be inserted"""
    object: notes_insert_input!

    """upsert condition"""
    on_conflict: notes_on_conflict
  ): notes

  """
  insert data into the table: "payroll_activation_results"
  """
  insert_payroll_activation_results(
    """the rows to be inserted"""
    objects: [payroll_activation_results_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_activation_results_on_conflict
  ): payroll_activation_results_mutation_response

  """
  insert a single row into the table: "payroll_activation_results"
  """
  insert_payroll_activation_results_one(
    """the row to be inserted"""
    object: payroll_activation_results_insert_input!

    """upsert condition"""
    on_conflict: payroll_activation_results_on_conflict
  ): payroll_activation_results

  """
  insert data into the table: "payroll_cycles"
  """
  insert_payroll_cycles(
    """the rows to be inserted"""
    objects: [payroll_cycles_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_cycles_on_conflict
  ): payroll_cycles_mutation_response

  """
  insert a single row into the table: "payroll_cycles"
  """
  insert_payroll_cycles_one(
    """the row to be inserted"""
    object: payroll_cycles_insert_input!

    """upsert condition"""
    on_conflict: payroll_cycles_on_conflict
  ): payroll_cycles

  """
  insert data into the table: "payroll_date_types"
  """
  insert_payroll_date_types(
    """the rows to be inserted"""
    objects: [payroll_date_types_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_date_types_on_conflict
  ): payroll_date_types_mutation_response

  """
  insert a single row into the table: "payroll_date_types"
  """
  insert_payroll_date_types_one(
    """the row to be inserted"""
    object: payroll_date_types_insert_input!

    """upsert condition"""
    on_conflict: payroll_date_types_on_conflict
  ): payroll_date_types

  """
  insert data into the table: "payroll_dates"
  """
  insert_payroll_dates(
    """the rows to be inserted"""
    objects: [payroll_dates_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_dates_on_conflict
  ): payroll_dates_mutation_response

  """
  insert a single row into the table: "payroll_dates"
  """
  insert_payroll_dates_one(
    """the row to be inserted"""
    object: payroll_dates_insert_input!

    """upsert condition"""
    on_conflict: payroll_dates_on_conflict
  ): payroll_dates

  """
  insert data into the table: "payroll_version_history_results"
  """
  insert_payroll_version_history_results(
    """the rows to be inserted"""
    objects: [payroll_version_history_results_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_version_history_results_on_conflict
  ): payroll_version_history_results_mutation_response

  """
  insert a single row into the table: "payroll_version_history_results"
  """
  insert_payroll_version_history_results_one(
    """the row to be inserted"""
    object: payroll_version_history_results_insert_input!

    """upsert condition"""
    on_conflict: payroll_version_history_results_on_conflict
  ): payroll_version_history_results

  """
  insert data into the table: "payroll_version_results"
  """
  insert_payroll_version_results(
    """the rows to be inserted"""
    objects: [payroll_version_results_insert_input!]!

    """upsert condition"""
    on_conflict: payroll_version_results_on_conflict
  ): payroll_version_results_mutation_response

  """
  insert a single row into the table: "payroll_version_results"
  """
  insert_payroll_version_results_one(
    """the row to be inserted"""
    object: payroll_version_results_insert_input!

    """upsert condition"""
    on_conflict: payroll_version_results_on_conflict
  ): payroll_version_results

  """
  insert data into the table: "payrolls"
  """
  insert_payrolls(
    """the rows to be inserted"""
    objects: [payrolls_insert_input!]!

    """upsert condition"""
    on_conflict: payrolls_on_conflict
  ): payrolls_mutation_response

  """
  insert a single row into the table: "payrolls"
  """
  insert_payrolls_one(
    """the row to be inserted"""
    object: payrolls_insert_input!

    """upsert condition"""
    on_conflict: payrolls_on_conflict
  ): payrolls

  """
  insert data into the table: "permissions"
  """
  insert_permissions(
    """the rows to be inserted"""
    objects: [permissions_insert_input!]!

    """upsert condition"""
    on_conflict: permissions_on_conflict
  ): permissions_mutation_response

  """
  insert a single row into the table: "permissions"
  """
  insert_permissions_one(
    """the row to be inserted"""
    object: permissions_insert_input!

    """upsert condition"""
    on_conflict: permissions_on_conflict
  ): permissions

  """
  insert data into the table: "resources"
  """
  insert_resources(
    """the rows to be inserted"""
    objects: [resources_insert_input!]!

    """upsert condition"""
    on_conflict: resources_on_conflict
  ): resources_mutation_response

  """
  insert a single row into the table: "resources"
  """
  insert_resources_one(
    """the row to be inserted"""
    object: resources_insert_input!

    """upsert condition"""
    on_conflict: resources_on_conflict
  ): resources

  """
  insert data into the table: "role_permissions"
  """
  insert_role_permissions(
    """the rows to be inserted"""
    objects: [role_permissions_insert_input!]!

    """upsert condition"""
    on_conflict: role_permissions_on_conflict
  ): role_permissions_mutation_response

  """
  insert a single row into the table: "role_permissions"
  """
  insert_role_permissions_one(
    """the row to be inserted"""
    object: role_permissions_insert_input!

    """upsert condition"""
    on_conflict: role_permissions_on_conflict
  ): role_permissions

  """
  insert data into the table: "roles"
  """
  insert_roles(
    """the rows to be inserted"""
    objects: [roles_insert_input!]!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles_mutation_response

  """
  insert a single row into the table: "roles"
  """
  insert_roles_one(
    """the row to be inserted"""
    object: roles_insert_input!

    """upsert condition"""
    on_conflict: roles_on_conflict
  ): roles

  """
  insert data into the table: "user_roles"
  """
  insert_user_roles(
    """the rows to be inserted"""
    objects: [user_roles_insert_input!]!

    """upsert condition"""
    on_conflict: user_roles_on_conflict
  ): user_roles_mutation_response

  """
  insert a single row into the table: "user_roles"
  """
  insert_user_roles_one(
    """the row to be inserted"""
    object: user_roles_insert_input!

    """upsert condition"""
    on_conflict: user_roles_on_conflict
  ): user_roles

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "users_role_backup"
  """
  insert_users_role_backup(
    """the rows to be inserted"""
    objects: [users_role_backup_insert_input!]!
  ): users_role_backup_mutation_response

  """
  insert a single row into the table: "users_role_backup"
  """
  insert_users_role_backup_one(
    """the row to be inserted"""
    object: users_role_backup_insert_input!
  ): users_role_backup

  """
  insert data into the table: "work_schedule"
  """
  insert_work_schedule(
    """the rows to be inserted"""
    objects: [work_schedule_insert_input!]!

    """upsert condition"""
    on_conflict: work_schedule_on_conflict
  ): work_schedule_mutation_response

  """
  insert a single row into the table: "work_schedule"
  """
  insert_work_schedule_one(
    """the row to be inserted"""
    object: work_schedule_insert_input!

    """upsert condition"""
    on_conflict: work_schedule_on_conflict
  ): work_schedule

  """
  update data of the table: "adjustment_rules"
  """
  update_adjustment_rules(
    """sets the columns of the filtered rows to the given values"""
    _set: adjustment_rules_set_input

    """filter the rows which have to be updated"""
    where: adjustment_rules_bool_exp!
  ): adjustment_rules_mutation_response

  """
  update single row of the table: "adjustment_rules"
  """
  update_adjustment_rules_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: adjustment_rules_set_input
    pk_columns: adjustment_rules_pk_columns_input!
  ): adjustment_rules

  """
  update multiples rows of table: "adjustment_rules"
  """
  update_adjustment_rules_many(
    """updates to execute, in order"""
    updates: [adjustment_rules_updates!]!
  ): [adjustment_rules_mutation_response]

  """
  update data of the table: "app_settings"
  """
  update_app_settings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: app_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: app_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: app_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: app_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: app_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: app_settings_set_input

    """filter the rows which have to be updated"""
    where: app_settings_bool_exp!
  ): app_settings_mutation_response

  """
  update single row of the table: "app_settings"
  """
  update_app_settings_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: app_settings_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: app_settings_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: app_settings_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: app_settings_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: app_settings_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: app_settings_set_input
    pk_columns: app_settings_pk_columns_input!
  ): app_settings

  """
  update multiples rows of table: "app_settings"
  """
  update_app_settings_many(
    """updates to execute, in order"""
    updates: [app_settings_updates!]!
  ): [app_settings_mutation_response]

  """
  update data of the table: "billing_event_log"
  """
  update_billing_event_log(
    """sets the columns of the filtered rows to the given values"""
    _set: billing_event_log_set_input

    """filter the rows which have to be updated"""
    where: billing_event_log_bool_exp!
  ): billing_event_log_mutation_response

  """
  update single row of the table: "billing_event_log"
  """
  update_billing_event_log_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: billing_event_log_set_input
    pk_columns: billing_event_log_pk_columns_input!
  ): billing_event_log

  """
  update multiples rows of table: "billing_event_log"
  """
  update_billing_event_log_many(
    """updates to execute, in order"""
    updates: [billing_event_log_updates!]!
  ): [billing_event_log_mutation_response]

  """
  update data of the table: "billing_invoice"
  """
  update_billing_invoice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_invoice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_invoice_set_input

    """filter the rows which have to be updated"""
    where: billing_invoice_bool_exp!
  ): billing_invoice_mutation_response

  """
  update single row of the table: "billing_invoice"
  """
  update_billing_invoice_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_invoice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_invoice_set_input
    pk_columns: billing_invoice_pk_columns_input!
  ): billing_invoice

  """
  update data of the table: "billing_invoice_item"
  """
  update_billing_invoice_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_invoice_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_invoice_item_set_input

    """filter the rows which have to be updated"""
    where: billing_invoice_item_bool_exp!
  ): billing_invoice_item_mutation_response

  """
  update single row of the table: "billing_invoice_item"
  """
  update_billing_invoice_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_invoice_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_invoice_item_set_input
    pk_columns: billing_invoice_item_pk_columns_input!
  ): billing_invoice_item

  """
  update multiples rows of table: "billing_invoice_item"
  """
  update_billing_invoice_item_many(
    """updates to execute, in order"""
    updates: [billing_invoice_item_updates!]!
  ): [billing_invoice_item_mutation_response]

  """
  update multiples rows of table: "billing_invoice"
  """
  update_billing_invoice_many(
    """updates to execute, in order"""
    updates: [billing_invoice_updates!]!
  ): [billing_invoice_mutation_response]

  """
  update data of the table: "billing_invoices"
  """
  update_billing_invoices(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_invoices_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_invoices_set_input

    """filter the rows which have to be updated"""
    where: billing_invoices_bool_exp!
  ): billing_invoices_mutation_response

  """
  update single row of the table: "billing_invoices"
  """
  update_billing_invoices_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_invoices_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_invoices_set_input
    pk_columns: billing_invoices_pk_columns_input!
  ): billing_invoices

  """
  update multiples rows of table: "billing_invoices"
  """
  update_billing_invoices_many(
    """updates to execute, in order"""
    updates: [billing_invoices_updates!]!
  ): [billing_invoices_mutation_response]

  """
  update data of the table: "billing_items"
  """
  update_billing_items(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_items_set_input

    """filter the rows which have to be updated"""
    where: billing_items_bool_exp!
  ): billing_items_mutation_response

  """
  update single row of the table: "billing_items"
  """
  update_billing_items_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_items_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_items_set_input
    pk_columns: billing_items_pk_columns_input!
  ): billing_items

  """
  update multiples rows of table: "billing_items"
  """
  update_billing_items_many(
    """updates to execute, in order"""
    updates: [billing_items_updates!]!
  ): [billing_items_mutation_response]

  """
  update data of the table: "billing_plan"
  """
  update_billing_plan(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_plan_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_plan_set_input

    """filter the rows which have to be updated"""
    where: billing_plan_bool_exp!
  ): billing_plan_mutation_response

  """
  update single row of the table: "billing_plan"
  """
  update_billing_plan_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billing_plan_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: billing_plan_set_input
    pk_columns: billing_plan_pk_columns_input!
  ): billing_plan

  """
  update multiples rows of table: "billing_plan"
  """
  update_billing_plan_many(
    """updates to execute, in order"""
    updates: [billing_plan_updates!]!
  ): [billing_plan_mutation_response]

  """
  update data of the table: "client_billing_assignment"
  """
  update_client_billing_assignment(
    """sets the columns of the filtered rows to the given values"""
    _set: client_billing_assignment_set_input

    """filter the rows which have to be updated"""
    where: client_billing_assignment_bool_exp!
  ): client_billing_assignment_mutation_response

  """
  update single row of the table: "client_billing_assignment"
  """
  update_client_billing_assignment_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: client_billing_assignment_set_input
    pk_columns: client_billing_assignment_pk_columns_input!
  ): client_billing_assignment

  """
  update multiples rows of table: "client_billing_assignment"
  """
  update_client_billing_assignment_many(
    """updates to execute, in order"""
    updates: [client_billing_assignment_updates!]!
  ): [client_billing_assignment_mutation_response]

  """
  update data of the table: "client_external_systems"
  """
  update_client_external_systems(
    """sets the columns of the filtered rows to the given values"""
    _set: client_external_systems_set_input

    """filter the rows which have to be updated"""
    where: client_external_systems_bool_exp!
  ): client_external_systems_mutation_response

  """
  update single row of the table: "client_external_systems"
  """
  update_client_external_systems_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: client_external_systems_set_input
    pk_columns: client_external_systems_pk_columns_input!
  ): client_external_systems

  """
  update multiples rows of table: "client_external_systems"
  """
  update_client_external_systems_many(
    """updates to execute, in order"""
    updates: [client_external_systems_updates!]!
  ): [client_external_systems_mutation_response]

  """
  update data of the table: "clients"
  """
  update_clients(
    """sets the columns of the filtered rows to the given values"""
    _set: clients_set_input

    """filter the rows which have to be updated"""
    where: clients_bool_exp!
  ): clients_mutation_response

  """
  update single row of the table: "clients"
  """
  update_clients_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: clients_set_input
    pk_columns: clients_pk_columns_input!
  ): clients

  """
  update multiples rows of table: "clients"
  """
  update_clients_many(
    """updates to execute, in order"""
    updates: [clients_updates!]!
  ): [clients_mutation_response]

  """
  update data of the table: "external_systems"
  """
  update_external_systems(
    """sets the columns of the filtered rows to the given values"""
    _set: external_systems_set_input

    """filter the rows which have to be updated"""
    where: external_systems_bool_exp!
  ): external_systems_mutation_response

  """
  update single row of the table: "external_systems"
  """
  update_external_systems_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: external_systems_set_input
    pk_columns: external_systems_pk_columns_input!
  ): external_systems

  """
  update multiples rows of table: "external_systems"
  """
  update_external_systems_many(
    """updates to execute, in order"""
    updates: [external_systems_updates!]!
  ): [external_systems_mutation_response]

  """
  update data of the table: "feature_flags"
  """
  update_feature_flags(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feature_flags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_flags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_flags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_flags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feature_flags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feature_flags_set_input

    """filter the rows which have to be updated"""
    where: feature_flags_bool_exp!
  ): feature_flags_mutation_response

  """
  update single row of the table: "feature_flags"
  """
  update_feature_flags_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: feature_flags_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_flags_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_flags_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_flags_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: feature_flags_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: feature_flags_set_input
    pk_columns: feature_flags_pk_columns_input!
  ): feature_flags

  """
  update multiples rows of table: "feature_flags"
  """
  update_feature_flags_many(
    """updates to execute, in order"""
    updates: [feature_flags_updates!]!
  ): [feature_flags_mutation_response]

  """
  update data of the table: "holidays"
  """
  update_holidays(
    """increments the numeric columns with given value of the filtered values"""
    _inc: holidays_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: holidays_set_input

    """filter the rows which have to be updated"""
    where: holidays_bool_exp!
  ): holidays_mutation_response

  """
  update single row of the table: "holidays"
  """
  update_holidays_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: holidays_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: holidays_set_input
    pk_columns: holidays_pk_columns_input!
  ): holidays

  """
  update multiples rows of table: "holidays"
  """
  update_holidays_many(
    """updates to execute, in order"""
    updates: [holidays_updates!]!
  ): [holidays_mutation_response]

  """
  update data of the table: "latest_payroll_version_results"
  """
  update_latest_payroll_version_results(
    """increments the numeric columns with given value of the filtered values"""
    _inc: latest_payroll_version_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: latest_payroll_version_results_set_input

    """filter the rows which have to be updated"""
    where: latest_payroll_version_results_bool_exp!
  ): latest_payroll_version_results_mutation_response

  """
  update single row of the table: "latest_payroll_version_results"
  """
  update_latest_payroll_version_results_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: latest_payroll_version_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: latest_payroll_version_results_set_input
    pk_columns: latest_payroll_version_results_pk_columns_input!
  ): latest_payroll_version_results

  """
  update multiples rows of table: "latest_payroll_version_results"
  """
  update_latest_payroll_version_results_many(
    """updates to execute, in order"""
    updates: [latest_payroll_version_results_updates!]!
  ): [latest_payroll_version_results_mutation_response]

  """
  update data of the table: "leave"
  """
  update_leave(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_set_input

    """filter the rows which have to be updated"""
    where: leave_bool_exp!
  ): leave_mutation_response

  """
  update single row of the table: "leave"
  """
  update_leave_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: leave_set_input
    pk_columns: leave_pk_columns_input!
  ): leave

  """
  update multiples rows of table: "leave"
  """
  update_leave_many(
    """updates to execute, in order"""
    updates: [leave_updates!]!
  ): [leave_mutation_response]

  """
  update data of the table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: neon_auth_users_sync_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: neon_auth_users_sync_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: neon_auth_users_sync_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: neon_auth_users_sync_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: neon_auth_users_sync_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: neon_auth_users_sync_set_input

    """filter the rows which have to be updated"""
    where: neon_auth_users_sync_bool_exp!
  ): neon_auth_users_sync_mutation_response

  """
  update single row of the table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: neon_auth_users_sync_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: neon_auth_users_sync_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: neon_auth_users_sync_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: neon_auth_users_sync_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: neon_auth_users_sync_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: neon_auth_users_sync_set_input
    pk_columns: neon_auth_users_sync_pk_columns_input!
  ): neon_auth_users_sync

  """
  update multiples rows of table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync_many(
    """updates to execute, in order"""
    updates: [neon_auth_users_sync_updates!]!
  ): [neon_auth_users_sync_mutation_response]

  """
  update data of the table: "notes"
  """
  update_notes(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_set_input

    """filter the rows which have to be updated"""
    where: notes_bool_exp!
  ): notes_mutation_response

  """
  update single row of the table: "notes"
  """
  update_notes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: notes_set_input
    pk_columns: notes_pk_columns_input!
  ): notes

  """
  update multiples rows of table: "notes"
  """
  update_notes_many(
    """updates to execute, in order"""
    updates: [notes_updates!]!
  ): [notes_mutation_response]

  """
  update data of the table: "payroll_activation_results"
  """
  update_payroll_activation_results(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payroll_activation_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payroll_activation_results_set_input

    """filter the rows which have to be updated"""
    where: payroll_activation_results_bool_exp!
  ): payroll_activation_results_mutation_response

  """
  update single row of the table: "payroll_activation_results"
  """
  update_payroll_activation_results_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payroll_activation_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payroll_activation_results_set_input
    pk_columns: payroll_activation_results_pk_columns_input!
  ): payroll_activation_results

  """
  update multiples rows of table: "payroll_activation_results"
  """
  update_payroll_activation_results_many(
    """updates to execute, in order"""
    updates: [payroll_activation_results_updates!]!
  ): [payroll_activation_results_mutation_response]

  """
  update data of the table: "payroll_cycles"
  """
  update_payroll_cycles(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_cycles_set_input

    """filter the rows which have to be updated"""
    where: payroll_cycles_bool_exp!
  ): payroll_cycles_mutation_response

  """
  update single row of the table: "payroll_cycles"
  """
  update_payroll_cycles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_cycles_set_input
    pk_columns: payroll_cycles_pk_columns_input!
  ): payroll_cycles

  """
  update multiples rows of table: "payroll_cycles"
  """
  update_payroll_cycles_many(
    """updates to execute, in order"""
    updates: [payroll_cycles_updates!]!
  ): [payroll_cycles_mutation_response]

  """
  update data of the table: "payroll_date_types"
  """
  update_payroll_date_types(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_date_types_set_input

    """filter the rows which have to be updated"""
    where: payroll_date_types_bool_exp!
  ): payroll_date_types_mutation_response

  """
  update single row of the table: "payroll_date_types"
  """
  update_payroll_date_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_date_types_set_input
    pk_columns: payroll_date_types_pk_columns_input!
  ): payroll_date_types

  """
  update multiples rows of table: "payroll_date_types"
  """
  update_payroll_date_types_many(
    """updates to execute, in order"""
    updates: [payroll_date_types_updates!]!
  ): [payroll_date_types_mutation_response]

  """
  update data of the table: "payroll_dates"
  """
  update_payroll_dates(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_dates_set_input

    """filter the rows which have to be updated"""
    where: payroll_dates_bool_exp!
  ): payroll_dates_mutation_response

  """
  update single row of the table: "payroll_dates"
  """
  update_payroll_dates_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payroll_dates_set_input
    pk_columns: payroll_dates_pk_columns_input!
  ): payroll_dates

  """
  update multiples rows of table: "payroll_dates"
  """
  update_payroll_dates_many(
    """updates to execute, in order"""
    updates: [payroll_dates_updates!]!
  ): [payroll_dates_mutation_response]

  """
  update data of the table: "payroll_version_history_results"
  """
  update_payroll_version_history_results(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payroll_version_history_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payroll_version_history_results_set_input

    """filter the rows which have to be updated"""
    where: payroll_version_history_results_bool_exp!
  ): payroll_version_history_results_mutation_response

  """
  update single row of the table: "payroll_version_history_results"
  """
  update_payroll_version_history_results_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payroll_version_history_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payroll_version_history_results_set_input
    pk_columns: payroll_version_history_results_pk_columns_input!
  ): payroll_version_history_results

  """
  update multiples rows of table: "payroll_version_history_results"
  """
  update_payroll_version_history_results_many(
    """updates to execute, in order"""
    updates: [payroll_version_history_results_updates!]!
  ): [payroll_version_history_results_mutation_response]

  """
  update data of the table: "payroll_version_results"
  """
  update_payroll_version_results(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payroll_version_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payroll_version_results_set_input

    """filter the rows which have to be updated"""
    where: payroll_version_results_bool_exp!
  ): payroll_version_results_mutation_response

  """
  update single row of the table: "payroll_version_results"
  """
  update_payroll_version_results_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payroll_version_results_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payroll_version_results_set_input
    pk_columns: payroll_version_results_pk_columns_input!
  ): payroll_version_results

  """
  update multiples rows of table: "payroll_version_results"
  """
  update_payroll_version_results_many(
    """updates to execute, in order"""
    updates: [payroll_version_results_updates!]!
  ): [payroll_version_results_mutation_response]

  """
  update data of the table: "payrolls"
  """
  update_payrolls(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrolls_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payrolls_set_input

    """filter the rows which have to be updated"""
    where: payrolls_bool_exp!
  ): payrolls_mutation_response

  """
  update single row of the table: "payrolls"
  """
  update_payrolls_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrolls_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: payrolls_set_input
    pk_columns: payrolls_pk_columns_input!
  ): payrolls

  """
  update multiples rows of table: "payrolls"
  """
  update_payrolls_many(
    """updates to execute, in order"""
    updates: [payrolls_updates!]!
  ): [payrolls_mutation_response]

  """
  update data of the table: "permissions"
  """
  update_permissions(
    """sets the columns of the filtered rows to the given values"""
    _set: permissions_set_input

    """filter the rows which have to be updated"""
    where: permissions_bool_exp!
  ): permissions_mutation_response

  """
  update single row of the table: "permissions"
  """
  update_permissions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: permissions_set_input
    pk_columns: permissions_pk_columns_input!
  ): permissions

  """
  update multiples rows of table: "permissions"
  """
  update_permissions_many(
    """updates to execute, in order"""
    updates: [permissions_updates!]!
  ): [permissions_mutation_response]

  """
  update data of the table: "resources"
  """
  update_resources(
    """sets the columns of the filtered rows to the given values"""
    _set: resources_set_input

    """filter the rows which have to be updated"""
    where: resources_bool_exp!
  ): resources_mutation_response

  """
  update single row of the table: "resources"
  """
  update_resources_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: resources_set_input
    pk_columns: resources_pk_columns_input!
  ): resources

  """
  update multiples rows of table: "resources"
  """
  update_resources_many(
    """updates to execute, in order"""
    updates: [resources_updates!]!
  ): [resources_mutation_response]

  """
  update data of the table: "role_permissions"
  """
  update_role_permissions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: role_permissions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: role_permissions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: role_permissions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: role_permissions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: role_permissions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: role_permissions_set_input

    """filter the rows which have to be updated"""
    where: role_permissions_bool_exp!
  ): role_permissions_mutation_response

  """
  update single row of the table: "role_permissions"
  """
  update_role_permissions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: role_permissions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: role_permissions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: role_permissions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: role_permissions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: role_permissions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: role_permissions_set_input
    pk_columns: role_permissions_pk_columns_input!
  ): role_permissions

  """
  update multiples rows of table: "role_permissions"
  """
  update_role_permissions_many(
    """updates to execute, in order"""
    updates: [role_permissions_updates!]!
  ): [role_permissions_mutation_response]

  """
  update data of the table: "roles"
  """
  update_roles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: roles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input

    """filter the rows which have to be updated"""
    where: roles_bool_exp!
  ): roles_mutation_response

  """
  update single row of the table: "roles"
  """
  update_roles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: roles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles

  """
  update multiples rows of table: "roles"
  """
  update_roles_many(
    """updates to execute, in order"""
    updates: [roles_updates!]!
  ): [roles_mutation_response]

  """
  update data of the table: "user_roles"
  """
  update_user_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: user_roles_set_input

    """filter the rows which have to be updated"""
    where: user_roles_bool_exp!
  ): user_roles_mutation_response

  """
  update single row of the table: "user_roles"
  """
  update_user_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_roles_set_input
    pk_columns: user_roles_pk_columns_input!
  ): user_roles

  """
  update multiples rows of table: "user_roles"
  """
  update_user_roles_many(
    """updates to execute, in order"""
    updates: [user_roles_updates!]!
  ): [user_roles_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "users_role_backup"
  """
  update_users_role_backup(
    """sets the columns of the filtered rows to the given values"""
    _set: users_role_backup_set_input

    """filter the rows which have to be updated"""
    where: users_role_backup_bool_exp!
  ): users_role_backup_mutation_response

  """
  update multiples rows of table: "users_role_backup"
  """
  update_users_role_backup_many(
    """updates to execute, in order"""
    updates: [users_role_backup_updates!]!
  ): [users_role_backup_mutation_response]

  """
  update data of the table: "work_schedule"
  """
  update_work_schedule(
    """increments the numeric columns with given value of the filtered values"""
    _inc: work_schedule_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: work_schedule_set_input

    """filter the rows which have to be updated"""
    where: work_schedule_bool_exp!
  ): work_schedule_mutation_response

  """
  update single row of the table: "work_schedule"
  """
  update_work_schedule_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: work_schedule_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: work_schedule_set_input
    pk_columns: work_schedule_pk_columns_input!
  ): work_schedule

  """
  update multiples rows of table: "work_schedule"
  """
  update_work_schedule_many(
    """updates to execute, in order"""
    updates: [work_schedule_updates!]!
  ): [work_schedule_mutation_response]
}

"""
columns and relationships of "neon_auth.users_sync"
"""
type neon_auth_users_sync {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String!

  """User's full name from authentication provider"""
  name: String

  """Complete JSON data from the authentication provider"""
  raw_json(
    """JSON select path"""
    path: String
  ): jsonb!

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
aggregated selection of "neon_auth.users_sync"
"""
type neon_auth_users_sync_aggregate {
  aggregate: neon_auth_users_sync_aggregate_fields
  nodes: [neon_auth_users_sync!]!
}

"""
aggregate fields of "neon_auth.users_sync"
"""
type neon_auth_users_sync_aggregate_fields {
  count(columns: [neon_auth_users_sync_select_column!], distinct: Boolean): Int!
  max: neon_auth_users_sync_max_fields
  min: neon_auth_users_sync_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input neon_auth_users_sync_append_input {
  """Complete JSON data from the authentication provider"""
  raw_json: jsonb
}

"""
Boolean expression to filter rows from the table "neon_auth.users_sync". All fields are combined with a logical 'AND'.
"""
input neon_auth_users_sync_bool_exp {
  _and: [neon_auth_users_sync_bool_exp!]
  _not: neon_auth_users_sync_bool_exp
  _or: [neon_auth_users_sync_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  raw_json: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_sync_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input neon_auth_users_sync_delete_at_path_input {
  """Complete JSON data from the authentication provider"""
  raw_json: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input neon_auth_users_sync_delete_elem_input {
  """Complete JSON data from the authentication provider"""
  raw_json: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input neon_auth_users_sync_delete_key_input {
  """Complete JSON data from the authentication provider"""
  raw_json: String
}

"""
input type for inserting data into table "neon_auth.users_sync"
"""
input neon_auth_users_sync_insert_input {
  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """Complete JSON data from the authentication provider"""
  raw_json: jsonb

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type neon_auth_users_sync_max_fields {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String

  """User's full name from authentication provider"""
  name: String

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type neon_auth_users_sync_min_fields {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String

  """User's full name from authentication provider"""
  name: String

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "neon_auth.users_sync"
"""
type neon_auth_users_sync_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [neon_auth_users_sync!]!
}

"""
on_conflict condition type for table "neon_auth.users_sync"
"""
input neon_auth_users_sync_on_conflict {
  constraint: neon_auth_users_sync_constraint!
  update_columns: [neon_auth_users_sync_update_column!]! = []
  where: neon_auth_users_sync_bool_exp
}

"""Ordering options when selecting data from "neon_auth.users_sync"."""
input neon_auth_users_sync_order_by {
  created_at: order_by
  deleted_at: order_by
  email: order_by
  id: order_by
  name: order_by
  raw_json: order_by
  updated_at: order_by
}

"""primary key columns input for table: neon_auth.users_sync"""
input neon_auth_users_sync_pk_columns_input {
  """Unique identifier from the authentication provider"""
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input neon_auth_users_sync_prepend_input {
  """Complete JSON data from the authentication provider"""
  raw_json: jsonb
}

"""
select columns of table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  raw_json

  """column name"""
  updated_at
}

"""
input type for updating data in table "neon_auth.users_sync"
"""
input neon_auth_users_sync_set_input {
  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """Complete JSON data from the authentication provider"""
  raw_json: jsonb

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "neon_auth_users_sync"
"""
input neon_auth_users_sync_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: neon_auth_users_sync_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input neon_auth_users_sync_stream_cursor_value_input {
  """Timestamp when the user was created in the auth system"""
  created_at: timestamptz

  """Timestamp when the user was deleted in the auth system"""
  deleted_at: timestamptz

  """User's email address from authentication provider"""
  email: String

  """Unique identifier from the authentication provider"""
  id: String

  """User's full name from authentication provider"""
  name: String

  """Complete JSON data from the authentication provider"""
  raw_json: jsonb

  """Timestamp when the user was last updated in the auth system"""
  updated_at: timestamptz
}

"""
update columns of table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_update_column {
  """column name"""
  deleted_at

  """column name"""
  raw_json

  """column name"""
  updated_at
}

input neon_auth_users_sync_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: neon_auth_users_sync_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: neon_auth_users_sync_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: neon_auth_users_sync_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: neon_auth_users_sync_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: neon_auth_users_sync_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: neon_auth_users_sync_set_input

  """filter the rows which have to be updated"""
  where: neon_auth_users_sync_bool_exp!
}

"""
columns and relationships of "notes"
"""
type notes {
  """Content of the note"""
  content: String!

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid!

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String!

  """Unique identifier for the note"""
  id: uuid!

  """Whether the note is flagged as important"""
  is_important: Boolean

  """An array relationship"""
  notes_by_client(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """An aggregate relationship"""
  notes_by_client_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """An array relationship"""
  notes_by_payroll(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  notes_by_payroll_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """An object relationship"""
  user: users

  """User who created the note"""
  user_id: uuid
}

"""
aggregated selection of "notes"
"""
type notes_aggregate {
  aggregate: notes_aggregate_fields
  nodes: [notes!]!
}

input notes_aggregate_bool_exp {
  bool_and: notes_aggregate_bool_exp_bool_and
  bool_or: notes_aggregate_bool_exp_bool_or
  count: notes_aggregate_bool_exp_count
}

input notes_aggregate_bool_exp_bool_and {
  arguments: notes_select_column_notes_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Boolean_comparison_exp!
}

input notes_aggregate_bool_exp_bool_or {
  arguments: notes_select_column_notes_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Boolean_comparison_exp!
}

input notes_aggregate_bool_exp_count {
  arguments: [notes_select_column!]
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notes"
"""
type notes_aggregate_fields {
  count(columns: [notes_select_column!], distinct: Boolean): Int!
  max: notes_max_fields
  min: notes_min_fields
}

"""
order by aggregate values of table "notes"
"""
input notes_aggregate_order_by {
  count: order_by
  max: notes_max_order_by
  min: notes_min_order_by
}

"""
input type for inserting array relation for remote table "notes"
"""
input notes_arr_rel_insert_input {
  data: [notes_insert_input!]!

  """upsert condition"""
  on_conflict: notes_on_conflict
}

"""
Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'.
"""
input notes_bool_exp {
  _and: [notes_bool_exp!]
  _not: notes_bool_exp
  _or: [notes_bool_exp!]
  content: String_comparison_exp
  created_at: timestamp_comparison_exp
  entity_id: uuid_comparison_exp
  entity_type: String_comparison_exp
  id: uuid_comparison_exp
  is_important: Boolean_comparison_exp
  notes_by_client: clients_bool_exp
  notes_by_client_aggregate: clients_aggregate_bool_exp
  notes_by_payroll: payrolls_bool_exp
  notes_by_payroll_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamp_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notes"
"""
enum notes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notes_pkey
}

"""
input type for inserting data into table "notes"
"""
input notes_insert_input {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Whether the note is flagged as important"""
  is_important: Boolean
  notes_by_client: clients_arr_rel_insert_input
  notes_by_payroll: payrolls_arr_rel_insert_input

  """Timestamp when the note was last updated"""
  updated_at: timestamp
  user: users_obj_rel_insert_input

  """User who created the note"""
  user_id: uuid
}

"""aggregate max on columns"""
type notes_max_fields {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
order by max() on columns of table "notes"
"""
input notes_max_order_by {
  """Content of the note"""
  content: order_by

  """Timestamp when the note was created"""
  created_at: order_by

  """Identifier of the entity this note is attached to"""
  entity_id: order_by

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: order_by

  """Unique identifier for the note"""
  id: order_by

  """Timestamp when the note was last updated"""
  updated_at: order_by

  """User who created the note"""
  user_id: order_by
}

"""aggregate min on columns"""
type notes_min_fields {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
order by min() on columns of table "notes"
"""
input notes_min_order_by {
  """Content of the note"""
  content: order_by

  """Timestamp when the note was created"""
  created_at: order_by

  """Identifier of the entity this note is attached to"""
  entity_id: order_by

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: order_by

  """Unique identifier for the note"""
  id: order_by

  """Timestamp when the note was last updated"""
  updated_at: order_by

  """User who created the note"""
  user_id: order_by
}

"""
response of any mutation on the table "notes"
"""
type notes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notes!]!
}

"""
on_conflict condition type for table "notes"
"""
input notes_on_conflict {
  constraint: notes_constraint!
  update_columns: [notes_update_column!]! = []
  where: notes_bool_exp
}

"""Ordering options when selecting data from "notes"."""
input notes_order_by {
  content: order_by
  created_at: order_by
  entity_id: order_by
  entity_type: order_by
  id: order_by
  is_important: order_by
  notes_by_client_aggregate: clients_aggregate_order_by
  notes_by_payroll_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: notes"""
input notes_pk_columns_input {
  """Unique identifier for the note"""
  id: uuid!
}

"""
select columns of table "notes"
"""
enum notes_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  is_important

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
select "notes_aggregate_bool_exp_bool_and_arguments_columns" columns of table "notes"
"""
enum notes_select_column_notes_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_important
}

"""
select "notes_aggregate_bool_exp_bool_or_arguments_columns" columns of table "notes"
"""
enum notes_select_column_notes_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_important
}

"""
input type for updating data in table "notes"
"""
input notes_set_input {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Whether the note is flagged as important"""
  is_important: Boolean

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
Streaming cursor of the table "notes"
"""
input notes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notes_stream_cursor_value_input {
  """Content of the note"""
  content: String

  """Timestamp when the note was created"""
  created_at: timestamp

  """Identifier of the entity this note is attached to"""
  entity_id: uuid

  """Type of entity this note is attached to (client, payroll, etc.)"""
  entity_type: String

  """Unique identifier for the note"""
  id: uuid

  """Whether the note is flagged as important"""
  is_important: Boolean

  """Timestamp when the note was last updated"""
  updated_at: timestamp

  """User who created the note"""
  user_id: uuid
}

"""
update columns of table "notes"
"""
enum notes_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  entity_id

  """column name"""
  entity_type

  """column name"""
  id

  """column name"""
  is_important

  """column name"""
  updated_at

  """column name"""
  user_id
}

input notes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: notes_set_input

  """filter the rows which have to be updated"""
  where: notes_bool_exp!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "payroll_activation_results"
"""
type payroll_activation_results {
  action_taken: String!
  executed_at: timestamptz
  id: uuid!
  payroll_id: uuid!
  version_number: Int!
}

"""
aggregated selection of "payroll_activation_results"
"""
type payroll_activation_results_aggregate {
  aggregate: payroll_activation_results_aggregate_fields
  nodes: [payroll_activation_results!]!
}

"""
aggregate fields of "payroll_activation_results"
"""
type payroll_activation_results_aggregate_fields {
  avg: payroll_activation_results_avg_fields
  count(columns: [payroll_activation_results_select_column!], distinct: Boolean): Int!
  max: payroll_activation_results_max_fields
  min: payroll_activation_results_min_fields
  stddev: payroll_activation_results_stddev_fields
  stddev_pop: payroll_activation_results_stddev_pop_fields
  stddev_samp: payroll_activation_results_stddev_samp_fields
  sum: payroll_activation_results_sum_fields
  var_pop: payroll_activation_results_var_pop_fields
  var_samp: payroll_activation_results_var_samp_fields
  variance: payroll_activation_results_variance_fields
}

"""aggregate avg on columns"""
type payroll_activation_results_avg_fields {
  version_number: Float
}

"""
Boolean expression to filter rows from the table "payroll_activation_results". All fields are combined with a logical 'AND'.
"""
input payroll_activation_results_bool_exp {
  _and: [payroll_activation_results_bool_exp!]
  _not: payroll_activation_results_bool_exp
  _or: [payroll_activation_results_bool_exp!]
  action_taken: String_comparison_exp
  executed_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  payroll_id: uuid_comparison_exp
  version_number: Int_comparison_exp
}

"""
unique or primary key constraints on table "payroll_activation_results"
"""
enum payroll_activation_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_activation_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_activation_results"
"""
input payroll_activation_results_inc_input {
  version_number: Int
}

"""
input type for inserting data into table "payroll_activation_results"
"""
input payroll_activation_results_insert_input {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""aggregate max on columns"""
type payroll_activation_results_max_fields {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""aggregate min on columns"""
type payroll_activation_results_min_fields {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""
response of any mutation on the table "payroll_activation_results"
"""
type payroll_activation_results_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_activation_results!]!
}

"""
on_conflict condition type for table "payroll_activation_results"
"""
input payroll_activation_results_on_conflict {
  constraint: payroll_activation_results_constraint!
  update_columns: [payroll_activation_results_update_column!]! = []
  where: payroll_activation_results_bool_exp
}

"""
Ordering options when selecting data from "payroll_activation_results".
"""
input payroll_activation_results_order_by {
  action_taken: order_by
  executed_at: order_by
  id: order_by
  payroll_id: order_by
  version_number: order_by
}

"""primary key columns input for table: payroll_activation_results"""
input payroll_activation_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_activation_results"
"""
enum payroll_activation_results_select_column {
  """column name"""
  action_taken

  """column name"""
  executed_at

  """column name"""
  id

  """column name"""
  payroll_id

  """column name"""
  version_number
}

"""
input type for updating data in table "payroll_activation_results"
"""
input payroll_activation_results_set_input {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""aggregate stddev on columns"""
type payroll_activation_results_stddev_fields {
  version_number: Float
}

"""aggregate stddev_pop on columns"""
type payroll_activation_results_stddev_pop_fields {
  version_number: Float
}

"""aggregate stddev_samp on columns"""
type payroll_activation_results_stddev_samp_fields {
  version_number: Float
}

"""
Streaming cursor of the table "payroll_activation_results"
"""
input payroll_activation_results_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_activation_results_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_activation_results_stream_cursor_value_input {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""aggregate sum on columns"""
type payroll_activation_results_sum_fields {
  version_number: Int
}

"""
update columns of table "payroll_activation_results"
"""
enum payroll_activation_results_update_column {
  """column name"""
  action_taken

  """column name"""
  executed_at

  """column name"""
  id

  """column name"""
  payroll_id

  """column name"""
  version_number
}

input payroll_activation_results_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payroll_activation_results_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payroll_activation_results_set_input

  """filter the rows which have to be updated"""
  where: payroll_activation_results_bool_exp!
}

"""aggregate var_pop on columns"""
type payroll_activation_results_var_pop_fields {
  version_number: Float
}

"""aggregate var_samp on columns"""
type payroll_activation_results_var_samp_fields {
  version_number: Float
}

"""aggregate variance on columns"""
type payroll_activation_results_variance_fields {
  version_number: Float
}

scalar payroll_cycle_type

"""
Boolean expression to compare columns of type "payroll_cycle_type". All fields are combined with logical 'AND'.
"""
input payroll_cycle_type_comparison_exp {
  _eq: payroll_cycle_type
  _gt: payroll_cycle_type
  _gte: payroll_cycle_type
  _in: [payroll_cycle_type!]
  _is_null: Boolean
  _lt: payroll_cycle_type
  _lte: payroll_cycle_type
  _neq: payroll_cycle_type
  _nin: [payroll_cycle_type!]
}

"""
columns and relationships of "payroll_cycles"
"""
type payroll_cycles {
  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid!

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_cycles"
"""
type payroll_cycles_aggregate {
  aggregate: payroll_cycles_aggregate_fields
  nodes: [payroll_cycles!]!
}

"""
aggregate fields of "payroll_cycles"
"""
type payroll_cycles_aggregate_fields {
  count(columns: [payroll_cycles_select_column!], distinct: Boolean): Int!
  max: payroll_cycles_max_fields
  min: payroll_cycles_min_fields
}

"""
Boolean expression to filter rows from the table "payroll_cycles". All fields are combined with a logical 'AND'.
"""
input payroll_cycles_bool_exp {
  _and: [payroll_cycles_bool_exp!]
  _not: payroll_cycles_bool_exp
  _or: [payroll_cycles_bool_exp!]
  adjustment_rules: adjustment_rules_bool_exp
  adjustment_rules_aggregate: adjustment_rules_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: payroll_cycle_type_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_cycles"
"""
enum payroll_cycles_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_cycles_name_key

  """
  unique or primary key constraint on columns "id"
  """
  payroll_cycles_pkey
}

"""
input type for inserting data into table "payroll_cycles"
"""
input payroll_cycles_insert_input {
  adjustment_rules: adjustment_rules_arr_rel_insert_input

  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  payrolls: payrolls_arr_rel_insert_input

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payroll_cycles_max_fields {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payroll_cycles_min_fields {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "payroll_cycles"
"""
type payroll_cycles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_cycles!]!
}

"""
input type for inserting object relation for remote table "payroll_cycles"
"""
input payroll_cycles_obj_rel_insert_input {
  data: payroll_cycles_insert_input!

  """upsert condition"""
  on_conflict: payroll_cycles_on_conflict
}

"""
on_conflict condition type for table "payroll_cycles"
"""
input payroll_cycles_on_conflict {
  constraint: payroll_cycles_constraint!
  update_columns: [payroll_cycles_update_column!]! = []
  where: payroll_cycles_bool_exp
}

"""Ordering options when selecting data from "payroll_cycles"."""
input payroll_cycles_order_by {
  adjustment_rules_aggregate: adjustment_rules_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: payroll_cycles"""
input payroll_cycles_pk_columns_input {
  """Unique identifier for the payroll cycle"""
  id: uuid!
}

"""
select columns of table "payroll_cycles"
"""
enum payroll_cycles_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "payroll_cycles"
"""
input payroll_cycles_set_input {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_cycles"
"""
input payroll_cycles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_cycles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_cycles_stream_cursor_value_input {
  """Timestamp when the cycle was created"""
  created_at: timestamptz

  """Detailed description of the payroll cycle"""
  description: String

  """Unique identifier for the payroll cycle"""
  id: uuid

  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type

  """Timestamp when the cycle was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "payroll_cycles"
"""
enum payroll_cycles_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input payroll_cycles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payroll_cycles_set_input

  """filter the rows which have to be updated"""
  where: payroll_cycles_bool_exp!
}

scalar payroll_date_type

"""
Boolean expression to compare columns of type "payroll_date_type". All fields are combined with logical 'AND'.
"""
input payroll_date_type_comparison_exp {
  _eq: payroll_date_type
  _gt: payroll_date_type
  _gte: payroll_date_type
  _in: [payroll_date_type!]
  _is_null: Boolean
  _lt: payroll_date_type
  _lte: payroll_date_type
  _neq: payroll_date_type
  _nin: [payroll_date_type!]
}

"""
columns and relationships of "payroll_date_types"
"""
type payroll_date_types {
  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid!

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_date_types"
"""
type payroll_date_types_aggregate {
  aggregate: payroll_date_types_aggregate_fields
  nodes: [payroll_date_types!]!
}

"""
aggregate fields of "payroll_date_types"
"""
type payroll_date_types_aggregate_fields {
  count(columns: [payroll_date_types_select_column!], distinct: Boolean): Int!
  max: payroll_date_types_max_fields
  min: payroll_date_types_min_fields
}

"""
Boolean expression to filter rows from the table "payroll_date_types". All fields are combined with a logical 'AND'.
"""
input payroll_date_types_bool_exp {
  _and: [payroll_date_types_bool_exp!]
  _not: payroll_date_types_bool_exp
  _or: [payroll_date_types_bool_exp!]
  adjustment_rules: adjustment_rules_bool_exp
  adjustment_rules_aggregate: adjustment_rules_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: payroll_date_type_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_date_types"
"""
enum payroll_date_types_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_date_types_name_key

  """
  unique or primary key constraint on columns "id"
  """
  payroll_date_types_pkey
}

"""
input type for inserting data into table "payroll_date_types"
"""
input payroll_date_types_insert_input {
  adjustment_rules: adjustment_rules_arr_rel_insert_input

  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  payrolls: payrolls_arr_rel_insert_input

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payroll_date_types_max_fields {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""aggregate min on columns"""
type payroll_date_types_min_fields {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
response of any mutation on the table "payroll_date_types"
"""
type payroll_date_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_date_types!]!
}

"""
input type for inserting object relation for remote table "payroll_date_types"
"""
input payroll_date_types_obj_rel_insert_input {
  data: payroll_date_types_insert_input!

  """upsert condition"""
  on_conflict: payroll_date_types_on_conflict
}

"""
on_conflict condition type for table "payroll_date_types"
"""
input payroll_date_types_on_conflict {
  constraint: payroll_date_types_constraint!
  update_columns: [payroll_date_types_update_column!]! = []
  where: payroll_date_types_bool_exp
}

"""Ordering options when selecting data from "payroll_date_types"."""
input payroll_date_types_order_by {
  adjustment_rules_aggregate: adjustment_rules_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: payroll_date_types"""
input payroll_date_types_pk_columns_input {
  """Unique identifier for the payroll date type"""
  id: uuid!
}

"""
select columns of table "payroll_date_types"
"""
enum payroll_date_types_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "payroll_date_types"
"""
input payroll_date_types_set_input {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_date_types"
"""
input payroll_date_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_date_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_date_types_stream_cursor_value_input {
  """Timestamp when the date type was created"""
  created_at: timestamptz

  """Detailed description of how this date type works"""
  description: String

  """Unique identifier for the payroll date type"""
  id: uuid

  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type

  """Timestamp when the date type was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "payroll_date_types"
"""
enum payroll_date_types_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input payroll_date_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payroll_date_types_set_input

  """filter the rows which have to be updated"""
  where: payroll_date_types_bool_exp!
}

"""
columns and relationships of "payroll_dates"
"""
type payroll_dates {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date!

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid!

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date!

  """An object relationship"""
  payroll: payrolls!

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid!

  """Date when payroll processing must be completed"""
  processing_date: date!

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_dates"
"""
type payroll_dates_aggregate {
  aggregate: payroll_dates_aggregate_fields
  nodes: [payroll_dates!]!
}

input payroll_dates_aggregate_bool_exp {
  count: payroll_dates_aggregate_bool_exp_count
}

input payroll_dates_aggregate_bool_exp_count {
  arguments: [payroll_dates_select_column!]
  distinct: Boolean
  filter: payroll_dates_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payroll_dates"
"""
type payroll_dates_aggregate_fields {
  count(columns: [payroll_dates_select_column!], distinct: Boolean): Int!
  max: payroll_dates_max_fields
  min: payroll_dates_min_fields
}

"""
order by aggregate values of table "payroll_dates"
"""
input payroll_dates_aggregate_order_by {
  count: order_by
  max: payroll_dates_max_order_by
  min: payroll_dates_min_order_by
}

"""
input type for inserting array relation for remote table "payroll_dates"
"""
input payroll_dates_arr_rel_insert_input {
  data: [payroll_dates_insert_input!]!

  """upsert condition"""
  on_conflict: payroll_dates_on_conflict
}

"""
Boolean expression to filter rows from the table "payroll_dates". All fields are combined with a logical 'AND'.
"""
input payroll_dates_bool_exp {
  _and: [payroll_dates_bool_exp!]
  _not: payroll_dates_bool_exp
  _or: [payroll_dates_bool_exp!]
  adjusted_eft_date: date_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notes: String_comparison_exp
  original_eft_date: date_comparison_exp
  payroll: payrolls_bool_exp
  payroll_id: uuid_comparison_exp
  processing_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_dates"
"""
enum payroll_dates_constraint {
  """
  unique or primary key constraint on columns "original_eft_date", "payroll_id"
  """
  idx_unique_payroll_date

  """
  unique or primary key constraint on columns "id"
  """
  payroll_dates_pkey
}

"""
input type for inserting data into table "payroll_dates"
"""
input payroll_dates_insert_input {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date
  payroll: payrolls_obj_rel_insert_input

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""aggregate max on columns"""
type payroll_dates_max_fields {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
order by max() on columns of table "payroll_dates"
"""
input payroll_dates_max_order_by {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: order_by

  """Timestamp when the date record was created"""
  created_at: order_by

  """Unique identifier for the payroll date"""
  id: order_by

  """Additional notes about this payroll date"""
  notes: order_by

  """Originally calculated EFT date before adjustments"""
  original_eft_date: order_by

  """Reference to the payroll this date belongs to"""
  payroll_id: order_by

  """Date when payroll processing must be completed"""
  processing_date: order_by

  """Timestamp when the date record was last updated"""
  updated_at: order_by
}

"""aggregate min on columns"""
type payroll_dates_min_fields {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
order by min() on columns of table "payroll_dates"
"""
input payroll_dates_min_order_by {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: order_by

  """Timestamp when the date record was created"""
  created_at: order_by

  """Unique identifier for the payroll date"""
  id: order_by

  """Additional notes about this payroll date"""
  notes: order_by

  """Originally calculated EFT date before adjustments"""
  original_eft_date: order_by

  """Reference to the payroll this date belongs to"""
  payroll_id: order_by

  """Date when payroll processing must be completed"""
  processing_date: order_by

  """Timestamp when the date record was last updated"""
  updated_at: order_by
}

"""
response of any mutation on the table "payroll_dates"
"""
type payroll_dates_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_dates!]!
}

"""
on_conflict condition type for table "payroll_dates"
"""
input payroll_dates_on_conflict {
  constraint: payroll_dates_constraint!
  update_columns: [payroll_dates_update_column!]! = []
  where: payroll_dates_bool_exp
}

"""Ordering options when selecting data from "payroll_dates"."""
input payroll_dates_order_by {
  adjusted_eft_date: order_by
  created_at: order_by
  id: order_by
  notes: order_by
  original_eft_date: order_by
  payroll: payrolls_order_by
  payroll_id: order_by
  processing_date: order_by
  updated_at: order_by
}

"""primary key columns input for table: payroll_dates"""
input payroll_dates_pk_columns_input {
  """Unique identifier for the payroll date"""
  id: uuid!
}

"""
select columns of table "payroll_dates"
"""
enum payroll_dates_select_column {
  """column name"""
  adjusted_eft_date

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  original_eft_date

  """column name"""
  payroll_id

  """column name"""
  processing_date

  """column name"""
  updated_at
}

"""
input type for updating data in table "payroll_dates"
"""
input payroll_dates_set_input {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_dates"
"""
input payroll_dates_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_dates_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_dates_stream_cursor_value_input {
  """Final EFT date after holiday and weekend adjustments"""
  adjusted_eft_date: date

  """Timestamp when the date record was created"""
  created_at: timestamptz

  """Unique identifier for the payroll date"""
  id: uuid

  """Additional notes about this payroll date"""
  notes: String

  """Originally calculated EFT date before adjustments"""
  original_eft_date: date

  """Reference to the payroll this date belongs to"""
  payroll_id: uuid

  """Date when payroll processing must be completed"""
  processing_date: date

  """Timestamp when the date record was last updated"""
  updated_at: timestamptz
}

"""
update columns of table "payroll_dates"
"""
enum payroll_dates_update_column {
  """column name"""
  adjusted_eft_date

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  notes

  """column name"""
  original_eft_date

  """column name"""
  payroll_id

  """column name"""
  processing_date

  """column name"""
  updated_at
}

input payroll_dates_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payroll_dates_set_input

  """filter the rows which have to be updated"""
  where: payroll_dates_bool_exp!
}

scalar payroll_status

"""
Boolean expression to compare columns of type "payroll_status". All fields are combined with logical 'AND'.
"""
input payroll_status_comparison_exp {
  _eq: payroll_status
  _gt: payroll_status
  _gte: payroll_status
  _in: [payroll_status!]
  _is_null: Boolean
  _lt: payroll_status
  _lte: payroll_status
  _neq: payroll_status
  _nin: [payroll_status!]
}

"""
columns and relationships of "payroll_version_history_results"
"""
type payroll_version_history_results {
  active: Boolean!
  go_live_date: date
  id: uuid!
  is_current: Boolean!
  name: String!
  payroll_id: uuid!
  queried_at: timestamptz
  superseded_date: date
  version_number: Int!
  version_reason: String
}

"""
aggregated selection of "payroll_version_history_results"
"""
type payroll_version_history_results_aggregate {
  aggregate: payroll_version_history_results_aggregate_fields
  nodes: [payroll_version_history_results!]!
}

"""
aggregate fields of "payroll_version_history_results"
"""
type payroll_version_history_results_aggregate_fields {
  avg: payroll_version_history_results_avg_fields
  count(columns: [payroll_version_history_results_select_column!], distinct: Boolean): Int!
  max: payroll_version_history_results_max_fields
  min: payroll_version_history_results_min_fields
  stddev: payroll_version_history_results_stddev_fields
  stddev_pop: payroll_version_history_results_stddev_pop_fields
  stddev_samp: payroll_version_history_results_stddev_samp_fields
  sum: payroll_version_history_results_sum_fields
  var_pop: payroll_version_history_results_var_pop_fields
  var_samp: payroll_version_history_results_var_samp_fields
  variance: payroll_version_history_results_variance_fields
}

"""aggregate avg on columns"""
type payroll_version_history_results_avg_fields {
  version_number: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_history_results". All fields are combined with a logical 'AND'.
"""
input payroll_version_history_results_bool_exp {
  _and: [payroll_version_history_results_bool_exp!]
  _not: payroll_version_history_results_bool_exp
  _or: [payroll_version_history_results_bool_exp!]
  active: Boolean_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  is_current: Boolean_comparison_exp
  name: String_comparison_exp
  payroll_id: uuid_comparison_exp
  queried_at: timestamptz_comparison_exp
  superseded_date: date_comparison_exp
  version_number: Int_comparison_exp
  version_reason: String_comparison_exp
}

"""
unique or primary key constraints on table "payroll_version_history_results"
"""
enum payroll_version_history_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_history_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_history_results"
"""
input payroll_version_history_results_inc_input {
  version_number: Int
}

"""
input type for inserting data into table "payroll_version_history_results"
"""
input payroll_version_history_results_insert_input {
  active: Boolean
  go_live_date: date
  id: uuid
  is_current: Boolean
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""aggregate max on columns"""
type payroll_version_history_results_max_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""aggregate min on columns"""
type payroll_version_history_results_min_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""
response of any mutation on the table "payroll_version_history_results"
"""
type payroll_version_history_results_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_version_history_results!]!
}

"""
on_conflict condition type for table "payroll_version_history_results"
"""
input payroll_version_history_results_on_conflict {
  constraint: payroll_version_history_results_constraint!
  update_columns: [payroll_version_history_results_update_column!]! = []
  where: payroll_version_history_results_bool_exp
}

"""
Ordering options when selecting data from "payroll_version_history_results".
"""
input payroll_version_history_results_order_by {
  active: order_by
  go_live_date: order_by
  id: order_by
  is_current: order_by
  name: order_by
  payroll_id: order_by
  queried_at: order_by
  superseded_date: order_by
  version_number: order_by
  version_reason: order_by
}

"""primary key columns input for table: payroll_version_history_results"""
input payroll_version_history_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_version_history_results"
"""
enum payroll_version_history_results_select_column {
  """column name"""
  active

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  is_current

  """column name"""
  name

  """column name"""
  payroll_id

  """column name"""
  queried_at

  """column name"""
  superseded_date

  """column name"""
  version_number

  """column name"""
  version_reason
}

"""
input type for updating data in table "payroll_version_history_results"
"""
input payroll_version_history_results_set_input {
  active: Boolean
  go_live_date: date
  id: uuid
  is_current: Boolean
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""aggregate stddev on columns"""
type payroll_version_history_results_stddev_fields {
  version_number: Float
}

"""aggregate stddev_pop on columns"""
type payroll_version_history_results_stddev_pop_fields {
  version_number: Float
}

"""aggregate stddev_samp on columns"""
type payroll_version_history_results_stddev_samp_fields {
  version_number: Float
}

"""
Streaming cursor of the table "payroll_version_history_results"
"""
input payroll_version_history_results_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_version_history_results_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_version_history_results_stream_cursor_value_input {
  active: Boolean
  go_live_date: date
  id: uuid
  is_current: Boolean
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""aggregate sum on columns"""
type payroll_version_history_results_sum_fields {
  version_number: Int
}

"""
update columns of table "payroll_version_history_results"
"""
enum payroll_version_history_results_update_column {
  """column name"""
  active

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  is_current

  """column name"""
  name

  """column name"""
  payroll_id

  """column name"""
  queried_at

  """column name"""
  superseded_date

  """column name"""
  version_number

  """column name"""
  version_reason
}

input payroll_version_history_results_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payroll_version_history_results_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payroll_version_history_results_set_input

  """filter the rows which have to be updated"""
  where: payroll_version_history_results_bool_exp!
}

"""aggregate var_pop on columns"""
type payroll_version_history_results_var_pop_fields {
  version_number: Float
}

"""aggregate var_samp on columns"""
type payroll_version_history_results_var_samp_fields {
  version_number: Float
}

"""aggregate variance on columns"""
type payroll_version_history_results_variance_fields {
  version_number: Float
}

"""
columns and relationships of "payroll_version_results"
"""
type payroll_version_results {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int!
  id: uuid!
  message: String!
  new_payroll_id: uuid!
  new_version_number: Int!
  old_payroll_id: uuid!
}

type payroll_version_results_aggregate {
  aggregate: payroll_version_results_aggregate_fields
  nodes: [payroll_version_results!]!
}

"""
aggregate fields of "payroll_version_results"
"""
type payroll_version_results_aggregate_fields {
  avg: payroll_version_results_avg_fields
  count(columns: [payroll_version_results_select_column!], distinct: Boolean): Int!
  max: payroll_version_results_max_fields
  min: payroll_version_results_min_fields
  stddev: payroll_version_results_stddev_fields
  stddev_pop: payroll_version_results_stddev_pop_fields
  stddev_samp: payroll_version_results_stddev_samp_fields
  sum: payroll_version_results_sum_fields
  var_pop: payroll_version_results_var_pop_fields
  var_samp: payroll_version_results_var_samp_fields
  variance: payroll_version_results_variance_fields
}

"""aggregate avg on columns"""
type payroll_version_results_avg_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_results". All fields are combined with a logical 'AND'.
"""
input payroll_version_results_bool_exp {
  _and: [payroll_version_results_bool_exp!]
  _not: payroll_version_results_bool_exp
  _or: [payroll_version_results_bool_exp!]
  created_at: timestamptz_comparison_exp
  created_by_user_id: uuid_comparison_exp
  dates_deleted: Int_comparison_exp
  id: uuid_comparison_exp
  message: String_comparison_exp
  new_payroll_id: uuid_comparison_exp
  new_version_number: Int_comparison_exp
  old_payroll_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "payroll_version_results"
"""
enum payroll_version_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_results"
"""
input payroll_version_results_inc_input {
  dates_deleted: Int
  new_version_number: Int
}

"""
input type for inserting data into table "payroll_version_results"
"""
input payroll_version_results_insert_input {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""aggregate max on columns"""
type payroll_version_results_max_fields {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""aggregate min on columns"""
type payroll_version_results_min_fields {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""
response of any mutation on the table "payroll_version_results"
"""
type payroll_version_results_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payroll_version_results!]!
}

"""
on_conflict condition type for table "payroll_version_results"
"""
input payroll_version_results_on_conflict {
  constraint: payroll_version_results_constraint!
  update_columns: [payroll_version_results_update_column!]! = []
  where: payroll_version_results_bool_exp
}

"""Ordering options when selecting data from "payroll_version_results"."""
input payroll_version_results_order_by {
  created_at: order_by
  created_by_user_id: order_by
  dates_deleted: order_by
  id: order_by
  message: order_by
  new_payroll_id: order_by
  new_version_number: order_by
  old_payroll_id: order_by
}

"""primary key columns input for table: payroll_version_results"""
input payroll_version_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_version_results"
"""
enum payroll_version_results_select_column {
  """column name"""
  created_at

  """column name"""
  created_by_user_id

  """column name"""
  dates_deleted

  """column name"""
  id

  """column name"""
  message

  """column name"""
  new_payroll_id

  """column name"""
  new_version_number

  """column name"""
  old_payroll_id
}

"""
input type for updating data in table "payroll_version_results"
"""
input payroll_version_results_set_input {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""aggregate stddev on columns"""
type payroll_version_results_stddev_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""aggregate stddev_pop on columns"""
type payroll_version_results_stddev_pop_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""aggregate stddev_samp on columns"""
type payroll_version_results_stddev_samp_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
Streaming cursor of the table "payroll_version_results"
"""
input payroll_version_results_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payroll_version_results_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payroll_version_results_stream_cursor_value_input {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""aggregate sum on columns"""
type payroll_version_results_sum_fields {
  dates_deleted: Int
  new_version_number: Int
}

"""
update columns of table "payroll_version_results"
"""
enum payroll_version_results_update_column {
  """column name"""
  created_at

  """column name"""
  created_by_user_id

  """column name"""
  dates_deleted

  """column name"""
  id

  """column name"""
  message

  """column name"""
  new_payroll_id

  """column name"""
  new_version_number

  """column name"""
  old_payroll_id
}

input payroll_version_results_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payroll_version_results_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payroll_version_results_set_input

  """filter the rows which have to be updated"""
  where: payroll_version_results_bool_exp!
}

"""aggregate var_pop on columns"""
type payroll_version_results_var_pop_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""aggregate var_samp on columns"""
type payroll_version_results_var_samp_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""aggregate variance on columns"""
type payroll_version_results_variance_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
columns and relationships of "payrolls"
"""
type payrolls {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """An array relationship"""
  billing_items(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): [billing_items!]!

  """An aggregate relationship"""
  billing_items_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): billing_items_aggregate!

  """An object relationship"""
  client: clients!

  """Reference to the client this payroll belongs to"""
  client_id: uuid!

  """Timestamp when the payroll was created"""
  created_at: timestamptz
  created_by_user_id: uuid

  """Reference to the payroll cycle"""
  cycle_id: uuid!

  """Reference to the payroll date type"""
  date_type_id: uuid!

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid!

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String!
  parent_payroll_id: uuid

  """An object relationship"""
  payroll: payrolls

  """An object relationship"""
  payroll_cycle: payroll_cycles!

  """An object relationship"""
  payroll_date_type: payroll_date_types!

  """An array relationship"""
  payroll_dates(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """An aggregate relationship"""
  payroll_dates_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """External payroll system used for this client"""
  payroll_system: String

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int!

  """Number of hours required to process this payroll"""
  processing_time: Int!

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status!
  superseded_date: date

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz

  """An object relationship"""
  userByBackupConsultantUserId: users

  """An object relationship"""
  userByManagerUserId: users

  """An object relationship"""
  userByPrimaryConsultantUserId: users
  version_number: Int
  version_reason: String
}

"""
aggregated selection of "payrolls"
"""
type payrolls_aggregate {
  aggregate: payrolls_aggregate_fields
  nodes: [payrolls!]!
}

input payrolls_aggregate_bool_exp {
  count: payrolls_aggregate_bool_exp_count
}

input payrolls_aggregate_bool_exp_count {
  arguments: [payrolls_select_column!]
  distinct: Boolean
  filter: payrolls_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payrolls"
"""
type payrolls_aggregate_fields {
  avg: payrolls_avg_fields
  count(columns: [payrolls_select_column!], distinct: Boolean): Int!
  max: payrolls_max_fields
  min: payrolls_min_fields
  stddev: payrolls_stddev_fields
  stddev_pop: payrolls_stddev_pop_fields
  stddev_samp: payrolls_stddev_samp_fields
  sum: payrolls_sum_fields
  var_pop: payrolls_var_pop_fields
  var_samp: payrolls_var_samp_fields
  variance: payrolls_variance_fields
}

"""
order by aggregate values of table "payrolls"
"""
input payrolls_aggregate_order_by {
  avg: payrolls_avg_order_by
  count: order_by
  max: payrolls_max_order_by
  min: payrolls_min_order_by
  stddev: payrolls_stddev_order_by
  stddev_pop: payrolls_stddev_pop_order_by
  stddev_samp: payrolls_stddev_samp_order_by
  sum: payrolls_sum_order_by
  var_pop: payrolls_var_pop_order_by
  var_samp: payrolls_var_samp_order_by
  variance: payrolls_variance_order_by
}

"""
input type for inserting array relation for remote table "payrolls"
"""
input payrolls_arr_rel_insert_input {
  data: [payrolls_insert_input!]!

  """upsert condition"""
  on_conflict: payrolls_on_conflict
}

"""aggregate avg on columns"""
type payrolls_avg_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
  version_number: Float
}

"""
order by avg() on columns of table "payrolls"
"""
input payrolls_avg_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

"""
Boolean expression to filter rows from the table "payrolls". All fields are combined with a logical 'AND'.
"""
input payrolls_bool_exp {
  _and: [payrolls_bool_exp!]
  _not: payrolls_bool_exp
  _or: [payrolls_bool_exp!]
  backup_consultant_user_id: uuid_comparison_exp
  billing_items: billing_items_bool_exp
  billing_items_aggregate: billing_items_aggregate_bool_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by_user_id: uuid_comparison_exp
  cycle_id: uuid_comparison_exp
  date_type_id: uuid_comparison_exp
  date_value: Int_comparison_exp
  employee_count: Int_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  manager_user_id: uuid_comparison_exp
  name: String_comparison_exp
  parent_payroll_id: uuid_comparison_exp
  payroll: payrolls_bool_exp
  payroll_cycle: payroll_cycles_bool_exp
  payroll_date_type: payroll_date_types_bool_exp
  payroll_dates: payroll_dates_bool_exp
  payroll_dates_aggregate: payroll_dates_aggregate_bool_exp
  payroll_system: String_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  primary_consultant_user_id: uuid_comparison_exp
  processing_days_before_eft: Int_comparison_exp
  processing_time: Int_comparison_exp
  status: payroll_status_comparison_exp
  superseded_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
  userByBackupConsultantUserId: users_bool_exp
  userByManagerUserId: users_bool_exp
  userByPrimaryConsultantUserId: users_bool_exp
  version_number: Int_comparison_exp
  version_reason: String_comparison_exp
}

"""
unique or primary key constraints on table "payrolls"
"""
enum payrolls_constraint {
  """unique or primary key constraint on columns """
  only_one_current_version_per_family

  """
  unique or primary key constraint on columns "id"
  """
  payrolls_pkey
}

"""
input type for incrementing numeric columns in table "payrolls"
"""
input payrolls_inc_input {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int
  version_number: Int
}

"""
input type for inserting data into table "payrolls"
"""
input payrolls_insert_input {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid
  billing_items: billing_items_arr_rel_insert_input
  client: clients_obj_rel_insert_input

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz
  created_by_user_id: uuid

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String
  parent_payroll_id: uuid
  payroll: payrolls_obj_rel_insert_input
  payroll_cycle: payroll_cycles_obj_rel_insert_input
  payroll_date_type: payroll_date_types_obj_rel_insert_input
  payroll_dates: payroll_dates_arr_rel_insert_input

  """External payroll system used for this client"""
  payroll_system: String
  payrolls: payrolls_arr_rel_insert_input

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  superseded_date: date

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
  userByBackupConsultantUserId: users_obj_rel_insert_input
  userByManagerUserId: users_obj_rel_insert_input
  userByPrimaryConsultantUserId: users_obj_rel_insert_input
  version_number: Int
  version_reason: String
}

"""aggregate max on columns"""
type payrolls_max_fields {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz
  created_by_user_id: uuid

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String
  parent_payroll_id: uuid

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  superseded_date: date

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""
order by max() on columns of table "payrolls"
"""
input payrolls_max_order_by {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: order_by

  """Reference to the client this payroll belongs to"""
  client_id: order_by

  """Timestamp when the payroll was created"""
  created_at: order_by
  created_by_user_id: order_by

  """Reference to the payroll cycle"""
  cycle_id: order_by

  """Reference to the payroll date type"""
  date_type_id: order_by

  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """The date when the payroll went live in the system"""
  go_live_date: order_by

  """Unique identifier for the payroll"""
  id: order_by

  """Manager overseeing this payroll"""
  manager_user_id: order_by

  """Name of the payroll"""
  name: order_by
  parent_payroll_id: order_by

  """External payroll system used for this client"""
  payroll_system: order_by

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: order_by
  superseded_date: order_by

  """Timestamp when the payroll was last updated"""
  updated_at: order_by
  version_number: order_by
  version_reason: order_by
}

"""aggregate min on columns"""
type payrolls_min_fields {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz
  created_by_user_id: uuid

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String
  parent_payroll_id: uuid

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  superseded_date: date

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""
order by min() on columns of table "payrolls"
"""
input payrolls_min_order_by {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: order_by

  """Reference to the client this payroll belongs to"""
  client_id: order_by

  """Timestamp when the payroll was created"""
  created_at: order_by
  created_by_user_id: order_by

  """Reference to the payroll cycle"""
  cycle_id: order_by

  """Reference to the payroll date type"""
  date_type_id: order_by

  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """The date when the payroll went live in the system"""
  go_live_date: order_by

  """Unique identifier for the payroll"""
  id: order_by

  """Manager overseeing this payroll"""
  manager_user_id: order_by

  """Name of the payroll"""
  name: order_by
  parent_payroll_id: order_by

  """External payroll system used for this client"""
  payroll_system: order_by

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: order_by
  superseded_date: order_by

  """Timestamp when the payroll was last updated"""
  updated_at: order_by
  version_number: order_by
  version_reason: order_by
}

"""
response of any mutation on the table "payrolls"
"""
type payrolls_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payrolls!]!
}

"""
input type for inserting object relation for remote table "payrolls"
"""
input payrolls_obj_rel_insert_input {
  data: payrolls_insert_input!

  """upsert condition"""
  on_conflict: payrolls_on_conflict
}

"""
on_conflict condition type for table "payrolls"
"""
input payrolls_on_conflict {
  constraint: payrolls_constraint!
  update_columns: [payrolls_update_column!]! = []
  where: payrolls_bool_exp
}

"""Ordering options when selecting data from "payrolls"."""
input payrolls_order_by {
  backup_consultant_user_id: order_by
  billing_items_aggregate: billing_items_aggregate_order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  created_by_user_id: order_by
  cycle_id: order_by
  date_type_id: order_by
  date_value: order_by
  employee_count: order_by
  go_live_date: order_by
  id: order_by
  manager_user_id: order_by
  name: order_by
  parent_payroll_id: order_by
  payroll: payrolls_order_by
  payroll_cycle: payroll_cycles_order_by
  payroll_date_type: payroll_date_types_order_by
  payroll_dates_aggregate: payroll_dates_aggregate_order_by
  payroll_system: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  primary_consultant_user_id: order_by
  processing_days_before_eft: order_by
  processing_time: order_by
  status: order_by
  superseded_date: order_by
  updated_at: order_by
  userByBackupConsultantUserId: users_order_by
  userByManagerUserId: users_order_by
  userByPrimaryConsultantUserId: users_order_by
  version_number: order_by
  version_reason: order_by
}

"""primary key columns input for table: payrolls"""
input payrolls_pk_columns_input {
  """Unique identifier for the payroll"""
  id: uuid!
}

"""
select columns of table "payrolls"
"""
enum payrolls_select_column {
  """column name"""
  backup_consultant_user_id

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  created_by_user_id

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  date_value

  """column name"""
  employee_count

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  manager_user_id

  """column name"""
  name

  """column name"""
  parent_payroll_id

  """column name"""
  payroll_system

  """column name"""
  primary_consultant_user_id

  """column name"""
  processing_days_before_eft

  """column name"""
  processing_time

  """column name"""
  status

  """column name"""
  superseded_date

  """column name"""
  updated_at

  """column name"""
  version_number

  """column name"""
  version_reason
}

"""
input type for updating data in table "payrolls"
"""
input payrolls_set_input {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz
  created_by_user_id: uuid

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String
  parent_payroll_id: uuid

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  superseded_date: date

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""aggregate stddev on columns"""
type payrolls_stddev_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
  version_number: Float
}

"""
order by stddev() on columns of table "payrolls"
"""
input payrolls_stddev_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

"""aggregate stddev_pop on columns"""
type payrolls_stddev_pop_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
  version_number: Float
}

"""
order by stddev_pop() on columns of table "payrolls"
"""
input payrolls_stddev_pop_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

"""aggregate stddev_samp on columns"""
type payrolls_stddev_samp_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
  version_number: Float
}

"""
order by stddev_samp() on columns of table "payrolls"
"""
input payrolls_stddev_samp_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

"""
Streaming cursor of the table "payrolls"
"""
input payrolls_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payrolls_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payrolls_stream_cursor_value_input {
  """Backup consultant for this payroll"""
  backup_consultant_user_id: uuid

  """Reference to the client this payroll belongs to"""
  client_id: uuid

  """Timestamp when the payroll was created"""
  created_at: timestamptz
  created_by_user_id: uuid

  """Reference to the payroll cycle"""
  cycle_id: uuid

  """Reference to the payroll date type"""
  date_type_id: uuid

  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """The date when the payroll went live in the system"""
  go_live_date: date

  """Unique identifier for the payroll"""
  id: uuid

  """Manager overseeing this payroll"""
  manager_user_id: uuid

  """Name of the payroll"""
  name: String
  parent_payroll_id: uuid

  """External payroll system used for this client"""
  payroll_system: String

  """Primary consultant responsible for this payroll"""
  primary_consultant_user_id: uuid

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int

  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  superseded_date: date

  """Timestamp when the payroll was last updated"""
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""aggregate sum on columns"""
type payrolls_sum_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Int

  """Number of employees in this payroll"""
  employee_count: Int

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Int

  """Number of hours required to process this payroll"""
  processing_time: Int
  version_number: Int
}

"""
order by sum() on columns of table "payrolls"
"""
input payrolls_sum_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

"""
update columns of table "payrolls"
"""
enum payrolls_update_column {
  """column name"""
  backup_consultant_user_id

  """column name"""
  client_id

  """column name"""
  created_at

  """column name"""
  created_by_user_id

  """column name"""
  cycle_id

  """column name"""
  date_type_id

  """column name"""
  date_value

  """column name"""
  employee_count

  """column name"""
  go_live_date

  """column name"""
  id

  """column name"""
  manager_user_id

  """column name"""
  name

  """column name"""
  parent_payroll_id

  """column name"""
  payroll_system

  """column name"""
  primary_consultant_user_id

  """column name"""
  processing_days_before_eft

  """column name"""
  processing_time

  """column name"""
  status

  """column name"""
  superseded_date

  """column name"""
  updated_at

  """column name"""
  version_number

  """column name"""
  version_reason
}

input payrolls_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payrolls_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: payrolls_set_input

  """filter the rows which have to be updated"""
  where: payrolls_bool_exp!
}

"""aggregate var_pop on columns"""
type payrolls_var_pop_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
  version_number: Float
}

"""
order by var_pop() on columns of table "payrolls"
"""
input payrolls_var_pop_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

"""aggregate var_samp on columns"""
type payrolls_var_samp_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
  version_number: Float
}

"""
order by var_samp() on columns of table "payrolls"
"""
input payrolls_var_samp_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

"""aggregate variance on columns"""
type payrolls_variance_fields {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: Float

  """Number of employees in this payroll"""
  employee_count: Float

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: Float

  """Number of hours required to process this payroll"""
  processing_time: Float
  version_number: Float
}

"""
order by variance() on columns of table "payrolls"
"""
input payrolls_variance_order_by {
  """Specific value for date calculation (e.g., day of month)"""
  date_value: order_by

  """Number of employees in this payroll"""
  employee_count: order_by

  """Number of days before EFT that processing must complete"""
  processing_days_before_eft: order_by

  """Number of hours required to process this payroll"""
  processing_time: order_by
  version_number: order_by
}

scalar permission_action

"""
Boolean expression to compare columns of type "permission_action". All fields are combined with logical 'AND'.
"""
input permission_action_comparison_exp {
  _eq: permission_action
  _gt: permission_action
  _gte: permission_action
  _in: [permission_action!]
  _is_null: Boolean
  _lt: permission_action
  _lte: permission_action
  _neq: permission_action
  _nin: [permission_action!]
}

"""
columns and relationships of "permissions"
"""
type permissions {
  action: permission_action!
  created_at: timestamptz!
  description: String
  id: uuid!
  legacy_permission_name: String

  """An object relationship"""
  resource: resources!
  resource_id: uuid!

  """An array relationship"""
  role_permissions(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """An aggregate relationship"""
  role_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "permissions"
"""
type permissions_aggregate {
  aggregate: permissions_aggregate_fields
  nodes: [permissions!]!
}

input permissions_aggregate_bool_exp {
  count: permissions_aggregate_bool_exp_count
}

input permissions_aggregate_bool_exp_count {
  arguments: [permissions_select_column!]
  distinct: Boolean
  filter: permissions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "permissions"
"""
type permissions_aggregate_fields {
  count(columns: [permissions_select_column!], distinct: Boolean): Int!
  max: permissions_max_fields
  min: permissions_min_fields
}

"""
order by aggregate values of table "permissions"
"""
input permissions_aggregate_order_by {
  count: order_by
  max: permissions_max_order_by
  min: permissions_min_order_by
}

"""
input type for inserting array relation for remote table "permissions"
"""
input permissions_arr_rel_insert_input {
  data: [permissions_insert_input!]!

  """upsert condition"""
  on_conflict: permissions_on_conflict
}

"""
Boolean expression to filter rows from the table "permissions". All fields are combined with a logical 'AND'.
"""
input permissions_bool_exp {
  _and: [permissions_bool_exp!]
  _not: permissions_bool_exp
  _or: [permissions_bool_exp!]
  action: permission_action_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  legacy_permission_name: String_comparison_exp
  resource: resources_bool_exp
  resource_id: uuid_comparison_exp
  role_permissions: role_permissions_bool_exp
  role_permissions_aggregate: role_permissions_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "permissions"
"""
enum permissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permissions_pkey

  """
  unique or primary key constraint on columns "action", "resource_id"
  """
  permissions_resource_id_action_key
}

"""
input type for inserting data into table "permissions"
"""
input permissions_insert_input {
  action: permission_action
  created_at: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resource: resources_obj_rel_insert_input
  resource_id: uuid
  role_permissions: role_permissions_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type permissions_max_fields {
  action: permission_action
  created_at: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resource_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "permissions"
"""
input permissions_max_order_by {
  action: order_by
  created_at: order_by
  description: order_by
  id: order_by
  legacy_permission_name: order_by
  resource_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type permissions_min_fields {
  action: permission_action
  created_at: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resource_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "permissions"
"""
input permissions_min_order_by {
  action: order_by
  created_at: order_by
  description: order_by
  id: order_by
  legacy_permission_name: order_by
  resource_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "permissions"
"""
type permissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [permissions!]!
}

"""
input type for inserting object relation for remote table "permissions"
"""
input permissions_obj_rel_insert_input {
  data: permissions_insert_input!

  """upsert condition"""
  on_conflict: permissions_on_conflict
}

"""
on_conflict condition type for table "permissions"
"""
input permissions_on_conflict {
  constraint: permissions_constraint!
  update_columns: [permissions_update_column!]! = []
  where: permissions_bool_exp
}

"""Ordering options when selecting data from "permissions"."""
input permissions_order_by {
  action: order_by
  created_at: order_by
  description: order_by
  id: order_by
  legacy_permission_name: order_by
  resource: resources_order_by
  resource_id: order_by
  role_permissions_aggregate: role_permissions_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: permissions"""
input permissions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "permissions"
"""
enum permissions_select_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  legacy_permission_name

  """column name"""
  resource_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "permissions"
"""
input permissions_set_input {
  action: permission_action
  created_at: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resource_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "permissions"
"""
input permissions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: permissions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input permissions_stream_cursor_value_input {
  action: permission_action
  created_at: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resource_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "permissions"
"""
enum permissions_update_column {
  """column name"""
  action

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  legacy_permission_name

  """column name"""
  resource_id

  """column name"""
  updated_at
}

input permissions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: permissions_set_input

  """filter the rows which have to be updated"""
  where: permissions_bool_exp!
}

type query_root {
  """query _Entity union"""
  _entities(representations: [_Any!]!): _Entity
  _service: _Service!

  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustment_rules_by_pk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustment_rules

  """
  fetch data from the table: "app_settings"
  """
  app_settings(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): [app_settings!]!

  """
  fetch aggregated fields from the table: "app_settings"
  """
  app_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): app_settings_aggregate!

  """fetch data from the table: "app_settings" using primary key columns"""
  app_settings_by_pk(
    """Unique identifier for application setting"""
    id: String!
  ): app_settings

  """
  fetch data from the table: "billing_event_log"
  """
  billing_event_log(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!

  """
  fetch aggregated fields from the table: "billing_event_log"
  """
  billing_event_log_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!

  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billing_event_log_by_pk(id: uuid!): billing_event_log

  """
  fetch data from the table: "billing_invoice"
  """
  billing_invoice(
    """distinct select on columns"""
    distinct_on: [billing_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_order_by!]

    """filter the rows returned"""
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!

  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billing_invoice_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_order_by!]

    """filter the rows returned"""
    where: billing_invoice_bool_exp
  ): billing_invoice_aggregate!

  """fetch data from the table: "billing_invoice" using primary key columns"""
  billing_invoice_by_pk(id: uuid!): billing_invoice

  """
  fetch data from the table: "billing_invoice_item"
  """
  billing_invoice_item(
    """distinct select on columns"""
    distinct_on: [billing_invoice_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_item_order_by!]

    """filter the rows returned"""
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!

  """
  fetch aggregated fields from the table: "billing_invoice_item"
  """
  billing_invoice_item_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoice_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_item_order_by!]

    """filter the rows returned"""
    where: billing_invoice_item_bool_exp
  ): billing_invoice_item_aggregate!

  """
  fetch data from the table: "billing_invoice_item" using primary key columns
  """
  billing_invoice_item_by_pk(id: uuid!): billing_invoice_item

  """
  fetch data from the table: "billing_invoices"
  """
  billing_invoices(
    """distinct select on columns"""
    distinct_on: [billing_invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoices_order_by!]

    """filter the rows returned"""
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!

  """
  fetch aggregated fields from the table: "billing_invoices"
  """
  billing_invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoices_order_by!]

    """filter the rows returned"""
    where: billing_invoices_bool_exp
  ): billing_invoices_aggregate!

  """
  fetch data from the table: "billing_invoices" using primary key columns
  """
  billing_invoices_by_pk(id: uuid!): billing_invoices

  """An array relationship"""
  billing_items(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): [billing_items!]!

  """An aggregate relationship"""
  billing_items_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): billing_items_aggregate!

  """fetch data from the table: "billing_items" using primary key columns"""
  billing_items_by_pk(id: uuid!): billing_items

  """
  fetch data from the table: "billing_plan"
  """
  billing_plan(
    """distinct select on columns"""
    distinct_on: [billing_plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_plan_order_by!]

    """filter the rows returned"""
    where: billing_plan_bool_exp
  ): [billing_plan!]!

  """
  fetch aggregated fields from the table: "billing_plan"
  """
  billing_plan_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_plan_order_by!]

    """filter the rows returned"""
    where: billing_plan_bool_exp
  ): billing_plan_aggregate!

  """fetch data from the table: "billing_plan" using primary key columns"""
  billing_plan_by_pk(id: uuid!): billing_plan

  """
  fetch data from the table: "client_billing_assignment"
  """
  client_billing_assignment(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!

  """
  fetch aggregated fields from the table: "client_billing_assignment"
  """
  client_billing_assignment_aggregate(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!

  """
  fetch data from the table: "client_billing_assignment" using primary key columns
  """
  client_billing_assignment_by_pk(id: uuid!): client_billing_assignment

  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  client_external_systems_by_pk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): client_external_systems

  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  fetch aggregated fields from the table: "clients"
  """
  clients_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """fetch data from the table: "clients" using primary key columns"""
  clients_by_pk(
    """Unique identifier for the client"""
    id: uuid!
  ): clients

  """
  execute function "create_payroll_version" which returns "payroll_version_results"
  """
  create_payroll_version(
    """
    input parameters for function "create_payroll_version"
    """
    args: create_payroll_version_args!

    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!

  """
  execute function "create_payroll_version" and query aggregates on result of table type "payroll_version_results"
  """
  create_payroll_version_aggregate(
    """
    input parameters for function "create_payroll_version_aggregate"
    """
    args: create_payroll_version_args!

    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!

  """
  fetch data from the table: "current_payrolls"
  """
  current_payrolls(
    """distinct select on columns"""
    distinct_on: [current_payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_payrolls_order_by!]

    """filter the rows returned"""
    where: current_payrolls_bool_exp
  ): [current_payrolls!]!

  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  current_payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [current_payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_payrolls_order_by!]

    """filter the rows returned"""
    where: current_payrolls_bool_exp
  ): current_payrolls_aggregate!

  """
  fetch data from the table: "external_systems"
  """
  external_systems(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): [external_systems!]!

  """
  fetch aggregated fields from the table: "external_systems"
  """
  external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): external_systems_aggregate!

  """
  fetch data from the table: "external_systems" using primary key columns
  """
  external_systems_by_pk(
    """Unique identifier for the external system"""
    id: uuid!
  ): external_systems

  """
  fetch data from the table: "feature_flags"
  """
  feature_flags(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): [feature_flags!]!

  """
  fetch aggregated fields from the table: "feature_flags"
  """
  feature_flags_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): feature_flags_aggregate!

  """fetch data from the table: "feature_flags" using primary key columns"""
  feature_flags_by_pk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): feature_flags

  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generate_payroll_dates(
    """
    input parameters for function "generate_payroll_dates"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generate_payroll_dates_aggregate(
    """
    input parameters for function "generate_payroll_dates_aggregate"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): [holidays!]!

  """
  fetch aggregated fields from the table: "holidays"
  """
  holidays_aggregate(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): holidays_aggregate!

  """fetch data from the table: "holidays" using primary key columns"""
  holidays_by_pk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays

  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results(
    """distinct select on columns"""
    distinct_on: [latest_payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_payroll_version_results_order_by!]

    """filter the rows returned"""
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!

  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results_aggregate(
    """distinct select on columns"""
    distinct_on: [latest_payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_payroll_version_results_order_by!]

    """filter the rows returned"""
    where: latest_payroll_version_results_bool_exp
  ): latest_payroll_version_results_aggregate!

  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latest_payroll_version_results_by_pk(id: uuid!): latest_payroll_version_results

  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """
  fetch aggregated fields from the table: "leave"
  """
  leave_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): leave_aggregate!

  """fetch data from the table: "leave" using primary key columns"""
  leave_by_pk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave

  """
  fetch data from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!

  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync_aggregate(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): neon_auth_users_sync_aggregate!

  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  neon_auth_users_sync_by_pk(
    """Unique identifier from the authentication provider"""
    id: String!
  ): neon_auth_users_sync

  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """fetch data from the table: "notes" using primary key columns"""
  notes_by_pk(
    """Unique identifier for the note"""
    id: uuid!
  ): notes

  """
  fetch data from the table: "payroll_activation_results"
  """
  payroll_activation_results(
    """distinct select on columns"""
    distinct_on: [payroll_activation_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_activation_results_order_by!]

    """filter the rows returned"""
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!

  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payroll_activation_results_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_activation_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_activation_results_order_by!]

    """filter the rows returned"""
    where: payroll_activation_results_bool_exp
  ): payroll_activation_results_aggregate!

  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payroll_activation_results_by_pk(id: uuid!): payroll_activation_results

  """
  fetch data from the table: "payroll_cycles"
  """
  payroll_cycles(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!

  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payroll_cycles_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): payroll_cycles_aggregate!

  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payroll_cycles_by_pk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payroll_cycles

  """
  fetch data from the table: "payroll_date_types"
  """
  payroll_date_types(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!

  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payroll_date_types_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): payroll_date_types_aggregate!

  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payroll_date_types_by_pk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payroll_date_types

  """An array relationship"""
  payroll_dates(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """An aggregate relationship"""
  payroll_dates_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """fetch data from the table: "payroll_dates" using primary key columns"""
  payroll_dates_by_pk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payroll_dates

  """
  fetch data from the table: "payroll_version_history_results"
  """
  payroll_version_history_results(
    """distinct select on columns"""
    distinct_on: [payroll_version_history_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_history_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!

  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payroll_version_history_results_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_version_history_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_history_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_history_results_bool_exp
  ): payroll_version_history_results_aggregate!

  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payroll_version_history_results_by_pk(id: uuid!): payroll_version_history_results

  """
  fetch data from the table: "payroll_version_results"
  """
  payroll_version_results(
    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!

  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payroll_version_results_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!

  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payroll_version_results_by_pk(id: uuid!): payroll_version_results

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """fetch data from the table: "payrolls" using primary key columns"""
  payrolls_by_pk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls

  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): [permissions!]!

  """An aggregate relationship"""
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): permissions_aggregate!

  """fetch data from the table: "permissions" using primary key columns"""
  permissions_by_pk(id: uuid!): permissions

  """
  fetch data from the table: "resources"
  """
  resources(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): [resources!]!

  """
  fetch aggregated fields from the table: "resources"
  """
  resources_aggregate(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): resources_aggregate!

  """fetch data from the table: "resources" using primary key columns"""
  resources_by_pk(id: uuid!): resources

  """An array relationship"""
  role_permissions(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """An aggregate relationship"""
  role_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!

  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  role_permissions_by_pk(id: uuid!): role_permissions

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """An array relationship"""
  user_roles(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """An aggregate relationship"""
  user_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): user_roles_aggregate!

  """fetch data from the table: "user_roles" using primary key columns"""
  user_roles_by_pk(id: uuid!): user_roles

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(
    """Unique identifier for the user"""
    id: uuid!
  ): users

  """
  fetch data from the table: "users_role_backup"
  """
  users_role_backup(
    """distinct select on columns"""
    distinct_on: [users_role_backup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_role_backup_order_by!]

    """filter the rows returned"""
    where: users_role_backup_bool_exp
  ): [users_role_backup!]!

  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  users_role_backup_aggregate(
    """distinct select on columns"""
    distinct_on: [users_role_backup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_role_backup_order_by!]

    """filter the rows returned"""
    where: users_role_backup_bool_exp
  ): users_role_backup_aggregate!

  """
  fetch data from the table: "work_schedule"
  """
  work_schedule(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!

  """
  fetch aggregated fields from the table: "work_schedule"
  """
  work_schedule_aggregate(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!

  """fetch data from the table: "work_schedule" using primary key columns"""
  work_schedule_by_pk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): work_schedule
}

"""
columns and relationships of "resources"
"""
type resources {
  created_at: timestamptz!
  description: String
  display_name: String!
  id: uuid!
  name: String!

  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): [permissions!]!

  """An aggregate relationship"""
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): permissions_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "resources"
"""
type resources_aggregate {
  aggregate: resources_aggregate_fields
  nodes: [resources!]!
}

"""
aggregate fields of "resources"
"""
type resources_aggregate_fields {
  count(columns: [resources_select_column!], distinct: Boolean): Int!
  max: resources_max_fields
  min: resources_min_fields
}

"""
Boolean expression to filter rows from the table "resources". All fields are combined with a logical 'AND'.
"""
input resources_bool_exp {
  _and: [resources_bool_exp!]
  _not: resources_bool_exp
  _or: [resources_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  display_name: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  permissions: permissions_bool_exp
  permissions_aggregate: permissions_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "resources"
"""
enum resources_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  resources_name_key

  """
  unique or primary key constraint on columns "id"
  """
  resources_pkey
}

"""
input type for inserting data into table "resources"
"""
input resources_insert_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  name: String
  permissions: permissions_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type resources_max_fields {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type resources_min_fields {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "resources"
"""
type resources_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [resources!]!
}

"""
input type for inserting object relation for remote table "resources"
"""
input resources_obj_rel_insert_input {
  data: resources_insert_input!

  """upsert condition"""
  on_conflict: resources_on_conflict
}

"""
on_conflict condition type for table "resources"
"""
input resources_on_conflict {
  constraint: resources_constraint!
  update_columns: [resources_update_column!]! = []
  where: resources_bool_exp
}

"""Ordering options when selecting data from "resources"."""
input resources_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  name: order_by
  permissions_aggregate: permissions_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: resources"""
input resources_pk_columns_input {
  id: uuid!
}

"""
select columns of table "resources"
"""
enum resources_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "resources"
"""
input resources_set_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "resources"
"""
input resources_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: resources_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input resources_stream_cursor_value_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "resources"
"""
enum resources_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

input resources_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: resources_set_input

  """filter the rows which have to be updated"""
  where: resources_bool_exp!
}

"""
columns and relationships of "role_permissions"
"""
type role_permissions {
  conditions(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  permission: permissions!
  permission_id: uuid!

  """An object relationship"""
  role: roles!
  role_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "role_permissions"
"""
type role_permissions_aggregate {
  aggregate: role_permissions_aggregate_fields
  nodes: [role_permissions!]!
}

input role_permissions_aggregate_bool_exp {
  count: role_permissions_aggregate_bool_exp_count
}

input role_permissions_aggregate_bool_exp_count {
  arguments: [role_permissions_select_column!]
  distinct: Boolean
  filter: role_permissions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "role_permissions"
"""
type role_permissions_aggregate_fields {
  count(columns: [role_permissions_select_column!], distinct: Boolean): Int!
  max: role_permissions_max_fields
  min: role_permissions_min_fields
}

"""
order by aggregate values of table "role_permissions"
"""
input role_permissions_aggregate_order_by {
  count: order_by
  max: role_permissions_max_order_by
  min: role_permissions_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input role_permissions_append_input {
  conditions: jsonb
}

"""
input type for inserting array relation for remote table "role_permissions"
"""
input role_permissions_arr_rel_insert_input {
  data: [role_permissions_insert_input!]!

  """upsert condition"""
  on_conflict: role_permissions_on_conflict
}

"""
Boolean expression to filter rows from the table "role_permissions". All fields are combined with a logical 'AND'.
"""
input role_permissions_bool_exp {
  _and: [role_permissions_bool_exp!]
  _not: role_permissions_bool_exp
  _or: [role_permissions_bool_exp!]
  conditions: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  permission: permissions_bool_exp
  permission_id: uuid_comparison_exp
  role: roles_bool_exp
  role_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "role_permissions"
"""
enum role_permissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  role_permissions_pkey

  """
  unique or primary key constraint on columns "permission_id", "role_id"
  """
  role_permissions_role_id_permission_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input role_permissions_delete_at_path_input {
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input role_permissions_delete_elem_input {
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input role_permissions_delete_key_input {
  conditions: String
}

"""
input type for inserting data into table "role_permissions"
"""
input role_permissions_insert_input {
  conditions: jsonb
  created_at: timestamptz
  id: uuid
  permission: permissions_obj_rel_insert_input
  permission_id: uuid
  role: roles_obj_rel_insert_input
  role_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type role_permissions_max_fields {
  created_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "role_permissions"
"""
input role_permissions_max_order_by {
  created_at: order_by
  id: order_by
  permission_id: order_by
  role_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type role_permissions_min_fields {
  created_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "role_permissions"
"""
input role_permissions_min_order_by {
  created_at: order_by
  id: order_by
  permission_id: order_by
  role_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "role_permissions"
"""
type role_permissions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [role_permissions!]!
}

"""
on_conflict condition type for table "role_permissions"
"""
input role_permissions_on_conflict {
  constraint: role_permissions_constraint!
  update_columns: [role_permissions_update_column!]! = []
  where: role_permissions_bool_exp
}

"""Ordering options when selecting data from "role_permissions"."""
input role_permissions_order_by {
  conditions: order_by
  created_at: order_by
  id: order_by
  permission: permissions_order_by
  permission_id: order_by
  role: roles_order_by
  role_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: role_permissions"""
input role_permissions_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input role_permissions_prepend_input {
  conditions: jsonb
}

"""
select columns of table "role_permissions"
"""
enum role_permissions_select_column {
  """column name"""
  conditions

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  permission_id

  """column name"""
  role_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "role_permissions"
"""
input role_permissions_set_input {
  conditions: jsonb
  created_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
Streaming cursor of the table "role_permissions"
"""
input role_permissions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: role_permissions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input role_permissions_stream_cursor_value_input {
  conditions: jsonb
  created_at: timestamptz
  id: uuid
  permission_id: uuid
  role_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "role_permissions"
"""
enum role_permissions_update_column {
  """column name"""
  conditions

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  permission_id

  """column name"""
  role_id

  """column name"""
  updated_at
}

input role_permissions_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: role_permissions_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: role_permissions_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: role_permissions_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: role_permissions_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: role_permissions_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: role_permissions_set_input

  """filter the rows which have to be updated"""
  where: role_permissions_bool_exp!
}

"""
columns and relationships of "roles"
"""
type roles {
  created_at: timestamptz!
  description: String
  display_name: String!
  id: uuid!
  is_system_role: Boolean!
  name: String!
  priority: Int!

  """An array relationship"""
  role_permissions(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """An aggregate relationship"""
  role_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!
  updated_at: timestamptz!

  """An array relationship"""
  user_roles(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """An aggregate relationship"""
  user_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): user_roles_aggregate!
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  avg: roles_avg_fields
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
  stddev: roles_stddev_fields
  stddev_pop: roles_stddev_pop_fields
  stddev_samp: roles_stddev_samp_fields
  sum: roles_sum_fields
  var_pop: roles_var_pop_fields
  var_samp: roles_var_samp_fields
  variance: roles_variance_fields
}

"""aggregate avg on columns"""
type roles_avg_fields {
  priority: Float
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  display_name: String_comparison_exp
  id: uuid_comparison_exp
  is_system_role: Boolean_comparison_exp
  name: String_comparison_exp
  priority: Int_comparison_exp
  role_permissions: role_permissions_bool_exp
  role_permissions_aggregate: role_permissions_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user_roles: user_roles_bool_exp
  user_roles_aggregate: user_roles_aggregate_bool_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  roles_name_key

  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey
}

"""
input type for incrementing numeric columns in table "roles"
"""
input roles_inc_input {
  priority: Int
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  is_system_role: Boolean
  name: String
  priority: Int
  role_permissions: role_permissions_arr_rel_insert_input
  updated_at: timestamptz
  user_roles: user_roles_arr_rel_insert_input
}

"""aggregate max on columns"""
type roles_max_fields {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  name: String
  priority: Int
  updated_at: timestamptz
}

"""aggregate min on columns"""
type roles_min_fields {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  name: String
  priority: Int
  updated_at: timestamptz
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!

  """upsert condition"""
  on_conflict: roles_on_conflict
}

"""
on_conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""Ordering options when selecting data from "roles"."""
input roles_order_by {
  created_at: order_by
  description: order_by
  display_name: order_by
  id: order_by
  is_system_role: order_by
  name: order_by
  priority: order_by
  role_permissions_aggregate: role_permissions_aggregate_order_by
  updated_at: order_by
  user_roles_aggregate: user_roles_aggregate_order_by
}

"""primary key columns input for table: roles"""
input roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  is_system_role

  """column name"""
  name

  """column name"""
  priority

  """column name"""
  updated_at
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  is_system_role: Boolean
  name: String
  priority: Int
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type roles_stddev_fields {
  priority: Float
}

"""aggregate stddev_pop on columns"""
type roles_stddev_pop_fields {
  priority: Float
}

"""aggregate stddev_samp on columns"""
type roles_stddev_samp_fields {
  priority: Float
}

"""
Streaming cursor of the table "roles"
"""
input roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input roles_stream_cursor_value_input {
  created_at: timestamptz
  description: String
  display_name: String
  id: uuid
  is_system_role: Boolean
  name: String
  priority: Int
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type roles_sum_fields {
  priority: Int
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  is_system_role

  """column name"""
  name

  """column name"""
  priority

  """column name"""
  updated_at
}

input roles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: roles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: roles_set_input

  """filter the rows which have to be updated"""
  where: roles_bool_exp!
}

"""aggregate var_pop on columns"""
type roles_var_pop_fields {
  priority: Float
}

"""aggregate var_samp on columns"""
type roles_var_samp_fields {
  priority: Float
}

"""aggregate variance on columns"""
type roles_variance_fields {
  priority: Float
}

type subscription_root {
  """An array relationship"""
  adjustment_rules(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """An aggregate relationship"""
  adjustment_rules_aggregate(
    """distinct select on columns"""
    distinct_on: [adjustment_rules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [adjustment_rules_order_by!]

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!

  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustment_rules_by_pk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustment_rules

  """
  fetch data from the table in a streaming manner: "adjustment_rules"
  """
  adjustment_rules_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [adjustment_rules_stream_cursor_input]!

    """filter the rows returned"""
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!

  """
  fetch data from the table: "app_settings"
  """
  app_settings(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): [app_settings!]!

  """
  fetch aggregated fields from the table: "app_settings"
  """
  app_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [app_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_settings_order_by!]

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): app_settings_aggregate!

  """fetch data from the table: "app_settings" using primary key columns"""
  app_settings_by_pk(
    """Unique identifier for application setting"""
    id: String!
  ): app_settings

  """
  fetch data from the table in a streaming manner: "app_settings"
  """
  app_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [app_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: app_settings_bool_exp
  ): [app_settings!]!

  """
  fetch data from the table: "billing_event_log"
  """
  billing_event_log(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!

  """
  fetch aggregated fields from the table: "billing_event_log"
  """
  billing_event_log_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!

  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billing_event_log_by_pk(id: uuid!): billing_event_log

  """
  fetch data from the table in a streaming manner: "billing_event_log"
  """
  billing_event_log_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [billing_event_log_stream_cursor_input]!

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!

  """
  fetch data from the table: "billing_invoice"
  """
  billing_invoice(
    """distinct select on columns"""
    distinct_on: [billing_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_order_by!]

    """filter the rows returned"""
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!

  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billing_invoice_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_order_by!]

    """filter the rows returned"""
    where: billing_invoice_bool_exp
  ): billing_invoice_aggregate!

  """fetch data from the table: "billing_invoice" using primary key columns"""
  billing_invoice_by_pk(id: uuid!): billing_invoice

  """
  fetch data from the table: "billing_invoice_item"
  """
  billing_invoice_item(
    """distinct select on columns"""
    distinct_on: [billing_invoice_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_item_order_by!]

    """filter the rows returned"""
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!

  """
  fetch aggregated fields from the table: "billing_invoice_item"
  """
  billing_invoice_item_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoice_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoice_item_order_by!]

    """filter the rows returned"""
    where: billing_invoice_item_bool_exp
  ): billing_invoice_item_aggregate!

  """
  fetch data from the table: "billing_invoice_item" using primary key columns
  """
  billing_invoice_item_by_pk(id: uuid!): billing_invoice_item

  """
  fetch data from the table in a streaming manner: "billing_invoice_item"
  """
  billing_invoice_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [billing_invoice_item_stream_cursor_input]!

    """filter the rows returned"""
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!

  """
  fetch data from the table in a streaming manner: "billing_invoice"
  """
  billing_invoice_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [billing_invoice_stream_cursor_input]!

    """filter the rows returned"""
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!

  """
  fetch data from the table: "billing_invoices"
  """
  billing_invoices(
    """distinct select on columns"""
    distinct_on: [billing_invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoices_order_by!]

    """filter the rows returned"""
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!

  """
  fetch aggregated fields from the table: "billing_invoices"
  """
  billing_invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_invoices_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_invoices_order_by!]

    """filter the rows returned"""
    where: billing_invoices_bool_exp
  ): billing_invoices_aggregate!

  """
  fetch data from the table: "billing_invoices" using primary key columns
  """
  billing_invoices_by_pk(id: uuid!): billing_invoices

  """
  fetch data from the table in a streaming manner: "billing_invoices"
  """
  billing_invoices_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [billing_invoices_stream_cursor_input]!

    """filter the rows returned"""
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!

  """An array relationship"""
  billing_items(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): [billing_items!]!

  """An aggregate relationship"""
  billing_items_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_items_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_items_order_by!]

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): billing_items_aggregate!

  """fetch data from the table: "billing_items" using primary key columns"""
  billing_items_by_pk(id: uuid!): billing_items

  """
  fetch data from the table in a streaming manner: "billing_items"
  """
  billing_items_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [billing_items_stream_cursor_input]!

    """filter the rows returned"""
    where: billing_items_bool_exp
  ): [billing_items!]!

  """
  fetch data from the table: "billing_plan"
  """
  billing_plan(
    """distinct select on columns"""
    distinct_on: [billing_plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_plan_order_by!]

    """filter the rows returned"""
    where: billing_plan_bool_exp
  ): [billing_plan!]!

  """
  fetch aggregated fields from the table: "billing_plan"
  """
  billing_plan_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_plan_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_plan_order_by!]

    """filter the rows returned"""
    where: billing_plan_bool_exp
  ): billing_plan_aggregate!

  """fetch data from the table: "billing_plan" using primary key columns"""
  billing_plan_by_pk(id: uuid!): billing_plan

  """
  fetch data from the table in a streaming manner: "billing_plan"
  """
  billing_plan_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [billing_plan_stream_cursor_input]!

    """filter the rows returned"""
    where: billing_plan_bool_exp
  ): [billing_plan!]!

  """
  fetch data from the table: "client_billing_assignment"
  """
  client_billing_assignment(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!

  """
  fetch aggregated fields from the table: "client_billing_assignment"
  """
  client_billing_assignment_aggregate(
    """distinct select on columns"""
    distinct_on: [client_billing_assignment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_billing_assignment_order_by!]

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!

  """
  fetch data from the table: "client_billing_assignment" using primary key columns
  """
  client_billing_assignment_by_pk(id: uuid!): client_billing_assignment

  """
  fetch data from the table in a streaming manner: "client_billing_assignment"
  """
  client_billing_assignment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [client_billing_assignment_stream_cursor_input]!

    """filter the rows returned"""
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!

  """An array relationship"""
  client_external_systems(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """An aggregate relationship"""
  client_external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [client_external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [client_external_systems_order_by!]

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!

  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  client_external_systems_by_pk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): client_external_systems

  """
  fetch data from the table in a streaming manner: "client_external_systems"
  """
  client_external_systems_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [client_external_systems_stream_cursor_input]!

    """filter the rows returned"""
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!

  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  fetch aggregated fields from the table: "clients"
  """
  clients_aggregate(
    """distinct select on columns"""
    distinct_on: [clients_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clients_order_by!]

    """filter the rows returned"""
    where: clients_bool_exp
  ): clients_aggregate!

  """fetch data from the table: "clients" using primary key columns"""
  clients_by_pk(
    """Unique identifier for the client"""
    id: uuid!
  ): clients

  """
  fetch data from the table in a streaming manner: "clients"
  """
  clients_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [clients_stream_cursor_input]!

    """filter the rows returned"""
    where: clients_bool_exp
  ): [clients!]!

  """
  execute function "create_payroll_version" which returns "payroll_version_results"
  """
  create_payroll_version(
    """
    input parameters for function "create_payroll_version"
    """
    args: create_payroll_version_args!

    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!

  """
  execute function "create_payroll_version" and query aggregates on result of table type "payroll_version_results"
  """
  create_payroll_version_aggregate(
    """
    input parameters for function "create_payroll_version_aggregate"
    """
    args: create_payroll_version_args!

    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!

  """
  fetch data from the table: "current_payrolls"
  """
  current_payrolls(
    """distinct select on columns"""
    distinct_on: [current_payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_payrolls_order_by!]

    """filter the rows returned"""
    where: current_payrolls_bool_exp
  ): [current_payrolls!]!

  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  current_payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [current_payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [current_payrolls_order_by!]

    """filter the rows returned"""
    where: current_payrolls_bool_exp
  ): current_payrolls_aggregate!

  """
  fetch data from the table in a streaming manner: "current_payrolls"
  """
  current_payrolls_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [current_payrolls_stream_cursor_input]!

    """filter the rows returned"""
    where: current_payrolls_bool_exp
  ): [current_payrolls!]!

  """
  fetch data from the table: "external_systems"
  """
  external_systems(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): [external_systems!]!

  """
  fetch aggregated fields from the table: "external_systems"
  """
  external_systems_aggregate(
    """distinct select on columns"""
    distinct_on: [external_systems_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [external_systems_order_by!]

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): external_systems_aggregate!

  """
  fetch data from the table: "external_systems" using primary key columns
  """
  external_systems_by_pk(
    """Unique identifier for the external system"""
    id: uuid!
  ): external_systems

  """
  fetch data from the table in a streaming manner: "external_systems"
  """
  external_systems_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [external_systems_stream_cursor_input]!

    """filter the rows returned"""
    where: external_systems_bool_exp
  ): [external_systems!]!

  """
  fetch data from the table: "feature_flags"
  """
  feature_flags(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): [feature_flags!]!

  """
  fetch aggregated fields from the table: "feature_flags"
  """
  feature_flags_aggregate(
    """distinct select on columns"""
    distinct_on: [feature_flags_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [feature_flags_order_by!]

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): feature_flags_aggregate!

  """fetch data from the table: "feature_flags" using primary key columns"""
  feature_flags_by_pk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): feature_flags

  """
  fetch data from the table in a streaming manner: "feature_flags"
  """
  feature_flags_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [feature_flags_stream_cursor_input]!

    """filter the rows returned"""
    where: feature_flags_bool_exp
  ): [feature_flags!]!

  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generate_payroll_dates(
    """
    input parameters for function "generate_payroll_dates"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generate_payroll_dates_aggregate(
    """
    input parameters for function "generate_payroll_dates_aggregate"
    """
    args: generate_payroll_dates_args!

    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): [holidays!]!

  """
  fetch aggregated fields from the table: "holidays"
  """
  holidays_aggregate(
    """distinct select on columns"""
    distinct_on: [holidays_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [holidays_order_by!]

    """filter the rows returned"""
    where: holidays_bool_exp
  ): holidays_aggregate!

  """fetch data from the table: "holidays" using primary key columns"""
  holidays_by_pk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays

  """
  fetch data from the table in a streaming manner: "holidays"
  """
  holidays_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [holidays_stream_cursor_input]!

    """filter the rows returned"""
    where: holidays_bool_exp
  ): [holidays!]!

  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results(
    """distinct select on columns"""
    distinct_on: [latest_payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_payroll_version_results_order_by!]

    """filter the rows returned"""
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!

  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results_aggregate(
    """distinct select on columns"""
    distinct_on: [latest_payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [latest_payroll_version_results_order_by!]

    """filter the rows returned"""
    where: latest_payroll_version_results_bool_exp
  ): latest_payroll_version_results_aggregate!

  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latest_payroll_version_results_by_pk(id: uuid!): latest_payroll_version_results

  """
  fetch data from the table in a streaming manner: "latest_payroll_version_results"
  """
  latest_payroll_version_results_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [latest_payroll_version_results_stream_cursor_input]!

    """filter the rows returned"""
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!

  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """
  fetch aggregated fields from the table: "leave"
  """
  leave_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): leave_aggregate!

  """fetch data from the table: "leave" using primary key columns"""
  leave_by_pk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave

  """
  fetch data from the table in a streaming manner: "leave"
  """
  leave_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [leave_stream_cursor_input]!

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """
  fetch data from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!

  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync_aggregate(
    """distinct select on columns"""
    distinct_on: [neon_auth_users_sync_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neon_auth_users_sync_order_by!]

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): neon_auth_users_sync_aggregate!

  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  neon_auth_users_sync_by_pk(
    """Unique identifier from the authentication provider"""
    id: String!
  ): neon_auth_users_sync

  """
  fetch data from the table in a streaming manner: "neon_auth.users_sync"
  """
  neon_auth_users_sync_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [neon_auth_users_sync_stream_cursor_input]!

    """filter the rows returned"""
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!

  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """fetch data from the table: "notes" using primary key columns"""
  notes_by_pk(
    """Unique identifier for the note"""
    id: uuid!
  ): notes

  """
  fetch data from the table in a streaming manner: "notes"
  """
  notes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notes_stream_cursor_input]!

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """
  fetch data from the table: "payroll_activation_results"
  """
  payroll_activation_results(
    """distinct select on columns"""
    distinct_on: [payroll_activation_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_activation_results_order_by!]

    """filter the rows returned"""
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!

  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payroll_activation_results_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_activation_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_activation_results_order_by!]

    """filter the rows returned"""
    where: payroll_activation_results_bool_exp
  ): payroll_activation_results_aggregate!

  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payroll_activation_results_by_pk(id: uuid!): payroll_activation_results

  """
  fetch data from the table in a streaming manner: "payroll_activation_results"
  """
  payroll_activation_results_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_activation_results_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!

  """
  fetch data from the table: "payroll_cycles"
  """
  payroll_cycles(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!

  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payroll_cycles_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_cycles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_cycles_order_by!]

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): payroll_cycles_aggregate!

  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payroll_cycles_by_pk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payroll_cycles

  """
  fetch data from the table in a streaming manner: "payroll_cycles"
  """
  payroll_cycles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_cycles_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!

  """
  fetch data from the table: "payroll_date_types"
  """
  payroll_date_types(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!

  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payroll_date_types_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_date_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_date_types_order_by!]

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): payroll_date_types_aggregate!

  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payroll_date_types_by_pk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payroll_date_types

  """
  fetch data from the table in a streaming manner: "payroll_date_types"
  """
  payroll_date_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_date_types_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!

  """An array relationship"""
  payroll_dates(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """An aggregate relationship"""
  payroll_dates_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_dates_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_dates_order_by!]

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!

  """fetch data from the table: "payroll_dates" using primary key columns"""
  payroll_dates_by_pk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payroll_dates

  """
  fetch data from the table in a streaming manner: "payroll_dates"
  """
  payroll_dates_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_dates_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!

  """
  fetch data from the table: "payroll_version_history_results"
  """
  payroll_version_history_results(
    """distinct select on columns"""
    distinct_on: [payroll_version_history_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_history_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!

  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payroll_version_history_results_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_version_history_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_history_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_history_results_bool_exp
  ): payroll_version_history_results_aggregate!

  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payroll_version_history_results_by_pk(id: uuid!): payroll_version_history_results

  """
  fetch data from the table in a streaming manner: "payroll_version_history_results"
  """
  payroll_version_history_results_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_version_history_results_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!

  """
  fetch data from the table: "payroll_version_results"
  """
  payroll_version_results(
    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!

  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payroll_version_results_aggregate(
    """distinct select on columns"""
    distinct_on: [payroll_version_results_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payroll_version_results_order_by!]

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!

  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payroll_version_results_by_pk(id: uuid!): payroll_version_results

  """
  fetch data from the table in a streaming manner: "payroll_version_results"
  """
  payroll_version_results_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payroll_version_results_stream_cursor_input]!

    """filter the rows returned"""
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!

  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrolls_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """fetch data from the table: "payrolls" using primary key columns"""
  payrolls_by_pk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls

  """
  fetch data from the table in a streaming manner: "payrolls"
  """
  payrolls_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payrolls_stream_cursor_input]!

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): [permissions!]!

  """An aggregate relationship"""
  permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [permissions_order_by!]

    """filter the rows returned"""
    where: permissions_bool_exp
  ): permissions_aggregate!

  """fetch data from the table: "permissions" using primary key columns"""
  permissions_by_pk(id: uuid!): permissions

  """
  fetch data from the table in a streaming manner: "permissions"
  """
  permissions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [permissions_stream_cursor_input]!

    """filter the rows returned"""
    where: permissions_bool_exp
  ): [permissions!]!

  """
  fetch data from the table: "resources"
  """
  resources(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): [resources!]!

  """
  fetch aggregated fields from the table: "resources"
  """
  resources_aggregate(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): resources_aggregate!

  """fetch data from the table: "resources" using primary key columns"""
  resources_by_pk(id: uuid!): resources

  """
  fetch data from the table in a streaming manner: "resources"
  """
  resources_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [resources_stream_cursor_input]!

    """filter the rows returned"""
    where: resources_bool_exp
  ): [resources!]!

  """An array relationship"""
  role_permissions(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """An aggregate relationship"""
  role_permissions_aggregate(
    """distinct select on columns"""
    distinct_on: [role_permissions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_permissions_order_by!]

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!

  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  role_permissions_by_pk(id: uuid!): role_permissions

  """
  fetch data from the table in a streaming manner: "role_permissions"
  """
  role_permissions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [role_permissions_stream_cursor_input]!

    """filter the rows returned"""
    where: role_permissions_bool_exp
  ): [role_permissions!]!

  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [roles_order_by!]

    """filter the rows returned"""
    where: roles_bool_exp
  ): roles_aggregate!

  """fetch data from the table: "roles" using primary key columns"""
  roles_by_pk(id: uuid!): roles

  """
  fetch data from the table in a streaming manner: "roles"
  """
  roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [roles_stream_cursor_input]!

    """filter the rows returned"""
    where: roles_bool_exp
  ): [roles!]!

  """An array relationship"""
  user_roles(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """An aggregate relationship"""
  user_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): user_roles_aggregate!

  """fetch data from the table: "user_roles" using primary key columns"""
  user_roles_by_pk(id: uuid!): user_roles

  """
  fetch data from the table in a streaming manner: "user_roles"
  """
  user_roles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_roles_stream_cursor_input]!

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(
    """Unique identifier for the user"""
    id: uuid!
  ): users

  """
  fetch data from the table: "users_role_backup"
  """
  users_role_backup(
    """distinct select on columns"""
    distinct_on: [users_role_backup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_role_backup_order_by!]

    """filter the rows returned"""
    where: users_role_backup_bool_exp
  ): [users_role_backup!]!

  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  users_role_backup_aggregate(
    """distinct select on columns"""
    distinct_on: [users_role_backup_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_role_backup_order_by!]

    """filter the rows returned"""
    where: users_role_backup_bool_exp
  ): users_role_backup_aggregate!

  """
  fetch data from the table in a streaming manner: "users_role_backup"
  """
  users_role_backup_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_role_backup_stream_cursor_input]!

    """filter the rows returned"""
    where: users_role_backup_bool_exp
  ): [users_role_backup!]!

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "work_schedule"
  """
  work_schedule(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!

  """
  fetch aggregated fields from the table: "work_schedule"
  """
  work_schedule_aggregate(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!

  """fetch data from the table: "work_schedule" using primary key columns"""
  work_schedule_by_pk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): work_schedule

  """
  fetch data from the table in a streaming manner: "work_schedule"
  """
  work_schedule_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [work_schedule_stream_cursor_input]!

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar user_role

"""
Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'.
"""
input user_role_comparison_exp {
  _eq: user_role
  _gt: user_role
  _gte: user_role
  _in: [user_role!]
  _is_null: Boolean
  _lt: user_role
  _lte: user_role
  _neq: user_role
  _nin: [user_role!]
}

"""
columns and relationships of "user_roles"
"""
type user_roles {
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  role: roles!
  role_id: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "user_roles"
"""
type user_roles_aggregate {
  aggregate: user_roles_aggregate_fields
  nodes: [user_roles!]!
}

input user_roles_aggregate_bool_exp {
  count: user_roles_aggregate_bool_exp_count
}

input user_roles_aggregate_bool_exp_count {
  arguments: [user_roles_select_column!]
  distinct: Boolean
  filter: user_roles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_roles"
"""
type user_roles_aggregate_fields {
  count(columns: [user_roles_select_column!], distinct: Boolean): Int!
  max: user_roles_max_fields
  min: user_roles_min_fields
}

"""
order by aggregate values of table "user_roles"
"""
input user_roles_aggregate_order_by {
  count: order_by
  max: user_roles_max_order_by
  min: user_roles_min_order_by
}

"""
input type for inserting array relation for remote table "user_roles"
"""
input user_roles_arr_rel_insert_input {
  data: [user_roles_insert_input!]!

  """upsert condition"""
  on_conflict: user_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "user_roles". All fields are combined with a logical 'AND'.
"""
input user_roles_bool_exp {
  _and: [user_roles_bool_exp!]
  _not: user_roles_bool_exp
  _or: [user_roles_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: roles_bool_exp
  role_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_roles"
"""
enum user_roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role_id"
  """
  user_roles_user_id_role_id_key
}

"""
input type for inserting data into table "user_roles"
"""
input user_roles_insert_input {
  created_at: timestamptz
  id: uuid
  role: roles_obj_rel_insert_input
  role_id: uuid
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_roles_max_fields {
  created_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "user_roles"
"""
input user_roles_max_order_by {
  created_at: order_by
  id: order_by
  role_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_roles_min_fields {
  created_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "user_roles"
"""
input user_roles_min_order_by {
  created_at: order_by
  id: order_by
  role_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_roles"
"""
type user_roles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_roles!]!
}

"""
on_conflict condition type for table "user_roles"
"""
input user_roles_on_conflict {
  constraint: user_roles_constraint!
  update_columns: [user_roles_update_column!]! = []
  where: user_roles_bool_exp
}

"""Ordering options when selecting data from "user_roles"."""
input user_roles_order_by {
  created_at: order_by
  id: order_by
  role: roles_order_by
  role_id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_roles"""
input user_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_roles"
"""
enum user_roles_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_roles"
"""
input user_roles_set_input {
  created_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "user_roles"
"""
input user_roles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_roles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_roles_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  role_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "user_roles"
"""
enum user_roles_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input user_roles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_roles_set_input

  """filter the rows which have to be updated"""
  where: user_roles_bool_exp!
}

"""
columns and relationships of "users"
"""
type users {
  """An array relationship"""
  billing_event_logs(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!

  """An aggregate relationship"""
  billing_event_logs_aggregate(
    """distinct select on columns"""
    distinct_on: [billing_event_log_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [billing_event_log_order_by!]

    """filter the rows returned"""
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!

  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz
  deactivated_at: timestamptz
  deactivated_by: String

  """User's email address (unique)"""
  email: String!

  """Unique identifier for the user"""
  id: uuid!

  """URL to the user's profile image"""
  image: String
  is_active: Boolean

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean

  """An array relationship"""
  leaves(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): [leave!]!

  """An aggregate relationship"""
  leaves_aggregate(
    """distinct select on columns"""
    distinct_on: [leave_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [leave_order_by!]

    """filter the rows returned"""
    where: leave_bool_exp
  ): leave_aggregate!

  """An object relationship"""
  manager: users

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String!

  """An array relationship"""
  notes_written(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): [notes!]!

  """An aggregate relationship"""
  notes_written_aggregate(
    """distinct select on columns"""
    distinct_on: [notes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notes_order_by!]

    """filter the rows returned"""
    where: notes_bool_exp
  ): notes_aggregate!

  """An array relationship"""
  payrollsByBackupConsultantUserId(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrollsByBackupConsultantUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """An array relationship"""
  payrollsByManagerUserId(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrollsByManagerUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """An array relationship"""
  payrollsByPrimaryConsultantUserId(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): [payrolls!]!

  """An aggregate relationship"""
  payrollsByPrimaryConsultantUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [payrolls_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payrolls_order_by!]

    """filter the rows returned"""
    where: payrolls_bool_exp
  ): payrolls_aggregate!

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role!

  """An array relationship"""
  staffByManager(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  staffByManager_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """An array relationship"""
  user_roles(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): [user_roles!]!

  """An aggregate relationship"""
  user_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [user_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_roles_order_by!]

    """filter the rows returned"""
    where: user_roles_bool_exp
  ): user_roles_aggregate!

  """User's unique username for login"""
  username: String

  """An array relationship"""
  usersManager(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersManager_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """An array relationship"""
  work_schedules(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): [work_schedule!]!

  """An aggregate relationship"""
  work_schedules_aggregate(
    """distinct select on columns"""
    distinct_on: [work_schedule_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [work_schedule_order_by!]

    """filter the rows returned"""
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  billing_event_logs: billing_event_log_bool_exp
  billing_event_logs_aggregate: billing_event_log_aggregate_bool_exp
  clerk_user_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deactivated_at: timestamptz_comparison_exp
  deactivated_by: String_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  is_active: Boolean_comparison_exp
  is_staff: Boolean_comparison_exp
  leaves: leave_bool_exp
  leaves_aggregate: leave_aggregate_bool_exp
  manager: users_bool_exp
  manager_id: uuid_comparison_exp
  name: String_comparison_exp
  notes_written: notes_bool_exp
  notes_written_aggregate: notes_aggregate_bool_exp
  payrollsByBackupConsultantUserId: payrolls_bool_exp
  payrollsByBackupConsultantUserId_aggregate: payrolls_aggregate_bool_exp
  payrollsByManagerUserId: payrolls_bool_exp
  payrollsByManagerUserId_aggregate: payrolls_aggregate_bool_exp
  payrollsByPrimaryConsultantUserId: payrolls_bool_exp
  payrollsByPrimaryConsultantUserId_aggregate: payrolls_aggregate_bool_exp
  role: user_role_comparison_exp
  staffByManager: users_bool_exp
  staffByManager_aggregate: users_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user_roles: user_roles_bool_exp
  user_roles_aggregate: user_roles_aggregate_bool_exp
  username: String_comparison_exp
  usersManager: users_bool_exp
  usersManager_aggregate: users_aggregate_bool_exp
  work_schedules: work_schedule_bool_exp
  work_schedules_aggregate: work_schedule_aggregate_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "clerk_user_id"
  """
  users_clerk_user_id_key

  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey

  """
  unique or primary key constraint on columns "username"
  """
  users_username_key
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  billing_event_logs: billing_event_log_arr_rel_insert_input

  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz
  deactivated_at: timestamptz
  deactivated_by: String

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String
  is_active: Boolean

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean
  leaves: leave_arr_rel_insert_input
  manager: users_obj_rel_insert_input

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String
  notes_written: notes_arr_rel_insert_input
  payrollsByBackupConsultantUserId: payrolls_arr_rel_insert_input
  payrollsByManagerUserId: payrolls_arr_rel_insert_input
  payrollsByPrimaryConsultantUserId: payrolls_arr_rel_insert_input

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  staffByManager: users_arr_rel_insert_input

  """Timestamp when the user was last updated"""
  updated_at: timestamptz
  user_roles: user_roles_arr_rel_insert_input

  """User's unique username for login"""
  username: String
  usersManager: users_arr_rel_insert_input
  work_schedules: work_schedule_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz
  deactivated_at: timestamptz
  deactivated_by: String

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  """External identifier from Clerk authentication service"""
  clerk_user_id: order_by

  """Timestamp when the user was created"""
  created_at: order_by
  deactivated_at: order_by
  deactivated_by: order_by

  """User's email address (unique)"""
  email: order_by

  """Unique identifier for the user"""
  id: order_by

  """URL to the user's profile image"""
  image: order_by

  """Reference to the user's manager"""
  manager_id: order_by

  """User's full name"""
  name: order_by

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: order_by

  """Timestamp when the user was last updated"""
  updated_at: order_by

  """User's unique username for login"""
  username: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz
  deactivated_at: timestamptz
  deactivated_by: String

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  """External identifier from Clerk authentication service"""
  clerk_user_id: order_by

  """Timestamp when the user was created"""
  created_at: order_by
  deactivated_at: order_by
  deactivated_by: order_by

  """User's email address (unique)"""
  email: order_by

  """Unique identifier for the user"""
  id: order_by

  """URL to the user's profile image"""
  image: order_by

  """Reference to the user's manager"""
  manager_id: order_by

  """User's full name"""
  name: order_by

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: order_by

  """Timestamp when the user was last updated"""
  updated_at: order_by

  """User's unique username for login"""
  username: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  billing_event_logs_aggregate: billing_event_log_aggregate_order_by
  clerk_user_id: order_by
  created_at: order_by
  deactivated_at: order_by
  deactivated_by: order_by
  email: order_by
  id: order_by
  image: order_by
  is_active: order_by
  is_staff: order_by
  leaves_aggregate: leave_aggregate_order_by
  manager: users_order_by
  manager_id: order_by
  name: order_by
  notes_written_aggregate: notes_aggregate_order_by
  payrollsByBackupConsultantUserId_aggregate: payrolls_aggregate_order_by
  payrollsByManagerUserId_aggregate: payrolls_aggregate_order_by
  payrollsByPrimaryConsultantUserId_aggregate: payrolls_aggregate_order_by
  role: order_by
  staffByManager_aggregate: users_aggregate_order_by
  updated_at: order_by
  user_roles_aggregate: user_roles_aggregate_order_by
  username: order_by
  usersManager_aggregate: users_aggregate_order_by
  work_schedules_aggregate: work_schedule_aggregate_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  """Unique identifier for the user"""
  id: uuid!
}

"""
columns and relationships of "users_role_backup"
"""
type users_role_backup {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
aggregated selection of "users_role_backup"
"""
type users_role_backup_aggregate {
  aggregate: users_role_backup_aggregate_fields
  nodes: [users_role_backup!]!
}

"""
aggregate fields of "users_role_backup"
"""
type users_role_backup_aggregate_fields {
  count(columns: [users_role_backup_select_column!], distinct: Boolean): Int!
  max: users_role_backup_max_fields
  min: users_role_backup_min_fields
}

"""
Boolean expression to filter rows from the table "users_role_backup". All fields are combined with a logical 'AND'.
"""
input users_role_backup_bool_exp {
  _and: [users_role_backup_bool_exp!]
  _not: users_role_backup_bool_exp
  _or: [users_role_backup_bool_exp!]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  role: user_role_comparison_exp
}

"""
input type for inserting data into table "users_role_backup"
"""
input users_role_backup_insert_input {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""aggregate max on columns"""
type users_role_backup_max_fields {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""aggregate min on columns"""
type users_role_backup_min_fields {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
response of any mutation on the table "users_role_backup"
"""
type users_role_backup_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users_role_backup!]!
}

"""Ordering options when selecting data from "users_role_backup"."""
input users_role_backup_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  role: order_by
}

"""
select columns of table "users_role_backup"
"""
enum users_role_backup_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  role
}

"""
input type for updating data in table "users_role_backup"
"""
input users_role_backup_set_input {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
Streaming cursor of the table "users_role_backup"
"""
input users_role_backup_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_role_backup_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_role_backup_stream_cursor_value_input {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

input users_role_backup_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_role_backup_set_input

  """filter the rows which have to be updated"""
  where: users_role_backup_bool_exp!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  clerk_user_id

  """column name"""
  created_at

  """column name"""
  deactivated_at

  """column name"""
  deactivated_by

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  is_active

  """column name"""
  is_staff

  """column name"""
  manager_id

  """column name"""
  name

  """column name"""
  role

  """column name"""
  updated_at

  """column name"""
  username
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_staff
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_staff
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz
  deactivated_at: timestamptz
  deactivated_by: String

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String
  is_active: Boolean

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  """External identifier from Clerk authentication service"""
  clerk_user_id: String

  """Timestamp when the user was created"""
  created_at: timestamptz
  deactivated_at: timestamptz
  deactivated_by: String

  """User's email address (unique)"""
  email: String

  """Unique identifier for the user"""
  id: uuid

  """URL to the user's profile image"""
  image: String
  is_active: Boolean

  """Whether the user is a staff member (vs. external user)"""
  is_staff: Boolean

  """Reference to the user's manager"""
  manager_id: uuid

  """User's full name"""
  name: String

  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role

  """Timestamp when the user was last updated"""
  updated_at: timestamptz

  """User's unique username for login"""
  username: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  clerk_user_id

  """column name"""
  created_at

  """column name"""
  deactivated_at

  """column name"""
  deactivated_by

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  is_active

  """column name"""
  is_staff

  """column name"""
  manager_id

  """column name"""
  name

  """column name"""
  role

  """column name"""
  updated_at

  """column name"""
  username
}

input users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "work_schedule"
"""
type work_schedule {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid!

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """An object relationship"""
  user: users!

  """Reference to the user this schedule belongs to"""
  user_id: uuid!

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String!

  """Number of hours worked on this day"""
  work_hours: numeric!

  """An object relationship"""
  work_schedule_user: users!
}

"""
aggregated selection of "work_schedule"
"""
type work_schedule_aggregate {
  aggregate: work_schedule_aggregate_fields
  nodes: [work_schedule!]!
}

input work_schedule_aggregate_bool_exp {
  count: work_schedule_aggregate_bool_exp_count
}

input work_schedule_aggregate_bool_exp_count {
  arguments: [work_schedule_select_column!]
  distinct: Boolean
  filter: work_schedule_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "work_schedule"
"""
type work_schedule_aggregate_fields {
  avg: work_schedule_avg_fields
  count(columns: [work_schedule_select_column!], distinct: Boolean): Int!
  max: work_schedule_max_fields
  min: work_schedule_min_fields
  stddev: work_schedule_stddev_fields
  stddev_pop: work_schedule_stddev_pop_fields
  stddev_samp: work_schedule_stddev_samp_fields
  sum: work_schedule_sum_fields
  var_pop: work_schedule_var_pop_fields
  var_samp: work_schedule_var_samp_fields
  variance: work_schedule_variance_fields
}

"""
order by aggregate values of table "work_schedule"
"""
input work_schedule_aggregate_order_by {
  avg: work_schedule_avg_order_by
  count: order_by
  max: work_schedule_max_order_by
  min: work_schedule_min_order_by
  stddev: work_schedule_stddev_order_by
  stddev_pop: work_schedule_stddev_pop_order_by
  stddev_samp: work_schedule_stddev_samp_order_by
  sum: work_schedule_sum_order_by
  var_pop: work_schedule_var_pop_order_by
  var_samp: work_schedule_var_samp_order_by
  variance: work_schedule_variance_order_by
}

"""
input type for inserting array relation for remote table "work_schedule"
"""
input work_schedule_arr_rel_insert_input {
  data: [work_schedule_insert_input!]!

  """upsert condition"""
  on_conflict: work_schedule_on_conflict
}

"""aggregate avg on columns"""
type work_schedule_avg_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by avg() on columns of table "work_schedule"
"""
input work_schedule_avg_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
Boolean expression to filter rows from the table "work_schedule". All fields are combined with a logical 'AND'.
"""
input work_schedule_bool_exp {
  _and: [work_schedule_bool_exp!]
  _not: work_schedule_bool_exp
  _or: [work_schedule_bool_exp!]
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamp_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  work_day: String_comparison_exp
  work_hours: numeric_comparison_exp
  work_schedule_user: users_bool_exp
}

"""
unique or primary key constraints on table "work_schedule"
"""
enum work_schedule_constraint {
  """
  unique or primary key constraint on columns "user_id", "work_day"
  """
  unique_user_work_day

  """
  unique or primary key constraint on columns "id"
  """
  work_schedule_pkey
}

"""
input type for incrementing numeric columns in table "work_schedule"
"""
input work_schedule_inc_input {
  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
input type for inserting data into table "work_schedule"
"""
input work_schedule_insert_input {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp
  user: users_obj_rel_insert_input

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
  work_schedule_user: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type work_schedule_max_fields {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
order by max() on columns of table "work_schedule"
"""
input work_schedule_max_order_by {
  """Timestamp when the schedule entry was created"""
  created_at: order_by

  """Unique identifier for the work schedule entry"""
  id: order_by

  """Timestamp when the schedule entry was last updated"""
  updated_at: order_by

  """Reference to the user this schedule belongs to"""
  user_id: order_by

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: order_by

  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate min on columns"""
type work_schedule_min_fields {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
order by min() on columns of table "work_schedule"
"""
input work_schedule_min_order_by {
  """Timestamp when the schedule entry was created"""
  created_at: order_by

  """Unique identifier for the work schedule entry"""
  id: order_by

  """Timestamp when the schedule entry was last updated"""
  updated_at: order_by

  """Reference to the user this schedule belongs to"""
  user_id: order_by

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: order_by

  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
response of any mutation on the table "work_schedule"
"""
type work_schedule_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [work_schedule!]!
}

"""
on_conflict condition type for table "work_schedule"
"""
input work_schedule_on_conflict {
  constraint: work_schedule_constraint!
  update_columns: [work_schedule_update_column!]! = []
  where: work_schedule_bool_exp
}

"""Ordering options when selecting data from "work_schedule"."""
input work_schedule_order_by {
  created_at: order_by
  id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  work_day: order_by
  work_hours: order_by
  work_schedule_user: users_order_by
}

"""primary key columns input for table: work_schedule"""
input work_schedule_pk_columns_input {
  """Unique identifier for the work schedule entry"""
  id: uuid!
}

"""
select columns of table "work_schedule"
"""
enum work_schedule_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  work_day

  """column name"""
  work_hours
}

"""
input type for updating data in table "work_schedule"
"""
input work_schedule_set_input {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""aggregate stddev on columns"""
type work_schedule_stddev_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by stddev() on columns of table "work_schedule"
"""
input work_schedule_stddev_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate stddev_pop on columns"""
type work_schedule_stddev_pop_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by stddev_pop() on columns of table "work_schedule"
"""
input work_schedule_stddev_pop_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate stddev_samp on columns"""
type work_schedule_stddev_samp_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by stddev_samp() on columns of table "work_schedule"
"""
input work_schedule_stddev_samp_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
Streaming cursor of the table "work_schedule"
"""
input work_schedule_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: work_schedule_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input work_schedule_stream_cursor_value_input {
  """Timestamp when the schedule entry was created"""
  created_at: timestamp

  """Unique identifier for the work schedule entry"""
  id: uuid

  """Timestamp when the schedule entry was last updated"""
  updated_at: timestamp

  """Reference to the user this schedule belongs to"""
  user_id: uuid

  """Day of the week (Monday, Tuesday, etc.)"""
  work_day: String

  """Number of hours worked on this day"""
  work_hours: numeric
}

"""aggregate sum on columns"""
type work_schedule_sum_fields {
  """Number of hours worked on this day"""
  work_hours: numeric
}

"""
order by sum() on columns of table "work_schedule"
"""
input work_schedule_sum_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""
update columns of table "work_schedule"
"""
enum work_schedule_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  work_day

  """column name"""
  work_hours
}

input work_schedule_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: work_schedule_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: work_schedule_set_input

  """filter the rows which have to be updated"""
  where: work_schedule_bool_exp!
}

"""aggregate var_pop on columns"""
type work_schedule_var_pop_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by var_pop() on columns of table "work_schedule"
"""
input work_schedule_var_pop_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate var_samp on columns"""
type work_schedule_var_samp_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by var_samp() on columns of table "work_schedule"
"""
input work_schedule_var_samp_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}

"""aggregate variance on columns"""
type work_schedule_variance_fields {
  """Number of hours worked on this day"""
  work_hours: Float
}

"""
order by variance() on columns of table "work_schedule"
"""
input work_schedule_variance_order_by {
  """Number of hours worked on this day"""
  work_hours: order_by
}