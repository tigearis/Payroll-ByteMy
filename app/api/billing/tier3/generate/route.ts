import { gql } from '@apollo/client';
import { NextRequest, NextResponse } from 'next/server';
import { serverApolloClient } from '@/lib/apollo/unified-client';
import { withAuth } from '@/lib/auth/api-auth';
import { logger, DataClassification } from "@/lib/logging/enterprise-logger";

interface GenerateTier3BillingRequest {
  clientId: string;
  billingMonth: string; // YYYY-MM-DD format (first day of month)
  generatedBy: string;
}

interface GenerateTier3BillingResponse {
  success: boolean;
  tier: number;
  clientId: string;
  billingMonth: string;
  itemsCreated: number;
  totalAmount: number;
  message: string;
  error?: string;
}

/**
 * Generate Tier 3 Billing (Monthly Client Level)
 * Generates monthly recurring services billing when all payroll dates are completed
 */
async function POST(request: NextRequest) {
  try {
    const body = await request.json() as GenerateTier3BillingRequest;
    const { clientId, billingMonth, generatedBy } = body;

    if (!clientId) {
      return NextResponse.json(
        { success: false, error: 'Client ID is required' },
        { status: 400 }
      );
    }

    if (!billingMonth) {
      return NextResponse.json(
        { success: false, error: 'Billing month is required' },
        { status: 400 }
      );
    }

    if (!generatedBy) {
      return NextResponse.json(
        { success: false, error: 'Generated By user ID is required' },
        { status: 400 }
      );
    }

    const client = serverApolloClient;

    // First, verify the client exists
    const CHECK_CLIENT = gql`
      query CheckClient($id: uuid!) {
        clientsByPk(id: $id) {
          id
          name
          active
        }
      }
    `;

    const { data: clientData } = await client.query({
      query: CHECK_CLIENT,
      variables: { id: clientId },
      fetchPolicy: 'network-only'
    });

    if (!clientData?.clientsByPk) {
      return NextResponse.json(
        { success: false, error: 'Client not found' },
        { status: 404 }
      );
    }

    const clientInfo = clientData.clientsByPk;

    // Check monthly billing completion status
    const CHECK_MONTHLY_COMPLETION = gql`
      query CheckMonthlyCompletion($clientId: uuid!, $billingMonth: date!) {
        monthlyBillingCompletion(
          where: {
            clientId: { _eq: $clientId }
            billingMonth: { _eq: $billingMonth }
          }
        ) {
          id
          status
          tier3BillingGenerated
          autoBillingEnabled
          completedPayrolls
          totalPayrolls
          completedPayrollDates
          totalPayrollDates
        }
      }
    `;

    const { data: completionData } = await client.query({
      query: CHECK_MONTHLY_COMPLETION,
      variables: { clientId, billingMonth },
      fetchPolicy: 'network-only'
    });

    const billingCompletion = completionData?.monthlyBillingCompletion?.[0];

    if (!billingCompletion || billingCompletion.status !== 'ready_to_bill') {
      return NextResponse.json(
        { success: false, error: 'Monthly billing not ready - all payroll dates must be completed' },
        { status: 400 }
      );
    }

    // Get tier 3 services (monthly client services)
    const GET_TIER3_SERVICES = gql`
      query GetTier3Services($clientId: uuid!) {
        clientServiceAgreements(
          where: {
            clientId: { _eq: $clientId }
            isActive: { _eq: true }
            isEnabled: { _eq: true }
            service: { 
              billingTier: { _eq: "client_monthly" }
              isActive: { _eq: true }
            }
            billingFrequency: { _eq: "monthly" }
          }
        ) {
          id
          serviceId
          customRate
          billingFrequency
          serviceConfiguration
          service {
            id
            name
            description
            billingUnit
            defaultRate
            billingTier
            tierPriority
          }
        }
      }
    `;

    const { data: servicesData } = await client.query({
      query: GET_TIER3_SERVICES,
      variables: { clientId },
      fetchPolicy: 'network-only'
    });

    const serviceAgreements = servicesData?.clientServiceAgreements || [];
    let itemsCreated = 0;
    let totalAmount = 0;

    // Create billing items for each applicable service
    for (const agreement of serviceAgreements) {
      // Check if billing item already exists for this client + month + service
      const billingMonthStart = new Date(billingMonth);
      const billingMonthEnd = new Date(billingMonthStart.getFullYear(), billingMonthStart.getMonth() + 1, 0);

      const CHECK_EXISTING_BILLING = gql`
        query CheckExistingBilling($clientId: uuid!, $serviceId: uuid!, $monthStart: timestamptz!, $monthEnd: timestamptz!) {
          billingItems(
            where: {
              clientId: { _eq: $clientId }
              serviceId: { _eq: $serviceId }
              payrollId: { _is_null: true }
              payrollDateId: { _is_null: true }
              createdAt: { _gte: $monthStart, _lte: $monthEnd }
              status: { _neq: "draft" }
            }
          ) {
            id
          }
        }
      `;

      const { data: existingData } = await client.query({
        query: CHECK_EXISTING_BILLING,
        variables: { 
          clientId,
          serviceId: agreement.serviceId,
          monthStart: billingMonthStart.toISOString(),
          monthEnd: billingMonthEnd.toISOString()
        },
        fetchPolicy: 'network-only'
      });

      if (existingData?.billingItems?.length > 0) {
        continue; // Skip if already billed
      }

      // Calculate billing details
      const effectiveRate = agreement.customRate || agreement.service.defaultRate || 0;
      
      // Calculate quantity based on billing unit
      let quantity = 1;
      if (agreement.service.billingUnit === 'Per Payroll') {
        quantity = billingCompletion.completedPayrolls || 1;
      } else if (agreement.service.billingUnit === 'Per Employee') {
        // Get average employee count for this month
        const GET_EMPLOYEE_COUNT = gql`
          query GetEmployeeCount($clientId: uuid!, $billingMonth: date!) {
            payrolls(
              where: {
                clientId: { _eq: $clientId }
                payrollDates: {
                  adjustedEftDate: { _gte: $billingMonth }
                }
              }
            ) {
              employeeCount
            }
          }
        `;

        const { data: employeeData } = await client.query({
          query: GET_EMPLOYEE_COUNT,
          variables: { clientId, billingMonth },
          fetchPolicy: 'network-only'
        });

        if (employeeData?.payrolls?.length > 0) {
          const avgEmployees = employeeData.payrolls.reduce((sum: number, p: any) => sum + (p.employeeCount || 0), 0) / employeeData.payrolls.length;
          quantity = Math.ceil(avgEmployees);
        }
      }

      const itemAmount = quantity * effectiveRate;

      // Create billing item
      const CREATE_BILLING_ITEM = gql`
        mutation CreateBillingItem($input: BillingItemsInsertInput!) {
          insertBillingItemsOne(object: $input) {
            id
            description
            totalAmount
          }
        }
      `;

      const monthYear = new Date(billingMonth).toLocaleDateString('en-AU', { month: 'short', year: 'numeric' });
      const description = `${agreement.service.name} - ${clientInfo.name} (${monthYear})`;

      try {
        await client.mutate({
          mutation: CREATE_BILLING_ITEM,
          variables: {
            input: {
              clientId,
              serviceId: agreement.serviceId,
              serviceName: agreement.service.name,
              description,
              quantity,
              unitPrice: effectiveRate,
              totalAmount: itemAmount,
              amount: itemAmount,
              staffUserId: generatedBy,
              status: 'confirmed'
            }
          }
        });

        itemsCreated++;
        totalAmount += itemAmount;
      } catch (error) {
        logger.error('Failed to create billing item', {
          namespace: 'billing_tier3_api',
          operation: 'create_billing_item',
          classification: DataClassification.CONFIDENTIAL,
          error: error instanceof Error ? error.message : 'Unknown error',
          metadata: {
            clientId,
            serviceId: agreement.serviceId,
            serviceName: agreement.service.name,
            errorName: error instanceof Error ? error.name : 'UnknownError',
            timestamp: new Date().toISOString()
          }
        });
      }
    }

    // Update monthly billing completion status to billed
    const UPDATE_MONTHLY_COMPLETION = gql`
      mutation UpdateMonthlyCompletion($clientId: uuid!, $billingMonth: date!) {
        updateMonthlyBillingCompletion(
          where: {
            clientId: { _eq: $clientId }
            billingMonth: { _eq: $billingMonth }
          }
          _set: {
            status: "billed"
            tier3BillingGenerated: true
            billingGeneratedAt: "now()"
          }
        ) {
          affectedRows
        }
      }
    `;

    await client.mutate({
      mutation: UPDATE_MONTHLY_COMPLETION,
      variables: { clientId, billingMonth }
    });

    // Log the billing generation event
    const LOG_EVENT = gql`
      mutation LogBillingEvent($input: BillingEventLogInsertInput!) {
        insertBillingEventLogOne(object: $input) {
          id
        }
      }
    `;

    await client.mutate({
      mutation: LOG_EVENT,
      variables: {
        input: {
          eventType: 'tier3_billing_generated',
          message: `Generated ${itemsCreated} tier 3 billing items for client ${clientId} (${billingMonth}, total: $${totalAmount})`,
          createdBy: generatedBy
        }
      }
    });

    const result: GenerateTier3BillingResponse = {
      success: true,
      tier: 3,
      clientId,
      billingMonth,
      itemsCreated,
      totalAmount,
      message: 'Tier 3 billing items generated successfully'
    };

    return NextResponse.json(result);

  } catch (error) {
    logger.error('Error generating tier 3 billing', {
      namespace: 'billing_tier3_api',
      operation: 'generate_tier3_billing',
      classification: DataClassification.CONFIDENTIAL,
      error: error instanceof Error ? error.message : 'Unknown error',
      metadata: {
        errorName: error instanceof Error ? error.name : 'UnknownError',
        timestamp: new Date().toISOString()
      }
    });
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export { POST };
export default withAuth(POST);