# Payroll Mutations

mutation CreatePayroll($object: payrolls_insert_input!) {
  insertPayroll(object: $object) {
    id
    name
    clientId
    cycleId
    dateTypeId
    primaryConsultantUserId
    employeeCount
  }
}

mutation UpdatePayroll($id: uuid!, $set: payrolls_set_input!) {
  updatePayroll(pk_columns: { id: $id }, _set: $set) {
    id
    name
    clientId
    cycleId
    dateTypeId
    primaryConsultantUserId
    employeeCount
  }
}

mutation DeletePayroll($id: uuid!) {
  deletePayroll(id: $id) {
    id
    name
  }
}

# Migrated from hooks/use-payroll-creation.ts

# Note: These mutations were extracted from hooks/use-payroll-creation.ts
# but the field names and operations don't match the current Hasura schema.
# They need to be updated to match the actual schema or use existing operations.

# mutation CreatePayrollExtracted(
#   $name: String!
#   $clientId: uuid!
#   $cycleId: uuid!
#   $primaryConsultantId: uuid!
#   $managerId: uuid!
#   $processingDaysBeforeEft: Int!
# ) {
#   insertPayrolls(
#     objects: [{
#       name: $name
#       clientId: $clientId
#       cycleId: $cycleId
#       primaryConsultantUserId: $primaryConsultantId
#       managerUserId: $managerId
#       processingDaysBeforeEft: $processingDaysBeforeEft
#     }]
#   ) {
#     returning {
#       id
#       name
#       clientId
#       cycleId
#       createdAt
#     }
#   }
# }

# Note: generate_payroll_dates appears to be a custom function
# that may need to be implemented as a Hasura action or custom function

mutation UpdatePayrollStatus($id: uuid!, $status: payroll_status!) {
  updatePayroll(pk_columns: { id: $id }, _set: { status: $status }) {
    id
    name
  }
}

mutation UpdatePayrollDateNotes($id: uuid!, $notes: String) {
  updatePayrollDate(pk_columns: { id: $id }, _set: { notes: $notes }) {
    id
    notes
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
  }
}

# Migrated from inline operations - Priority 1 fixes

# Note: These mutations need to be implemented as Hasura actions or custom functions
# mutation GeneratePayrollDates(
#   $payrollId: uuid!
#   $startDate: date!
#   $endDate: date!
# ) {
#   generate_payroll_dates(
#     p_payroll_id: $payrollId
#     p_start_date: $startDate
#     p_end_date: $endDate
#   ) {
#     id
#     original_eft_date
#     adjusted_eft_date
#     processing_date
#     notes
#   }
# }

mutation DeletePayrollDates($payrollId: uuid!) {
  deletePayrollDates(where: { payrollId: { _eq: $payrollId } }) {
    affected_rows
  }
}

# Payroll operations migrated from app/api/signed/payroll-operations/route.ts

mutation ProcessPayrollBatch($payrollIds: [uuid!]!, $processedBy: String!) {
  updatePayrolls(
    where: { id: { _in: $payrollIds } }
    _set: {
      status: "Implementation"
      updatedAt: "now()"
    }
  ) {
    affected_rows
    returning {
      id
      name
      status
      updatedAt
    }
  }
}

mutation ApprovePayrollBatch($payrollIds: [uuid!]!, $approvedBy: String!) {
  updatePayrolls(
    where: { id: { _in: $payrollIds } }
    _set: {
      status: "Approved"
      updatedAt: "now()"
    }
  ) {
    affected_rows
    returning {
      id
      name
      status
      updatedAt
    }
  }
}

# Payroll deletion and archiving operations (missing from current schema)

mutation ArchivePayroll($id: uuid!, $archivedBy: String!) {
  updatePayroll(
    pk_columns: { id: $id }
    _set: {
      status: "Archived"
      supersededDate: "now()"
      updatedAt: "now()"
    }
  ) {
    id
    name
    status
    supersededDate
  }
}

mutation DeletePayrollSoft($id: uuid!, $deletedBy: String!) {
  updatePayroll(
    pk_columns: { id: $id }
    _set: {
      status: "Deleted"
      supersededDate: "now()"
      updatedAt: "now()"
    }
  ) {
    id
    name
    status
    supersededDate
  }
}

# Date regeneration mutation migrated from app/api/developer/regenerate-single-dates/route.ts

mutation RegeneratePayrollDates(
  $payrollId: uuid!
  $startDate: date!
  $endDate: date!
) {
  deletePayrollDates(where: { payrollId: { _eq: $payrollId } }) {
    affected_rows
  }
  # Note: Additional regeneration logic would need to be implemented
  # as a Hasura action or custom function
}
