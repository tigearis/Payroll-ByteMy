import { serverApolloClient } from '@/lib/apollo/unified-client';
import { gql } from '@apollo/client';

/**
 * Tier 1 Immediate Billing Engine
 * Implements outcome-based billing generation from payroll completion metrics
 */

// Types for Tier 1 billing system
export interface PayrollCompletionMetrics {
  payrollDateId: string;
  completedBy: string;
  completedAt: string;
  
  // Core deliverables
  payslipsProcessed: number;
  employeesProcessed: number;
  
  // Complexity indicators
  newStarters: number;
  terminations: number;
  leaveCalculations: number;
  bonusPayments: number;
  taxAdjustments: number;
  
  // Additional services
  superContributions: number;
  workersCompClaims: number;
  garnishmentOrders: number;
  
  // Statutory services
  paygSummaries?: number;
  fbtCalculations?: number;
  
  // Quality metrics
  exceptionsHandled: number;
  correctionsRequired: number;
  clientCommunications: number;
  
  generationNotes?: string;
}

export interface GeneratedBillingItem {
  id: string;
  payrollId: string;
  payrollDateId: string;
  clientId: string;
  serviceId?: string;
  
  serviceCode: string;
  serviceName: string;
  description: string;
  category: string;
  
  quantity: number;
  unitPrice: number;
  totalAmount: number;
  currency: string;
  
  autoGenerated: boolean;
  generatedFrom: string;
  generatedAt: Date;
  generatedBy: string;
  
  status: 'draft' | 'approved' | 'pending_review';
  requiresApproval: boolean;
  approvalLevel: 'auto' | 'review' | 'manager' | 'admin';
  
  rateJustification: string;
  billingTier: string;
}

export interface BillingGenerationResult {
  success: boolean;
  itemsCreated: number;
  totalAmount: number;
  items: GeneratedBillingItem[];
  errors?: string[];
  warnings?: string[];
}

// Service rate mappings from Tier 1 document
const SERVICE_CONFIGURATIONS = {
  PAYSLIP_STD: {
    code: 'PAYSLIP_STD',
    name: 'Standard Payslip Processing',
    defaultRate: 2.50,
    unit: 'per_payslip',
    category: 'standard',
    approvalLevel: 'auto',
    description: 'Processing of regular employee payslips'
  },
  NEW_STARTER: {
    code: 'NEW_STARTER',
    name: 'New Starter Setup',
    defaultRate: 25.00,
    unit: 'per_employee',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Complete setup for new employees'
  },
  TERMINATION: {
    code: 'TERMINATION',
    name: 'Employee Termination Processing',
    defaultRate: 35.00,
    unit: 'per_employee',
    category: 'premium',
    approvalLevel: 'manager',
    description: 'Complete termination processing including final pays'
  },
  LEAVE_CALC: {
    code: 'LEAVE_CALC',
    name: 'Leave Calculations',
    defaultRate: 5.00,
    unit: 'per_calculation',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of leave entitlements and calculations'
  },
  BONUS_PROC: {
    code: 'BONUS_PROC',
    name: 'Bonus Processing',
    defaultRate: 8.00,
    unit: 'per_payment',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of employee bonuses and incentive payments'
  },
  TAX_ADJ: {
    code: 'TAX_ADJ',
    name: 'Tax Adjustments',
    defaultRate: 12.00,
    unit: 'per_adjustment',
    category: 'premium',
    approvalLevel: 'manager',
    description: 'Processing of complex tax adjustments and corrections'
  },
  SUPER_PROC: {
    code: 'SUPER_PROC',
    name: 'Superannuation Processing',
    defaultRate: 1.50,
    unit: 'per_employee',
    category: 'standard',
    approvalLevel: 'auto',
    description: 'Processing of superannuation contributions'
  },
  PAYG_SUMMARY: {
    code: 'PAYG_SUMMARY',
    name: 'PAYG Payment Summary Generation',
    defaultRate: 4.50,
    unit: 'per_employee',
    category: 'statutory',
    approvalLevel: 'review',
    description: 'Annual PAYG payment summary generation'
  },
  FBT_CALC: {
    code: 'FBT_CALC',
    name: 'FBT Calculations',
    defaultRate: 25.00,
    unit: 'per_employee',
    category: 'statutory',
    approvalLevel: 'manager',
    description: 'Fringe Benefits Tax calculations and reporting'
  },
  WORKERS_COMP: {
    code: 'WORKERS_COMP',
    name: 'Workers Compensation Claims',
    defaultRate: 15.00,
    unit: 'per_claim',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of workers compensation claims'
  },
  GARNISHMENT: {
    code: 'GARNISHMENT',
    name: 'Garnishment Orders',
    defaultRate: 10.00,
    unit: 'per_order',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of garnishment orders and deductions'
  }
};

export class Tier1BillingEngine {
  /**
   * Generate Tier 1 billing items from payroll completion metrics
   */
  async generateBillingFromMetrics(
    payrollDateId: string,
    metrics: PayrollCompletionMetrics,
    completedBy: string
  ): Promise<BillingGenerationResult> {
    
    try {
      console.log('Starting Tier 1 billing generation for payroll date:', payrollDateId);
      
      // 1. Get payroll information
      const payrollInfo = await this.getPayrollInfo(payrollDateId);
      if (!payrollInfo) {
        throw new Error('Payroll date not found');
      }

      console.log('Found payroll info:', payrollInfo);

      // 2. Get client service agreements (base rates)
      const clientAgreements = await this.getClientServiceAgreements(payrollInfo.clientId);
      console.log('Client agreements found:', clientAgreements?.length || 0);

      // 3. Get payroll-specific overrides (if any)
      const payrollOverrides = await this.getPayrollServiceAgreements(payrollInfo.payrollId);
      console.log('Payroll overrides found:', payrollOverrides ? 'Yes' : 'No');

      // 4. Generate billing items for each deliverable type
      const billingItems: GeneratedBillingItem[] = [];
      const errors: string[] = [];
      const warnings: string[] = [];

      // Map metrics to service billing
      const serviceMapping = [
        { metric: 'payslipsProcessed', serviceCode: 'PAYSLIP_STD', quantity: metrics.payslipsProcessed },
        { metric: 'newStarters', serviceCode: 'NEW_STARTER', quantity: metrics.newStarters },
        { metric: 'terminations', serviceCode: 'TERMINATION', quantity: metrics.terminations },
        { metric: 'leaveCalculations', serviceCode: 'LEAVE_CALC', quantity: metrics.leaveCalculations },
        { metric: 'bonusPayments', serviceCode: 'BONUS_PROC', quantity: metrics.bonusPayments },
        { metric: 'taxAdjustments', serviceCode: 'TAX_ADJ', quantity: metrics.taxAdjustments },
        { metric: 'superContributions', serviceCode: 'SUPER_PROC', quantity: metrics.superContributions },
        { metric: 'workersCompClaims', serviceCode: 'WORKERS_COMP', quantity: metrics.workersCompClaims },
        { metric: 'garnishmentOrders', serviceCode: 'GARNISHMENT', quantity: metrics.garnishmentOrders },
      ];

      // Add statutory services if present
      if (metrics.paygSummaries && metrics.paygSummaries > 0) {
        serviceMapping.push({ metric: 'paygSummaries', serviceCode: 'PAYG_SUMMARY', quantity: metrics.paygSummaries });
      }
      
      if (metrics.fbtCalculations && metrics.fbtCalculations > 0) {
        serviceMapping.push({ metric: 'fbtCalculations', serviceCode: 'FBT_CALC', quantity: metrics.fbtCalculations });
      }

      // Generate billing for each service with quantity > 0
      for (const mapping of serviceMapping) {
        if (mapping.quantity > 0) {
          try {
            const billingItem = await this.generateServiceBilling(
              mapping.serviceCode,
              mapping.quantity,
              clientAgreements,
              payrollOverrides,
              payrollInfo,
              completedBy,
              metrics
            );
            
            if (billingItem) {
              billingItems.push(billingItem);
              console.log(`Generated billing for ${mapping.serviceCode}: ${mapping.quantity} units @ $${billingItem.unitPrice}`);
            }
          } catch (error: any) {
            errors.push(`Failed to generate billing for ${mapping.serviceCode}: ${error.message}`);
            console.error(`Service billing error for ${mapping.serviceCode}:`, error);
          }
        }
      }

      // 5. Process additional services from payroll overrides
      if (payrollOverrides?.additionalServices) {
        try {
          const additionalItems = await this.generateAdditionalServiceBilling(
            payrollOverrides.additionalServices,
            payrollInfo,
            completedBy
          );
          billingItems.push(...additionalItems);
        } catch (error: any) {
          errors.push(`Failed to generate additional services: ${error.message}`);
        }
      }

      // 6. Insert billing items into database
      const insertedItems = await this.insertBillingItems(billingItems, payrollDateId);
      console.log(`Inserted ${insertedItems.length} billing items into database`);

      // 7. Update completion metrics to mark billing as generated
      await this.markBillingGenerated(payrollDateId, billingItems.length);

      const totalAmount = billingItems.reduce((sum, item) => sum + item.totalAmount, 0);

      console.log('Tier 1 billing generation completed successfully:', {
        itemsCreated: billingItems.length,
        totalAmount,
        errors: errors.length,
        warnings: warnings.length
      });

      return {
        success: true,
        itemsCreated: billingItems.length,
        totalAmount,
        items: insertedItems,
        errors: errors.length > 0 ? errors : undefined,
        warnings: warnings.length > 0 ? warnings : undefined
      };

    } catch (error: any) {
      console.error('Tier 1 billing generation failed:', error);
      return {
        success: false,
        itemsCreated: 0,
        totalAmount: 0,
        items: [],
        errors: [error.message]
      };
    }
  }

  /**
   * Generate billing item for a specific service
   */
  private generateServiceBilling(
    serviceCode: string,
    quantity: number,
    clientAgreements: any[] | null,
    payrollOverrides: any | null,
    payrollInfo: any,
    completedBy: string,
    metrics: PayrollCompletionMetrics
  ): GeneratedBillingItem {
    
    // Get service configuration
    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    if (!serviceConfig) {
      throw new Error(`Service configuration not found for: ${serviceCode}`);
    }

    // Determine effective rate (hierarchy: payroll override > client agreement > default)
    let effectiveRate = serviceConfig.defaultRate;
    let rateSource = 'default';

    // Check client agreement for custom rate
    const clientAgreement = clientAgreements?.find(a => a.serviceCode === serviceCode);
    if (clientAgreement?.customRate && clientAgreement.customRate > 0) {
      effectiveRate = parseFloat(clientAgreement.customRate);
      rateSource = 'client_agreement';
    }

    // Check payroll override
    if (payrollOverrides?.serviceOverrides?.[serviceCode]?.customRate) {
      effectiveRate = parseFloat(payrollOverrides.serviceOverrides[serviceCode].customRate);
      rateSource = 'payroll_override';
    }

    // Apply seasonal multipliers if applicable
    const seasonalRate = this.applySeasonalMultiplier(effectiveRate, serviceCode, new Date());
    if (seasonalRate !== effectiveRate) {
      rateSource += '_seasonal';
      effectiveRate = seasonalRate;
    }

    // Calculate total amount
    const totalAmount = quantity * effectiveRate;

    // Determine approval requirement
    const approvalLevel = this.determineApprovalLevel(
      serviceCode,
      totalAmount,
      clientAgreement?.autoApprovalThresholds
    );

    // Generate unique ID
    const id = this.generateUUID();

    // Generate billing item
    const billingItem: GeneratedBillingItem = {
      id,
      payrollId: payrollInfo.payrollId,
      payrollDateId: payrollInfo.id,
      clientId: payrollInfo.clientId,
      
      serviceCode,
      serviceName: serviceConfig.name,
      description: this.generateServiceDescription(serviceCode, quantity, payrollInfo, metrics),
      category: serviceConfig.category,
      
      quantity,
      unitPrice: effectiveRate,
      totalAmount,
      currency: 'AUD',
      
      autoGenerated: true,
      generatedFrom: 'completion_metrics',
      generatedAt: new Date(),
      generatedBy: completedBy,
      
      status: approvalLevel === 'auto' ? 'approved' : 'draft',
      requiresApproval: approvalLevel !== 'auto',
      approvalLevel,
      
      rateJustification: this.generateRateJustification(serviceCode, effectiveRate, rateSource),
      billingTier: 'tier1'
    };

    return billingItem;
  }

  /**
   * Determine approval level based on service and amount
   */
  private determineApprovalLevel(
    serviceCode: string,
    totalAmount: number,
    clientThresholds?: any
  ): 'auto' | 'review' | 'manager' | 'admin' {
    
    // Get base approval level from service configuration
    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    let baseApproval = serviceConfig?.approvalLevel || 'review';

    // Amount-based escalation
    if (clientThresholds) {
      const thresholds = typeof clientThresholds === 'string' 
        ? JSON.parse(clientThresholds) 
        : clientThresholds;
        
      if (totalAmount > (thresholds.adminThreshold || 2000)) {
        return 'admin';
      }
      if (totalAmount > (thresholds.managerThreshold || 1000)) {
        return baseApproval === 'auto' ? 'review' : 'manager';
      }
      if (totalAmount > (thresholds.reviewThreshold || 500)) {
        return baseApproval === 'auto' ? 'review' : baseApproval;
      }
    }

    return baseApproval as any;
  }

  /**
   * Apply seasonal multipliers (e.g., year-end processing)
   */
  private applySeasonalMultiplier(baseRate: number, serviceCode: string, date: Date): number {
    const month = date.getMonth() + 1; // 1-12
    
    // Year-end processing (June-July in Australia)
    if ((month === 6 || month === 7) && serviceCode === 'PAYG_SUMMARY') {
      return baseRate * 1.0; // No multiplier for standard PAYG
    }
    
    // Complex year-end services get premium
    if ((month === 6 || month === 7) && ['FBT_CALC', 'TAX_ADJ'].includes(serviceCode)) {
      return baseRate * 1.2; // 20% premium
    }

    return baseRate;
  }

  /**
   * Generate descriptive billing item description
   */
  private generateServiceDescription(
    serviceCode: string, 
    quantity: number, 
    payrollInfo: any,
    metrics: PayrollCompletionMetrics
  ): string {
    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    const serviceName = serviceConfig?.name || serviceCode;
    const eftDate = new Date(payrollInfo.adjustedEftDate || payrollInfo.originalEftDate).toLocaleDateString();
    
    let description = `${serviceName} - ${payrollInfo.payrollName} (EFT: ${eftDate})`;
    
    // Add quantity context
    if (quantity === 1) {
      description += ` - 1 ${serviceConfig?.unit?.replace('per_', '') || 'unit'}`;
    } else {
      description += ` - ${quantity} ${serviceConfig?.unit?.replace('per_', '') || 'units'}`;
    }

    // Add complexity notes for high-complexity payrolls
    const complexityIndicators = [];
    if (metrics.exceptionsHandled > 0) complexityIndicators.push(`${metrics.exceptionsHandled} exceptions`);
    if (metrics.correctionsRequired > 0) complexityIndicators.push(`${metrics.correctionsRequired} corrections`);
    if (metrics.clientCommunications > 2) complexityIndicators.push(`${metrics.clientCommunications} client contacts`);
    
    if (complexityIndicators.length > 0) {
      description += ` (${complexityIndicators.join(', ')})`;
    }

    return description;
  }

  /**
   * Generate rate justification text
   */
  private generateRateJustification(serviceCode: string, rate: number, source: string): string {
    const sourceDescriptions = {
      'default': 'Standard service rate',
      'client_agreement': 'Rate per client service agreement',
      'payroll_override': 'Custom rate for this payroll',
      'client_agreement_seasonal': 'Client rate with seasonal adjustment',
      'payroll_override_seasonal': 'Override rate with seasonal adjustment'
    };

    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    return `${sourceDescriptions[source as keyof typeof sourceDescriptions] || source} - $${rate.toFixed(2)} ${serviceConfig?.unit || 'per unit'}`;
  }

  // Database interaction methods
  private async getPayrollInfo(payrollDateId: string) {
    const GET_PAYROLL_INFO = gql`
      query GetPayrollInfo($payrollDateId: uuid!) {
        payrollDates(where: { id: { _eq: $payrollDateId } }) {
          id
          payrollId
          originalEftDate
          adjustedEftDate
          status
          payroll {
            id
            name
            clientId
            client {
              id
              name
            }
          }
        }
      }
    `;

    try {
      const { data } = await serverApolloClient.query({
        query: GET_PAYROLL_INFO,
        variables: { payrollDateId },
        fetchPolicy: 'network-only'
      });

      const payrollDate = data?.payrollDates?.[0];
      if (!payrollDate) return null;

      return {
        id: payrollDate.id,
        payrollId: payrollDate.payrollId,
        payrollName: payrollDate.payroll.name,
        clientId: payrollDate.payroll.clientId,
        clientName: payrollDate.payroll.client.name,
        originalEftDate: payrollDate.originalEftDate,
        adjustedEftDate: payrollDate.adjustedEftDate,
        status: payrollDate.status
      };
    } catch (error) {
      console.error('Error fetching payroll info:', error);
      return null;
    }
  }

  private async getClientServiceAgreements(clientId: string) {
    const GET_CLIENT_AGREEMENTS = gql`
      query GetClientServiceAgreements($clientId: uuid!) {
        clientServiceAgreements(
          where: { 
            clientId: { _eq: $clientId }
            isActive: { _eq: true }
          }
        ) {
          id
          serviceId
          customRate
          billingFrequency
          autoApprovalThresholds
          service {
            id
            name
            serviceCode
            defaultRate
          }
        }
      }
    `;

    try {
      const { data } = await serverApolloClient.query({
        query: GET_CLIENT_AGREEMENTS,
        variables: { clientId },
        fetchPolicy: 'network-only'
      });

      return data?.clientServiceAgreements || [];
    } catch (error) {
      console.error('Error fetching client agreements:', error);
      return [];
    }
  }

  private async getPayrollServiceAgreements(payrollId: string) {
    const GET_PAYROLL_AGREEMENTS = gql`
      query GetPayrollServiceAgreements($payrollId: uuid!) {
        payrollServiceAgreements(where: { payrollId: { _eq: $payrollId } }) {
          id
          serviceOverrides
          additionalServices
          overrideReason
          approvedBy
        }
      }
    `;

    try {
      const { data } = await serverApolloClient.query({
        query: GET_PAYROLL_AGREEMENTS,
        variables: { payrollId },
        fetchPolicy: 'network-only'
      });

      return data?.payrollServiceAgreements?.[0] || null;
    } catch (error) {
      console.error('Error fetching payroll agreements:', error);
      return null;
    }
  }

  private async generateAdditionalServiceBilling(
    additionalServices: any,
    payrollInfo: any,
    completedBy: string
  ): Promise<GeneratedBillingItem[]> {
    const items: GeneratedBillingItem[] = [];
    
    const services = typeof additionalServices === 'string' 
      ? JSON.parse(additionalServices) 
      : additionalServices;

    for (const [serviceCode, serviceData] of Object.entries(services as any)) {
      try {
        const item: GeneratedBillingItem = {
          id: this.generateUUID(),
          payrollId: payrollInfo.payrollId,
          payrollDateId: payrollInfo.id,
          clientId: payrollInfo.clientId,
          
          serviceCode,
          serviceName: serviceData.name || serviceCode,
          description: serviceData.description || `Additional service: ${serviceCode}`,
          category: 'additional',
          
          quantity: serviceData.quantity || 1,
          unitPrice: serviceData.rate || 0,
          totalAmount: (serviceData.quantity || 1) * (serviceData.rate || 0),
          currency: 'AUD',
          
          autoGenerated: true,
          generatedFrom: 'payroll_override',
          generatedAt: new Date(),
          generatedBy: completedBy,
          
          status: 'draft', // Additional services always require approval
          requiresApproval: true,
          approvalLevel: 'manager',
          
          rateJustification: `One-time additional service: ${serviceData.reason || 'No reason provided'}`,
          billingTier: 'tier1'
        };

        items.push(item);
      } catch (error) {
        console.error(`Error generating additional service ${serviceCode}:`, error);
      }
    }

    return items;
  }

  private async insertBillingItems(
    billingItems: GeneratedBillingItem[],
    payrollDateId: string
  ): Promise<GeneratedBillingItem[]> {
    if (billingItems.length === 0) return [];

    const INSERT_BILLING_ITEMS = gql`
      mutation InsertBillingItems($items: [BillingItemsInsertInput!]!) {
        insertBillingItems(objects: $items) {
          returning {
            id
            serviceCode
            serviceName
            quantity
            unitPrice
            totalAmount
            status
            autoGenerated
            createdAt
          }
        }
      }
    `;

    try {
      const insertData = billingItems.map(item => ({
        payrollId: item.payrollId,
        payrollDateId: item.payrollDateId,
        clientId: item.clientId,
        serviceName: item.serviceName,
        description: item.description,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        amount: item.totalAmount,
        totalAmount: item.totalAmount,
        status: item.status,
        serviceCode: item.serviceCode,
        autoGenerated: item.autoGenerated,
        generatedFrom: item.generatedFrom,
        approvalLevel: item.approvalLevel,
        rateJustification: item.rateJustification,
        billingTier: item.billingTier,
        staffUserId: item.generatedBy
      }));

      const { data } = await serverApolloClient.mutate({
        mutation: INSERT_BILLING_ITEMS,
        variables: { items: insertData }
      });

      console.log(`Successfully inserted ${data?.insertBillingItems?.returning?.length || 0} billing items`);
      return billingItems; // Return original items with generated data
    } catch (error) {
      console.error('Error inserting billing items:', error);
      throw error;
    }
  }

  private async markBillingGenerated(payrollDateId: string, itemCount: number): Promise<void> {
    const UPDATE_METRICS = gql`
      mutation UpdateCompletionMetrics($payrollDateId: uuid!) {
        updatePayrollCompletionMetrics(
          where: { payrollDateId: { _eq: $payrollDateId } }
          _set: { 
            billingGenerated: true, 
            billingGeneratedAt: "now()" 
          }
        ) {
          affectedRows
        }
      }
    `;

    try {
      await serverApolloClient.mutate({
        mutation: UPDATE_METRICS,
        variables: { payrollDateId }
      });
      console.log(`Marked payroll date ${payrollDateId} as billing generated`);
    } catch (error) {
      console.error('Error marking billing as generated:', error);
      // Don't throw - this is not critical for the billing process
    }
  }

  private generateUUID(): string {
    return crypto.randomUUID();
  }
}