import { serverApolloClient } from '@/lib/apollo/unified-client';
import { logger } from '@/lib/logging/enterprise-logger';
import {
  GetPayrollInfoForTier1BillingDocument,
  GetClientServiceAgreementsForTier1BillingDocument,
  GetPayrollServiceAgreementsForTier1BillingEngineDocument,
  InsertTier1BillingItemsDocument,
  UpdateTier1CompletionMetricsDocument,
  type GetPayrollInfoForTier1BillingQuery,
  type GetPayrollInfoForTier1BillingQueryVariables,
  type GetClientServiceAgreementsForTier1BillingQuery,
  type GetClientServiceAgreementsForTier1BillingQueryVariables,
  type GetPayrollServiceAgreementsForTier1BillingEngineQuery,
  type GetPayrollServiceAgreementsForTier1BillingEngineQueryVariables,
  type InsertTier1BillingItemsMutation,
  type InsertTier1BillingItemsMutationVariables,
  type UpdateTier1CompletionMetricsMutation,
  type UpdateTier1CompletionMetricsMutationVariables,
} from '@/domains/billing/graphql/generated/graphql';

/**
 * Tier 1 Immediate Billing Engine
 * Implements outcome-based billing generation from payroll completion metrics
 */

// Types for Tier 1 billing system
export interface PayrollCompletionMetrics {
  payrollDateId: string;
  completedBy: string;
  completedAt: string;
  
  // Core deliverables
  payslipsProcessed: number;
  employeesProcessed: number;
  
  // Complexity indicators
  newStarters: number;
  terminations: number;
  leaveCalculations: number;
  bonusPayments: number;
  taxAdjustments: number;
  
  // Additional services
  superContributions: number;
  workersCompClaims: number;
  garnishmentOrders: number;
  
  // Statutory services
  paygSummaries?: number;
  fbtCalculations?: number;
  
  // Quality metrics
  exceptionsHandled: number;
  correctionsRequired: number;
  clientCommunications: number;
  
  generationNotes?: string;
}

export interface GeneratedBillingItem {
  id: string;
  payrollId: string;
  payrollDateId: string;
  clientId: string;
  serviceId?: string;
  
  serviceCode: string;
  serviceName: string;
  description: string;
  category: string;
  
  quantity: number;
  unitPrice: number;
  totalAmount: number;
  currency: string;
  
  autoGenerated: boolean;
  generatedFrom: string;
  generatedAt: Date;
  generatedBy: string;
  
  status: 'draft' | 'approved' | 'pending_review';
  requiresApproval: boolean;
  approvalLevel: 'auto' | 'review' | 'manager' | 'admin';
  
  rateJustification: string;
  billingTier: string;
}

export interface BillingGenerationResult {
  success: boolean;
  itemsCreated: number;
  totalAmount: number;
  items: GeneratedBillingItem[];
  errors?: string[];
  warnings?: string[];
}

// Service rate mappings from Tier 1 document
const SERVICE_CONFIGURATIONS = {
  PAYSLIP_STD: {
    code: 'PAYSLIP_STD',
    name: 'Standard Payslip Processing',
    defaultRate: 2.50,
    unit: 'per_payslip',
    category: 'standard',
    approvalLevel: 'auto',
    description: 'Processing of regular employee payslips'
  },
  NEW_STARTER: {
    code: 'NEW_STARTER',
    name: 'New Starter Setup',
    defaultRate: 25.00,
    unit: 'per_employee',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Complete setup for new employees'
  },
  TERMINATION: {
    code: 'TERMINATION',
    name: 'Employee Termination Processing',
    defaultRate: 35.00,
    unit: 'per_employee',
    category: 'premium',
    approvalLevel: 'manager',
    description: 'Complete termination processing including final pays'
  },
  LEAVE_CALC: {
    code: 'LEAVE_CALC',
    name: 'Leave Calculations',
    defaultRate: 5.00,
    unit: 'per_calculation',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of leave entitlements and calculations'
  },
  BONUS_PROC: {
    code: 'BONUS_PROC',
    name: 'Bonus Processing',
    defaultRate: 8.00,
    unit: 'per_payment',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of employee bonuses and incentive payments'
  },
  TAX_ADJ: {
    code: 'TAX_ADJ',
    name: 'Tax Adjustments',
    defaultRate: 12.00,
    unit: 'per_adjustment',
    category: 'premium',
    approvalLevel: 'manager',
    description: 'Processing of complex tax adjustments and corrections'
  },
  SUPER_PROC: {
    code: 'SUPER_PROC',
    name: 'Superannuation Processing',
    defaultRate: 1.50,
    unit: 'per_employee',
    category: 'standard',
    approvalLevel: 'auto',
    description: 'Processing of superannuation contributions'
  },
  PAYG_SUMMARY: {
    code: 'PAYG_SUMMARY',
    name: 'PAYG Payment Summary Generation',
    defaultRate: 4.50,
    unit: 'per_employee',
    category: 'statutory',
    approvalLevel: 'review',
    description: 'Annual PAYG payment summary generation'
  },
  FBT_CALC: {
    code: 'FBT_CALC',
    name: 'FBT Calculations',
    defaultRate: 25.00,
    unit: 'per_employee',
    category: 'statutory',
    approvalLevel: 'manager',
    description: 'Fringe Benefits Tax calculations and reporting'
  },
  WORKERS_COMP: {
    code: 'WORKERS_COMP',
    name: 'Workers Compensation Claims',
    defaultRate: 15.00,
    unit: 'per_claim',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of workers compensation claims'
  },
  GARNISHMENT: {
    code: 'GARNISHMENT',
    name: 'Garnishment Orders',
    defaultRate: 10.00,
    unit: 'per_order',
    category: 'complex',
    approvalLevel: 'review',
    description: 'Processing of garnishment orders and deductions'
  }
};

export class Tier1BillingEngine {
  /**
   * Generate Tier 1 billing items from payroll completion metrics
   */
  async generateBillingFromMetrics(
    payrollDateId: string,
    metrics: PayrollCompletionMetrics,
    completedBy: string
  ): Promise<BillingGenerationResult> {
    
    try {
      logger.info('Starting Tier 1 billing generation', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'generate_billing_from_metrics',
        metadata: {
          payrollDateId,
          completedBy,
          billingTier: 'tier1',
          payslipsProcessed: metrics.payslipsProcessed,
          employeesProcessed: metrics.employeesProcessed,
        },
      });
      
      // 1. Get payroll information
      const payrollInfo = await this.getPayrollInfo(payrollDateId);
      if (!payrollInfo) {
        logger.error('Payroll date not found during billing generation', {
          namespace: 'billing_domain',
          component: 'tier1_billing_engine',
          action: 'get_payroll_info',
          error: 'Payroll date not found',
          metadata: {
            payrollDateId,
            completedBy,
          },
        });
        throw new Error('Payroll date not found');
      }

      logger.info('Payroll information retrieved successfully', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'get_payroll_info',
        metadata: {
          payrollDateId,
          payrollId: payrollInfo.payrollId,
          clientId: payrollInfo.clientId,
          payrollName: payrollInfo.payrollName,
        },
      });

      // 2. Get client service agreements (base rates)
      const clientAgreements = await this.getClientServiceAgreements(payrollInfo.clientId);
      logger.info('Client service agreements retrieved', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'get_client_service_agreements',
        metadata: {
          clientId: payrollInfo.clientId,
          agreementsCount: clientAgreements?.length || 0,
          hasAgreements: (clientAgreements?.length || 0) > 0,
        },
      });

      // 3. Get payroll-specific overrides (if any)
      const payrollOverrides = await this.getPayrollServiceAgreements(payrollInfo.payrollId);
      logger.info('Payroll service overrides retrieved', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'get_payroll_service_agreements',
        metadata: {
          payrollId: payrollInfo.payrollId,
          hasOverrides: !!payrollOverrides,
          overridesActive: !!payrollOverrides,
        },
      });

      // 4. Generate billing items for each deliverable type
      const billingItems: GeneratedBillingItem[] = [];
      const errors: string[] = [];
      const warnings: string[] = [];

      // Map metrics to service billing
      const serviceMapping = [
        { metric: 'payslipsProcessed', serviceCode: 'PAYSLIP_STD', quantity: metrics.payslipsProcessed },
        { metric: 'newStarters', serviceCode: 'NEW_STARTER', quantity: metrics.newStarters },
        { metric: 'terminations', serviceCode: 'TERMINATION', quantity: metrics.terminations },
        { metric: 'leaveCalculations', serviceCode: 'LEAVE_CALC', quantity: metrics.leaveCalculations },
        { metric: 'bonusPayments', serviceCode: 'BONUS_PROC', quantity: metrics.bonusPayments },
        { metric: 'taxAdjustments', serviceCode: 'TAX_ADJ', quantity: metrics.taxAdjustments },
        { metric: 'superContributions', serviceCode: 'SUPER_PROC', quantity: metrics.superContributions },
        { metric: 'workersCompClaims', serviceCode: 'WORKERS_COMP', quantity: metrics.workersCompClaims },
        { metric: 'garnishmentOrders', serviceCode: 'GARNISHMENT', quantity: metrics.garnishmentOrders },
      ];

      // Add statutory services if present
      if (metrics.paygSummaries && metrics.paygSummaries > 0) {
        serviceMapping.push({ metric: 'paygSummaries', serviceCode: 'PAYG_SUMMARY', quantity: metrics.paygSummaries });
      }
      
      if (metrics.fbtCalculations && metrics.fbtCalculations > 0) {
        serviceMapping.push({ metric: 'fbtCalculations', serviceCode: 'FBT_CALC', quantity: metrics.fbtCalculations });
      }

      // Generate billing for each service with quantity > 0
      for (const mapping of serviceMapping) {
        if (mapping.quantity > 0) {
          try {
            const billingItem = await this.generateServiceBilling(
              mapping.serviceCode,
              mapping.quantity,
              clientAgreements,
              payrollOverrides,
              payrollInfo,
              completedBy,
              metrics
            );
            
            if (billingItem) {
              billingItems.push(billingItem);
              logger.info('Service billing item generated successfully', {
                namespace: 'billing_domain',
                component: 'tier1_billing_engine',
                action: 'generate_service_billing',
                metadata: {
                  serviceCode: mapping.serviceCode,
                  quantity: mapping.quantity,
                  unitPrice: billingItem.unitPrice,
                  totalAmount: billingItem.unitPrice * mapping.quantity,
                  payrollDateId,
                  clientId: payrollInfo.clientId,
                },
              });
            }
          } catch (error: any) {
            errors.push(`Failed to generate billing for ${mapping.serviceCode}: ${error.message}`);
            logger.error('Service billing generation failed', {
              namespace: 'billing_domain',
              component: 'tier1_billing_engine',
              action: 'generate_service_billing',
              error: error.message,
              metadata: {
                serviceCode: mapping.serviceCode,
                quantity: mapping.quantity,
                payrollDateId,
                clientId: payrollInfo.clientId,
                errorType: 'service_billing_error',
              },
            });
          }
        }
      }

      // 5. Process additional services from payroll overrides
      if (payrollOverrides?.serviceConfiguration) {
        try {
          const additionalItems = await this.generateAdditionalServiceBilling(
            payrollOverrides.serviceConfiguration,
            payrollInfo,
            completedBy
          );
          billingItems.push(...additionalItems);
        } catch (error: any) {
          errors.push(`Failed to generate additional services: ${error.message}`);
        }
      }

      // 6. Insert billing items into database
      const insertedItems = await this.insertBillingItems(billingItems, payrollDateId);
      logger.info('Billing items inserted into database successfully', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'insert_billing_items',
        metadata: {
          insertedCount: insertedItems.length,
          generatedCount: billingItems.length,
          payrollDateId,
          completedBy,
        },
      });

      // 7. Update completion metrics to mark billing as generated
      await this.markBillingGenerated(payrollDateId, billingItems.length);

      const totalAmount = billingItems.reduce((sum, item) => sum + item.totalAmount, 0);

      logger.info('Tier 1 billing generation completed successfully', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'generate_billing_from_metrics',
        metadata: {
          itemsCreated: billingItems.length,
          totalAmount,
          errors: errors.length,
          warnings: warnings.length,
          payrollDateId,
          completedBy,
          success: true,
        },
      });

      return {
        success: true,
        itemsCreated: billingItems.length,
        totalAmount,
        items: insertedItems,
        ...(errors.length > 0 && { errors }),
        ...(warnings.length > 0 && { warnings })
      };

    } catch (error: any) {
      logger.error('Tier 1 billing generation failed completely', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'generate_billing_from_metrics',
        error: error.message,
        metadata: {
          payrollDateId,
          completedBy,
          errorType: 'billing_generation_failure',
          criticalError: true,
        },
      });
      return {
        success: false,
        itemsCreated: 0,
        totalAmount: 0,
        items: [],
        errors: [error.message]
      };
    }
  }

  /**
   * Generate billing item for a specific service
   */
  private generateServiceBilling(
    serviceCode: string,
    quantity: number,
    clientAgreements: any[] | null,
    payrollOverrides: any | null,
    payrollInfo: any,
    completedBy: string,
    metrics: PayrollCompletionMetrics
  ): GeneratedBillingItem {
    
    // Get service configuration
    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    if (!serviceConfig) {
      throw new Error(`Service configuration not found for: ${serviceCode}`);
    }

    // Determine effective rate (hierarchy: payroll override > client agreement > default)
    let effectiveRate = serviceConfig.defaultRate;
    let rateSource = 'default';

    // Check client agreement for custom rate
    const clientAgreement = clientAgreements?.find(a => a.service.serviceCode === serviceCode);
    if (clientAgreement?.customRate && clientAgreement.customRate > 0) {
      effectiveRate = parseFloat(clientAgreement.customRate.toString());
      rateSource = 'client_agreement';
    }

    // Check payroll override for custom rate
    if (payrollOverrides?.customRate && payrollOverrides.customRate > 0) {
      effectiveRate = parseFloat(payrollOverrides.customRate.toString());
      rateSource = 'payroll_override';
    }

    // Apply seasonal multipliers if applicable
    const seasonalRate = this.applySeasonalMultiplier(effectiveRate, serviceCode, new Date());
    if (seasonalRate !== effectiveRate) {
      rateSource += '_seasonal';
      effectiveRate = seasonalRate;
    }

    // Calculate total amount
    const totalAmount = quantity * effectiveRate;

    // Determine approval requirement
    const approvalLevel = this.determineApprovalLevel(
      serviceCode,
      totalAmount,
      clientAgreement?.autoBillingTriggers
    );

    // Generate unique ID
    const id = this.generateUUID();

    // Generate billing item
    const billingItem: GeneratedBillingItem = {
      id,
      payrollId: payrollInfo.payrollId,
      payrollDateId: payrollInfo.id,
      clientId: payrollInfo.clientId,
      
      serviceCode,
      serviceName: serviceConfig.name,
      description: this.generateServiceDescription(serviceCode, quantity, payrollInfo, metrics),
      category: serviceConfig.category,
      
      quantity,
      unitPrice: effectiveRate,
      totalAmount,
      currency: 'AUD',
      
      autoGenerated: true,
      generatedFrom: 'completion_metrics',
      generatedAt: new Date(),
      generatedBy: completedBy,
      
      status: approvalLevel === 'auto' ? 'approved' : 'draft',
      requiresApproval: approvalLevel !== 'auto',
      approvalLevel,
      
      rateJustification: this.generateRateJustification(serviceCode, effectiveRate, rateSource),
      billingTier: 'tier1'
    };

    return billingItem;
  }

  /**
   * Determine approval level based on service and amount
   */
  private determineApprovalLevel(
    serviceCode: string,
    totalAmount: number,
    clientThresholds?: any
  ): 'auto' | 'review' | 'manager' | 'admin' {
    
    // Get base approval level from service configuration
    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    const baseApproval: 'auto' | 'review' | 'manager' | 'admin' = 
      (serviceConfig?.approvalLevel as 'auto' | 'review' | 'manager' | 'admin') || 'review';

    // Amount-based escalation
    if (clientThresholds) {
      const thresholds = typeof clientThresholds === 'string' 
        ? JSON.parse(clientThresholds) 
        : clientThresholds;
        
      if (totalAmount > (thresholds.adminThreshold || 2000)) {
        return 'admin';
      }
      if (totalAmount > (thresholds.managerThreshold || 1000)) {
        return baseApproval === 'auto' ? 'review' : 'manager';
      }
      if (totalAmount > (thresholds.reviewThreshold || 500)) {
        return baseApproval === 'auto' ? 'review' : baseApproval;
      }
    }

    return baseApproval;
  }

  /**
   * Apply seasonal multipliers (e.g., year-end processing)
   */
  private applySeasonalMultiplier(baseRate: number, serviceCode: string, date: Date): number {
    const month = date.getMonth() + 1; // 1-12
    
    // Year-end processing (June-July in Australia)
    if ((month === 6 || month === 7) && serviceCode === 'PAYG_SUMMARY') {
      return baseRate * 1.0; // No multiplier for standard PAYG
    }
    
    // Complex year-end services get premium
    if ((month === 6 || month === 7) && ['FBT_CALC', 'TAX_ADJ'].includes(serviceCode)) {
      return baseRate * 1.2; // 20% premium
    }

    return baseRate;
  }

  /**
   * Generate descriptive billing item description
   */
  private generateServiceDescription(
    serviceCode: string, 
    quantity: number, 
    payrollInfo: any,
    metrics: PayrollCompletionMetrics
  ): string {
    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    const serviceName = serviceConfig?.name || serviceCode;
    const eftDate = new Date(payrollInfo.adjustedEftDate || payrollInfo.originalEftDate).toLocaleDateString();
    
    let description = `${serviceName} - ${payrollInfo.payrollName} (EFT: ${eftDate})`;
    
    // Add quantity context
    if (quantity === 1) {
      description += ` - 1 ${serviceConfig?.unit?.replace('per_', '') || 'unit'}`;
    } else {
      description += ` - ${quantity} ${serviceConfig?.unit?.replace('per_', '') || 'units'}`;
    }

    // Add complexity notes for high-complexity payrolls
    const complexityIndicators = [];
    if (metrics.exceptionsHandled > 0) complexityIndicators.push(`${metrics.exceptionsHandled} exceptions`);
    if (metrics.correctionsRequired > 0) complexityIndicators.push(`${metrics.correctionsRequired} corrections`);
    if (metrics.clientCommunications > 2) complexityIndicators.push(`${metrics.clientCommunications} client contacts`);
    
    if (complexityIndicators.length > 0) {
      description += ` (${complexityIndicators.join(', ')})`;
    }

    return description;
  }

  /**
   * Generate rate justification text
   */
  private generateRateJustification(serviceCode: string, rate: number, source: string): string {
    const sourceDescriptions = {
      'default': 'Standard service rate',
      'client_agreement': 'Rate per client service agreement',
      'payroll_override': 'Custom rate for this payroll',
      'client_agreement_seasonal': 'Client rate with seasonal adjustment',
      'payroll_override_seasonal': 'Override rate with seasonal adjustment'
    };

    const serviceConfig = SERVICE_CONFIGURATIONS[serviceCode as keyof typeof SERVICE_CONFIGURATIONS];
    return `${sourceDescriptions[source as keyof typeof sourceDescriptions] || source} - $${rate.toFixed(2)} ${serviceConfig?.unit || 'per unit'}`;
  }

  // Database interaction methods
  private async getPayrollInfo(payrollDateId: string) {
    try {
      const { data } = await serverApolloClient.query<
        GetPayrollInfoForTier1BillingQuery,
        GetPayrollInfoForTier1BillingQueryVariables
      >({
        query: GetPayrollInfoForTier1BillingDocument,
        variables: { payrollDateId },
        fetchPolicy: 'network-only'
      });

      const payrollDate = data?.payrollDates?.[0];
      if (!payrollDate) return null;

      return {
        id: payrollDate.id,
        payrollId: payrollDate.payrollId,
        payrollName: payrollDate.payroll.name,
        clientId: payrollDate.payroll.clientId,
        clientName: payrollDate.payroll.client.name,
        originalEftDate: payrollDate.originalEftDate,
        adjustedEftDate: payrollDate.adjustedEftDate,
        status: payrollDate.status
      };
    } catch (error) {
      logger.error('Failed to fetch payroll information', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'get_payroll_info',
        error: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          payrollDateId,
          errorType: 'graphql_query_error',
        },
      });
      return null;
    }
  }

  private async getClientServiceAgreements(clientId: string) {
    try {
      const { data } = await serverApolloClient.query<
        GetClientServiceAgreementsForTier1BillingQuery,
        GetClientServiceAgreementsForTier1BillingQueryVariables
      >({
        query: GetClientServiceAgreementsForTier1BillingDocument,
        variables: { clientId },
        fetchPolicy: 'network-only'
      });

      return data?.clientServiceAgreements || [];
    } catch (error) {
      logger.error('Failed to fetch client service agreements', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'get_client_service_agreements',
        error: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          clientId,
          errorType: 'graphql_query_error',
        },
      });
      return [];
    }
  }

  private async getPayrollServiceAgreements(payrollId: string) {
    try {
      const { data } = await serverApolloClient.query<
        GetPayrollServiceAgreementsForTier1BillingEngineQuery,
        GetPayrollServiceAgreementsForTier1BillingEngineQueryVariables
      >({
        query: GetPayrollServiceAgreementsForTier1BillingEngineDocument,
        variables: { payrollId },
        fetchPolicy: 'network-only'
      });

      return data?.payrollServiceAgreements?.[0] || null;
    } catch (error) {
      logger.error('Failed to fetch payroll service agreements', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'get_payroll_service_agreements',
        error: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          payrollId,
          errorType: 'graphql_query_error',
        },
      });
      return null;
    }
  }

  private async generateAdditionalServiceBilling(
    additionalServices: any,
    payrollInfo: any,
    completedBy: string
  ): Promise<GeneratedBillingItem[]> {
    const items: GeneratedBillingItem[] = [];
    
    const services = typeof additionalServices === 'string' 
      ? JSON.parse(additionalServices) 
      : additionalServices;

    for (const [serviceCode, serviceData] of Object.entries(services as any)) {
      const typedServiceData = serviceData as any;
      try {
        const item: GeneratedBillingItem = {
          id: this.generateUUID(),
          payrollId: payrollInfo.payrollId,
          payrollDateId: payrollInfo.id,
          clientId: payrollInfo.clientId,
          
          serviceCode,
          serviceName: typedServiceData.name || serviceCode,
          description: typedServiceData.description || `Additional service: ${serviceCode}`,
          category: 'additional',
          
          quantity: typedServiceData.quantity || 1,
          unitPrice: typedServiceData.rate || 0,
          totalAmount: (typedServiceData.quantity || 1) * (typedServiceData.rate || 0),
          currency: 'AUD',
          
          autoGenerated: true,
          generatedFrom: 'payroll_override',
          generatedAt: new Date(),
          generatedBy: completedBy,
          
          status: 'draft', // Additional services always require approval
          requiresApproval: true,
          approvalLevel: 'manager',
          
          rateJustification: `One-time additional service: ${typedServiceData.reason || 'No reason provided'}`,
          billingTier: 'tier1'
        };

        items.push(item);
      } catch (error) {
        logger.error('Failed to generate additional service billing', {
          namespace: 'billing_domain',
          component: 'tier1_billing_engine',
          action: 'generate_additional_service_billing',
          error: error instanceof Error ? error.message : 'Unknown error',
          metadata: {
            serviceCode,
            errorType: 'additional_service_generation_error',
          },
        });
      }
    }

    return items;
  }

  private async insertBillingItems(
    billingItems: GeneratedBillingItem[],
    payrollDateId: string
  ): Promise<GeneratedBillingItem[]> {
    if (billingItems.length === 0) return [];

    try {
      const insertData = billingItems.map(item => ({
        payrollId: item.payrollId,
        payrollDateId: item.payrollDateId,
        clientId: item.clientId,
        serviceName: item.serviceName,
        description: item.description,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        amount: item.totalAmount,
        totalAmount: item.totalAmount,
        status: item.status,
        serviceCode: item.serviceCode,
        autoGenerated: item.autoGenerated,
        generatedFrom: item.generatedFrom,
        approvalLevel: item.approvalLevel,
        rateJustification: item.rateJustification,
        billingTier: item.billingTier,
        staffUserId: item.generatedBy
      }));

      const { data } = await serverApolloClient.mutate<
        InsertTier1BillingItemsMutation,
        InsertTier1BillingItemsMutationVariables
      >({
        mutation: InsertTier1BillingItemsDocument,
        variables: { items: insertData }
      });

      logger.info('Billing items successfully inserted to database', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'insert_billing_items',
        metadata: {
          insertedCount: data?.insertBillingItems?.returning?.length || 0,
          requestedCount: billingItems.length,
          payrollDateId,
        },
      });
      return billingItems; // Return original items with generated data
    } catch (error) {
      logger.error('Failed to insert billing items to database', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'insert_billing_items',
        error: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          billingItemsCount: billingItems.length,
          payrollDateId,
          errorType: 'graphql_mutation_error',
        },
      });
      throw error;
    }
  }

  private async markBillingGenerated(payrollDateId: string, itemCount: number): Promise<void> {
    try {
      await serverApolloClient.mutate<
        UpdateTier1CompletionMetricsMutation,
        UpdateTier1CompletionMetricsMutationVariables
      >({
        mutation: UpdateTier1CompletionMetricsDocument,
        variables: { payrollDateId }
      });
      logger.info('Payroll date marked as billing generated', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'mark_billing_generated',
        metadata: {
          payrollDateId,
          itemCount,
        },
      });
    } catch (error) {
      logger.warn('Failed to mark payroll date as billing generated', {
        namespace: 'billing_domain',
        component: 'tier1_billing_engine',
        action: 'mark_billing_generated',
        error: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          payrollDateId,
          itemCount,
          errorType: 'graphql_mutation_error',
          criticalError: false,
        },
      });
      // Don't throw - this is not critical for the billing process
    }
  }

  private generateUUID(): string {
    return crypto.randomUUID();
  }
}