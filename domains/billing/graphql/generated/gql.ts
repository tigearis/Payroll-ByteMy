/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "fragment BillingItemCore on billingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  billingPlanId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on billingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approver {\n    id\n    firstName\n    lastName\n    email\n  }\n  relatedPayroll {\n    id\n    name\n    status\n  }\n  billingServicePlan {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n  }\n}\n\nfragment BillingItemStats on billingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: billingItemsBoolExp, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: billingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: billingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: billingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditLogs(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}": typeof types.BillingItemCoreFragmentDoc,
    "mutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": typeof types.CreateServiceDocument,
    "fragment ServiceCatalogFragment on billingPlans {\n  id\n  name\n  description\n  standardRate\n  billingUnit\n  category\n  isActive\n  currency\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on clientBillingAssignments {\n  id\n  clientId\n  billingPlanId\n  customRate\n  billingFrequency\n  effectiveDate\n  isEnabled\n  isActive\n  startDate\n  endDate\n  createdAt\n  updatedAt\n  assignedBillingPlan {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment BillingItemFragment on billingItems {\n  id\n  invoiceId\n  description\n  quantity\n  amount\n  totalAmount\n  payrollId\n  billingPlanId\n  clientId\n  serviceName\n  hourlyRate\n  isApproved\n  approvalDate\n  approvedBy\n  confirmedAt\n  confirmedBy\n  notes\n  createdAt\n  updatedAt\n}\n\nfragment TimeEntryFragment on timeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  billingItemId\n  workDate\n  hoursSpent\n  description\n  createdAt\n  updatedAt\n}\n\nfragment BillingPeriodFragment on billingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n}\n\nfragment BillingInvoiceFragment on billingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on billingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  processingTime\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}": typeof types.ServiceCatalogFragmentFragmentDoc,
    "query GetInvoices($where: billingInvoiceBoolExp, $orderBy: [billingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceById(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: billingInvoiceInsertInput!) {\n  insertBillingInvoice(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  bulkUpdateBillingItems(\n    where: {id: {_in: $billingItemIds}}\n    _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  bulkUpdateBillingItems(\n    where: {invoiceId: {_eq: $id}}\n    _set: {invoiceId: null, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoice(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [billingPeriodsInsertInput!]!) {\n  insertBillingPeriod(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}": typeof types.GetInvoicesDocument,
    "mutation CreateMultipleTimeEntries($timeEntries: [notesInsertInput!]!) {\n  bulkInsertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: billingItemsInsertInput!) {\n  insertBillingItem(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [billingItemsInsertInput!]!) {\n  billingItems: bulkInsertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: billingPlansSetInput!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: timeEntriesSetInput!) {\n  updateTimeEntry(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [clientBillingAssignmentsInsertInput!]!) {\n  bulkDeleteClientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  bulkInsertClientBillingAssignments(objects: $agreements) {\n    returning {\n      id\n      clientId\n      billingPlanId\n      customRate\n      billingFrequency\n      effectiveDate\n      isEnabled\n      isActive\n      startDate\n      endDate\n      createdAt\n      assignedBillingPlan {\n        id\n        name\n        description\n        standardRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": typeof types.CreateMultipleTimeEntriesDocument,
    "query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GetTimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    billingPlanId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    effectiveDate\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  billingPlans(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  billingPlanById(id: $id) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    billingPlanId\n    customRate\n    billingFrequency\n    effectiveDate\n    isEnabled\n    isActive\n    startDate\n    endDate\n    createdAt\n    updatedAt\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllBillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}": typeof types.GetStaffBillingPerformanceDocument,
    "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}": typeof types.GetFinancialPerformanceDataDocument,
    "fragment UserMinimal on users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on users {\n  ...UserBasic\n}\n\nfragment UserWithRole on users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  managerUser {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on clients {\n  id\n  name\n}\n\nfragment ClientBase on clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  authorUser {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  assignedPermissions {\n    grantedPermission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on auditLogs {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on authEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on dataAccessLogs {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on permissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on payrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on permissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}": typeof types.UserMinimalFragmentDoc,
    "mutation LogAuditEvent($input: auditLogsInsertInput!) {\n  insertAuditLogsOne: insertAuditLog(object: $input) {\n    id\n    eventTime\n  }\n}\n\nmutation InsertFile($input: filesInsertInput!) {\n  insertFile(object: $input) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: filesSetInput!) {\n  updateFileById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFileById(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}": typeof types.LogAuditEventDocument,
    "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: userById(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditLogsAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  fileById(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery ListFiles($where: filesBoolExp, $limit: Int, $offset: Int, $orderBy: [filesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}": typeof types.GetDashboardMetricsDocument,
    "subscription RecentActivity($resourceTypes: [String!]) {\n  auditLogs(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  authEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  dataAccessLogs(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  permissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}": typeof types.RecentActivityDocument,
};
const documents: Documents = {
    "fragment BillingItemCore on billingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  billingPlanId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on billingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approver {\n    id\n    firstName\n    lastName\n    email\n  }\n  relatedPayroll {\n    id\n    name\n    status\n  }\n  billingServicePlan {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n  }\n}\n\nfragment BillingItemStats on billingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: billingItemsBoolExp, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: billingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: billingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: billingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditLogs(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}": types.BillingItemCoreFragmentDoc,
    "mutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": types.CreateServiceDocument,
    "fragment ServiceCatalogFragment on billingPlans {\n  id\n  name\n  description\n  standardRate\n  billingUnit\n  category\n  isActive\n  currency\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on clientBillingAssignments {\n  id\n  clientId\n  billingPlanId\n  customRate\n  billingFrequency\n  effectiveDate\n  isEnabled\n  isActive\n  startDate\n  endDate\n  createdAt\n  updatedAt\n  assignedBillingPlan {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment BillingItemFragment on billingItems {\n  id\n  invoiceId\n  description\n  quantity\n  amount\n  totalAmount\n  payrollId\n  billingPlanId\n  clientId\n  serviceName\n  hourlyRate\n  isApproved\n  approvalDate\n  approvedBy\n  confirmedAt\n  confirmedBy\n  notes\n  createdAt\n  updatedAt\n}\n\nfragment TimeEntryFragment on timeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  billingItemId\n  workDate\n  hoursSpent\n  description\n  createdAt\n  updatedAt\n}\n\nfragment BillingPeriodFragment on billingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n}\n\nfragment BillingInvoiceFragment on billingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on billingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  processingTime\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}": types.ServiceCatalogFragmentFragmentDoc,
    "query GetInvoices($where: billingInvoiceBoolExp, $orderBy: [billingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceById(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: billingInvoiceInsertInput!) {\n  insertBillingInvoice(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  bulkUpdateBillingItems(\n    where: {id: {_in: $billingItemIds}}\n    _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  bulkUpdateBillingItems(\n    where: {invoiceId: {_eq: $id}}\n    _set: {invoiceId: null, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoice(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [billingPeriodsInsertInput!]!) {\n  insertBillingPeriod(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}": types.GetInvoicesDocument,
    "mutation CreateMultipleTimeEntries($timeEntries: [notesInsertInput!]!) {\n  bulkInsertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: billingItemsInsertInput!) {\n  insertBillingItem(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [billingItemsInsertInput!]!) {\n  billingItems: bulkInsertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: billingPlansSetInput!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: timeEntriesSetInput!) {\n  updateTimeEntry(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [clientBillingAssignmentsInsertInput!]!) {\n  bulkDeleteClientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  bulkInsertClientBillingAssignments(objects: $agreements) {\n    returning {\n      id\n      clientId\n      billingPlanId\n      customRate\n      billingFrequency\n      effectiveDate\n      isEnabled\n      isActive\n      startDate\n      endDate\n      createdAt\n      assignedBillingPlan {\n        id\n        name\n        description\n        standardRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": types.CreateMultipleTimeEntriesDocument,
    "query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GetTimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    billingPlanId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    effectiveDate\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  billingPlans(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  billingPlanById(id: $id) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    billingPlanId\n    customRate\n    billingFrequency\n    effectiveDate\n    isEnabled\n    isActive\n    startDate\n    endDate\n    createdAt\n    updatedAt\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllBillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}": types.GetStaffBillingPerformanceDocument,
    "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}": types.GetFinancialPerformanceDataDocument,
    "fragment UserMinimal on users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on users {\n  ...UserBasic\n}\n\nfragment UserWithRole on users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  managerUser {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on clients {\n  id\n  name\n}\n\nfragment ClientBase on clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  authorUser {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  assignedPermissions {\n    grantedPermission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on auditLogs {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on authEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on dataAccessLogs {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on permissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on payrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on permissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}": types.UserMinimalFragmentDoc,
    "mutation LogAuditEvent($input: auditLogsInsertInput!) {\n  insertAuditLogsOne: insertAuditLog(object: $input) {\n    id\n    eventTime\n  }\n}\n\nmutation InsertFile($input: filesInsertInput!) {\n  insertFile(object: $input) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: filesSetInput!) {\n  updateFileById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFileById(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}": types.LogAuditEventDocument,
    "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: userById(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditLogsAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  fileById(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery ListFiles($where: filesBoolExp, $limit: Int, $offset: Int, $orderBy: [filesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}": types.GetDashboardMetricsDocument,
    "subscription RecentActivity($resourceTypes: [String!]) {\n  auditLogs(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  authEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  dataAccessLogs(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  permissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}": types.RecentActivityDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment BillingItemCore on billingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  billingPlanId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on billingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approver {\n    id\n    firstName\n    lastName\n    email\n  }\n  relatedPayroll {\n    id\n    name\n    status\n  }\n  billingServicePlan {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n  }\n}\n\nfragment BillingItemStats on billingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: billingItemsBoolExp, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: billingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: billingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: billingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditLogs(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}"): (typeof documents)["fragment BillingItemCore on billingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  billingPlanId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on billingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approver {\n    id\n    firstName\n    lastName\n    email\n  }\n  relatedPayroll {\n    id\n    name\n    status\n  }\n  billingServicePlan {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n  }\n}\n\nfragment BillingItemStats on billingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: billingItemsBoolExp, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: billingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [billingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemById(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: billingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemById(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: billingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditLogs(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"): (typeof documents)["mutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment ServiceCatalogFragment on billingPlans {\n  id\n  name\n  description\n  standardRate\n  billingUnit\n  category\n  isActive\n  currency\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on clientBillingAssignments {\n  id\n  clientId\n  billingPlanId\n  customRate\n  billingFrequency\n  effectiveDate\n  isEnabled\n  isActive\n  startDate\n  endDate\n  createdAt\n  updatedAt\n  assignedBillingPlan {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment BillingItemFragment on billingItems {\n  id\n  invoiceId\n  description\n  quantity\n  amount\n  totalAmount\n  payrollId\n  billingPlanId\n  clientId\n  serviceName\n  hourlyRate\n  isApproved\n  approvalDate\n  approvedBy\n  confirmedAt\n  confirmedBy\n  notes\n  createdAt\n  updatedAt\n}\n\nfragment TimeEntryFragment on timeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  billingItemId\n  workDate\n  hoursSpent\n  description\n  createdAt\n  updatedAt\n}\n\nfragment BillingPeriodFragment on billingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n}\n\nfragment BillingInvoiceFragment on billingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on billingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  processingTime\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}"): (typeof documents)["fragment ServiceCatalogFragment on billingPlans {\n  id\n  name\n  description\n  standardRate\n  billingUnit\n  category\n  isActive\n  currency\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on clientBillingAssignments {\n  id\n  clientId\n  billingPlanId\n  customRate\n  billingFrequency\n  effectiveDate\n  isEnabled\n  isActive\n  startDate\n  endDate\n  createdAt\n  updatedAt\n  assignedBillingPlan {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment BillingItemFragment on billingItems {\n  id\n  invoiceId\n  description\n  quantity\n  amount\n  totalAmount\n  payrollId\n  billingPlanId\n  clientId\n  serviceName\n  hourlyRate\n  isApproved\n  approvalDate\n  approvedBy\n  confirmedAt\n  confirmedBy\n  notes\n  createdAt\n  updatedAt\n}\n\nfragment TimeEntryFragment on timeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  billingItemId\n  workDate\n  hoursSpent\n  description\n  createdAt\n  updatedAt\n}\n\nfragment BillingPeriodFragment on billingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n}\n\nfragment BillingInvoiceFragment on billingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on billingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  processingTime\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetInvoices($where: billingInvoiceBoolExp, $orderBy: [billingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceById(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: billingInvoiceInsertInput!) {\n  insertBillingInvoice(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  bulkUpdateBillingItems(\n    where: {id: {_in: $billingItemIds}}\n    _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  bulkUpdateBillingItems(\n    where: {invoiceId: {_eq: $id}}\n    _set: {invoiceId: null, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoice(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [billingPeriodsInsertInput!]!) {\n  insertBillingPeriod(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}"): (typeof documents)["query GetInvoices($where: billingInvoiceBoolExp, $orderBy: [billingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceById(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    billingInvoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: billingInvoiceInsertInput!) {\n  insertBillingInvoice(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  bulkUpdateBillingItems(\n    where: {id: {_in: $billingItemIds}}\n    _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  bulkUpdateBillingItems(\n    where: {invoiceId: {_eq: $id}}\n    _set: {invoiceId: null, updatedAt: \"now()\"}\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceById(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoice(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [billingPeriodsInsertInput!]!) {\n  insertBillingPeriod(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateMultipleTimeEntries($timeEntries: [notesInsertInput!]!) {\n  bulkInsertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: billingItemsInsertInput!) {\n  insertBillingItem(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [billingItemsInsertInput!]!) {\n  billingItems: bulkInsertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: billingPlansSetInput!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: timeEntriesSetInput!) {\n  updateTimeEntry(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [clientBillingAssignmentsInsertInput!]!) {\n  bulkDeleteClientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  bulkInsertClientBillingAssignments(objects: $agreements) {\n    returning {\n      id\n      clientId\n      billingPlanId\n      customRate\n      billingFrequency\n      effectiveDate\n      isEnabled\n      isActive\n      startDate\n      endDate\n      createdAt\n      assignedBillingPlan {\n        id\n        name\n        description\n        standardRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"): (typeof documents)["mutation CreateMultipleTimeEntries($timeEntries: [notesInsertInput!]!) {\n  bulkInsertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: billingItemsInsertInput!) {\n  insertBillingItem(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [billingItemsInsertInput!]!) {\n  billingItems: bulkInsertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateService($input: billingPlansInsertInput!) {\n  insertBillingPlan(object: $input) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: billingPlansSetInput!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateBillingPlanById(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: billingItemsInsertInput!) {\n  insertBillingItem(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: billingItemsSetInput!) {\n  updateBillingItemById(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemById(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: timeEntriesInsertInput!) {\n  insertTimeEntryOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: timeEntriesSetInput!) {\n  updateTimeEntry(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [clientBillingAssignmentsInsertInput!]!) {\n  bulkDeleteClientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  bulkInsertClientBillingAssignments(objects: $agreements) {\n    returning {\n      id\n      clientId\n      billingPlanId\n      customRate\n      billingFrequency\n      effectiveDate\n      isEnabled\n      isActive\n      startDate\n      endDate\n      createdAt\n      assignedBillingPlan {\n        id\n        name\n        description\n        standardRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: payrollsSetInput!) {\n  updatePayrollById(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GetTimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    billingPlanId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    effectiveDate\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  billingPlans(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  billingPlanById(id: $id) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    billingPlanId\n    customRate\n    billingFrequency\n    effectiveDate\n    isEnabled\n    isActive\n    startDate\n    endDate\n    createdAt\n    updatedAt\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllBillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}"): (typeof documents)["query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryConsultantPayrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GetTimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    billingPlanId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    effectiveDate\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  billingPlans(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  billingPlanById(id: $id) {\n    id\n    name\n    description\n    standardRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientBillingAssignments(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    billingPlanId\n    customRate\n    billingFrequency\n    effectiveDate\n    isEnabled\n    isActive\n    startDate\n    endDate\n    createdAt\n    updatedAt\n    assignedBillingPlan {\n      id\n      name\n      description\n      standardRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllBillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approver {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    billingPlanId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollById(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}"): (typeof documents)["query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientById(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment UserMinimal on users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on users {\n  ...UserBasic\n}\n\nfragment UserWithRole on users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  managerUser {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on clients {\n  id\n  name\n}\n\nfragment ClientBase on clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  authorUser {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  assignedPermissions {\n    grantedPermission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on auditLogs {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on authEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on dataAccessLogs {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on permissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on payrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on permissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}"): (typeof documents)["fragment UserMinimal on users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on users {\n  ...UserBasic\n}\n\nfragment UserWithRole on users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  managerUser {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on clients {\n  id\n  name\n}\n\nfragment ClientBase on clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  authorUser {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  assignedPermissions {\n    grantedPermission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on auditLogs {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on authEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on dataAccessLogs {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on permissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on payrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on permissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation LogAuditEvent($input: auditLogsInsertInput!) {\n  insertAuditLogsOne: insertAuditLog(object: $input) {\n    id\n    eventTime\n  }\n}\n\nmutation InsertFile($input: filesInsertInput!) {\n  insertFile(object: $input) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: filesSetInput!) {\n  updateFileById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFileById(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}"): (typeof documents)["mutation LogAuditEvent($input: auditLogsInsertInput!) {\n  insertAuditLogsOne: insertAuditLog(object: $input) {\n    id\n    eventTime\n  }\n}\n\nmutation InsertFile($input: filesInsertInput!) {\n  insertFile(object: $input) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: filesSetInput!) {\n  updateFileById(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFileById(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: userById(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditLogsAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  fileById(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery ListFiles($where: filesBoolExp, $limit: Int, $offset: Int, $orderBy: [filesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}"): (typeof documents)["query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: userById(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditLogsAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  fileById(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery ListFiles($where: filesBoolExp, $limit: Int, $offset: Int, $orderBy: [filesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploader {\n      firstName\n      lastName\n      computedName\n    }\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "subscription RecentActivity($resourceTypes: [String!]) {\n  auditLogs(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  authEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  dataAccessLogs(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  permissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}"): (typeof documents)["subscription RecentActivity($resourceTypes: [String!]) {\n  auditLogs(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  authEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  dataAccessLogs(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  permissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}"];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;