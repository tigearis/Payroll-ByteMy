/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}": typeof types.BillingItemCoreFragmentDoc,
    "mutation CreateServiceCore($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    serviceType\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntryCore($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatusCore($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": typeof types.CreateServiceCoreDocument,
    "mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}": typeof types.CreateTimeEntryWithUnitsDocument,
    "fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}": typeof types.ServiceCatalogFragmentFragmentDoc,
    "query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}": typeof types.GetInvoicesDocument,
    "mutation CreateMultipleTimeEntries($timeEntries: [NotesInsertInput!]!) {\n  insertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [BillingItemsInsertInput!]!) {\n  billingItems: insertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateBillingItemLog($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLogOne(object: $input) {\n    id\n    userId\n    action\n    success\n    metadata\n    eventTime\n  }\n}\n\nmutation CreateService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: ServicesSetInput!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [ClientServiceAgreementsInsertInput!]!) {\n  deleteClientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  insertClientServiceAgreements(objects: $agreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      billingFrequency\n      contractStartDate\n      isEnabled\n      isActive\n      contractStartDate\n      contractEndDate\n      createdAt\n      service {\n        id\n        name\n        description\n        defaultRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": typeof types.CreateMultipleTimeEntriesDocument,
    "query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GettimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    serviceId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    contractStartDate\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  services(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    serviceId\n    customRate\n    billingFrequency\n    contractStartDate\n    isEnabled\n    isActive\n    contractStartDate\n    contractEndDate\n    createdAt\n    updatedAt\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllbillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemById($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}": typeof types.GetStaffBillingPerformanceDocument,
    "mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}": typeof types.CreateQuoteDocument,
    "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}": typeof types.GetFinancialPerformanceDataDocument,
    "fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0, $category: String) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid, $serviceId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, serviceId: {_eq: $serviceId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}": typeof types.ServiceFragmentFragmentDoc,
    "fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}": typeof types.UserMinimalFragmentDoc,
    "mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}": typeof types.LogAuditEventDocument,
    "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}": typeof types.GetDashboardMetricsDocument,
    "subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}": typeof types.RecentActivityDocument,
};
const documents: Documents = {
    "fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}": types.BillingItemCoreFragmentDoc,
    "mutation CreateServiceCore($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    serviceType\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntryCore($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatusCore($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": types.CreateServiceCoreDocument,
    "mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}": types.CreateTimeEntryWithUnitsDocument,
    "fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}": types.ServiceCatalogFragmentFragmentDoc,
    "query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}": types.GetInvoicesDocument,
    "mutation CreateMultipleTimeEntries($timeEntries: [NotesInsertInput!]!) {\n  insertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [BillingItemsInsertInput!]!) {\n  billingItems: insertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateBillingItemLog($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLogOne(object: $input) {\n    id\n    userId\n    action\n    success\n    metadata\n    eventTime\n  }\n}\n\nmutation CreateService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: ServicesSetInput!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [ClientServiceAgreementsInsertInput!]!) {\n  deleteClientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  insertClientServiceAgreements(objects: $agreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      billingFrequency\n      contractStartDate\n      isEnabled\n      isActive\n      contractStartDate\n      contractEndDate\n      createdAt\n      service {\n        id\n        name\n        description\n        defaultRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}": types.CreateMultipleTimeEntriesDocument,
    "query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GettimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    serviceId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    contractStartDate\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  services(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    serviceId\n    customRate\n    billingFrequency\n    contractStartDate\n    isEnabled\n    isActive\n    contractStartDate\n    contractEndDate\n    createdAt\n    updatedAt\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllbillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemById($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}": types.GetStaffBillingPerformanceDocument,
    "mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}": types.CreateQuoteDocument,
    "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}": types.GetFinancialPerformanceDataDocument,
    "fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0, $category: String) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid, $serviceId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, serviceId: {_eq: $serviceId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}": types.ServiceFragmentFragmentDoc,
    "fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}": types.UserMinimalFragmentDoc,
    "mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}": types.LogAuditEventDocument,
    "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}": types.GetDashboardMetricsDocument,
    "subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}": types.RecentActivityDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}"): (typeof documents)["fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateServiceCore($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    serviceType\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntryCore($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatusCore($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"): (typeof documents)["mutation CreateServiceCore($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    serviceType\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation CreateTimeEntryCore($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollBillingStatusCore($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}"): (typeof documents)["mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}"): (typeof documents)["fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}"): (typeof documents)["query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateMultipleTimeEntries($timeEntries: [NotesInsertInput!]!) {\n  insertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [BillingItemsInsertInput!]!) {\n  billingItems: insertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateBillingItemLog($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLogOne(object: $input) {\n    id\n    userId\n    action\n    success\n    metadata\n    eventTime\n  }\n}\n\nmutation CreateService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: ServicesSetInput!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [ClientServiceAgreementsInsertInput!]!) {\n  deleteClientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  insertClientServiceAgreements(objects: $agreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      billingFrequency\n      contractStartDate\n      isEnabled\n      isActive\n      contractStartDate\n      contractEndDate\n      createdAt\n      service {\n        id\n        name\n        description\n        defaultRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"): (typeof documents)["mutation CreateMultipleTimeEntries($timeEntries: [NotesInsertInput!]!) {\n  insertNotes(objects: $timeEntries) {\n    returning {\n      id\n      content\n      entityId\n      entityType\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation GeneratePayrollBilling($billingItem: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $billingItem) {\n    id\n    payrollId\n    clientId\n    totalAmount\n    isApproved\n    createdAt\n  }\n}\n\nmutation CreatePayrollBilling($payrollId: uuid!, $billingItems: [BillingItemsInsertInput!]!) {\n  billingItems: insertBillingItems(objects: $billingItems) {\n    returning {\n      id\n      payrollId\n      clientId\n      description\n      quantity\n      amount\n      isApproved\n      createdAt\n    }\n    affectedRows\n  }\n}\n\nmutation CreateBillingItemLog($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLogOne(object: $input) {\n    id\n    userId\n    action\n    success\n    metadata\n    eventTime\n  }\n}\n\nmutation CreateService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateService($id: uuid!, $updates: ServicesSetInput!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nmutation DeleteService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    name\n    isActive\n    updatedAt\n  }\n}\n\nmutation CreateBillingItem($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation UpdateBillingItem($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nmutation DeleteBillingItem($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nquery GetClientsForBilling {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n  }\n}\n\nmutation CreateTimeEntry($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdateTimeEntry($id: uuid!, $updates: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nmutation BulkUpdateClientServiceAgreements($clientId: uuid!, $agreements: [ClientServiceAgreementsInsertInput!]!) {\n  deleteClientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    affectedRows\n  }\n  insertClientServiceAgreements(objects: $agreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      billingFrequency\n      contractStartDate\n      isEnabled\n      isActive\n      contractStartDate\n      contractEndDate\n      createdAt\n      service {\n        id\n        name\n        description\n        defaultRate\n        billingUnit\n        category\n      }\n    }\n    affectedRows\n  }\n}\n\nmutation UpdatePayrollBillingStatus($payrollId: uuid!, $updates: PayrollsSetInput!) {\n  updatePayrollsByPk(pkColumns: {id: $payrollId}, _set: $updates) {\n    id\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    profitMargin\n    updatedAt\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GettimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    serviceId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    contractStartDate\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  services(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    serviceId\n    customRate\n    billingFrequency\n    contractStartDate\n    isEnabled\n    isActive\n    contractStartDate\n    contractEndDate\n    createdAt\n    updatedAt\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllbillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemById($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}"): (typeof documents)["query GetStaffBillingPerformance($staffId: uuid, $dateFrom: date, $dateTo: date) {\n  staff_billing_performance: users(\n    where: {_and: [{id: {_eq: $staffId}}, {isActive: {_eq: true}}]}\n  ) {\n    id\n    firstName\n    lastName\n    computedName\n    email\n    totalBilledHours: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    totalRevenue: primaryPayrollAssignmentsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n  }\n}\n\nquery GetClientProfitability($clientId: uuid, $dateFrom: date, $dateTo: date) {\n  client_profitability: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    totalRevenue: payrollsAggregate {\n      aggregate {\n        sum {\n          estimatedRevenue\n        }\n      }\n    }\n    totalCosts: payrollsAggregate {\n      aggregate {\n        sum {\n          actualHours\n        }\n      }\n    }\n    profitability: payrolls {\n      id\n      name\n      estimatedRevenue\n      actualHours\n      status\n    }\n  }\n}\n\nquery GettimeEntries($payrollId: uuid, $userId: uuid) {\n  timeEntries: payrolls(where: {id: {_eq: $payrollId}}) {\n    id\n    name\n    actualHours\n    estimatedHours\n    status\n  }\n}\n\nquery GetPayrollForBilling($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    status\n    employeeCount\n    processingTime\n    processingDaysBeforeEft\n    clientId\n    primaryConsultantUserId\n    backupConsultantUserId\n    managerUserId\n    client {\n      id\n      name\n    }\n    payrollDates {\n      id\n      originalEftDate\n      adjustedEftDate\n      notes\n    }\n  }\n}\n\nquery GetClientServicesWithRates($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    id\n    serviceId\n    clientId\n    customRate\n    billingFrequency\n    isActive\n    contractStartDate\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n    }\n  }\n}\n\nquery GetServiceCatalog($isActive: Boolean) {\n  services(\n    where: {isActive: {_eq: $isActive}}\n    orderBy: {category: ASC, name: ASC}\n  ) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    id\n    name\n    description\n    defaultRate\n    billingUnit\n    category\n    isActive\n    currency\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientServiceAgreements($clientId: uuid!) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}, isEnabled: {_eq: true}}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    clientId\n    serviceId\n    customRate\n    billingFrequency\n    contractStartDate\n    isEnabled\n    isActive\n    contractStartDate\n    contractEndDate\n    createdAt\n    updatedAt\n    service {\n      id\n      name\n      description\n      defaultRate\n      billingUnit\n      category\n      isActive\n    }\n  }\n}\n\nquery GetBillingItemsByPayroll($payrollId: uuid!) {\n  billingItems(where: {payrollId: {_eq: $payrollId}}, orderBy: {createdAt: ASC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemsByStatus($isApproved: Boolean, $clientId: uuid) {\n  billingItems(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetAllbillingItems($searchTerm: String, $isApproved: Boolean, $limit: Int, $offset: Int) {\n  billingItems(orderBy: {createdAt: DESC}, limit: $limit, offset: $offset) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsWithSearch($searchTerm: String!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {_or: [{description: {_ilike: $searchTerm}}, {serviceName: {_ilike: $searchTerm}}, {client: {name: {_ilike: $searchTerm}}}]}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsByApproval($isApproved: Boolean!, $limit: Int, $offset: Int) {\n  billingItems(\n    where: {isApproved: {_eq: $isApproved}}\n    orderBy: {createdAt: DESC}\n    limit: $limit\n    offset: $offset\n  ) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetBillingItemsStats($isApproved: Boolean, $clientId: uuid) {\n  billingItemsAggregate(\n    where: {_and: [{isApproved: {_eq: $isApproved}}, {clientId: {_eq: $clientId}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        amount\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetBillingItemsByClient($clientId: uuid!) {\n  billingItems(where: {clientId: {_eq: $clientId}}, orderBy: {createdAt: DESC}) {\n    id\n    invoiceId\n    description\n    quantity\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n  }\n}\n\nquery GetBillingItemById($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    approvedByUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n}\n\nquery GetTimeEntriesByPayroll($payrollId: uuid!) {\n  timeEntries(where: {payrollId: {_eq: $payrollId}}, orderBy: {workDate: ASC}) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetTimeEntriesByStaff($staffUserId: uuid!, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    billingItemId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollWithBillingData($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    employeeCount\n    billingStatus\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    billingItems {\n      id\n      description\n      quantity\n      amount\n      serviceName\n      hourlyRate\n      isApproved\n    }\n    timeEntries {\n      id\n      staffUserId\n      workDate\n      hoursSpent\n      description\n    }\n  }\n}\n\nquery GetPayrollProfitability($startDate: timestamptz, $endDate: timestamptz) {\n  payrolls(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, billingStatus: {_neq: \"not_started\"}}\n    orderBy: {profitMargin: DESC}\n  ) {\n    id\n    name\n    clientId\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    billingStatus\n    client {\n      id\n      name\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}"): (typeof documents)["mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}"): (typeof documents)["query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0, $category: String) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid, $serviceId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, serviceId: {_eq: $serviceId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}"): (typeof documents)["fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0, $category: String) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid, $serviceId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, serviceId: {_eq: $serviceId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}"): (typeof documents)["fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}"): (typeof documents)["mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}"): (typeof documents)["query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}"): (typeof documents)["subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}"];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;