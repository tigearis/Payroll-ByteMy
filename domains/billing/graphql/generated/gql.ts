/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
    "fragment MonthlyBillingCompletionFragment on MonthlyBillingCompletion {\n  id\n  clientId\n  billingMonth\n  billingPeriodId\n  totalPayrolls\n  completedPayrolls\n  pendingPayrollIds\n  totalPayrollDates\n  completedPayrollDates\n  pendingPayrollDateIds\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  firstPayrollCompletedAt\n  lastPayrollCompletedAt\n  billingReadyAt\n  billingGeneratedAt\n  completionNotes\n  autoBillingEnabled\n  overrideCompletionDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollServiceAgreementFragment on PayrollServiceAgreements {\n  id\n  payrollId\n  serviceId\n  clientServiceAgreementId\n  customRate\n  customQuantity\n  customDescription\n  isOneTime\n  isActive\n  billingFrequency\n  autoBillingEnabled\n  billingNotes\n  billingItemsGenerated\n  generatedAt\n  generatedBy\n  serviceConfiguration\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithTierFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  billingTier\n  tierPriority\n  requiresPayrollCompletion\n  requiresMonthlyCompletion\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment UserRateHistoryFragment on UserRateHistory {\n  id\n  userId\n  hourlyRate\n  effectiveFrom\n  effectiveTo\n  rateType\n  costCenter\n  billingCategory\n  notes\n  createdAt\n  createdBy\n}\n\nfragment TimeEntryWithCostFragment on PayrollDateTimeEntries {\n  id\n  payrollDateId\n  userId\n  timeSpentMinutes\n  description\n  workDate\n  hourlyRateUsed\n  totalCost\n  costCenter\n  isBillable\n  createdAt\n  updatedAt\n}\n\nfragment MonthlyBillingDashboardFragment on MonthlyBillingDashboard {\n  id\n  clientId\n  clientName\n  billingMonth\n  billingMonthDisplay\n  totalPayrolls\n  completedPayrolls\n  totalPayrollDates\n  completedPayrollDates\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  billingReadyAt\n  billingGeneratedAt\n  completionPercentage\n  daysReadyForBilling\n  billingItemsCount\n  totalBillingAmount\n  activeServiceAgreements\n}\n\nfragment PayrollCostAnalysisFragment on PayrollCostAnalysis {\n  payrollDateId\n  payrollId\n  payrollName\n  clientId\n  clientName\n  billingMonth\n  payrollDateStatus\n  completedAt\n  completedBy\n  totalTimeMinutes\n  totalHours\n  totalInternalCost\n  uniqueUsersWorked\n  totalRevenue\n  billingItemsCount\n  estimatedProfit\n  profitMarginPercentage\n  revenuePerHour\n  costPerHour\n}\n\nfragment UserProductivityAnalysisFragment on UserProductivityAnalysis {\n  userId\n  firstName\n  lastName\n  computedName\n  defaultHourlyRate\n  costCenter\n  billingCategory\n  totalHoursLast30Days\n  totalInternalCost30d\n  payrollDatesWorked30d\n  totalRevenueGenerated30d\n  revenuePerHour30d\n  profitGenerated30d\n  efficiencyRatio30d\n}\n\nquery GetMonthlyBillingDashboard($limit: Int = 50, $offset: Int = 0, $clientId: uuid, $billingMonth: date, $status: monthly_billing_status) {\n  monthlyBillingDashboard(\n    limit: $limit\n    offset: $offset\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}, {status: {_eq: $status}}]}\n    orderBy: [{billingMonth: DESC}, {clientName: ASC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nquery GetMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!) {\n  monthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n  }\n}\n\nquery GetClientsReadyForBilling($limit: Int = 20, $billingMonth: date) {\n  monthlyBillingCompletion(\n    where: {status: {_eq: \"ready_to_bill\"}, billingMonth: {_eq: $billingMonth}, autoBillingEnabled: {_eq: true}}\n    limit: $limit\n    orderBy: [{billingReadyAt: ASC}]\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n      active\n    }\n  }\n}\n\nquery GetPayrollServiceAgreements($payrollId: uuid!, $isActive: Boolean = true) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}, isActive: {_eq: $isActive}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nquery GetServicesByTier($billingTier: billing_tier_level!, $isActive: Boolean = true, $limit: Int = 100) {\n  services(\n    where: {billingTier: {_eq: $billingTier}, isActive: {_eq: $isActive}}\n    limit: $limit\n    orderBy: [{tierPriority: ASC}, {name: ASC}]\n  ) {\n    ...ServiceWithTierFragment\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      id\n      clientId\n      customRate\n      billingFrequency\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery GetUserRateHistory($userId: uuid!, $limit: Int = 50) {\n  userRateHistory(\n    where: {userId: {_eq: $userId}}\n    limit: $limit\n    orderBy: [{effectiveFrom: DESC}]\n  ) {\n    ...UserRateHistoryFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n      billingCategory\n    }\n  }\n}\n\nquery GetCurrentUserRates($userIds: [uuid!], $effectiveDate: date = \"now()\") {\n  users(where: {id: {_in: $userIds}}) {\n    id\n    firstName\n    lastName\n    computedName\n    defaultHourlyRate\n    costCenter\n    billingCategory\n    rateEffectiveFrom\n    currentRate: userRateHistories(\n      where: {effectiveFrom: {_lte: $effectiveDate}, _or: [{effectiveTo: {_gte: $effectiveDate}}, {effectiveTo: {_isNull: true}}]}\n      orderBy: [{effectiveFrom: DESC}]\n      limit: 1\n    ) {\n      ...UserRateHistoryFragment\n    }\n  }\n}\n\nquery GetPayrollCostAnalysis($payrollDateId: uuid, $payrollId: uuid, $clientId: uuid, $billingMonth: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrollCostAnalysis(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{completedAt: DESC}]\n  ) {\n    ...PayrollCostAnalysisFragment\n  }\n}\n\nquery GetUserProductivityAnalysis($userIds: [uuid!], $limit: Int = 50) {\n  userProductivityAnalysis(\n    where: {userId: {_in: $userIds}}\n    limit: $limit\n    orderBy: [{revenuePerHour30d: DESC}]\n  ) {\n    ...UserProductivityAnalysisFragment\n  }\n}\n\nquery GetTimeEntriesWithCost($payrollDateId: uuid, $userId: uuid, $workDateFrom: date, $workDateTo: date, $limit: Int = 100, $offset: Int = 0) {\n  payrollDateTimeEntries(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {userId: {_eq: $userId}}, {workDate: {_gte: $workDateFrom}}, {workDate: {_lte: $workDateTo}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n    }\n    payrollDate {\n      id\n      payrollId\n      originalEftDate\n      adjustedEftDate\n      status\n      payroll {\n        id\n        name\n        client {\n          id\n          name\n        }\n      }\n    }\n  }\n}\n\nmutation CreatePayrollServiceAgreement($input: PayrollServiceAgreementsInsertInput!) {\n  insertPayrollServiceAgreementsOne(object: $input) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation UpdatePayrollServiceAgreement($id: uuid!, $updates: PayrollServiceAgreementsSetInput!) {\n  updatePayrollServiceAgreementsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation DeletePayrollServiceAgreement($id: uuid!) {\n  deletePayrollServiceAgreementsByPk(id: $id) {\n    id\n    payrollId\n    serviceId\n  }\n}\n\nmutation CreateUserRateHistory($input: UserRateHistoryInsertInput!) {\n  insertUserRateHistoryOne(object: $input) {\n    ...UserRateHistoryFragment\n  }\n}\n\nmutation UpdateUserHourlyRate($userId: uuid!, $defaultHourlyRate: numeric!, $rateEffectiveFrom: date = \"now()\", $costCenter: String, $billingCategory: String = \"consultant\") {\n  updateUsersByPk(\n    pkColumns: {id: $userId}\n    _set: {defaultHourlyRate: $defaultHourlyRate, rateEffectiveFrom: $rateEffectiveFrom, costCenter: $costCenter, billingCategory: $billingCategory}\n  ) {\n    id\n    firstName\n    lastName\n    defaultHourlyRate\n    rateEffectiveFrom\n    costCenter\n    billingCategory\n  }\n}\n\nmutation UpdateMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $updates: MonthlyBillingCompletionSetInput!) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: $updates\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation OverrideMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $overrideCompletionDate: date!, $completionNotes: String) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: {status: \"ready_to_bill\", overrideCompletionDate: $overrideCompletionDate, completionNotes: $completionNotes, billingReadyAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation AddTimeEntryWithCost($input: PayrollDateTimeEntriesInsertInput!) {\n  insertPayrollDateTimeEntriesOne(object: $input) {\n    ...TimeEntryWithCostFragment\n  }\n}\n\nmutation UpdateServiceBillingTier($serviceId: uuid!, $billingTier: billing_tier_level!, $tierPriority: Int = 100, $requiresPayrollCompletion: Boolean = false, $requiresMonthlyCompletion: Boolean = true) {\n  updateServicesByPk(\n    pkColumns: {id: $serviceId}\n    _set: {billingTier: $billingTier, tierPriority: $tierPriority, requiresPayrollCompletion: $requiresPayrollCompletion, requiresMonthlyCompletion: $requiresMonthlyCompletion}\n  ) {\n    ...ServiceWithTierFragment\n  }\n}\n\nsubscription MonthlyBillingDashboardSubscription($clientId: uuid, $billingMonth: date) {\n  monthlyBillingDashboard(\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    orderBy: [{billingMonth: DESC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nsubscription PayrollServiceAgreementsSubscription($payrollId: uuid!) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nsubscription TimeEntriesWithCostSubscription($payrollDateId: uuid!) {\n  payrollDateTimeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}": typeof types.MonthlyBillingCompletionFragmentFragmentDoc,
    "fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation CompletePayrollDateWithTime($id: uuid!, $completedBy: uuid!, $timeSpentMinutes: Int = 0, $completionNotes: String) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy, completionNotes: $completionNotes}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation AddPayrollDateTimeEntry($payrollDateId: uuid!, $userId: uuid!, $timeSpentMinutes: Int!, $description: String, $workDate: date) {\n  insertPayrollDateTimeEntriesOne(\n    object: {payrollDateId: $payrollDateId, userId: $userId, timeSpentMinutes: $timeSpentMinutes, description: $description, workDate: $workDate}\n    onConflict: {constraint: payroll_date_time_entries_payroll_date_id_user_id_work_date_key, updateColumns: [timeSpentMinutes, description, updatedAt]}\n  ) {\n    id\n    payrollDateId\n    userId\n    timeSpentMinutes\n    description\n    workDate\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}\n\nquery GetTimeEntriesByPayrollDocument($payrollId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollId: {_eq: $payrollId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n  timeEntriesAggregate(where: {payrollId: {_eq: $payrollId}}) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n      avg {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetTimeEntriesByPayrollDateDocument($payrollDateId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    payrollDateId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetTimeEntriesForBillingDocument($payrollId: uuid, $clientId: uuid, $staffUserId: uuid, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n  }\n  timeEntriesAggregate(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetPayrollByIdForBillingDocument($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      id\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetPayrollDatesWithBillingStatusDocument($limit: Int = 50, $offset: Int = 0, $status: String, $includeCompleted: Boolean = true) {\n  payrollDates(\n    where: {_and: [{status: {_eq: $status}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {adjustedEftDate: DESC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    notes\n    createdAt\n    updatedAt\n    payroll {\n      id\n      name\n      status\n      clientId\n      employeeCount\n      client {\n        id\n        name\n        contactEmail\n      }\n      primaryConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n      backupConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n    }\n    billingItems: billingItemsAggregate(where: {payrollId: {_eq: payrollId}}) {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetPayrollCompletionStatsDocument {\n  pendingPayrollDates: payrollDatesAggregate(\n    where: {status: {_in: [\"pending\", \"processing\"]}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  completedPayrollDates: payrollDatesAggregate(\n    where: {status: {_eq: \"completed\"}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  readyForBilling: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {_not: {billingItems: {}}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  billingGenerated: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {billingItems: {}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollDatesBillingReadyDocument($limit: Int = 20) {\n  payrollDates(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '7 days')\"}}, {_not: {billingItems: {}}}]}\n    limit: $limit\n    orderBy: {completedAt: DESC}\n  ) {\n    id\n    payrollId\n    adjustedEftDate\n    completedAt\n    completedBy\n    payroll {\n      id\n      name\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nmutation GenerateBillingFromPayrollDateDocument($payrollDateId: uuid!, $generatedBy: uuid!) {\n  insertBillingItemsOne(\n    object: {description: \"Auto-generated from payroll completion\", quantity: 1, unitPrice: 0, totalAmount: 0, status: \"draft\", staffUserId: $generatedBy}\n  ) {\n    id\n    description\n    status\n    createdAt\n  }\n}\n\nquery GetPayrollProfitabilityAnalytics($clientId: uuid, $dateFrom: timestamptz, $dateTo: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrolls(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $dateFrom}}, {createdAt: {_lte: $dateTo}}, {supersededDate: {_isNull: true}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    client {\n      id\n      name\n    }\n    status\n    createdAt\n    primaryConsultant {\n      id\n      firstName\n      lastName\n    }\n    backupConsultant {\n      id\n      firstName\n      lastName\n    }\n    billingItems(where: {status: {_eq: \"approved\"}}) {\n      id\n      amount\n      totalAmount\n      quantity\n      serviceName\n      createdAt\n    }\n    timeEntries {\n      id\n      hoursSpent\n      workDate\n      createdAt\n    }\n  }\n}\n\nquery GetStaffBillingPerformanceAnalytics($staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date, $limit: Int = 50) {\n  billingItems(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    amount\n    totalAmount\n    quantity\n    serviceName\n    createdAt\n    staffUser {\n      id\n      firstName\n      lastName\n      email\n      role\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n  timeEntries(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    hoursSpent\n    workDate\n    description\n    staffUser {\n      id\n      firstName\n      lastName\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n}\n\nquery GetProfitabilityStatsAdvanced($clientId: uuid, $staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date) {\n  totalRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  totalHours: timeEntriesAggregate(\n    where: {_and: [{workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  pendingRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"pending\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n}": typeof types.BillingItemCoreFragmentDoc,
    "mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}": typeof types.CreateTimeEntryWithUnitsDocument,
    "fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}": typeof types.ServiceCatalogFragmentFragmentDoc,
    "query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}": typeof types.GetInvoicesDocument,
    "mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}": typeof types.CreateQuoteDocument,
    "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}": typeof types.GetFinancialPerformanceDataDocument,
    "fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetServicesByCategory($limit: Int = 50, $offset: Int = 0, $category: String!) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetAllActiveServices($limit: Int = 100) {\n  services(limit: $limit, where: {isActive: {_eq: true}}, orderBy: [{name: ASC}]) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n    isActive\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}": typeof types.ServiceFragmentFragmentDoc,
    "fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}": typeof types.UserMinimalFragmentDoc,
    "mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}": typeof types.LogAuditEventDocument,
    "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}": typeof types.GetDashboardMetricsDocument,
    "subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}": typeof types.RecentActivityDocument,
};
const documents: Documents = {
    "fragment MonthlyBillingCompletionFragment on MonthlyBillingCompletion {\n  id\n  clientId\n  billingMonth\n  billingPeriodId\n  totalPayrolls\n  completedPayrolls\n  pendingPayrollIds\n  totalPayrollDates\n  completedPayrollDates\n  pendingPayrollDateIds\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  firstPayrollCompletedAt\n  lastPayrollCompletedAt\n  billingReadyAt\n  billingGeneratedAt\n  completionNotes\n  autoBillingEnabled\n  overrideCompletionDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollServiceAgreementFragment on PayrollServiceAgreements {\n  id\n  payrollId\n  serviceId\n  clientServiceAgreementId\n  customRate\n  customQuantity\n  customDescription\n  isOneTime\n  isActive\n  billingFrequency\n  autoBillingEnabled\n  billingNotes\n  billingItemsGenerated\n  generatedAt\n  generatedBy\n  serviceConfiguration\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithTierFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  billingTier\n  tierPriority\n  requiresPayrollCompletion\n  requiresMonthlyCompletion\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment UserRateHistoryFragment on UserRateHistory {\n  id\n  userId\n  hourlyRate\n  effectiveFrom\n  effectiveTo\n  rateType\n  costCenter\n  billingCategory\n  notes\n  createdAt\n  createdBy\n}\n\nfragment TimeEntryWithCostFragment on PayrollDateTimeEntries {\n  id\n  payrollDateId\n  userId\n  timeSpentMinutes\n  description\n  workDate\n  hourlyRateUsed\n  totalCost\n  costCenter\n  isBillable\n  createdAt\n  updatedAt\n}\n\nfragment MonthlyBillingDashboardFragment on MonthlyBillingDashboard {\n  id\n  clientId\n  clientName\n  billingMonth\n  billingMonthDisplay\n  totalPayrolls\n  completedPayrolls\n  totalPayrollDates\n  completedPayrollDates\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  billingReadyAt\n  billingGeneratedAt\n  completionPercentage\n  daysReadyForBilling\n  billingItemsCount\n  totalBillingAmount\n  activeServiceAgreements\n}\n\nfragment PayrollCostAnalysisFragment on PayrollCostAnalysis {\n  payrollDateId\n  payrollId\n  payrollName\n  clientId\n  clientName\n  billingMonth\n  payrollDateStatus\n  completedAt\n  completedBy\n  totalTimeMinutes\n  totalHours\n  totalInternalCost\n  uniqueUsersWorked\n  totalRevenue\n  billingItemsCount\n  estimatedProfit\n  profitMarginPercentage\n  revenuePerHour\n  costPerHour\n}\n\nfragment UserProductivityAnalysisFragment on UserProductivityAnalysis {\n  userId\n  firstName\n  lastName\n  computedName\n  defaultHourlyRate\n  costCenter\n  billingCategory\n  totalHoursLast30Days\n  totalInternalCost30d\n  payrollDatesWorked30d\n  totalRevenueGenerated30d\n  revenuePerHour30d\n  profitGenerated30d\n  efficiencyRatio30d\n}\n\nquery GetMonthlyBillingDashboard($limit: Int = 50, $offset: Int = 0, $clientId: uuid, $billingMonth: date, $status: monthly_billing_status) {\n  monthlyBillingDashboard(\n    limit: $limit\n    offset: $offset\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}, {status: {_eq: $status}}]}\n    orderBy: [{billingMonth: DESC}, {clientName: ASC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nquery GetMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!) {\n  monthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n  }\n}\n\nquery GetClientsReadyForBilling($limit: Int = 20, $billingMonth: date) {\n  monthlyBillingCompletion(\n    where: {status: {_eq: \"ready_to_bill\"}, billingMonth: {_eq: $billingMonth}, autoBillingEnabled: {_eq: true}}\n    limit: $limit\n    orderBy: [{billingReadyAt: ASC}]\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n      active\n    }\n  }\n}\n\nquery GetPayrollServiceAgreements($payrollId: uuid!, $isActive: Boolean = true) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}, isActive: {_eq: $isActive}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nquery GetServicesByTier($billingTier: billing_tier_level!, $isActive: Boolean = true, $limit: Int = 100) {\n  services(\n    where: {billingTier: {_eq: $billingTier}, isActive: {_eq: $isActive}}\n    limit: $limit\n    orderBy: [{tierPriority: ASC}, {name: ASC}]\n  ) {\n    ...ServiceWithTierFragment\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      id\n      clientId\n      customRate\n      billingFrequency\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery GetUserRateHistory($userId: uuid!, $limit: Int = 50) {\n  userRateHistory(\n    where: {userId: {_eq: $userId}}\n    limit: $limit\n    orderBy: [{effectiveFrom: DESC}]\n  ) {\n    ...UserRateHistoryFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n      billingCategory\n    }\n  }\n}\n\nquery GetCurrentUserRates($userIds: [uuid!], $effectiveDate: date = \"now()\") {\n  users(where: {id: {_in: $userIds}}) {\n    id\n    firstName\n    lastName\n    computedName\n    defaultHourlyRate\n    costCenter\n    billingCategory\n    rateEffectiveFrom\n    currentRate: userRateHistories(\n      where: {effectiveFrom: {_lte: $effectiveDate}, _or: [{effectiveTo: {_gte: $effectiveDate}}, {effectiveTo: {_isNull: true}}]}\n      orderBy: [{effectiveFrom: DESC}]\n      limit: 1\n    ) {\n      ...UserRateHistoryFragment\n    }\n  }\n}\n\nquery GetPayrollCostAnalysis($payrollDateId: uuid, $payrollId: uuid, $clientId: uuid, $billingMonth: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrollCostAnalysis(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{completedAt: DESC}]\n  ) {\n    ...PayrollCostAnalysisFragment\n  }\n}\n\nquery GetUserProductivityAnalysis($userIds: [uuid!], $limit: Int = 50) {\n  userProductivityAnalysis(\n    where: {userId: {_in: $userIds}}\n    limit: $limit\n    orderBy: [{revenuePerHour30d: DESC}]\n  ) {\n    ...UserProductivityAnalysisFragment\n  }\n}\n\nquery GetTimeEntriesWithCost($payrollDateId: uuid, $userId: uuid, $workDateFrom: date, $workDateTo: date, $limit: Int = 100, $offset: Int = 0) {\n  payrollDateTimeEntries(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {userId: {_eq: $userId}}, {workDate: {_gte: $workDateFrom}}, {workDate: {_lte: $workDateTo}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n    }\n    payrollDate {\n      id\n      payrollId\n      originalEftDate\n      adjustedEftDate\n      status\n      payroll {\n        id\n        name\n        client {\n          id\n          name\n        }\n      }\n    }\n  }\n}\n\nmutation CreatePayrollServiceAgreement($input: PayrollServiceAgreementsInsertInput!) {\n  insertPayrollServiceAgreementsOne(object: $input) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation UpdatePayrollServiceAgreement($id: uuid!, $updates: PayrollServiceAgreementsSetInput!) {\n  updatePayrollServiceAgreementsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation DeletePayrollServiceAgreement($id: uuid!) {\n  deletePayrollServiceAgreementsByPk(id: $id) {\n    id\n    payrollId\n    serviceId\n  }\n}\n\nmutation CreateUserRateHistory($input: UserRateHistoryInsertInput!) {\n  insertUserRateHistoryOne(object: $input) {\n    ...UserRateHistoryFragment\n  }\n}\n\nmutation UpdateUserHourlyRate($userId: uuid!, $defaultHourlyRate: numeric!, $rateEffectiveFrom: date = \"now()\", $costCenter: String, $billingCategory: String = \"consultant\") {\n  updateUsersByPk(\n    pkColumns: {id: $userId}\n    _set: {defaultHourlyRate: $defaultHourlyRate, rateEffectiveFrom: $rateEffectiveFrom, costCenter: $costCenter, billingCategory: $billingCategory}\n  ) {\n    id\n    firstName\n    lastName\n    defaultHourlyRate\n    rateEffectiveFrom\n    costCenter\n    billingCategory\n  }\n}\n\nmutation UpdateMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $updates: MonthlyBillingCompletionSetInput!) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: $updates\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation OverrideMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $overrideCompletionDate: date!, $completionNotes: String) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: {status: \"ready_to_bill\", overrideCompletionDate: $overrideCompletionDate, completionNotes: $completionNotes, billingReadyAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation AddTimeEntryWithCost($input: PayrollDateTimeEntriesInsertInput!) {\n  insertPayrollDateTimeEntriesOne(object: $input) {\n    ...TimeEntryWithCostFragment\n  }\n}\n\nmutation UpdateServiceBillingTier($serviceId: uuid!, $billingTier: billing_tier_level!, $tierPriority: Int = 100, $requiresPayrollCompletion: Boolean = false, $requiresMonthlyCompletion: Boolean = true) {\n  updateServicesByPk(\n    pkColumns: {id: $serviceId}\n    _set: {billingTier: $billingTier, tierPriority: $tierPriority, requiresPayrollCompletion: $requiresPayrollCompletion, requiresMonthlyCompletion: $requiresMonthlyCompletion}\n  ) {\n    ...ServiceWithTierFragment\n  }\n}\n\nsubscription MonthlyBillingDashboardSubscription($clientId: uuid, $billingMonth: date) {\n  monthlyBillingDashboard(\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    orderBy: [{billingMonth: DESC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nsubscription PayrollServiceAgreementsSubscription($payrollId: uuid!) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nsubscription TimeEntriesWithCostSubscription($payrollDateId: uuid!) {\n  payrollDateTimeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}": types.MonthlyBillingCompletionFragmentFragmentDoc,
    "fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation CompletePayrollDateWithTime($id: uuid!, $completedBy: uuid!, $timeSpentMinutes: Int = 0, $completionNotes: String) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy, completionNotes: $completionNotes}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation AddPayrollDateTimeEntry($payrollDateId: uuid!, $userId: uuid!, $timeSpentMinutes: Int!, $description: String, $workDate: date) {\n  insertPayrollDateTimeEntriesOne(\n    object: {payrollDateId: $payrollDateId, userId: $userId, timeSpentMinutes: $timeSpentMinutes, description: $description, workDate: $workDate}\n    onConflict: {constraint: payroll_date_time_entries_payroll_date_id_user_id_work_date_key, updateColumns: [timeSpentMinutes, description, updatedAt]}\n  ) {\n    id\n    payrollDateId\n    userId\n    timeSpentMinutes\n    description\n    workDate\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}\n\nquery GetTimeEntriesByPayrollDocument($payrollId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollId: {_eq: $payrollId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n  timeEntriesAggregate(where: {payrollId: {_eq: $payrollId}}) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n      avg {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetTimeEntriesByPayrollDateDocument($payrollDateId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    payrollDateId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetTimeEntriesForBillingDocument($payrollId: uuid, $clientId: uuid, $staffUserId: uuid, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n  }\n  timeEntriesAggregate(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetPayrollByIdForBillingDocument($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      id\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetPayrollDatesWithBillingStatusDocument($limit: Int = 50, $offset: Int = 0, $status: String, $includeCompleted: Boolean = true) {\n  payrollDates(\n    where: {_and: [{status: {_eq: $status}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {adjustedEftDate: DESC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    notes\n    createdAt\n    updatedAt\n    payroll {\n      id\n      name\n      status\n      clientId\n      employeeCount\n      client {\n        id\n        name\n        contactEmail\n      }\n      primaryConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n      backupConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n    }\n    billingItems: billingItemsAggregate(where: {payrollId: {_eq: payrollId}}) {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetPayrollCompletionStatsDocument {\n  pendingPayrollDates: payrollDatesAggregate(\n    where: {status: {_in: [\"pending\", \"processing\"]}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  completedPayrollDates: payrollDatesAggregate(\n    where: {status: {_eq: \"completed\"}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  readyForBilling: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {_not: {billingItems: {}}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  billingGenerated: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {billingItems: {}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollDatesBillingReadyDocument($limit: Int = 20) {\n  payrollDates(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '7 days')\"}}, {_not: {billingItems: {}}}]}\n    limit: $limit\n    orderBy: {completedAt: DESC}\n  ) {\n    id\n    payrollId\n    adjustedEftDate\n    completedAt\n    completedBy\n    payroll {\n      id\n      name\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nmutation GenerateBillingFromPayrollDateDocument($payrollDateId: uuid!, $generatedBy: uuid!) {\n  insertBillingItemsOne(\n    object: {description: \"Auto-generated from payroll completion\", quantity: 1, unitPrice: 0, totalAmount: 0, status: \"draft\", staffUserId: $generatedBy}\n  ) {\n    id\n    description\n    status\n    createdAt\n  }\n}\n\nquery GetPayrollProfitabilityAnalytics($clientId: uuid, $dateFrom: timestamptz, $dateTo: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrolls(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $dateFrom}}, {createdAt: {_lte: $dateTo}}, {supersededDate: {_isNull: true}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    client {\n      id\n      name\n    }\n    status\n    createdAt\n    primaryConsultant {\n      id\n      firstName\n      lastName\n    }\n    backupConsultant {\n      id\n      firstName\n      lastName\n    }\n    billingItems(where: {status: {_eq: \"approved\"}}) {\n      id\n      amount\n      totalAmount\n      quantity\n      serviceName\n      createdAt\n    }\n    timeEntries {\n      id\n      hoursSpent\n      workDate\n      createdAt\n    }\n  }\n}\n\nquery GetStaffBillingPerformanceAnalytics($staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date, $limit: Int = 50) {\n  billingItems(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    amount\n    totalAmount\n    quantity\n    serviceName\n    createdAt\n    staffUser {\n      id\n      firstName\n      lastName\n      email\n      role\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n  timeEntries(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    hoursSpent\n    workDate\n    description\n    staffUser {\n      id\n      firstName\n      lastName\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n}\n\nquery GetProfitabilityStatsAdvanced($clientId: uuid, $staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date) {\n  totalRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  totalHours: timeEntriesAggregate(\n    where: {_and: [{workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  pendingRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"pending\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n}": types.BillingItemCoreFragmentDoc,
    "mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}": types.CreateTimeEntryWithUnitsDocument,
    "fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}": types.ServiceCatalogFragmentFragmentDoc,
    "query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}": types.GetInvoicesDocument,
    "mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}": types.CreateQuoteDocument,
    "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}": types.GetFinancialPerformanceDataDocument,
    "fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetServicesByCategory($limit: Int = 50, $offset: Int = 0, $category: String!) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetAllActiveServices($limit: Int = 100) {\n  services(limit: $limit, where: {isActive: {_eq: true}}, orderBy: [{name: ASC}]) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n    isActive\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}": types.ServiceFragmentFragmentDoc,
    "fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}": types.UserMinimalFragmentDoc,
    "mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}": types.LogAuditEventDocument,
    "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}": types.GetDashboardMetricsDocument,
    "subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}": types.RecentActivityDocument,
};

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = gql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function gql(source: string): unknown;

/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment MonthlyBillingCompletionFragment on MonthlyBillingCompletion {\n  id\n  clientId\n  billingMonth\n  billingPeriodId\n  totalPayrolls\n  completedPayrolls\n  pendingPayrollIds\n  totalPayrollDates\n  completedPayrollDates\n  pendingPayrollDateIds\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  firstPayrollCompletedAt\n  lastPayrollCompletedAt\n  billingReadyAt\n  billingGeneratedAt\n  completionNotes\n  autoBillingEnabled\n  overrideCompletionDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollServiceAgreementFragment on PayrollServiceAgreements {\n  id\n  payrollId\n  serviceId\n  clientServiceAgreementId\n  customRate\n  customQuantity\n  customDescription\n  isOneTime\n  isActive\n  billingFrequency\n  autoBillingEnabled\n  billingNotes\n  billingItemsGenerated\n  generatedAt\n  generatedBy\n  serviceConfiguration\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithTierFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  billingTier\n  tierPriority\n  requiresPayrollCompletion\n  requiresMonthlyCompletion\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment UserRateHistoryFragment on UserRateHistory {\n  id\n  userId\n  hourlyRate\n  effectiveFrom\n  effectiveTo\n  rateType\n  costCenter\n  billingCategory\n  notes\n  createdAt\n  createdBy\n}\n\nfragment TimeEntryWithCostFragment on PayrollDateTimeEntries {\n  id\n  payrollDateId\n  userId\n  timeSpentMinutes\n  description\n  workDate\n  hourlyRateUsed\n  totalCost\n  costCenter\n  isBillable\n  createdAt\n  updatedAt\n}\n\nfragment MonthlyBillingDashboardFragment on MonthlyBillingDashboard {\n  id\n  clientId\n  clientName\n  billingMonth\n  billingMonthDisplay\n  totalPayrolls\n  completedPayrolls\n  totalPayrollDates\n  completedPayrollDates\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  billingReadyAt\n  billingGeneratedAt\n  completionPercentage\n  daysReadyForBilling\n  billingItemsCount\n  totalBillingAmount\n  activeServiceAgreements\n}\n\nfragment PayrollCostAnalysisFragment on PayrollCostAnalysis {\n  payrollDateId\n  payrollId\n  payrollName\n  clientId\n  clientName\n  billingMonth\n  payrollDateStatus\n  completedAt\n  completedBy\n  totalTimeMinutes\n  totalHours\n  totalInternalCost\n  uniqueUsersWorked\n  totalRevenue\n  billingItemsCount\n  estimatedProfit\n  profitMarginPercentage\n  revenuePerHour\n  costPerHour\n}\n\nfragment UserProductivityAnalysisFragment on UserProductivityAnalysis {\n  userId\n  firstName\n  lastName\n  computedName\n  defaultHourlyRate\n  costCenter\n  billingCategory\n  totalHoursLast30Days\n  totalInternalCost30d\n  payrollDatesWorked30d\n  totalRevenueGenerated30d\n  revenuePerHour30d\n  profitGenerated30d\n  efficiencyRatio30d\n}\n\nquery GetMonthlyBillingDashboard($limit: Int = 50, $offset: Int = 0, $clientId: uuid, $billingMonth: date, $status: monthly_billing_status) {\n  monthlyBillingDashboard(\n    limit: $limit\n    offset: $offset\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}, {status: {_eq: $status}}]}\n    orderBy: [{billingMonth: DESC}, {clientName: ASC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nquery GetMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!) {\n  monthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n  }\n}\n\nquery GetClientsReadyForBilling($limit: Int = 20, $billingMonth: date) {\n  monthlyBillingCompletion(\n    where: {status: {_eq: \"ready_to_bill\"}, billingMonth: {_eq: $billingMonth}, autoBillingEnabled: {_eq: true}}\n    limit: $limit\n    orderBy: [{billingReadyAt: ASC}]\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n      active\n    }\n  }\n}\n\nquery GetPayrollServiceAgreements($payrollId: uuid!, $isActive: Boolean = true) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}, isActive: {_eq: $isActive}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nquery GetServicesByTier($billingTier: billing_tier_level!, $isActive: Boolean = true, $limit: Int = 100) {\n  services(\n    where: {billingTier: {_eq: $billingTier}, isActive: {_eq: $isActive}}\n    limit: $limit\n    orderBy: [{tierPriority: ASC}, {name: ASC}]\n  ) {\n    ...ServiceWithTierFragment\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      id\n      clientId\n      customRate\n      billingFrequency\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery GetUserRateHistory($userId: uuid!, $limit: Int = 50) {\n  userRateHistory(\n    where: {userId: {_eq: $userId}}\n    limit: $limit\n    orderBy: [{effectiveFrom: DESC}]\n  ) {\n    ...UserRateHistoryFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n      billingCategory\n    }\n  }\n}\n\nquery GetCurrentUserRates($userIds: [uuid!], $effectiveDate: date = \"now()\") {\n  users(where: {id: {_in: $userIds}}) {\n    id\n    firstName\n    lastName\n    computedName\n    defaultHourlyRate\n    costCenter\n    billingCategory\n    rateEffectiveFrom\n    currentRate: userRateHistories(\n      where: {effectiveFrom: {_lte: $effectiveDate}, _or: [{effectiveTo: {_gte: $effectiveDate}}, {effectiveTo: {_isNull: true}}]}\n      orderBy: [{effectiveFrom: DESC}]\n      limit: 1\n    ) {\n      ...UserRateHistoryFragment\n    }\n  }\n}\n\nquery GetPayrollCostAnalysis($payrollDateId: uuid, $payrollId: uuid, $clientId: uuid, $billingMonth: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrollCostAnalysis(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{completedAt: DESC}]\n  ) {\n    ...PayrollCostAnalysisFragment\n  }\n}\n\nquery GetUserProductivityAnalysis($userIds: [uuid!], $limit: Int = 50) {\n  userProductivityAnalysis(\n    where: {userId: {_in: $userIds}}\n    limit: $limit\n    orderBy: [{revenuePerHour30d: DESC}]\n  ) {\n    ...UserProductivityAnalysisFragment\n  }\n}\n\nquery GetTimeEntriesWithCost($payrollDateId: uuid, $userId: uuid, $workDateFrom: date, $workDateTo: date, $limit: Int = 100, $offset: Int = 0) {\n  payrollDateTimeEntries(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {userId: {_eq: $userId}}, {workDate: {_gte: $workDateFrom}}, {workDate: {_lte: $workDateTo}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n    }\n    payrollDate {\n      id\n      payrollId\n      originalEftDate\n      adjustedEftDate\n      status\n      payroll {\n        id\n        name\n        client {\n          id\n          name\n        }\n      }\n    }\n  }\n}\n\nmutation CreatePayrollServiceAgreement($input: PayrollServiceAgreementsInsertInput!) {\n  insertPayrollServiceAgreementsOne(object: $input) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation UpdatePayrollServiceAgreement($id: uuid!, $updates: PayrollServiceAgreementsSetInput!) {\n  updatePayrollServiceAgreementsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation DeletePayrollServiceAgreement($id: uuid!) {\n  deletePayrollServiceAgreementsByPk(id: $id) {\n    id\n    payrollId\n    serviceId\n  }\n}\n\nmutation CreateUserRateHistory($input: UserRateHistoryInsertInput!) {\n  insertUserRateHistoryOne(object: $input) {\n    ...UserRateHistoryFragment\n  }\n}\n\nmutation UpdateUserHourlyRate($userId: uuid!, $defaultHourlyRate: numeric!, $rateEffectiveFrom: date = \"now()\", $costCenter: String, $billingCategory: String = \"consultant\") {\n  updateUsersByPk(\n    pkColumns: {id: $userId}\n    _set: {defaultHourlyRate: $defaultHourlyRate, rateEffectiveFrom: $rateEffectiveFrom, costCenter: $costCenter, billingCategory: $billingCategory}\n  ) {\n    id\n    firstName\n    lastName\n    defaultHourlyRate\n    rateEffectiveFrom\n    costCenter\n    billingCategory\n  }\n}\n\nmutation UpdateMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $updates: MonthlyBillingCompletionSetInput!) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: $updates\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation OverrideMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $overrideCompletionDate: date!, $completionNotes: String) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: {status: \"ready_to_bill\", overrideCompletionDate: $overrideCompletionDate, completionNotes: $completionNotes, billingReadyAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation AddTimeEntryWithCost($input: PayrollDateTimeEntriesInsertInput!) {\n  insertPayrollDateTimeEntriesOne(object: $input) {\n    ...TimeEntryWithCostFragment\n  }\n}\n\nmutation UpdateServiceBillingTier($serviceId: uuid!, $billingTier: billing_tier_level!, $tierPriority: Int = 100, $requiresPayrollCompletion: Boolean = false, $requiresMonthlyCompletion: Boolean = true) {\n  updateServicesByPk(\n    pkColumns: {id: $serviceId}\n    _set: {billingTier: $billingTier, tierPriority: $tierPriority, requiresPayrollCompletion: $requiresPayrollCompletion, requiresMonthlyCompletion: $requiresMonthlyCompletion}\n  ) {\n    ...ServiceWithTierFragment\n  }\n}\n\nsubscription MonthlyBillingDashboardSubscription($clientId: uuid, $billingMonth: date) {\n  monthlyBillingDashboard(\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    orderBy: [{billingMonth: DESC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nsubscription PayrollServiceAgreementsSubscription($payrollId: uuid!) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nsubscription TimeEntriesWithCostSubscription($payrollDateId: uuid!) {\n  payrollDateTimeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}"): (typeof documents)["fragment MonthlyBillingCompletionFragment on MonthlyBillingCompletion {\n  id\n  clientId\n  billingMonth\n  billingPeriodId\n  totalPayrolls\n  completedPayrolls\n  pendingPayrollIds\n  totalPayrollDates\n  completedPayrollDates\n  pendingPayrollDateIds\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  firstPayrollCompletedAt\n  lastPayrollCompletedAt\n  billingReadyAt\n  billingGeneratedAt\n  completionNotes\n  autoBillingEnabled\n  overrideCompletionDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollServiceAgreementFragment on PayrollServiceAgreements {\n  id\n  payrollId\n  serviceId\n  clientServiceAgreementId\n  customRate\n  customQuantity\n  customDescription\n  isOneTime\n  isActive\n  billingFrequency\n  autoBillingEnabled\n  billingNotes\n  billingItemsGenerated\n  generatedAt\n  generatedBy\n  serviceConfiguration\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithTierFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  billingTier\n  tierPriority\n  requiresPayrollCompletion\n  requiresMonthlyCompletion\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment UserRateHistoryFragment on UserRateHistory {\n  id\n  userId\n  hourlyRate\n  effectiveFrom\n  effectiveTo\n  rateType\n  costCenter\n  billingCategory\n  notes\n  createdAt\n  createdBy\n}\n\nfragment TimeEntryWithCostFragment on PayrollDateTimeEntries {\n  id\n  payrollDateId\n  userId\n  timeSpentMinutes\n  description\n  workDate\n  hourlyRateUsed\n  totalCost\n  costCenter\n  isBillable\n  createdAt\n  updatedAt\n}\n\nfragment MonthlyBillingDashboardFragment on MonthlyBillingDashboard {\n  id\n  clientId\n  clientName\n  billingMonth\n  billingMonthDisplay\n  totalPayrolls\n  completedPayrolls\n  totalPayrollDates\n  completedPayrollDates\n  status\n  tier1BillingGenerated\n  tier2BillingGenerated\n  tier3BillingGenerated\n  billingReadyAt\n  billingGeneratedAt\n  completionPercentage\n  daysReadyForBilling\n  billingItemsCount\n  totalBillingAmount\n  activeServiceAgreements\n}\n\nfragment PayrollCostAnalysisFragment on PayrollCostAnalysis {\n  payrollDateId\n  payrollId\n  payrollName\n  clientId\n  clientName\n  billingMonth\n  payrollDateStatus\n  completedAt\n  completedBy\n  totalTimeMinutes\n  totalHours\n  totalInternalCost\n  uniqueUsersWorked\n  totalRevenue\n  billingItemsCount\n  estimatedProfit\n  profitMarginPercentage\n  revenuePerHour\n  costPerHour\n}\n\nfragment UserProductivityAnalysisFragment on UserProductivityAnalysis {\n  userId\n  firstName\n  lastName\n  computedName\n  defaultHourlyRate\n  costCenter\n  billingCategory\n  totalHoursLast30Days\n  totalInternalCost30d\n  payrollDatesWorked30d\n  totalRevenueGenerated30d\n  revenuePerHour30d\n  profitGenerated30d\n  efficiencyRatio30d\n}\n\nquery GetMonthlyBillingDashboard($limit: Int = 50, $offset: Int = 0, $clientId: uuid, $billingMonth: date, $status: monthly_billing_status) {\n  monthlyBillingDashboard(\n    limit: $limit\n    offset: $offset\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}, {status: {_eq: $status}}]}\n    orderBy: [{billingMonth: DESC}, {clientName: ASC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nquery GetMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!) {\n  monthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n    }\n  }\n}\n\nquery GetClientsReadyForBilling($limit: Int = 20, $billingMonth: date) {\n  monthlyBillingCompletion(\n    where: {status: {_eq: \"ready_to_bill\"}, billingMonth: {_eq: $billingMonth}, autoBillingEnabled: {_eq: true}}\n    limit: $limit\n    orderBy: [{billingReadyAt: ASC}]\n  ) {\n    ...MonthlyBillingCompletionFragment\n    client {\n      id\n      name\n      contactEmail\n      active\n    }\n  }\n}\n\nquery GetPayrollServiceAgreements($payrollId: uuid!, $isActive: Boolean = true) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}, isActive: {_eq: $isActive}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nquery GetServicesByTier($billingTier: billing_tier_level!, $isActive: Boolean = true, $limit: Int = 100) {\n  services(\n    where: {billingTier: {_eq: $billingTier}, isActive: {_eq: $isActive}}\n    limit: $limit\n    orderBy: [{tierPriority: ASC}, {name: ASC}]\n  ) {\n    ...ServiceWithTierFragment\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      id\n      clientId\n      customRate\n      billingFrequency\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nquery GetUserRateHistory($userId: uuid!, $limit: Int = 50) {\n  userRateHistory(\n    where: {userId: {_eq: $userId}}\n    limit: $limit\n    orderBy: [{effectiveFrom: DESC}]\n  ) {\n    ...UserRateHistoryFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n      billingCategory\n    }\n  }\n}\n\nquery GetCurrentUserRates($userIds: [uuid!], $effectiveDate: date = \"now()\") {\n  users(where: {id: {_in: $userIds}}) {\n    id\n    firstName\n    lastName\n    computedName\n    defaultHourlyRate\n    costCenter\n    billingCategory\n    rateEffectiveFrom\n    currentRate: userRateHistories(\n      where: {effectiveFrom: {_lte: $effectiveDate}, _or: [{effectiveTo: {_gte: $effectiveDate}}, {effectiveTo: {_isNull: true}}]}\n      orderBy: [{effectiveFrom: DESC}]\n      limit: 1\n    ) {\n      ...UserRateHistoryFragment\n    }\n  }\n}\n\nquery GetPayrollCostAnalysis($payrollDateId: uuid, $payrollId: uuid, $clientId: uuid, $billingMonth: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrollCostAnalysis(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{completedAt: DESC}]\n  ) {\n    ...PayrollCostAnalysisFragment\n  }\n}\n\nquery GetUserProductivityAnalysis($userIds: [uuid!], $limit: Int = 50) {\n  userProductivityAnalysis(\n    where: {userId: {_in: $userIds}}\n    limit: $limit\n    orderBy: [{revenuePerHour30d: DESC}]\n  ) {\n    ...UserProductivityAnalysisFragment\n  }\n}\n\nquery GetTimeEntriesWithCost($payrollDateId: uuid, $userId: uuid, $workDateFrom: date, $workDateTo: date, $limit: Int = 100, $offset: Int = 0) {\n  payrollDateTimeEntries(\n    where: {_and: [{payrollDateId: {_eq: $payrollDateId}}, {userId: {_eq: $userId}}, {workDate: {_gte: $workDateFrom}}, {workDate: {_lte: $workDateTo}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n      defaultHourlyRate\n      costCenter\n    }\n    payrollDate {\n      id\n      payrollId\n      originalEftDate\n      adjustedEftDate\n      status\n      payroll {\n        id\n        name\n        client {\n          id\n          name\n        }\n      }\n    }\n  }\n}\n\nmutation CreatePayrollServiceAgreement($input: PayrollServiceAgreementsInsertInput!) {\n  insertPayrollServiceAgreementsOne(object: $input) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation UpdatePayrollServiceAgreement($id: uuid!, $updates: PayrollServiceAgreementsSetInput!) {\n  updatePayrollServiceAgreementsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nmutation DeletePayrollServiceAgreement($id: uuid!) {\n  deletePayrollServiceAgreementsByPk(id: $id) {\n    id\n    payrollId\n    serviceId\n  }\n}\n\nmutation CreateUserRateHistory($input: UserRateHistoryInsertInput!) {\n  insertUserRateHistoryOne(object: $input) {\n    ...UserRateHistoryFragment\n  }\n}\n\nmutation UpdateUserHourlyRate($userId: uuid!, $defaultHourlyRate: numeric!, $rateEffectiveFrom: date = \"now()\", $costCenter: String, $billingCategory: String = \"consultant\") {\n  updateUsersByPk(\n    pkColumns: {id: $userId}\n    _set: {defaultHourlyRate: $defaultHourlyRate, rateEffectiveFrom: $rateEffectiveFrom, costCenter: $costCenter, billingCategory: $billingCategory}\n  ) {\n    id\n    firstName\n    lastName\n    defaultHourlyRate\n    rateEffectiveFrom\n    costCenter\n    billingCategory\n  }\n}\n\nmutation UpdateMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $updates: MonthlyBillingCompletionSetInput!) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: $updates\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation OverrideMonthlyBillingCompletion($clientId: uuid!, $billingMonth: date!, $overrideCompletionDate: date!, $completionNotes: String) {\n  updateMonthlyBillingCompletion(\n    where: {clientId: {_eq: $clientId}, billingMonth: {_eq: $billingMonth}}\n    _set: {status: \"ready_to_bill\", overrideCompletionDate: $overrideCompletionDate, completionNotes: $completionNotes, billingReadyAt: \"now()\"}\n  ) {\n    affectedRows\n    returning {\n      ...MonthlyBillingCompletionFragment\n    }\n  }\n}\n\nmutation AddTimeEntryWithCost($input: PayrollDateTimeEntriesInsertInput!) {\n  insertPayrollDateTimeEntriesOne(object: $input) {\n    ...TimeEntryWithCostFragment\n  }\n}\n\nmutation UpdateServiceBillingTier($serviceId: uuid!, $billingTier: billing_tier_level!, $tierPriority: Int = 100, $requiresPayrollCompletion: Boolean = false, $requiresMonthlyCompletion: Boolean = true) {\n  updateServicesByPk(\n    pkColumns: {id: $serviceId}\n    _set: {billingTier: $billingTier, tierPriority: $tierPriority, requiresPayrollCompletion: $requiresPayrollCompletion, requiresMonthlyCompletion: $requiresMonthlyCompletion}\n  ) {\n    ...ServiceWithTierFragment\n  }\n}\n\nsubscription MonthlyBillingDashboardSubscription($clientId: uuid, $billingMonth: date) {\n  monthlyBillingDashboard(\n    where: {_and: [{clientId: {_eq: $clientId}}, {billingMonth: {_eq: $billingMonth}}]}\n    orderBy: [{billingMonth: DESC}]\n  ) {\n    ...MonthlyBillingDashboardFragment\n  }\n}\n\nsubscription PayrollServiceAgreementsSubscription($payrollId: uuid!) {\n  payrollServiceAgreements(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: [{createdAt: DESC}]\n  ) {\n    ...PayrollServiceAgreementFragment\n  }\n}\n\nsubscription TimeEntriesWithCostSubscription($payrollDateId: uuid!) {\n  payrollDateTimeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    orderBy: [{workDate: DESC}, {createdAt: DESC}]\n  ) {\n    ...TimeEntryWithCostFragment\n    user {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation CompletePayrollDateWithTime($id: uuid!, $completedBy: uuid!, $timeSpentMinutes: Int = 0, $completionNotes: String) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy, completionNotes: $completionNotes}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation AddPayrollDateTimeEntry($payrollDateId: uuid!, $userId: uuid!, $timeSpentMinutes: Int!, $description: String, $workDate: date) {\n  insertPayrollDateTimeEntriesOne(\n    object: {payrollDateId: $payrollDateId, userId: $userId, timeSpentMinutes: $timeSpentMinutes, description: $description, workDate: $workDate}\n    onConflict: {constraint: payroll_date_time_entries_payroll_date_id_user_id_work_date_key, updateColumns: [timeSpentMinutes, description, updatedAt]}\n  ) {\n    id\n    payrollDateId\n    userId\n    timeSpentMinutes\n    description\n    workDate\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}\n\nquery GetTimeEntriesByPayrollDocument($payrollId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollId: {_eq: $payrollId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n  timeEntriesAggregate(where: {payrollId: {_eq: $payrollId}}) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n      avg {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetTimeEntriesByPayrollDateDocument($payrollDateId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    payrollDateId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetTimeEntriesForBillingDocument($payrollId: uuid, $clientId: uuid, $staffUserId: uuid, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n  }\n  timeEntriesAggregate(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetPayrollByIdForBillingDocument($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      id\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetPayrollDatesWithBillingStatusDocument($limit: Int = 50, $offset: Int = 0, $status: String, $includeCompleted: Boolean = true) {\n  payrollDates(\n    where: {_and: [{status: {_eq: $status}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {adjustedEftDate: DESC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    notes\n    createdAt\n    updatedAt\n    payroll {\n      id\n      name\n      status\n      clientId\n      employeeCount\n      client {\n        id\n        name\n        contactEmail\n      }\n      primaryConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n      backupConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n    }\n    billingItems: billingItemsAggregate(where: {payrollId: {_eq: payrollId}}) {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetPayrollCompletionStatsDocument {\n  pendingPayrollDates: payrollDatesAggregate(\n    where: {status: {_in: [\"pending\", \"processing\"]}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  completedPayrollDates: payrollDatesAggregate(\n    where: {status: {_eq: \"completed\"}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  readyForBilling: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {_not: {billingItems: {}}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  billingGenerated: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {billingItems: {}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollDatesBillingReadyDocument($limit: Int = 20) {\n  payrollDates(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '7 days')\"}}, {_not: {billingItems: {}}}]}\n    limit: $limit\n    orderBy: {completedAt: DESC}\n  ) {\n    id\n    payrollId\n    adjustedEftDate\n    completedAt\n    completedBy\n    payroll {\n      id\n      name\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nmutation GenerateBillingFromPayrollDateDocument($payrollDateId: uuid!, $generatedBy: uuid!) {\n  insertBillingItemsOne(\n    object: {description: \"Auto-generated from payroll completion\", quantity: 1, unitPrice: 0, totalAmount: 0, status: \"draft\", staffUserId: $generatedBy}\n  ) {\n    id\n    description\n    status\n    createdAt\n  }\n}\n\nquery GetPayrollProfitabilityAnalytics($clientId: uuid, $dateFrom: timestamptz, $dateTo: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrolls(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $dateFrom}}, {createdAt: {_lte: $dateTo}}, {supersededDate: {_isNull: true}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    client {\n      id\n      name\n    }\n    status\n    createdAt\n    primaryConsultant {\n      id\n      firstName\n      lastName\n    }\n    backupConsultant {\n      id\n      firstName\n      lastName\n    }\n    billingItems(where: {status: {_eq: \"approved\"}}) {\n      id\n      amount\n      totalAmount\n      quantity\n      serviceName\n      createdAt\n    }\n    timeEntries {\n      id\n      hoursSpent\n      workDate\n      createdAt\n    }\n  }\n}\n\nquery GetStaffBillingPerformanceAnalytics($staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date, $limit: Int = 50) {\n  billingItems(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    amount\n    totalAmount\n    quantity\n    serviceName\n    createdAt\n    staffUser {\n      id\n      firstName\n      lastName\n      email\n      role\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n  timeEntries(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    hoursSpent\n    workDate\n    description\n    staffUser {\n      id\n      firstName\n      lastName\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n}\n\nquery GetProfitabilityStatsAdvanced($clientId: uuid, $staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date) {\n  totalRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  totalHours: timeEntriesAggregate(\n    where: {_and: [{workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  pendingRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"pending\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n}"): (typeof documents)["fragment BillingItemCore on BillingItems {\n  id\n  description\n  amount\n  quantity\n  unitPrice\n  totalAmount\n  status\n  notes\n  createdAt\n  updatedAt\n  approvalDate\n  isApproved\n  clientId\n  staffUserId\n  approvedBy\n  confirmedAt\n  confirmedBy\n  payrollId\n  serviceId\n  serviceName\n  hourlyRate\n  invoiceId\n}\n\nfragment BillingItemWithRelations on BillingItems {\n  ...BillingItemCore\n  client {\n    id\n    name\n    contactEmail\n  }\n  staffUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  approvedByUser {\n    id\n    firstName\n    lastName\n    email\n  }\n  payroll {\n    id\n    name\n    status\n  }\n  service {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n  }\n}\n\nfragment BillingItemStats on BillingItemsAggregate {\n  aggregate {\n    count\n    sum {\n      amount\n      totalAmount\n      quantity\n    }\n    avg {\n      amount\n      totalAmount\n      quantity\n    }\n  }\n}\n\nquery GetBillingItemsAdvanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemByIdAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsStatsAdvanced($where: BillingItemsBoolExp = {}) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n  pending: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"pending\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  approved: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"approved\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n  rejected: billingItemsAggregate(\n    where: {_and: [$where, {status: {_eq: \"rejected\"}}]}\n  ) {\n    ...BillingItemStats\n  }\n}\n\nquery GetBillingItemsByClientAdvanced($clientId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetBillingItemsByUserAdvanced($userId: uuid!, $limit: Int = 50, $offset: Int = 0, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(\n    where: {staffUserId: {_eq: $userId}}\n    limit: $limit\n    offset: $offset\n    orderBy: $orderBy\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nquery GetRecentBillingItemsAdvanced($limit: Int = 10, $days: Int = 30) {\n  billingItems(\n    where: {createdAt: {_gte: \"date_trunc('day', now() - interval '$days days')\"}}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation UpdateBillingItemAdvanced($id: uuid!, $updates: BillingItemsSetInput!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: $updates) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation DeleteBillingItemAdvanced($id: uuid!) {\n  deleteBillingItemsByPk(id: $id) {\n    id\n    description\n  }\n}\n\nmutation BulkUpdateBillingItemsStatusAdvanced($ids: [uuid!]!, $status: String!, $approvedBy: uuid) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $ids}}, _set: {status: $status, approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation ApproveBillingItemAdvanced($id: uuid!, $approvedBy: uuid!) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"approved\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: true}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation RejectBillingItemAdvanced($id: uuid!, $approvedBy: uuid!, $notes: String) {\n  updateBillingItemsByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"rejected\", approvedBy: $approvedBy, approvalDate: \"now()\", isApproved: false, notes: $notes}\n  ) {\n    ...BillingItemWithRelations\n  }\n}\n\nmutation ArchiveBillingItemAdvanced($id: uuid!) {\n  updateBillingItemsByPk(pkColumns: {id: $id}, _set: {status: \"archived\"}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsSubscriptionAdvanced($where: BillingItemsBoolExp, $limit: Int = 50) {\n  billingItems(where: $where, limit: $limit, orderBy: {createdAt: DESC}) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {\n  billingItemsByPk(id: $id) {\n    ...BillingItemWithRelations\n  }\n}\n\nsubscription BillingItemsStatsSubscriptionAdvanced($where: BillingItemsBoolExp) {\n  billingItemsAggregate(where: $where) {\n    ...BillingItemStats\n  }\n}\n\nmutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation CompletePayrollDateWithTime($id: uuid!, $completedBy: uuid!, $timeSpentMinutes: Int = 0, $completionNotes: String) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"completed\", completedAt: \"now()\", completedBy: $completedBy, completionNotes: $completionNotes}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n  }\n}\n\nmutation AddPayrollDateTimeEntry($payrollDateId: uuid!, $userId: uuid!, $timeSpentMinutes: Int!, $description: String, $workDate: date) {\n  insertPayrollDateTimeEntriesOne(\n    object: {payrollDateId: $payrollDateId, userId: $userId, timeSpentMinutes: $timeSpentMinutes, description: $description, workDate: $workDate}\n    onConflict: {constraint: payroll_date_time_entries_payroll_date_id_user_id_work_date_key, updateColumns: [timeSpentMinutes, description, updatedAt]}\n  ) {\n    id\n    payrollDateId\n    userId\n    timeSpentMinutes\n    description\n    workDate\n    createdAt\n    updatedAt\n  }\n}\n\nmutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {\n  updatePayrollDatesByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, updatedAt: \"now()\", completedBy: $updatedBy}\n  ) {\n    id\n    status\n    completedAt\n    completedBy\n    payrollId\n  }\n}\n\nquery GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}, _and: {status: {_eq: $status}}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetPayrollDatesWithStatus($payrollId: uuid!) {\n  payrollDates(\n    where: {payrollId: {_eq: $payrollId}}\n    orderBy: {adjustedEftDate: ASC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    notes\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientsForBillingItemsAdvanced {\n  clients(where: {active: {_eq: true}}, orderBy: {name: ASC}) {\n    id\n    name\n    contactEmail\n    active\n  }\n}\n\nquery GetUsersForBillingItemsAdvanced {\n  users(\n    where: {isActive: {_eq: true}}\n    orderBy: [{firstName: ASC}, {lastName: ASC}]\n  ) {\n    id\n    firstName\n    lastName\n    email\n    role\n  }\n}\n\nquery GetBillingItemAuditLogAdvanced($billingItemId: String!, $limit: Int = 50, $offset: Int = 0) {\n  auditAuditLog(\n    where: {_and: [{resourceType: {_eq: \"billing_items\"}}, {resourceId: {_eq: $billingItemId}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    action\n    oldValues\n    newValues\n    createdAt\n    ipAddress\n    userAgent\n    userId\n    userEmail\n    userRole\n  }\n}\n\nquery GetTimeEntriesByPayrollDocument($payrollId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollId: {_eq: $payrollId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n    payroll {\n      id\n      name\n      status\n    }\n  }\n  timeEntriesAggregate(where: {payrollId: {_eq: $payrollId}}) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n      avg {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetTimeEntriesByPayrollDateDocument($payrollDateId: uuid!, $limit: Int = 100, $offset: Int = 0) {\n  timeEntries(\n    where: {payrollDateId: {_eq: $payrollDateId}}\n    limit: $limit\n    offset: $offset\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    payrollDateId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n    }\n  }\n}\n\nquery GetTimeEntriesForBillingDocument($payrollId: uuid, $clientId: uuid, $staffUserId: uuid, $startDate: date, $endDate: date) {\n  timeEntries(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    payrollId\n    clientId\n    staffUserId\n    hoursSpent\n    description\n    workDate\n    createdAt\n    client {\n      id\n      name\n    }\n    staffUser {\n      id\n      firstName\n      lastName\n      computedName\n      email\n    }\n  }\n  timeEntriesAggregate(\n    where: {_and: [{payrollId: {_eq: $payrollId}}, {clientId: {_eq: $clientId}}, {staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        hoursSpent\n      }\n    }\n  }\n}\n\nquery GetPayrollByIdForBillingDocument($payrollId: uuid!) {\n  payrollsByPk(id: $payrollId) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      id\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetPayrollDatesWithBillingStatusDocument($limit: Int = 50, $offset: Int = 0, $status: String, $includeCompleted: Boolean = true) {\n  payrollDates(\n    where: {_and: [{status: {_eq: $status}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {adjustedEftDate: DESC}\n  ) {\n    id\n    payrollId\n    originalEftDate\n    adjustedEftDate\n    processingDate\n    status\n    completedAt\n    completedBy\n    totalTimeSpentMinutes\n    completionNotes\n    notes\n    createdAt\n    updatedAt\n    payroll {\n      id\n      name\n      status\n      clientId\n      employeeCount\n      client {\n        id\n        name\n        contactEmail\n      }\n      primaryConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n      backupConsultant {\n        id\n        firstName\n        lastName\n        computedName\n      }\n    }\n    billingItems: billingItemsAggregate(where: {payrollId: {_eq: payrollId}}) {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetPayrollCompletionStatsDocument {\n  pendingPayrollDates: payrollDatesAggregate(\n    where: {status: {_in: [\"pending\", \"processing\"]}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  completedPayrollDates: payrollDatesAggregate(\n    where: {status: {_eq: \"completed\"}, adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  readyForBilling: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {_not: {billingItems: {}}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  billingGenerated: payrollDatesAggregate(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '30 days')\"}}, {billingItems: {}}]}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollDatesBillingReadyDocument($limit: Int = 20) {\n  payrollDates(\n    where: {_and: [{status: {_eq: \"completed\"}}, {adjustedEftDate: {_gte: \"date_trunc('day', now() - interval '7 days')\"}}, {_not: {billingItems: {}}}]}\n    limit: $limit\n    orderBy: {completedAt: DESC}\n  ) {\n    id\n    payrollId\n    adjustedEftDate\n    completedAt\n    completedBy\n    payroll {\n      id\n      name\n      client {\n        id\n        name\n      }\n    }\n  }\n}\n\nmutation GenerateBillingFromPayrollDateDocument($payrollDateId: uuid!, $generatedBy: uuid!) {\n  insertBillingItemsOne(\n    object: {description: \"Auto-generated from payroll completion\", quantity: 1, unitPrice: 0, totalAmount: 0, status: \"draft\", staffUserId: $generatedBy}\n  ) {\n    id\n    description\n    status\n    createdAt\n  }\n}\n\nquery GetPayrollProfitabilityAnalytics($clientId: uuid, $dateFrom: timestamptz, $dateTo: timestamptz, $limit: Int = 50, $offset: Int = 0) {\n  payrolls(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $dateFrom}}, {createdAt: {_lte: $dateTo}}, {supersededDate: {_isNull: true}}]}\n    limit: $limit\n    offset: $offset\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    client {\n      id\n      name\n    }\n    status\n    createdAt\n    primaryConsultant {\n      id\n      firstName\n      lastName\n    }\n    backupConsultant {\n      id\n      firstName\n      lastName\n    }\n    billingItems(where: {status: {_eq: \"approved\"}}) {\n      id\n      amount\n      totalAmount\n      quantity\n      serviceName\n      createdAt\n    }\n    timeEntries {\n      id\n      hoursSpent\n      workDate\n      createdAt\n    }\n  }\n}\n\nquery GetStaffBillingPerformanceAnalytics($staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date, $limit: Int = 50) {\n  billingItems(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n    limit: $limit\n    orderBy: {createdAt: DESC}\n  ) {\n    id\n    amount\n    totalAmount\n    quantity\n    serviceName\n    createdAt\n    staffUser {\n      id\n      firstName\n      lastName\n      email\n      role\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n  timeEntries(\n    where: {_and: [{staffUserId: {_eq: $staffUserId}}, {workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    hoursSpent\n    workDate\n    description\n    staffUser {\n      id\n      firstName\n      lastName\n    }\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n  }\n}\n\nquery GetProfitabilityStatsAdvanced($clientId: uuid, $staffUserId: uuid, $timestampFrom: timestamp, $timestampTo: timestamp, $dateFrom: date, $dateTo: date) {\n  totalRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"approved\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  totalHours: timeEntriesAggregate(\n    where: {_and: [{workDate: {_gte: $dateFrom}}, {workDate: {_lte: $dateTo}}]}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  pendingRevenue: billingItemsAggregate(\n    where: {_and: [{createdAt: {_gte: $timestampFrom}}, {createdAt: {_lte: $timestampTo}}, {status: {_eq: \"pending\"}}]}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}"): (typeof documents)["mutation CreateTimeEntryWithUnits($input: TimeEntriesInsertInput!) {\n  insertTimeEntriesOne(object: $input) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    payrollDateId\n    workDate\n    hoursSpent\n    description\n    createdAt\n    updatedAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation UpdateTimeEntryWithUnits($id: uuid!, $changes: TimeEntriesSetInput!) {\n  updateTimeEntriesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    hoursSpent\n    updatedAt\n  }\n}\n\nquery GetTimeTrackingSummary($staffUserId: uuid, $clientId: uuid, $startDate: date!, $endDate: date!) {\n  timeEntries(\n    where: {staffUserId: {_eq: $staffUserId}, clientId: {_eq: $clientId}, workDate: {_gte: $startDate, _lte: $endDate}}\n    orderBy: {workDate: DESC}\n  ) {\n    id\n    staffUserId\n    clientId\n    payrollId\n    workDate\n    hoursSpent\n    description\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nquery GetBillableTimeSummary($clientId: uuid!, $billingPeriodStart: date!, $billingPeriodEnd: date!) {\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    workDate\n    hoursSpent\n    description\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n}\n\nmutation CreateBillingItemWithQuote($input: BillingItemsInsertInput!) {\n  insertBillingItemsOne(object: $input) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetBillingItemsEnhanced($limit: Int = 50, $offset: Int = 0, $where: BillingItemsBoolExp, $orderBy: [BillingItemsOrderBy!] = [{createdAt: DESC}]) {\n  billingItems(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    clientId\n    payrollId\n    payrollDateId\n    serviceId\n    quantity\n    unitPrice\n    amount\n    description\n    status\n    staffUserId\n    notes\n    confirmedAt\n    confirmedBy\n    createdAt\n    client {\n      id\n      name\n    }\n    payroll {\n      id\n      name\n    }\n    service {\n      id\n      name\n      category\n      billingUnit\n    }\n  }\n}\n\nquery GetPendingBillingApprovals($limit: Int = 100) {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: $limit\n  ) {\n    id\n    payrollId\n    clientId\n    serviceId\n    description\n    quantity\n    unitPrice\n    amount\n    staffUserId\n    createdAt\n    client {\n      name\n    }\n    service {\n      name\n      category\n    }\n    payroll {\n      name\n    }\n  }\n}\n\nmutation ApproveBillingItemsBulk($itemIds: [uuid!]!, $approvedByUserId: uuid!, $approvalNotes: String) {\n  updateBillingItems(\n    where: {id: {_in: $itemIds}, status: {_eq: \"draft\"}}\n    _set: {status: \"confirmed\", confirmedBy: $approvedByUserId, confirmedAt: \"now()\", notes: $approvalNotes}\n  ) {\n    returning {\n      id\n      status\n      confirmedAt\n      amount\n    }\n    affectedRows\n  }\n}\n\nmutation GenerateAutoBillingForPayroll($payrollId: uuid!) {\n  updatePayrollsByPk(\n    pkColumns: {id: $payrollId}\n    _set: {billingStatus: \"ready_to_bill\"}\n  ) {\n    id\n    billingStatus\n    estimatedRevenue\n    updatedAt\n  }\n}\n\nquery GetBillingAutomationMetrics {\n  autoGeneratedItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: true}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  manualItems: billingItemsAggregate(where: {isAutoGenerated: {_eq: false}}) {\n    aggregate {\n      count\n      sum {\n        amount\n      }\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {status: {_eq: \"confirmed\"}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetPayrollBillingStatus($clientId: uuid, $billingStatus: String) {\n  payrolls(\n    where: {clientId: {_eq: $clientId}, billingStatus: {_eq: $billingStatus}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    name\n    clientId\n    billingStatus\n    payslipCount\n    employeeCount\n    newEmployees\n    terminatedEmployees\n    estimatedRevenue\n    actualRevenue\n    estimatedHours\n    actualHours\n    profitMargin\n    lastBilledDate\n    client {\n      name\n    }\n    billingItems(where: {status: {_neq: \"draft\"}}) {\n      id\n      amount\n      status\n    }\n  }\n}\n\nquery GetEnhancedClientProfitabilityAnalysis($clientId: uuid!, $startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!) {\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n      avg {\n        amount\n      }\n    }\n  }\n  timeEntriesAggregate(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    aggregate {\n      sum {\n        hoursSpent\n      }\n      count\n    }\n  }\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      name\n      category\n    }\n    amount\n    quantity\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n  }\n}\n\nquery GetInvoicingReadyItems($clientId: uuid!, $billingPeriodStart: timestamp!, $billingPeriodEnd: timestamp!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n    orderBy: [{createdAt: ASC}]\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    service {\n      name\n      category\n      billingUnit\n    }\n    payroll {\n      name\n    }\n  }\n  billingItemsAggregate(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $billingPeriodStart, _lte: $billingPeriodEnd}, status: {_eq: \"confirmed\"}}\n  ) {\n    aggregate {\n      sum {\n        amount\n      }\n      count\n    }\n  }\n}\n\nquery GetComprehensiveBillingReport($startDate: timestamp!, $endDate: timestamp!, $quoteStartDate: timestamptz!, $quoteEndDate: timestamptz!, $workDateStart: date!, $workDateEnd: date!, $clientId: uuid) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      category\n      name\n    }\n    amount\n    quantity\n    isAutoGenerated\n  }\n  timeEntries(\n    where: {clientId: {_eq: $clientId}, workDate: {_gte: $workDateStart, _lte: $workDateEnd}}\n  ) {\n    hoursSpent\n    description\n  }\n  quotes(\n    where: {clientId: {_eq: $clientId}, createdAt: {_gte: $quoteStartDate, _lte: $quoteEndDate}}\n  ) {\n    quoteNumber\n    status\n    totalAmount\n    conversionValue\n    createdAt\n    convertedAt\n  }\n}\n\nquery GetServicePerformanceMetrics($startDate: timestamp!, $endDate: timestamp!) {\n  billingItems(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_neq: \"draft\"}}\n  ) {\n    service {\n      id\n      name\n      category\n      billingUnit\n      defaultRate\n    }\n    amount\n    quantity\n    unitPrice\n    isAutoGenerated\n  }\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    category\n    defaultRate\n    clientAgreements(where: {isActive: {_eq: true}}) {\n      customRate\n      client {\n        name\n      }\n    }\n  }\n}\n\nsubscription SubscribeToBillingItemUpdates($clientId: uuid!) {\n  billingItems(\n    where: {clientId: {_eq: $clientId}}\n    orderBy: {updatedAt: DESC}\n    limit: 20\n  ) {\n    id\n    status\n    amount\n    description\n    updatedAt\n    isAutoGenerated\n  }\n}\n\nsubscription SubscribeToPendingApprovals {\n  billingItems(\n    where: {status: {_eq: \"draft\"}}\n    orderBy: {createdAt: ASC}\n    limit: 50\n  ) {\n    id\n    amount\n    isAutoGenerated\n    client {\n      name\n    }\n    service {\n      name\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}"): (typeof documents)["fragment ServiceCatalogFragment on Services {\n  id\n  name\n  description\n  defaultRate\n  billingUnit\n  category\n  isActive\n  currency\n  serviceType\n  metadata\n  createdAt\n  updatedAt\n}\n\nfragment ClientServiceAgreementFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  isEnabled\n  isActive\n  createdAt\n  updatedAt\n  service {\n    ...ServiceCatalogFragment\n  }\n  client {\n    id\n    name\n  }\n}\n\nfragment QuoteFragment on Quotes {\n  id\n  quoteNumber\n  clientId\n  prospectName\n  prospectEmail\n  prospectPhone\n  prospectCompany\n  status\n  totalAmount\n  validUntil\n  createdBy\n  convertedAt\n  convertedToClientId\n  conversionValue\n  notes\n  termsConditions\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteLineItemFragment on QuoteLineItems {\n  id\n  quoteId\n  serviceId\n  description\n  quantity\n  unitRate\n  totalAmount\n  notes\n  createdAt\n  service {\n    ...ServiceCatalogFragment\n  }\n}\n\nfragment QuoteTemplateFragment on QuoteTemplates {\n  id\n  name\n  description\n  category\n  serviceBundle\n  targetClientSize\n  targetIndustry\n  estimatedTotal\n  isActive\n  isPublic\n  createdBy\n  createdAt\n  updatedAt\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment QuoteConversionFragment on QuoteConversions {\n  id\n  quoteId\n  clientId\n  conversionDate\n  serviceAgreementsCreated\n  totalValue\n  conversionNotes\n  createdBy\n  quote {\n    ...QuoteFragment\n  }\n  client {\n    id\n    name\n  }\n  createdByUser {\n    id\n    firstName\n    lastName\n  }\n}\n\nfragment BillingItemFragment on BillingItems {\n  id\n  clientId\n  payrollId\n  payrollDateId\n  serviceId\n  quoteId\n  quantity\n  unitPrice\n  amount\n  description\n  status\n  isAutoGenerated\n  staffUserId\n  notes\n  confirmedAt\n  confirmedBy\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  service {\n    ...ServiceCatalogFragment\n  }\n  quote {\n    id\n    quoteNumber\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment TimeEntryFragment on TimeEntries {\n  id\n  staffUserId\n  clientId\n  payrollId\n  payrollDateId\n  workDate\n  hoursSpent\n  timeUnits\n  billingRate\n  isBillable\n  billingNotes\n  description\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  payroll {\n    id\n    name\n  }\n}\n\nfragment BillingPeriodFragment on BillingPeriods {\n  id\n  clientId\n  periodStart\n  periodEnd\n  status\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n}\n\nfragment BillingInvoiceFragment on BillingInvoice {\n  id\n  clientId\n  billingPeriodStart\n  billingPeriodEnd\n  billingPeriodId\n  issuedDate\n  dueDate\n  status\n  totalAmount\n  invoiceNumber\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nfragment BillingInvoiceItemFragment on BillingInvoiceItem {\n  id\n  invoiceId\n  descriptionOverride\n  quantityHours\n  hourlyRate\n  netAmount\n  totalAmount\n  createdAt\n}\n\nfragment PayrollBillingFragment on Payrolls {\n  id\n  name\n  clientId\n  employeeCount\n  payslipCount\n  newEmployees\n  terminatedEmployees\n  billingStatus\n  estimatedRevenue\n  actualRevenue\n  estimatedHours\n  actualHours\n  profitMargin\n  lastBilledDate\n  createdAt\n  updatedAt\n  client {\n    id\n    name\n  }\n  billingItems {\n    ...BillingItemFragment\n  }\n  timeEntries {\n    ...TimeEntryFragment\n  }\n}\n\nfragment UserFragment on Users {\n  id\n  firstName\n  lastName\n  email\n}\n\nfragment ClientFragment on Clients {\n  id\n  name\n  contactPerson\n  contactEmail\n  createdAt\n  updatedAt\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}"): (typeof documents)["query GetInvoices($where: BillingInvoiceBoolExp, $orderBy: [BillingInvoiceOrderBy!], $limit: Int, $offset: Int) {\n  billingInvoice(where: $where, orderBy: $orderBy, limit: $limit, offset: $offset) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n    }\n  }\n}\n\nquery GetInvoiceById($id: uuid!) {\n  billingInvoiceByPk(id: $id) {\n    id\n    invoiceNumber\n    clientId\n    billingPeriodId\n    issuedDate\n    dueDate\n    status\n    totalAmount\n    currency\n    notes\n    payrollCount\n    totalHours\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactPerson\n      contactEmail\n      contactPhone\n    }\n    invoiceItems {\n      id\n      descriptionOverride\n      quantityHours\n      hourlyRate\n      netAmount\n      totalAmount\n      createdAt\n    }\n  }\n}\n\nquery GetBillingItemsForInvoice($clientId: uuid, $payrollIds: [uuid!]) {\n  billingItems(\n    where: {_and: [{clientId: {_eq: $clientId}}, {payrollId: {_in: $payrollIds}}, {isApproved: {_eq: true}}, {invoiceId: {_isNull: true}}]}\n    orderBy: {createdAt: ASC}\n  ) {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n    payrollId\n    serviceId\n    clientId\n    staffUserId\n    serviceName\n    hourlyRate\n    totalAmount\n    isApproved\n    approvalDate\n    approvedBy\n    createdAt\n    updatedAt\n  }\n}\n\nquery GetClientForInvoice($clientId: uuid!) {\n  clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    contactPhone\n    createdAt\n  }\n}\n\nquery GetInvoiceStats($clientId: uuid, $startDate: timestamptz, $endDate: timestamptz) {\n  billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        payrollCount\n        totalHours\n      }\n    }\n  }\n  draftInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"draft\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"sent\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  paidInvoices: billingInvoiceAggregate(\n    where: {_and: [{clientId: {_eq: $clientId}}, {status: {_eq: \"paid\"}}, {createdAt: {_gte: $startDate, _lte: $endDate}}]}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetClientsWithUnbilledItems {\n  clients {\n    id\n    name\n    contactPerson\n    contactEmail\n  }\n}\n\nmutation CreateInvoice($input: BillingInvoiceInsertInput!) {\n  insertBillingInvoiceOne(object: $input) {\n    id\n    invoiceNumber\n    clientId\n    status\n    totalAmount\n    currency\n    createdAt\n  }\n}\n\nmutation UpdateInvoiceStatus($id: uuid!, $status: String!, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: $status, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation UpdateInvoiceDetails($id: uuid!, $invoiceNumber: String, $dueDate: date, $totalAmount: numeric, $currency: String, $notes: String) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {invoiceNumber: $invoiceNumber, dueDate: $dueDate, totalAmount: $totalAmount, currency: $currency, notes: $notes, updatedAt: \"now()\"}\n  ) {\n    id\n    invoiceNumber\n    dueDate\n    totalAmount\n    currency\n    notes\n    updatedAt\n  }\n}\n\nmutation LinkBillingItemsToInvoice($billingItemIds: [uuid!]!, $invoiceId: uuid!) {\n  updateBillingItemsMany(\n    updates: [{where: {id: {_in: $billingItemIds}}, _set: {invoiceId: $invoiceId, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n    returning {\n      id\n      invoiceId\n    }\n  }\n}\n\nmutation CancelInvoice($id: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $id}\n    _set: {status: \"cancelled\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n  updateBillingItemsMany(\n    updates: [{where: {invoiceId: {_eq: $id}}, _set: {invoiceId: null, updatedAt: \"now()\"}}]\n  ) {\n    affectedRows\n  }\n}\n\nmutation SendInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"sent\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation MarkInvoiceAsPaid($invoiceId: uuid!, $paymentDate: date) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"paid\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nmutation GenerateInvoice($invoiceId: uuid!) {\n  updateBillingInvoiceByPk(\n    pkColumns: {id: $invoiceId}\n    _set: {status: \"generating\", updatedAt: \"now()\"}\n  ) {\n    id\n    status\n    updatedAt\n  }\n}\n\nquery GetBillingItemsForConsolidation($clientIds: [uuid!]!) {\n  billingItems(\n    where: {_and: [{clientId: {_in: $clientIds}}, {invoiceId: {_isNull: true}}, {isApproved: {_eq: true}}]}\n  ) {\n    id\n    clientId\n    totalAmount\n  }\n}\n\nquery GetBillingPeriodsForConsolidation($clientIds: [uuid!]) {\n  billingPeriods(\n    where: {clientId: {_in: $clientIds}, status: {_eq: \"active\"}}\n    orderBy: {periodStart: DESC}\n  ) {\n    id\n    clientId\n    periodStart\n    periodEnd\n    status\n    client {\n      id\n      name\n    }\n  }\n}\n\nmutation ConsolidateInvoices($clientId: uuid!, $consolidationDate: date!) {\n  insertBillingInvoiceOne(\n    object: {clientId: $clientId, issuedDate: $consolidationDate, status: \"draft\", currency: \"AUD\"}\n  ) {\n    id\n    clientId\n    status\n    createdAt\n  }\n}\n\nmutation AutoGenerateInvoices($billingPeriods: [BillingPeriodsInsertInput!]!) {\n  insertBillingPeriods(objects: $billingPeriods) {\n    affectedRows\n    returning {\n      id\n      clientId\n      periodStart\n      periodEnd\n      status\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}"): (typeof documents)["mutation CreateQuote($input: QuotesInsertInput!) {\n  insertQuotesOne(object: $input) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nmutation UpdateQuote($id: uuid!, $changes: QuotesSetInput!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    updatedAt\n  }\n}\n\nmutation DeleteQuote($id: uuid!) {\n  updateQuotesByPk(pkColumns: {id: $id}, _set: {status: \"cancelled\"}) {\n    id\n    status\n  }\n}\n\nquery GetQuoteById($id: uuid!) {\n  quotesByPk(id: $id) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectEmail\n    prospectPhone\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdBy\n    convertedAt\n    convertedToClientId\n    conversionValue\n    notes\n    termsConditions\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n      contactEmail\n      contactPhone\n    }\n    convertedToClient {\n      id\n      name\n    }\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      serviceId\n      description\n      quantity\n      unitRate\n      totalAmount\n      notes\n      service {\n        id\n        name\n        category\n        billingUnit\n        defaultRate\n      }\n    }\n    conversions {\n      id\n      clientId\n      conversionDate\n      totalValue\n      conversionNotes\n      serviceAgreementsCreated\n    }\n  }\n}\n\nquery GetQuotes($limit: Int = 50, $offset: Int = 0, $where: QuotesBoolExp, $orderBy: [QuotesOrderBy!] = [{createdAt: DESC}]) {\n  quotes(limit: $limit, offset: $offset, where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    clientId\n    prospectName\n    prospectCompany\n    status\n    totalAmount\n    validUntil\n    createdAt\n    updatedAt\n    client {\n      id\n      name\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n  quotesAggregate(where: $where) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetQuoteAnalytics($where: QuoteAnalyticsBoolExp, $orderBy: [QuoteAnalyticsOrderBy!] = [{createdAt: DESC}]) {\n  quoteAnalytics(where: $where, orderBy: $orderBy) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    createdAt\n    validUntil\n    convertedAt\n    conversionValue\n    clientName\n    createdByName\n    lineItemsCount\n    pipelineStatus\n    daysInPipeline\n  }\n}\n\nmutation AddQuoteLineItem($input: QuoteLineItemsInsertInput!) {\n  insertQuoteLineItemsOne(object: $input) {\n    id\n    quoteId\n    serviceId\n    description\n    quantity\n    unitRate\n    totalAmount\n    notes\n    createdAt\n    service {\n      id\n      name\n      billingUnit\n      defaultRate\n    }\n  }\n}\n\nmutation UpdateQuoteLineItem($id: uuid!, $changes: QuoteLineItemsSetInput!) {\n  updateQuoteLineItemsByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    description\n    quantity\n    unitRate\n    totalAmount\n    createdAt\n  }\n}\n\nmutation DeleteQuoteLineItem($id: uuid!) {\n  deleteQuoteLineItemsByPk(id: $id) {\n    id\n  }\n}\n\nmutation AddMultipleQuoteLineItems($items: [QuoteLineItemsInsertInput!]!) {\n  insertQuoteLineItems(objects: $items) {\n    returning {\n      id\n      quoteId\n      description\n      totalAmount\n    }\n    affectedRows\n  }\n}\n\nmutation CreateQuoteTemplate($input: QuoteTemplatesInsertInput!) {\n  insertQuoteTemplatesOne(object: $input) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n  }\n}\n\nmutation UpdateQuoteTemplate($id: uuid!, $changes: QuoteTemplatesSetInput!) {\n  updateQuoteTemplatesByPk(pkColumns: {id: $id}, _set: $changes) {\n    id\n    name\n    description\n    estimatedTotal\n    updatedAt\n  }\n}\n\nquery GetQuoteTemplates($where: QuoteTemplatesBoolExp, $orderBy: [QuoteTemplatesOrderBy!] = [{createdAt: DESC}]) {\n  quoteTemplates(where: $where, orderBy: $orderBy) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdAt\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateById($id: uuid!) {\n  quoteTemplatesByPk(id: $id) {\n    id\n    name\n    description\n    category\n    serviceBundle\n    targetClientSize\n    targetIndustry\n    estimatedTotal\n    isActive\n    isPublic\n    createdBy\n    createdAt\n    updatedAt\n    createdByUser {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuoteTemplateSummary {\n  quoteTemplates {\n    id\n    name\n    description\n    category\n    targetClientSize\n    estimatedTotal\n    isActive\n    createdAt\n  }\n}\n\nmutation ConvertQuoteToClient($quoteId: uuid!, $clientId: uuid!, $conversionNotes: String, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\", convertedToClientId: $clientId}\n  ) {\n    id\n    status\n    convertedAt\n  }\n  insertClientServiceAgreements(objects: $serviceAgreements) {\n    returning {\n      id\n      clientId\n      serviceId\n      customRate\n      isActive\n    }\n    affectedRows\n  }\n  insertQuoteConversionsOne(\n    object: {quoteId: $quoteId, clientId: $clientId, conversionNotes: $conversionNotes, totalValue: 0}\n  ) {\n    id\n    conversionDate\n    totalValue\n  }\n}\n\nmutation CreateClientFromQuote($quoteId: uuid!, $clientData: ClientsInsertInput!, $serviceAgreements: [ClientServiceAgreementsInsertInput!]!) {\n  insertClientsOne(object: $clientData) {\n    id\n    name\n    contactEmail\n    createdAt\n  }\n  updateQuotesByPk(\n    pkColumns: {id: $quoteId}\n    _set: {status: \"converted\", convertedAt: \"now()\"}\n  ) {\n    id\n    status\n  }\n}\n\nquery GetQuoteConversions($where: QuoteConversionsBoolExp, $orderBy: [QuoteConversionsOrderBy!] = [{conversionDate: DESC}]) {\n  quoteConversions(where: $where, orderBy: $orderBy) {\n    id\n    quoteId\n    clientId\n    conversionDate\n    totalValue\n    conversionNotes\n    serviceAgreementsCreated\n    quote {\n      quoteNumber\n      prospectName\n      totalAmount\n    }\n    client {\n      name\n      contactEmail\n    }\n    createdByUser {\n      firstName\n      lastName\n    }\n  }\n}\n\nquery GetQuotePipeline {\n  quotes(where: {status: {_in: [\"draft\", \"sent\"]}}) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    validUntil\n    createdAt\n    prospectName\n    prospectCompany\n    client {\n      name\n    }\n  }\n  draftQuotes: quotesAggregate(where: {status: {_eq: \"draft\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  sentQuotes: quotesAggregate(where: {status: {_eq: \"sent\"}}) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotes: quotesAggregate(where: {status: {_eq: \"converted\"}}) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n}\n\nquery GetQuoteMetrics($startDate: timestamptz!, $endDate: timestamptz!) {\n  totalQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  convertedQuotesMetrics: quotesAggregate(\n    where: {convertedAt: {_gte: $startDate, _lte: $endDate}, status: {_eq: \"converted\"}}\n  ) {\n    aggregate {\n      count\n      sum {\n        conversionValue\n      }\n    }\n  }\n  lostQuotes: quotesAggregate(\n    where: {createdAt: {_gte: $startDate, _lte: $endDate}, status: {_in: [\"rejected\", \"expired\"]}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetServicesForQuoting($category: String, $billingUnit: String) {\n  services(\n    where: {isActive: {_eq: true}, category: {_ilike: $category}, billingUnit: {_ilike: $billingUnit}}\n    orderBy: [{category: ASC}, {defaultRate: ASC}]\n  ) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    metadata\n  }\n}\n\nquery GetServiceCatalogForQuotes {\n  services(where: {isActive: {_eq: true}}) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    isActive\n  }\n}\n\nsubscription SubscribeToQuoteUpdates($quoteId: uuid!) {\n  quotesByPk(id: $quoteId) {\n    id\n    status\n    totalAmount\n    updatedAt\n    lineItems {\n      id\n      totalAmount\n    }\n  }\n}\n\nsubscription SubscribeToQuotePipeline {\n  quotes(\n    where: {status: {_in: [\"draft\", \"sent\", \"converted\", \"rejected\"]}}\n    orderBy: {updatedAt: DESC}\n  ) {\n    id\n    quoteNumber\n    status\n    totalAmount\n    updatedAt\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}"): (typeof documents)["query GetFinancialPerformanceData {\n  currentPeriod: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n}\n\nquery GetRevenueAnalytics {\n  totalRevenue: billingInvoiceAggregate {\n    aggregate {\n      sum {\n        totalAmount\n      }\n    }\n  }\n  monthlyRevenue: billingInvoice(orderBy: {createdAt: ASC}, limit: 100) {\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetClientProfitabilityAnalysis {\n  clients(limit: 50, orderBy: {name: ASC}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientPerformanceMetrics($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n    contactPerson\n    contactEmail\n    createdAt\n  }\n}\n\nquery GetClientForecastData($clientId: uuid!) {\n  client: clientsByPk(id: $clientId) {\n    id\n    name\n  }\n}\n\nquery GetBusinessIntelligenceData {\n  systemMetrics: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        totalHours\n        payrollCount\n      }\n      avg {\n        totalAmount\n      }\n    }\n  }\n  clientMetrics: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  serviceMetrics: billingItems(limit: 100, orderBy: {createdAt: DESC}) {\n    serviceName\n    totalAmount\n    hourlyRate\n    quantity\n    createdAt\n  }\n  invoicesByStatus: billingInvoice(limit: 100, orderBy: {createdAt: DESC}) {\n    status\n    totalAmount\n    createdAt\n  }\n}\n\nquery GetAutomationMetrics {\n  billingItemsProcessed: billingItemsAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  invoicesGenerated: billingInvoiceAggregate {\n    aggregate {\n      count\n      sum {\n        totalAmount\n      }\n    }\n  }\n  approvedItems: billingItemsAggregate(where: {isApproved: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  pendingApproval: billingItemsAggregate(where: {isApproved: {_eq: false}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetEfficiencyAnalytics {\n  billingItems(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    updatedAt\n    isApproved\n    approvalDate\n    serviceName\n  }\n  invoices: billingInvoice(orderBy: {createdAt: DESC}, limit: 100) {\n    id\n    createdAt\n    issuedDate\n    status\n    totalAmount\n  }\n}\n\nquery GetFinancialKpiSummary {\n  totalRevenue: billingInvoiceAggregate(where: {status: {_neq: \"cancelled\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  paidRevenue: billingInvoiceAggregate(where: {status: {_eq: \"paid\"}}) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  outstandingRevenue: billingInvoiceAggregate(\n    where: {status: {_in: [\"sent\", \"viewed\"]}}\n  ) {\n    aggregate {\n      sum {\n        totalAmount\n      }\n      count\n    }\n  }\n  activeClients: clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetBillingAnalytics($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid, $staffUserId: uuid) {\n  billingAnalytics: billingItemsAggregate(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    aggregate {\n      count\n      sum {\n        totalAmount\n        quantity\n      }\n      avg {\n        totalAmount\n        hourlyRate\n      }\n    }\n  }\n  revenueByStatus: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n  ) {\n    status\n    totalAmount\n  }\n  revenueByMonth: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    orderBy: {createdAt: ASC}\n  ) {\n    totalAmount\n    createdAt\n  }\n  topClients: clients(limit: 10, orderBy: {name: ASC}) {\n    id\n    name\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        sum {\n          totalAmount\n        }\n        count\n      }\n    }\n  }\n  topServices: billingItems(\n    where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}, clientId: {_eq: $clientId}, staffUserId: {_eq: $staffUserId}}\n    distinctOn: serviceName\n    orderBy: [{serviceName: ASC}, {totalAmount: DESC}]\n    limit: 10\n  ) {\n    serviceName\n    totalAmount\n    quantity\n  }\n}\n\nquery GetClientBillingStats($dateFrom: timestamp!, $dateTo: timestamp!, $clientId: uuid) {\n  clientBillingStats: clients(where: {id: {_eq: $clientId}}) {\n    id\n    name\n    contactPerson\n    contactEmail\n    billingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    payrollsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nquery GetStaffAnalyticsPerformance($dateFrom: timestamp!, $dateTo: timestamp!, $staffUserId: uuid) {\n  staffBillingPerformance: users(where: {id: {_eq: $staffUserId}}) {\n    id\n    firstName\n    lastName\n    email\n    role\n    staffBillingItemsAggregate(where: {createdAt: {_gte: $dateFrom, _lte: $dateTo}}) {\n      aggregate {\n        count\n        sum {\n          totalAmount\n          quantity\n        }\n        avg {\n          totalAmount\n          hourlyRate\n        }\n      }\n    }\n    primaryPayrollAssignmentsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetServicesByCategory($limit: Int = 50, $offset: Int = 0, $category: String!) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetAllActiveServices($limit: Int = 100) {\n  services(limit: $limit, where: {isActive: {_eq: true}}, orderBy: [{name: ASC}]) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n    isActive\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}"): (typeof documents)["fragment ServiceFragment on Services {\n  id\n  name\n  description\n  category\n  billingUnit\n  defaultRate\n  currency\n  serviceType\n  isActive\n  isTemplate\n  metadata\n  pricingRules\n  dependencies\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ServiceTemplateFragment on ServiceTemplates {\n  id\n  name\n  description\n  category\n  services\n  pricingStrategy\n  bundleDiscountPercentage\n  isPublic\n  targetClientTypes\n  createdAt\n  updatedAt\n  createdBy\n  updatedBy\n}\n\nfragment ClientServiceAgreementNewFragment on ClientServiceAgreements {\n  id\n  clientId\n  serviceId\n  customRate\n  billingFrequency\n  contractStartDate\n  contractEndDate\n  serviceConfiguration\n  autoBillingEnabled\n  autoBillingTriggers\n  isActive\n  isEnabled\n  createdAt\n  updatedAt\n  createdBy\n}\n\nfragment ServiceWithRelationshipsFragment on Services {\n  ...ServiceFragment\n  billingItems {\n    id\n    description\n    quantity\n    unitPrice\n    amount\n  }\n  clientAgreements {\n    id\n    clientId\n    customRate\n    isActive\n  }\n}\n\nquery GetNewServiceCatalog($limit: Int = 50, $offset: Int = 0) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetServicesByCategory($limit: Int = 50, $offset: Int = 0, $category: String!) {\n  services(\n    limit: $limit\n    offset: $offset\n    where: {isActive: {_eq: true}, category: {_eq: $category}}\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n  servicesAggregate(where: {isActive: {_eq: true}, category: {_eq: $category}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GetAllActiveServices($limit: Int = 100) {\n  services(limit: $limit, where: {isActive: {_eq: true}}, orderBy: [{name: ASC}]) {\n    id\n    name\n    description\n    category\n    billingUnit\n    defaultRate\n    currency\n    serviceType\n    isActive\n  }\n}\n\nquery GetNewServiceById($id: uuid!) {\n  servicesByPk(id: $id) {\n    ...ServiceWithRelationshipsFragment\n  }\n}\n\nquery GetserviceTemplates($isPublic: Boolean) {\n  serviceTemplates(where: {isPublic: {_eq: $isPublic}}, orderBy: [{name: ASC}]) {\n    ...ServiceTemplateFragment\n  }\n}\n\nquery GetNewclientServiceAgreements($clientId: uuid) {\n  clientServiceAgreements(\n    where: {clientId: {_eq: $clientId}, isActive: {_eq: true}}\n  ) {\n    ...ClientServiceAgreementNewFragment\n    client {\n      id\n      name\n    }\n    service {\n      id\n      name\n    }\n  }\n}\n\nquery GetServiceUsageAnalytics($serviceIds: [uuid!], $startDate: timestamp, $endDate: timestamp) {\n  services(where: {id: {_in: $serviceIds}}) {\n    id\n    name\n    billingItems(where: {createdAt: {_gte: $startDate, _lte: $endDate}}) {\n      id\n      amount\n      quantity\n      createdAt\n    }\n    clientAgreementsAggregate {\n      aggregate {\n        count\n      }\n    }\n  }\n}\n\nmutation CreateNewService($input: ServicesInsertInput!) {\n  insertServicesOne(object: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation UpdateNewService($id: uuid!, $input: ServicesSetInput) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ServiceFragment\n  }\n}\n\nmutation CreateNewServiceTemplate($input: ServiceTemplatesInsertInput!) {\n  insertServiceTemplatesOne(object: $input) {\n    ...ServiceTemplateFragment\n  }\n}\n\nmutation CreateClientServiceAgreement($input: ClientServiceAgreementsInsertInput!) {\n  insertClientServiceAgreementsOne(object: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation UpdateClientServiceAgreement($id: uuid!, $input: ClientServiceAgreementsSetInput) {\n  updateClientServiceAgreementsByPk(pkColumns: {id: $id}, _set: $input) {\n    ...ClientServiceAgreementNewFragment\n  }\n}\n\nmutation DeactivateService($id: uuid!) {\n  updateServicesByPk(pkColumns: {id: $id}, _set: {isActive: false}) {\n    id\n    isActive\n  }\n}\n\nquery Searchservices($searchTerm: String!, $limit: Int = 20) {\n  services(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {description: {_ilike: $searchTerm}}, {category: {_ilike: $searchTerm}}], isActive: {_eq: true}}\n    limit: $limit\n    orderBy: [{name: ASC}]\n  ) {\n    ...ServiceFragment\n  }\n}\n\nquery GetServiceCategories {\n  services(distinctOn: [category], where: {isActive: {_eq: true}}) {\n    category\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}"): (typeof documents)["fragment UserMinimal on Users {\n  id\n  firstName\n  lastName\n  computedName\n  email\n}\n\nfragment UserCoreShared on Users {\n  ...UserMinimal\n  role\n  isActive\n}\n\nfragment UserBasic on Users {\n  ...UserCoreShared\n  clerkUserId\n  createdAt\n  updatedAt\n}\n\nfragment UserBase on Users {\n  ...UserBasic\n}\n\nfragment UserWithRole on Users {\n  ...UserBasic\n  username\n  isStaff\n}\n\nfragment UserProfile on Users {\n  ...UserWithRole\n  clerkUserId\n  image\n  managerId\n  deactivatedAt\n  deactivatedBy\n  manager {\n    ...UserMinimal\n  }\n}\n\nfragment UserSearchResult on Users {\n  ...UserCoreShared\n  username\n  isStaff\n}\n\nfragment ClientMinimal on Clients {\n  id\n  name\n}\n\nfragment ClientBase on Clients {\n  id\n  name\n  active\n  contactEmail\n  contactPerson\n  contactPhone\n  createdAt\n}\n\nfragment ClientWithStats on Clients {\n  ...ClientBase\n  currentEmployeeCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  activePayrollCount: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment ClientListBase on Clients {\n  ...ClientBase\n  payrollCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n}\n\nfragment PayrollMinimal on Payrolls {\n  id\n  name\n  employeeCount\n  status\n}\n\nfragment PayrollBase on Payrolls {\n  id\n  name\n  employeeCount\n  status\n  payrollSystem\n  processingTime\n  processingDaysBeforeEft\n  versionNumber\n  supersededDate\n  createdAt\n  updatedAt\n}\n\nfragment PayrollWithClient on Payrolls {\n  ...PayrollBase\n  clientId\n  client {\n    id\n    name\n    active\n  }\n}\n\nfragment PayrollListItem on Payrolls {\n  ...PayrollWithClient\n  primaryConsultantUserId\n  backupConsultantUserId\n  managerUserId\n  createdByUserId\n  cycleId\n  dateTypeId\n  dateValue\n  payrollCycle {\n    id\n    name\n    description\n  }\n  payrollDateType {\n    id\n    name\n    description\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment PayrollWithDates on Payrolls {\n  ...PayrollBase\n  goLiveDate\n  payrollDates(orderBy: {originalEftDate: ASC}) {\n    id\n    originalEftDate\n    adjustedEftDate\n    notes\n  }\n}\n\nfragment PayrollFullDetail on Payrolls {\n  ...PayrollWithDates\n  ...PayrollWithClient\n  dateTypeId\n  cycleId\n  dateValue\n  versionReason\n  supersededDate\n  parentPayrollId\n  parentPayroll {\n    id\n    versionNumber\n  }\n  childPayrolls(orderBy: {versionNumber: DESC}) {\n    id\n    versionNumber\n    versionReason\n    createdAt\n  }\n  primaryConsultant {\n    ...UserMinimal\n  }\n  backupConsultant {\n    ...UserMinimal\n  }\n  assignedManager {\n    ...UserMinimal\n  }\n}\n\nfragment NoteWithAuthor on Notes {\n  id\n  content\n  isImportant\n  createdAt\n  entityId\n  entityType\n  author {\n    ...UserMinimal\n  }\n}\n\nfragment PermissionBase on Permissions {\n  id\n  resourceId\n  description\n  legacyPermissionName\n  action\n}\n\nfragment RoleWithPermissions on Roles {\n  id\n  name\n  displayName\n  description\n  isSystemRole\n  priority\n  rolePermissions {\n    permission {\n      ...PermissionBase\n    }\n  }\n}\n\nfragment AuditLogEntry on AuditAuditLog {\n  id\n  userId\n  userEmail\n  userRole\n  action\n  resourceType\n  resourceId\n  eventTime\n  success\n  errorMessage\n  ipAddress\n  userAgent\n  requestId\n  sessionId\n  metadata\n  oldValues\n  newValues\n  createdAt\n}\n\nfragment AuthEvent on AuditAuthEvents {\n  id\n  userId\n  userEmail\n  eventType\n  eventTime\n  success\n  failureReason\n  ipAddress\n  userAgent\n  metadata\n}\n\nfragment DataAccessLog on AuditDataAccessLog {\n  id\n  userId\n  resourceType\n  resourceId\n  accessType\n  accessedAt\n  dataClassification\n  fieldsAccessed\n  rowCount\n  ipAddress\n  metadata\n}\n\nfragment PermissionChange on AuditPermissionChanges {\n  id\n  changedAt\n  changedByUserId\n  targetUserId\n  targetRoleId\n  changeType\n  permissionType\n  oldPermissions\n  newPermissions\n  reason\n  approvedByUserId\n}\n\nfragment PayrollDateInfo on PayrollDates {\n  id\n  originalEftDate\n  adjustedEftDate\n  notes\n  createdAt\n}\n\nfragment PermissionOverrideInfo on PermissionOverrides {\n  id\n  userId\n  role\n  resource\n  operation\n  granted\n  reason\n  conditions\n  expiresAt\n  createdBy\n  createdAt\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}"): (typeof documents)["mutation LogAuditEvent($input: AuditAuditLogInsertInput!) {\n  insertAuditAuditLog(objects: [$input]) {\n    returning {\n      id\n      eventTime\n    }\n  }\n}\n\nmutation InsertFile($input: FilesInsertInput!) {\n  insertFiles(objects: [$input]) {\n    returning {\n      id\n      filename\n      bucket\n      objectKey\n      size\n      mimetype\n      url\n      clientId\n      payrollId\n      uploadedBy\n      category\n      isPublic\n      metadata\n      fileType\n      createdAt\n    }\n  }\n}\n\nmutation UpdateFileMetadata($id: uuid!, $updates: FilesSetInput!) {\n  updateFilesByPk(pkColumns: {id: $id}, _set: $updates) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n  }\n}\n\nmutation DeleteFile($id: uuid!) {\n  deleteFilesByPk(id: $id) {\n    id\n    filename\n    objectKey\n  }\n}\n\nmutation RefreshData {\n  __typename\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}"): (typeof documents)["query GetDashboardMetrics($userId: uuid!) {\n  clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrollsAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\"]}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesAggregate: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}}\n  ) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_nin: [\"Completed\", \"Failed\", \"Cancelled\"]}}\n    orderBy: {updatedAt: DESC}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetDashboardStatsOptimized($limit: Int = 10) {\n  clientsAggregate {\n    aggregate {\n      count\n    }\n  }\n  totalPayrolls: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  activePayrolls: payrollsAggregate(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n  upcomingPayrolls: payrolls(\n    where: {supersededDate: {_isNull: true}, status: {_eq: \"Active\"}, payrollDates: {adjustedEftDate: {_gte: \"now()\"}}}\n    orderBy: {updatedAt: DESC}\n    limit: $limit\n  ) {\n    id\n    name\n    status\n    client {\n      id\n      name\n    }\n    nextEftDate: payrollDates(\n      where: {adjustedEftDate: {_gte: \"now()\"}}\n      orderBy: {adjustedEftDate: ASC}\n      limit: 1\n    ) {\n      originalEftDate\n      adjustedEftDate\n      processingDate\n    }\n  }\n}\n\nquery GetClientsDashboardStats {\n  activeClientsCount: clientsAggregate(where: {active: {_eq: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalPayrollsCount: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      count\n    }\n  }\n  totalEmployeesSum: payrollsAggregate(where: {supersededDate: {_isNull: true}}) {\n    aggregate {\n      sum {\n        employeeCount\n      }\n    }\n  }\n  clientsNeedingAttention: clients(\n    where: {active: {_eq: true}, _not: {payrolls: {supersededDate: {_isNull: true}}}}\n  ) {\n    ...ClientMinimal\n  }\n}\n\nquery GetCurrentUser($userId: uuid!) {\n  user: usersByPk(id: $userId) {\n    ...UserProfile\n  }\n}\n\nquery GetUsersForDropdown($role: user_role) {\n  users(\n    where: {isActive: {_eq: true}, role: {_eq: $role}}\n    orderBy: {computedName: ASC}\n  ) {\n    ...UserMinimal\n  }\n}\n\nquery GetSystemHealth {\n  databaseHealth: users(limit: 1) {\n    id\n  }\n  recentActivity: auditAuditLogAggregate(\n    where: {eventTime: {_gte: \"now() - interval '1 hour'\"}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n\nquery GlobalSearch($searchTerm: String!) {\n  clients(\n    where: {_or: [{name: {_ilike: $searchTerm}}, {contactEmail: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...ClientMinimal\n  }\n  users(\n    where: {_or: [{computedName: {_ilike: $searchTerm}}, {firstName: {_ilike: $searchTerm}}, {lastName: {_ilike: $searchTerm}}, {email: {_ilike: $searchTerm}}]}\n    limit: 5\n  ) {\n    ...UserMinimal\n  }\n  payrolls(\n    where: {client: {name: {_ilike: $searchTerm}}, supersededDate: {_isNull: true}}\n    limit: 5\n  ) {\n    ...PayrollMinimal\n    client {\n      ...ClientMinimal\n    }\n  }\n}\n\nquery GetFileById($id: uuid!) {\n  filesByPk(id: $id) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n}\n\nquery ListFiles($where: FilesBoolExp, $limit: Int, $offset: Int, $orderBy: [FilesOrderBy!]) {\n  files(where: $where, limit: $limit, offset: $offset, orderBy: $orderBy) {\n    id\n    filename\n    bucket\n    objectKey\n    size\n    mimetype\n    url\n    clientId\n    payrollId\n    uploadedBy\n    category\n    isPublic\n    metadata\n    fileType\n    createdAt\n    client {\n      name\n    }\n    payroll {\n      name\n    }\n    uploadedBy\n  }\n  filesAggregate(where: $where) {\n    aggregate {\n      count\n    }\n  }\n}"];
/**
 * The gql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function gql(source: "subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}"): (typeof documents)["subscription RecentActivity($resourceTypes: [String!]) {\n  auditAuditLog(\n    where: {resourceType: {_in: $resourceTypes}, eventTime: {_gte: \"now() - interval '5 minutes'\"}}\n    orderBy: {eventTime: DESC}\n    limit: 20\n  ) {\n    ...AuditLogEntry\n  }\n}\n\nsubscription AuthenticationEvents($userId: uuid) {\n  auditAuthEvents(\n    where: {userId: {_eq: $userId}, eventTime: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {eventTime: DESC}\n  ) {\n    ...AuthEvent\n  }\n}\n\nsubscription SensitiveDataAccess($resourceTypes: [String!]!) {\n  auditDataAccessLog(\n    where: {resourceType: {_in: $resourceTypes}, accessedAt: {_gte: \"now() - interval '10 minutes'\"}}\n    orderBy: {accessedAt: DESC}\n  ) {\n    ...DataAccessLog\n  }\n}\n\nsubscription PermissionChangeStream {\n  auditPermissionChanges(orderBy: {changedAt: DESC}, limit: 10) {\n    ...PermissionChange\n  }\n}"];

export function gql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;