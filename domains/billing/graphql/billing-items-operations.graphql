# Billing Items GraphQL Operations

# Fragments
fragment BillingItemCore on BillingItems {
  id
  description
  amount
  quantity
  unitPrice
  totalAmount
  status
  notes
  createdAt
  updatedAt
  approvalDate
  isApproved
  clientId
  staffUserId
  approvedBy
  confirmedAt
  confirmedBy
  payrollId
  serviceId
  serviceName
  hourlyRate
  invoiceId
}

fragment BillingItemWithRelations on BillingItems {
  ...BillingItemCore
  client {
    id
    name
    contactEmail
  }
  staffUser {
    id
    firstName
    lastName
    email
  }
  approvedByUser {
    id
    firstName
    lastName
    email
  }
  payroll {
    id
    name
    status
  }
  service {
    id
    name
    description
    category
    billingUnit
    defaultRate
    currency
    serviceType
  }
}

fragment BillingItemStats on BillingItemsAggregate {
  aggregate {
    count
    sum {
      amount
      totalAmount
      quantity
    }
    avg {
      amount
      totalAmount
      quantity
    }
  }
}

# Queries
query GetBillingItemsAdvanced(
  $limit: Int = 50
  $offset: Int = 0
  $where: BillingItemsBoolExp
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
) {
  billingItems(
    limit: $limit
    offset: $offset
    where: $where
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
  }
}

query GetBillingItemByIdAdvanced($id: uuid!) {
  billingItemsByPk(id: $id) {
    ...BillingItemWithRelations
  }
}

query GetBillingItemsStatsAdvanced(
  $where: BillingItemsBoolExp = {}
) {
  billingItemsAggregate(where: $where) {
    ...BillingItemStats
  }
  
  pending: billingItemsAggregate(
    where: { 
      _and: [
        $where,
        { status: { _eq: "pending" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  approved: billingItemsAggregate(
    where: { 
      _and: [
        $where,
        { status: { _eq: "approved" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  rejected: billingItemsAggregate(
    where: { 
      _and: [
        $where,
        { status: { _eq: "rejected" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
}

query GetBillingItemsByClientAdvanced(
  $clientId: uuid!
  $limit: Int = 50
  $offset: Int = 0
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
) {
  billingItems(
    where: { clientId: { _eq: $clientId } }
    limit: $limit
    offset: $offset
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
  }
}

query GetBillingItemsByUserAdvanced(
  $userId: uuid!
  $limit: Int = 50
  $offset: Int = 0
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
) {
  billingItems(
    where: { staffUserId: { _eq: $userId } }
    limit: $limit
    offset: $offset
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
  }
}

query GetRecentBillingItemsAdvanced(
  $limit: Int = 10
  $startDate: timestamp!
) {
  billingItems(
    where: {
      createdAt: {
        _gte: $startDate
      }
    }
    limit: $limit
    orderBy: { createdAt: DESC }
  ) {
    ...BillingItemWithRelations
  }
}

# Mutations
mutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {
  insertBillingItemsOne(object: $input) {
    ...BillingItemWithRelations
  }
}

mutation UpdateBillingItemAdvanced(
  $id: uuid!
  $updates: BillingItemsSetInput!
) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: $updates
  ) {
    ...BillingItemWithRelations
  }
}

mutation DeleteBillingItemAdvanced($id: uuid!) {
  deleteBillingItemsByPk(id: $id) {
    id
    description
  }
}

mutation BulkUpdateBillingItemsStatusAdvanced(
  $ids: [uuid!]!
  $status: String!
  $approvedBy: uuid
) {
  updateBillingItemsMany(
    updates: [{
      where: { id: { _in: $ids } }
      _set: {
        status: $status
        approvedBy: $approvedBy
        approvalDate: "now()"
        isApproved: true
      }
    }]
  ) {
    affectedRows
  }
}

mutation ApproveBillingItemAdvanced(
  $id: uuid!
  $approvedBy: uuid!
) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: {
      status: "approved"
      approvedBy: $approvedBy
      approvalDate: "now()"
      isApproved: true
    }
  ) {
    ...BillingItemWithRelations
  }
}

mutation RejectBillingItemAdvanced(
  $id: uuid!
  $approvedBy: uuid!
  $notes: String
) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: {
      status: "rejected"
      approvedBy: $approvedBy
      approvalDate: "now()"
      isApproved: false
      notes: $notes
    }
  ) {
    ...BillingItemWithRelations
  }
}

mutation ArchiveBillingItemAdvanced($id: uuid!) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: {
      status: "archived"
    }
  ) {
    ...BillingItemWithRelations
  }
}

# Subscriptions
subscription BillingItemsSubscriptionAdvanced(
  $where: BillingItemsBoolExp
  $limit: Int = 50
) {
  billingItems(
    where: $where
    limit: $limit
    orderBy: { createdAt: DESC }
  ) {
    ...BillingItemWithRelations
  }
}

subscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {
  billingItemsByPk(id: $id) {
    ...BillingItemWithRelations
  }
}

subscription BillingItemsStatsSubscriptionAdvanced(
  $where: BillingItemsBoolExp
) {
  billingItemsAggregate(where: $where) {
    ...BillingItemStats
  }
}

# Payroll Date Completion Operations
mutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {
  updatePayrollDatesByPk(
    pkColumns: { id: $id }
    _set: { 
      status: "completed"
      completedAt: "now()"
      completedBy: $completedBy
    }
  ) {
    id
    status
    completedAt
    completedBy
    totalTimeSpentMinutes
    completionNotes
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
  }
}

# Complete payroll date with time tracking
mutation CompletePayrollDateWithTime(
  $id: uuid!
  $completedBy: uuid!
  $timeSpentMinutes: Int = 0
  $completionNotes: String
) {
  updatePayrollDatesByPk(
    pkColumns: { id: $id }
    _set: { 
      status: "completed"
      completedAt: "now()"
      completedBy: $completedBy
      completionNotes: $completionNotes
    }
  ) {
    id
    status
    completedAt
    completedBy
    totalTimeSpentMinutes
    completionNotes
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
  }
}

# Add time entry for payroll date work
mutation AddPayrollDateTimeEntry(
  $payrollDateId: uuid!
  $userId: uuid!
  $timeSpentMinutes: Int!
  $description: String
  $workDate: date
) {
  insertPayrollDateTimeEntriesOne(
    object: {
      payrollDateId: $payrollDateId
      userId: $userId
      timeSpentMinutes: $timeSpentMinutes
      description: $description
      workDate: $workDate
    }
    onConflict: {
      constraint: payroll_date_time_entries_payroll_date_id_user_id_work_date_key
      updateColumns: [timeSpentMinutes, description, updatedAt]
    }
  ) {
    id
    payrollDateId
    userId
    timeSpentMinutes
    description
    workDate
    createdAt
    updatedAt
  }
}

mutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {
  updatePayrollDatesByPk(
    pkColumns: { id: $id }
    _set: { 
      status: $status
      updatedAt: "now()"
      completedBy: $updatedBy
    }
  ) {
    id
    status
    completedAt
    completedBy
    payrollId
  }
}

query GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {
  payrollDates(
    where: { 
      payrollId: { _eq: $payrollId }
      _and: { status: { _eq: $status } }
    }
    orderBy: { adjustedEftDate: ASC }
  ) {
    id
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
    status
    completedAt
    completedBy
    notes
    createdAt
    updatedAt
  }
}

query GetPayrollDatesWithStatus($payrollId: uuid!) {
  payrollDates(
    where: { payrollId: { _eq: $payrollId } }
    orderBy: { adjustedEftDate: ASC }
  ) {
    id
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
    status
    completedAt
    completedBy
    notes
    createdAt
    updatedAt
  }
}

# Consolidated Billing Dashboard Query - Replaces multiple separate queries
query GetBillingDashboardComplete(
  $limit: Int = 50
  $offset: Int = 0
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
  $timeRangeFilter: BillingItemsBoolExp = {}
  $statsFilter: BillingItemsBoolExp = {}
  $sevenDaysAgo: timestamp!
  $currentMonthStart: timestamp!
  $sevenDaysAgoDate: date!
  $thirtyDaysAgoDate: date!
) {
  # Core billing items with all relationships
  billingItems(
    limit: $limit
    offset: $offset
    where: $timeRangeFilter
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
    # Additional fields for dashboard
    invoiceId
    timeEntries {
      id
      hoursSpent
      workDate
      description
    }
  }
  
  # Comprehensive billing statistics
  billingStats: billingItemsAggregate(where: $statsFilter) {
    ...BillingItemStats
  }
  
  pendingStats: billingItemsAggregate(
    where: { 
      _and: [
        $statsFilter,
        { status: { _eq: "pending" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  approvedStats: billingItemsAggregate(
    where: { 
      _and: [
        $statsFilter,
        { status: { _eq: "approved" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  draftStats: billingItemsAggregate(
    where: { 
      _and: [
        $statsFilter,
        { status: { _eq: "draft" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  # Recent activity for overview
  recentBillingItems: billingItems(
    limit: 10
    orderBy: [{ createdAt: DESC }]
    where: {
      createdAt: {
        _gte: $sevenDaysAgo
      }
    }
  ) {
    ...BillingItemCore
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
    }
  }
  
  # Active clients for context
  activeClients: clients(
    where: { active: { _eq: true } }
    orderBy: { name: ASC }
  ) {
    id
    name
    contactEmail
    active
    # Client billing summary
    billingItems(
      where: {
        createdAt: {
          _gte: $currentMonthStart
        }
      }
    ) {
      id
      amount
      status
    }
  }
  
  # Active services for recurring services
  recurringServices: services(
    where: { 
      chargeBasis: { _in: ["per_client_monthly", "per_payroll_monthly"] }
      isActive: { _eq: true }
    }
    orderBy: { category: ASC }
  ) {
    id
    name
    serviceCode
    description
    baseRate
    category
    chargeBasis
    approvalLevel
    billingUnit
    defaultRate
    currency
    serviceType
  }
  
  # Payroll completion tracking for integration
  payrollCompletionStats: payrollDatesAggregate(
    where: { 
      adjustedEftDate: { _gte: $thirtyDaysAgoDate }
    }
  ) {
    aggregate {
      count
    }
  }
  
  completedPayrollDates: payrollDatesAggregate(
    where: { 
      status: { _eq: "completed" }
      adjustedEftDate: { _gte: $thirtyDaysAgoDate }
    }
  ) {
    aggregate {
      count
    }
  }
  
  # Recent payroll dates ready for billing
  payrollDatesReadyForBilling: payrollDates(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: $sevenDaysAgoDate } }
        { _not: { billingItems: {} } }
      ]
    }
    limit: 10
    orderBy: { completedAt: DESC }
  ) {
    id
    payrollId
    adjustedEftDate
    completedAt
    completedBy
    payroll {
      id
      name
      client {
        id
        name
      }
      primaryConsultant {
        id
        firstName
        lastName
      }
    }
  }
  
  # Time entries for analytics
  recentTimeEntries: timeEntries(
    where: {
      workDate: {
        _gte: $sevenDaysAgoDate
      }
    }
    limit: 20
    orderBy: { workDate: DESC }
  ) {
    id
    hoursSpent
    workDate
    description
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
    }
    payroll {
      id
      name
    }
  }
  
  # User performance data
  staffUsers: users(
    where: { 
      isActive: { _eq: true }
      role: { _in: ["consultant", "manager", "org_admin"] }
    }
    orderBy: [{ firstName: ASC }, { lastName: ASC }]
  ) {
    id
    firstName
    lastName
    email
    role
  }
}

# Additional Queries for Client and User Selection
query GetClientsForBillingItemsAdvanced {
  clients(
    where: { active: { _eq: true } }
    orderBy: { name: ASC }
  ) {
    id
    name
    contactEmail
    active
  }
}

query GetUsersForBillingItemsAdvanced {
  users(
    where: { isActive: { _eq: true } }
    orderBy: [{ firstName: ASC }, { lastName: ASC }]
  ) {
    id
    firstName
    lastName
    email
    role
  }
}

# Audit Queries
query GetBillingItemAuditLogAdvanced(
  $billingItemId: String!
  $limit: Int = 50
  $offset: Int = 0
) {
  auditAuditLog(
    where: {
      _and: [
        { resourceType: { _eq: "billing_items" } }
        { resourceId: { _eq: $billingItemId } }
      ]
    }
    limit: $limit
    offset: $offset
    orderBy: { createdAt: DESC }
  ) {
    id
    action
    oldValues
    newValues
    createdAt
    ipAddress
    userAgent
    userId
    userEmail
    userRole
  }
}

# Time Entries Operations for Billing Integration

# Get user time entries for payroll completion
query GetUserTimeEntries($payrollDateId: uuid!) {
  timeEntries(where: {
    payrollDateId: { _eq: $payrollDateId }
    isBillableToService: { _eq: true }
  }) {
    id
    staffUserId
    hoursSpent
    userHourlyRate
    calculatedFee
    assignedServiceId
    description
    workDate
    staffUser {
      computedName
      seniorityLevel
    }
    assignedService {
      name
      serviceCode
      seniorityMultipliers
    }
  }
}

# Get payroll completion data including service agreements
query GetPayrollCompletionData($payrollDateId: uuid!) {
  payrollDates(where: { id: { _eq: $payrollDateId } }) {
    id
    originalEftDate
    adjustedEftDate
    status
    completedAt
    completedBy
    payroll {
      id
      name
      clientId
      client {
        id
        name
      }
      payrollServiceAgreementsForPayroll(where: { isActive: { _eq: true } }) {
        id
        customQuantity
        customRate
        billingNotes
        payrollServiceAgreementsByServiceId {
          id
          name
          serviceCode
          category
          defaultRate
          billingUnit
          chargeBasis
          serviceType
          currency
        }
        clientServiceAgreement {
          id
          customRate
          isActive
        }
      }
    }
  }
  
  billingItems(where: { 
    payrollDateId: { _eq: $payrollDateId }
  }) {
    id
    serviceId
    serviceName
    description
    quantity
    unitPrice
    totalAmount
    status
  }
}

# Service Management Operations
query GetAllServices {
  services(orderBy: { name: ASC }) {
    id
    name
    serviceCode
    description
    defaultRate
    category
    serviceType
    billingUnitTypeId
    billingUnitType {
      id
      name
      displayName
      description
      defaultSource
      requiresQuantityInput
      quantityPrompt
      isSystemDefined
    }
    seniorityMultipliers
    approvalLevel
    isActive
    createdAt
    updatedAt
  }
}

query GetActiveBillingUnitTypes {
  billingUnitTypes(where: { isActive: { _eq: true } }, orderBy: { isSystemDefined: DESC, name: ASC }) {
    id
    name
    displayName
    description
    defaultSource
    isSystemDefined
    requiresQuantityInput
    quantityPrompt
  }
}

query GetServiceStatistics {
  servicesAggregate {
    aggregate {
      count
    }
  }
  activeServicesAggregate: servicesAggregate(where: { isActive: { _eq: true } }) {
    aggregate {
      count
    }
  }
  servicesByCategory: servicesAggregate {
    aggregate {
      count
    }
  }
}

mutation CreateService($input: ServicesInsertInput!) {
  insertServicesOne(object: $input) {
    id
    name
    serviceCode
    category
    defaultRate
    billingUnitTypeId
    billingUnitType {
      id
      name
      displayName
    }
  }
}

mutation UpdateService($id: uuid!, $input: ServicesSetInput!) {
  updateServicesByPk(pkColumns: { id: $id }, _set: $input) {
    id
    name
    serviceCode
    billingUnitTypeId
    billingUnitType {
      id
      name
      displayName
    }
    updatedAt
  }
}

mutation DeleteService($id: uuid!) {
  deleteServicesByPk(id: $id) {
    id
    name
  }
}

query GetTimeEntriesByPayrollDocument(
  $payrollId: uuid!
  $limit: Int = 100
  $offset: Int = 0
) {
  timeEntries(
    where: { payrollId: { _eq: $payrollId } }
    limit: $limit
    offset: $offset
    orderBy: { workDate: DESC }
  ) {
    id
    payrollId
    clientId
    staffUserId
    hoursSpent
    description
    workDate
    createdAt
    updatedAt
    client {
      id
      name
      contactEmail
    }
    staffUser {
      id
      firstName
      lastName
      computedName
      email
    }
    payroll {
      id
      name
      status
    }
  }
  
  timeEntriesAggregate(
    where: { payrollId: { _eq: $payrollId } }
  ) {
    aggregate {
      count
      sum {
        hoursSpent
      }
      avg {
        hoursSpent
      }
    }
  }
}

query GetTimeEntriesByPayrollDateDocument(
  $payrollDateId: uuid!
  $limit: Int = 100
  $offset: Int = 0
) {
  timeEntries(
    where: { payrollDateId: { _eq: $payrollDateId } }
    limit: $limit
    offset: $offset
    orderBy: { workDate: DESC }
  ) {
    id
    payrollId
    payrollDateId
    clientId
    staffUserId
    hoursSpent
    description
    workDate
    createdAt
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
      computedName
    }
  }
}

query GetTimeEntriesForBillingDocument(
  $payrollId: uuid
  $clientId: uuid
  $staffUserId: uuid
  $startDate: date
  $endDate: date
) {
  timeEntries(
    where: {
      _and: [
        { payrollId: { _eq: $payrollId } }
        { clientId: { _eq: $clientId } }
        { staffUserId: { _eq: $staffUserId } }
        { workDate: { _gte: $startDate, _lte: $endDate } }
      ]
    }
    orderBy: { workDate: DESC }
  ) {
    id
    payrollId
    clientId
    staffUserId
    hoursSpent
    description
    workDate
    createdAt
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
      computedName
      email
    }
  }
  
  timeEntriesAggregate(
    where: {
      _and: [
        { payrollId: { _eq: $payrollId } }
        { clientId: { _eq: $clientId } }
        { staffUserId: { _eq: $staffUserId } }
        { workDate: { _gte: $startDate, _lte: $endDate } }
      ]
    }
  ) {
    aggregate {
      count
      sum {
        hoursSpent
      }
    }
  }
}

# Time Entry Operations (removed fields that don't exist in schema)

# Payroll Integration Operations for Billing System

# Get a specific payroll by ID for billing interface
query GetPayrollByIdForBillingDocument($payrollId: uuid!) {
  payrollsByPk(id: $payrollId) {
    id
    name
    clientId
    billingStatus
    payslipCount
    employeeCount
    newEmployees
    terminatedEmployees
    estimatedRevenue
    actualRevenue
    estimatedHours
    actualHours
    profitMargin
    lastBilledDate
    client {
      id
      name
    }
    billingItems(where: { status: { _neq: "draft" } }) {
      id
      amount
      status
    }
  }
}

query GetPayrollDatesWithBillingStatusDocument(
  $limit: Int = 50
  $offset: Int = 0
  $status: String
  $includeCompleted: Boolean = true
) {
  payrollDates(
    where: {
      _and: [
        { status: { _eq: $status } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" } }
      ]
    }
    limit: $limit
    offset: $offset
    orderBy: { adjustedEftDate: DESC }
  ) {
    id
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
    status
    completedAt
    completedBy
    totalTimeSpentMinutes
    completionNotes
    notes
    createdAt
    updatedAt
    payroll {
      id
      name
      status
      clientId
      employeeCount
      client {
        id
        name
        contactEmail
      }
      primaryConsultant {
        id
        firstName
        lastName
        computedName
      }
      backupConsultant {
        id
        firstName
        lastName
        computedName
      }
    }
    # Check if billing has been generated for this payroll date
    billingItems: billingItemsAggregate(
      where: { payrollId: { _eq: payrollId } }
    ) {
      aggregate {
        count
      }
    }
  }
}

query GetPayrollCompletionStatsDocument {
  # All pending payroll dates
  pendingPayrollDates: payrollDatesAggregate(
    where: { 
      status: { _in: ["pending", "processing"] }
      adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" }
    }
  ) {
    aggregate {
      count
    }
  }
  
  # All completed payroll dates
  completedPayrollDates: payrollDatesAggregate(
    where: { 
      status: { _eq: "completed" }
      adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" }
    }
  ) {
    aggregate {
      count
    }
  }
  
  # Completed but billing not generated
  readyForBilling: payrollDatesAggregate(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" } }
        { _not: { billingItems: {} } }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
  
  # Completed with billing generated
  billingGenerated: payrollDatesAggregate(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" } }
        { billingItems: {} }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
}

query GetPayrollDatesBillingReadyDocument(
  $limit: Int = 20
) {
  payrollDates(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '7 days')" } }
        { _not: { billingItems: {} } }
      ]
    }
    limit: $limit
    orderBy: { completedAt: DESC }
  ) {
    id
    payrollId
    adjustedEftDate
    completedAt
    completedBy
    payroll {
      id
      name
      client {
        id
        name
      }
    }
  }
}

# Generate billing items from completed payroll date (simplified approach)
mutation GenerateBillingFromPayrollDateDocument(
  $payrollDateId: uuid!
  $generatedBy: uuid!
) {
  # This mutation will need to be implemented as an API endpoint
  # For now, we'll create a simple billing item as a placeholder
  insertBillingItemsOne(
    object: {
      description: "Auto-generated from payroll completion"
      quantity: 1
      unitPrice: 0
      totalAmount: 0
      status: "draft"
      staffUserId: $generatedBy
    }
  ) {
    id
    description
    status
    createdAt
  }
}

# Profitability Analytics Operations
query GetPayrollProfitabilityAnalytics(
  $clientId: uuid
  $dateFrom: timestamptz
  $dateTo: timestamptz
  $limit: Int = 50
  $offset: Int = 0
) {
  payrolls(
    where: {
      _and: [
        { clientId: { _eq: $clientId } }
        { createdAt: { _gte: $dateFrom } }
        { createdAt: { _lte: $dateTo } }
        { supersededDate: { _isNull: true } }
      ]
    }
    limit: $limit
    offset: $offset
    orderBy: { createdAt: DESC }
  ) {
    id
    name
    clientId
    client {
      id
      name
    }
    status
    createdAt
    primaryConsultant {
      id
      firstName
      lastName
    }
    backupConsultant {
      id
      firstName
      lastName
    }
    billingItems(
      where: { status: { _eq: "approved" } }
    ) {
      id
      amount
      totalAmount
      quantity
      serviceName
      createdAt
    }
    timeEntries {
      id
      hoursSpent
      workDate
      createdAt
    }
  }
}

query GetStaffBillingPerformanceAnalytics(
  $staffUserId: uuid
  $timestampFrom: timestamp
  $timestampTo: timestamp
  $dateFrom: date
  $dateTo: date
  $limit: Int = 50
) {
  billingItems(
    where: {
      _and: [
        { staffUserId: { _eq: $staffUserId } }
        { createdAt: { _gte: $timestampFrom } }
        { createdAt: { _lte: $timestampTo } }
        { status: { _eq: "approved" } }
      ]
    }
    limit: $limit
    orderBy: { createdAt: DESC }
  ) {
    id
    amount
    totalAmount
    quantity
    serviceName
    createdAt
    staffUser {
      id
      firstName
      lastName
      email
      role
    }
    client {
      id
      name
    }
    payroll {
      id
      name
    }
  }
  
  timeEntries(
    where: {
      _and: [
        { staffUserId: { _eq: $staffUserId } }
        { workDate: { _gte: $dateFrom } }
        { workDate: { _lte: $dateTo } }
      ]
    }
    orderBy: { workDate: DESC }
  ) {
    id
    hoursSpent
    workDate
    description
    staffUser {
      id
      firstName
      lastName
    }
    client {
      id
      name
    }
    payroll {
      id
      name
    }
  }
}

query GetProfitabilityStatsAdvanced(
  $clientId: uuid
  $staffUserId: uuid
  $timestampFrom: timestamp
  $timestampTo: timestamp
  $dateFrom: date
  $dateTo: date
) {
  # Total revenue from approved billing items
  totalRevenue: billingItemsAggregate(
    where: {
      _and: [
        { createdAt: { _gte: $timestampFrom } }
        { createdAt: { _lte: $timestampTo } }
        { status: { _eq: "approved" } }
      ]
    }
  ) {
    aggregate {
      sum {
        totalAmount
      }
      count
    }
  }
  
  # Total hours from time entries
  totalHours: timeEntriesAggregate(
    where: {
      _and: [
        { workDate: { _gte: $dateFrom } }
        { workDate: { _lte: $dateTo } }
      ]
    }
  ) {
    aggregate {
      sum {
        hoursSpent
      }
      count
    }
  }
  
  # Pending billing items  
  pendingRevenue: billingItemsAggregate(
    where: {
      _and: [
        { createdAt: { _gte: $timestampFrom } }
        { createdAt: { _lte: $timestampTo } }
        { status: { _eq: "pending" } }
      ]
    }
  ) {
    aggregate {
      sum {
        totalAmount
      }
      count
    }
  }
}

# User Billing Rate Management Operations
query GetUserBillingRatesAdvanced {
  users(where: { isActive: { _eq: true } }) {
    id
    email
    firstName
    lastName
    computedName
    role
    currentHourlyRate
    seniorityLevel
    isActive
    userBillingRates(orderBy: { effectiveFrom: DESC }) {
      id
      hourlyRate
      seniorityLevel
      effectiveFrom
      effectiveTo
      isActive
      createdAt
      createdByUser {
        computedName
      }
    }
  }
}

query GetUserBillingStatisticsAdvanced {
  usersAggregate(where: { isActive: { _eq: true } }) {
    aggregate {
      count
    }
  }
  usersWithRatesAggregate: usersAggregate(where: { 
    isActive: { _eq: true } 
    currentHourlyRate: { _isNull: false } 
  }) {
    aggregate {
      count
      avg {
        currentHourlyRate
      }
      min {
        currentHourlyRate
      }
      max {
        currentHourlyRate
      }
    }
  }
  ratesByRole: usersAggregate(
    where: { isActive: { _eq: true }, currentHourlyRate: { _isNull: false } }
  ) {
    aggregate {
      count
      avg {
        currentHourlyRate
      }
    }
  }
}

mutation CreateUserBillingRateAdvanced($input: UserBillingRatesInsertInput!) {
  insertUserBillingRatesOne(object: $input) {
    id
    hourlyRate
    seniorityLevel
    effectiveFrom
    user {
      computedName
      currentHourlyRate
    }
  }
}

mutation UpdateUserBillingRateAdvanced($id: uuid!, $input: UserBillingRatesSetInput!) {
  updateUserBillingRatesByPk(pkColumns: { id: $id }, _set: $input) {
    id
    hourlyRate
    effectiveFrom
    effectiveTo
  }
}

mutation UpdateUserCurrentRateAdvanced($userId: uuid!, $hourlyRate: numeric!, $seniorityLevel: seniority_level_type!) {
  updateUsersByPk(
    pkColumns: { id: $userId }
    _set: { 
      currentHourlyRate: $hourlyRate
      seniorityLevel: $seniorityLevel
    }
  ) {
    id
    currentHourlyRate
    seniorityLevel
  }
}

mutation DeactivateUserBillingRateAdvanced($id: uuid!, $effectiveTo: date!) {
  updateUserBillingRatesByPk(
    pkColumns: { id: $id }
    _set: { isActive: false, effectiveTo: $effectiveTo }
  ) {
    id
    effectiveTo
  }
}

# Service Management Dashboard Overview
query GetServiceManagementOverviewAdvanced($thirtyDaysAgo: timestamptz!) {
  # Service statistics
  servicesAggregate {
    aggregate {
      count
    }
  }
  activeServicesAggregate: servicesAggregate(where: { isActive: { _eq: true } }) {
    aggregate {
      count
      avg {
        baseRate
      }
    }
  }
  
  # User billing rate statistics  
  usersAggregate(where: { isActive: { _eq: true } }) {
    aggregate {
      count
    }
  }
  usersWithRatesAggregate: usersAggregate(where: { 
    isActive: { _eq: true }
    currentHourlyRate: { _isNull: false }
  }) {
    aggregate {
      count
      avg {
        currentHourlyRate
      }
      max {
        currentHourlyRate
      }
      min {
        currentHourlyRate
      }
    }
  }
  
  # Client assignment statistics
  clientsAggregate(where: { active: { _eq: true } }) {
    aggregate {
      count
    }
  }
  assignmentsAggregate: clientServiceAgreementsAggregate(where: { isActive: { _eq: true } }) {
    aggregate {
      count
    }
  }
  
  # Recent activity (services created in last 30 days)
  recentServicesAggregate: servicesAggregate(where: { 
    createdAt: { _gte: $thirtyDaysAgo }
  }) {
    aggregate {
      count
    }
  }
  
  # Assignment coverage per client
  clientsWithAssignments: clientServiceAgreementsAggregate(
    where: { isActive: { _eq: true } }
  ) {
    aggregate {
      count
    }
  }
}

# Client Service Assignment Management Operations
query GetClientServiceAssignmentsAdvanced {
  clientServiceAgreements(orderBy: { client: { name: ASC } }) {
    id
    clientId
    serviceId
    customRate
    isActive
    createdAt
    updatedAt
    client {
      id
      name
      active
    }
    service {
      id
      name
      serviceCode
      category
      baseRate
      billingUnit
      chargeBasis
      seniorityMultipliers
    }
    createdByUser {
      computedName
    }
  }
}

query GetClientsAndServicesAdvanced {
  clients(where: { active: { _eq: true } }, orderBy: { name: ASC }) {
    id
    name
    active
  }
  services(where: { isActive: { _eq: true } }, orderBy: { name: ASC }) {
    id
    name
    serviceCode
    category
    baseRate
    billingUnit
    chargeBasis
    seniorityMultipliers
  }
}

query GetClientAssignmentStatisticsAdvanced {
  assignmentsAggregate: clientServiceAgreementsAggregate {
    aggregate {
      count
    }
  }
  activeAssignmentsAggregate: clientServiceAgreementsAggregate(where: { isActive: { _eq: true } }) {
    aggregate {
      count
    }
  }
  clientsWithAssignments: clientServiceAgreementsAggregate(
    where: { isActive: { _eq: true } }
  ) {
    aggregate {
      count
    }
  }
}

mutation CreateClientServiceAssignmentAdvanced($input: ClientServiceAgreementsInsertInput!) {
  insertClientServiceAgreementsOne(object: $input) {
    id
    client {
      name
    }
    service {
      name
    }
  }
}

mutation UpdateClientServiceAssignmentAdvanced($id: uuid!, $input: ClientServiceAgreementsSetInput!) {
  updateClientServiceAgreementsByPk(pkColumns: { id: $id }, _set: $input) {
    id
    customRate
    isActive
  }
}

mutation DeleteClientServiceAssignmentAdvanced($id: uuid!) {
  deleteClientServiceAgreementsByPk(id: $id) {
    id
    client {
      name
    }
    service {
      name
    }
  }
}

# Recurring Services Panel Operations
query GetClientServiceAssignmentsForRecurringAdvanced($clientId: uuid!) {
  clientServiceAgreements(
    where: { clientId: { _eq: $clientId }, isActive: { _eq: true } }
  ) {
    id
    serviceId
    customRate
    isActive
    createdAt
    updatedAt
    service {
      id
      name
      serviceCode
      description
      baseRate
      category
      chargeBasis
      approvalLevel
    }
  }
}

mutation CreateClientServiceAssignmentForRecurringAdvanced(
  $input: ClientServiceAgreementsInsertInput!
) {
  insertClientServiceAgreementsOne(object: $input) {
    id
    serviceId
    customRate
    isActive
    service {
      id
      name
      serviceCode
      baseRate
      category
    }
  }
}

mutation UpdateClientServiceAssignmentForRecurringAdvanced(
  $id: uuid!
  $updates: ClientServiceAgreementsSetInput!
) {
  updateClientServiceAgreementsByPk(pkColumns: { id: $id }, _set: $updates) {
    id
    serviceId
    customRate
    isActive
  }
}

# Recurring Services Manager Operations
query GetRecurringServicesAdvanced {
  services(where: { 
    chargeBasis: { _in: ["per_client_monthly", "per_payroll_monthly"] }
    isActive: { _eq: true }
  }) {
    id
    name
    serviceCode
    description
    baseRate
    category
    chargeBasis
    approvalLevel
  }
}

query GetClientServiceAssignmentsForManagerAdvanced($clientId: uuid!) {
  clientServiceAgreements(where: {
    clientId: { _eq: $clientId }
    isActive: { _eq: true }
  }) {
    id
    serviceId
    customRate
    isActive
    createdAt
    updatedAt
    service {
      id
      name
      serviceCode
      description
      baseRate
      category
      chargeBasis
      approvalLevel
    }
  }
}

mutation CreateClientServiceAssignmentForManagerAdvanced($input: ClientServiceAgreementsInsertInput!) {
  insertClientServiceAgreementsOne(object: $input) {
    id
    serviceId
    customRate
    isActive
    service {
      id
      name
      serviceCode
      baseRate
      category
    }
  }
}

mutation UpdateClientServiceAssignmentForManagerAdvanced($id: uuid!, $updates: ClientServiceAgreementsSetInput!) {
  updateClientServiceAgreementsByPk(pkColumns: { id: $id }, _set: $updates) {
    id
    serviceId
    customRate
    isActive
    service {
      id
      name
      serviceCode
      baseRate
      category
    }
  }
}

# Payroll Service Assignment Operations
# These operations manage the assignment of services to specific payrolls
# This bridges the gap between client-service assignments and billing generation

fragment PayrollServiceAssignmentCore on PayrollServiceAgreements {
  id
  payrollId
  serviceId
  clientServiceAgreementId
  customQuantity
  customRate
  billingNotes
  isActive
  createdAt
  updatedAt
  createdBy
}

fragment PayrollServiceAssignmentWithRelations on PayrollServiceAgreements {
  ...PayrollServiceAssignmentCore
  payrollServiceAgreementsForPayroll {
    id
    name
    status
    client {
      id
      name
    }
  }
  payrollServiceAgreementsByServiceId {
    id
    name
    description
    category
    billingUnit
    baseRate
    currency
    serviceType
  }
  clientServiceAgreement {
    id
    customRate
    isActive
    client {
      id
      name
    }
  }
  serviceAgreementCreatedByUser {
    id
    firstName
    lastName
    email
  }
}

# Queries for Payroll Service Assignments
query GetPayrollServiceAgreementsForCompletion(
  $payrollId: uuid!
  $limit: Int = 50
  $offset: Int = 0
) {
  payrollServiceAgreements(
    where: { 
      payrollId: { _eq: $payrollId }
      isActive: { _eq: true }
    }
    limit: $limit
    offset: $offset
    orderBy: [{ payrollServiceAgreementsByServiceId: { category: ASC } }, { payrollServiceAgreementsByServiceId: { name: ASC } }]
  ) {
    ...PayrollServiceAssignmentWithRelations
  }
}

query GetPayrollServiceAssignmentById($id: uuid!) {
  payrollServiceAgreementsByPk(id: $id) {
    ...PayrollServiceAssignmentWithRelations
  }
}

query GetAvailableServicesForPayroll(
  $payrollId: uuid!
  $clientId: uuid!
) {
  # Get services already assigned to this client that aren't yet assigned to this payroll
  clientServiceAgreements(
    where: {
      _and: [
        { clientId: { _eq: $clientId } }
        { isActive: { _eq: true } }
        { _not: { 
          payrollServiceAgreements: { 
            payrollId: { _eq: $payrollId }
            isActive: { _eq: true }
          } 
        } }
      ]
    }
    orderBy: [{ service: { category: ASC } }, { service: { name: ASC } }]
  ) {
    id
    customRate
    isActive
    service {
      id
      name
      description
      category
      billingUnit
      baseRate
      currency
      serviceType
      chargeBasis
      approvalLevel
    }
    client {
      id
      name
    }
  }
}

# Mutations for Payroll Service Assignments
mutation AssignServiceToPayroll(
  $payrollId: uuid!
  $serviceId: uuid!
  $clientServiceAgreementId: uuid!
  $customQuantity: Int = 1
  $customRate: numeric
  $billingNotes: String
  $createdBy: uuid!
) {
  insertPayrollServiceAgreementsOne(
    object: {
      payrollId: $payrollId
      serviceId: $serviceId
      clientServiceAgreementId: $clientServiceAgreementId
      customQuantity: $customQuantity
      customRate: $customRate
      billingNotes: $billingNotes
      isActive: true
      createdBy: $createdBy
    }
    onConflict: {
      constraint: payroll_service_agreements_payroll_id_service_id_key
      updateColumns: [customQuantity, customRate, billingNotes, isActive, updatedAt]
    }
  ) {
    ...PayrollServiceAssignmentWithRelations
  }
}

mutation UpdatePayrollServiceAssignment(
  $id: uuid!
  $customQuantity: Int
  $customRate: numeric
  $billingNotes: String
  $isActive: Boolean
) {
  updatePayrollServiceAgreementsByPk(
    pkColumns: { id: $id }
    _set: {
      customQuantity: $customQuantity
      customRate: $customRate
      billingNotes: $billingNotes
      isActive: $isActive
      updatedAt: "now()"
    }
  ) {
    ...PayrollServiceAssignmentWithRelations
  }
}

mutation BulkAssignServicesToPayroll(
  $assignments: [PayrollServiceAgreementsInsertInput!]!
) {
  insertPayrollServiceAgreements(
    objects: $assignments
    onConflict: {
      constraint: payroll_service_agreements_payroll_id_service_id_key
      updateColumns: [customQuantity, customRate, billingNotes, isActive, updatedAt]
    }
  ) {
    affectedRows
    returning {
      ...PayrollServiceAssignmentCore
    }
  }
}

mutation RemoveServiceFromPayroll(
  $id: uuid!
) {
  updatePayrollServiceAgreementsByPk(
    pkColumns: { id: $id }
    _set: {
      isActive: false
      updatedAt: "now()"
    }
  ) {
    ...PayrollServiceAssignmentCore
  }
}

# Enhanced queries for service assignment workflow
query GetPayrollWithServiceAssignments($payrollId: uuid!) {
  payrollsByPk(id: $payrollId) {
    id
    name
    status
    clientId
    client {
      id
      name
      active
      contactEmail
    }
    primaryConsultant {
      id
      firstName
      lastName
      computedName
    }
    serviceAssignments: payrollServiceAgreementsForPayroll(
      where: { isActive: { _eq: true } }
      orderBy: [{ payrollServiceAgreementsByServiceId: { category: ASC } }, { payrollServiceAgreementsByServiceId: { name: ASC } }]
    ) {
      ...PayrollServiceAssignmentWithRelations
    }
  }
}

query GetClientServiceAgreementsForPayroll(
  $clientId: uuid!
  $excludePayrollId: uuid
) {
  clientServiceAgreements(
    where: {
      _and: [
        { clientId: { _eq: $clientId } }
        { isActive: { _eq: true } }
        { service: { isActive: { _eq: true } } }
      ]
    }
    orderBy: [{ service: { category: ASC } }, { service: { name: ASC } }]
  ) {
    id
    customRate
    isActive
    service {
      id
      name
      description
      category
      billingUnit
      baseRate
      currency
      serviceType
      chargeBasis
      approvalLevel
    }
    # Check if this service is already assigned to the payroll
    payrollAssignments: payrollServiceAgreements(
      where: {
        _and: [
          { payrollId: { _eq: $excludePayrollId } }
          { isActive: { _eq: true } }
        ]
      }
    ) {
      id
      customQuantity
      customRate
      isActive
    }
  }
}

# ============================================
# Tier 1 Billing Engine Operations
# Migrated from domains/billing/services/tier1-billing-engine.ts
# ============================================

# Get Payroll Information for Tier 1 Billing
query GetPayrollInfoForTier1Billing($payrollDateId: uuid!) {
  payrollDates(where: { id: { _eq: $payrollDateId } }) {
    id
    payrollId
    originalEftDate
    adjustedEftDate
    status
    payroll {
      id
      name
      clientId
      client {
        id
        name
      }
    }
  }
}

# Get Client Service Agreements for Tier 1 Billing
query GetClientServiceAgreementsForTier1Billing($clientId: uuid!) {
  clientServiceAgreements(
    where: { 
      clientId: { _eq: $clientId }
      isActive: { _eq: true }
    }
  ) {
    id
    serviceId
    customRate
    billingFrequency
    autoBillingTriggers
    service {
      id
      name
      serviceCode
      defaultRate
    }
  }
}

# Get Payroll Service Agreements for Tier 1 Billing
query GetPayrollServiceAgreementsForTier1BillingEngine($payrollId: uuid!) {
  payrollServiceAgreements(where: { payrollId: { _eq: $payrollId } }) {
    id
    customRate
    customQuantity
    customDescription
    billingNotes
    serviceConfiguration
  }
}

# Insert Tier 1 Billing Items
mutation InsertTier1BillingItems($items: [BillingItemsInsertInput!]!) {
  insertBillingItems(objects: $items) {
    returning {
      id
      serviceCode
      serviceName
      quantity
      unitPrice
      totalAmount
      status
      autoGenerated
      createdAt
    }
  }
}

# Update Completion Metrics for Tier 1 Billing  
mutation UpdateTier1CompletionMetrics($payrollDateId: uuid!) {
  updatePayrollDates(
    where: { id: { _eq: $payrollDateId } }
    _set: { 
      completionNotes: "Billing generated via Tier 1 engine"
    }
  ) {
    affectedRows
  }
}

# =============================================================================
# API ROUTE OPERATIONS - Tier 1 Generation
# =============================================================================

# Check Payroll Date Status for Tier 1 API
query CheckPayrollDateApiTier1($id: uuid!) {
  payrollDatesByPk(id: $id) {
    id
    status
    payrollId
    completedAt
    completedBy
    adjustedEftDate
    originalEftDate
    payroll {
      id
      name
      clientId
      client {
        id
        name
      }
    }
  }
}

# Get Tier 1 Services for API Generation
query GetTier1ServicesForApi($clientId: uuid!) {
  clientServiceAgreements(
    where: {
      clientId: { _eq: $clientId }
      isActive: { _eq: true }
      isEnabled: { _eq: true }
      service: { 
        isActive: { _eq: true }
      }
      billingFrequency: { _in: ["per_use", "per_payroll_date"] }
    }
  ) {
    id
    serviceId
    customRate
    billingFrequency
    serviceConfiguration
    service {
      id
      name
      description
      billingUnit
      defaultRate
    }
  }
}

# Check Existing Billing for API
query CheckExistingBillingApi($payrollDateId: uuid!, $serviceId: uuid!) {
  billingItems(
    where: {
      payrollDateId: { _eq: $payrollDateId }
      serviceId: { _eq: $serviceId }
      status: { _neq: "draft" }
    }
  ) {
    id
  }
}

# Create Billing Item for API  
mutation CreateBillingItemApi($input: BillingItemsInsertInput!) {
  insertBillingItemsOne(object: $input) {
    id
    description
    totalAmount
  }
}

# Log Billing Event for API
mutation LogBillingEventApi($input: BillingEventLogInsertInput!) {
  insertBillingEventLogOne(object: $input) {
    id
  }
}

# =============================================================================
# API ROUTE OPERATIONS - Tier 2 Generation
# =============================================================================

# Check Payroll Completion Status for Tier 2 API
query CheckPayrollCompletionApiTier2($id: uuid!) {
  payrollsByPk(id: $id) {
    id
    name
    clientId
    status
    client {
      id
      name
    }
    payrollDates {
      id
      status
    }
  }
}

# Get Tier 2 Services for API Generation
query GetTier2ServicesForApi($payrollId: uuid!, $clientId: uuid!) {
  # Client service agreements for tier 2
  clientServiceAgreements(
    where: {
      clientId: { _eq: $clientId }
      isActive: { _eq: true }
      isEnabled: { _eq: true }
      service: { 
        isActive: { _eq: true }
      }
      billingFrequency: { _in: ["per_payroll", "per_use"] }
    }
  ) {
    id
    serviceId
    customRate
    billingFrequency
    serviceConfiguration
    service {
      id
      name
      description
      billingUnit
      defaultRate
    }
  }
  
  # Payroll-specific service agreements (overrides)
  payrollServiceAgreements(
    where: {
      payrollId: { _eq: $payrollId }
      isActive: { _eq: true }
      autoBillingEnabled: { _eq: true }
    }
  ) {
    id
    serviceId
    customRate
    billingFrequency
    serviceConfiguration
    payrollServiceAgreementsByServiceId {
      id
      name
      description
      billingUnit
      defaultRate
    }
  }
}

# Check Existing Tier 2 Billing for API
query CheckExistingTier2BillingApi($payrollId: uuid!, $serviceId: uuid!) {
  billingItems(
    where: {
      payrollId: { _eq: $payrollId }
      serviceId: { _eq: $serviceId }
      payrollDateId: { _isNull: true }
      status: { _neq: "draft" }
    }
  ) {
    id
  }
}

# =============================================================================
# API ROUTE OPERATIONS - Tier 3 Generation
# =============================================================================

# Check Client for Tier 3 API
query CheckClientApiTier3($id: uuid!) {
  clientsByPk(id: $id) {
    id
    name
    active
  }
}

# Check Monthly Billing Completion for Tier 3 API
query CheckMonthlyCompletionApiTier3($clientId: uuid!, $billingMonth: date!) {
  monthlyBillingCompletion(
    where: {
      clientId: { _eq: $clientId }
      billingMonth: { _eq: $billingMonth }
    }
  ) {
    id
    status
    tier3BillingGenerated
    autoBillingEnabled
    completedPayrolls
    totalPayrolls
    completedPayrollDates
    totalPayrollDates
  }
}

# Get Tier 3 Services for API Generation
query GetTier3ServicesForApi($clientId: uuid!) {
  clientServiceAgreements(
    where: {
      clientId: { _eq: $clientId }
      isActive: { _eq: true }
      isEnabled: { _eq: true }
      service: { 
        isActive: { _eq: true }
      }
      billingFrequency: { _eq: "monthly" }
    }
  ) {
    id
    serviceId
    customRate
    billingFrequency
    serviceConfiguration
    service {
      id
      name
      description
      billingUnit
      defaultRate
    }
  }
}

# Check Existing Tier 3 Billing for API
query CheckExistingTier3BillingApi($clientId: uuid!, $serviceId: uuid!, $monthStart: timestamp!, $monthEnd: timestamp!) {
  billingItems(
    where: {
      clientId: { _eq: $clientId }
      serviceId: { _eq: $serviceId }
      payrollId: { _isNull: true }
      payrollDateId: { _isNull: true }
      createdAt: { _gte: $monthStart, _lte: $monthEnd }
      status: { _neq: "draft" }
    }
  ) {
    id
  }
}

# Get Employee Count for Tier 3 API  
query GetEmployeeCountApiTier3($clientId: uuid!, $billingMonth: date!) {
  payrolls(
    where: {
      clientId: { _eq: $clientId }
      payrollDates: {
        adjustedEftDate: { _gte: $billingMonth }
      }
    }
  ) {
    employeeCount
  }
}

# Update Monthly Billing Completion for Tier 3 API
mutation UpdateMonthlyCompletionApiTier3($clientId: uuid!, $billingMonth: date!) {
  updateMonthlyBillingCompletion(
    where: {
      clientId: { _eq: $clientId }
      billingMonth: { _eq: $billingMonth }
    }
    _set: {
      status: "billed"
      tier3BillingGenerated: true
      billingGeneratedAt: "now()"
    }
  ) {
    affectedRows
  }
}

# ===========================
# API ROUTE OPERATIONS - Recurring Billing
# ===========================

# Get Active Clients for Recurring Billing API - All Clients
query GetActiveClientsForRecurringApiAll {
  clients(
    where: {
      active: { _eq: true }
    }
    orderBy: [{ name: ASC }]
  ) {
    id
    name
    createdAt
  }
}

# Get Active Clients for Recurring Billing API - Specific Clients
query GetActiveClientsForRecurringApi($clientIds: [uuid!]!) {
  clients(
    where: {
      active: { _eq: true }
      id: { _in: $clientIds }
    }
    orderBy: [{ name: ASC }]
  ) {
    id
    name
    createdAt
  }
}

# Check Existing Recurring Billing for API - All Services
query CheckExistingRecurringBillingApiAll($clientId: uuid!, $billingMonth: date!) {
  billingItems(
    where: {
      clientId: { _eq: $clientId }
      billingPeriodStart: { _eq: $billingMonth }
      generatedFrom: { _eq: "recurring_schedule" }
    }
  ) {
    id
    serviceCode
    totalAmount
  }
}

# Check Existing Recurring Billing for API - Specific Service
query CheckExistingRecurringBillingApi($clientId: uuid!, $billingMonth: date!, $serviceCode: String!) {
  billingItems(
    where: {
      clientId: { _eq: $clientId }
      billingPeriodStart: { _eq: $billingMonth }
      generatedFrom: { _eq: "recurring_schedule" }
      serviceCode: { _eq: $serviceCode }
    }
  ) {
    id
    serviceCode
    totalAmount
  }
}

# Create Recurring Billing Item for API
mutation CreateRecurringBillingItemApi($input: BillingItemsInsertInput!) {
  insertBillingItemsOne(object: $input) {
    id
    totalAmount
  }
}