# Billing Items GraphQL Operations

# Fragments
fragment BillingItemCore on BillingItems {
  id
  description
  amount
  quantity
  unitPrice
  totalAmount
  status
  notes
  createdAt
  updatedAt
  approvalDate
  isApproved
  clientId
  staffUserId
  approvedBy
  confirmedAt
  confirmedBy
  payrollId
  serviceId
  serviceName
  hourlyRate
  invoiceId
}

fragment BillingItemWithRelations on BillingItems {
  ...BillingItemCore
  client {
    id
    name
    contactEmail
  }
  staffUser {
    id
    firstName
    lastName
    email
  }
  approvedByUser {
    id
    firstName
    lastName
    email
  }
  payroll {
    id
    name
    status
  }
  service {
    id
    name
    description
    category
    billingUnit
    defaultRate
    currency
    serviceType
  }
}

fragment BillingItemStats on BillingItemsAggregate {
  aggregate {
    count
    sum {
      amount
      totalAmount
      quantity
    }
    avg {
      amount
      totalAmount
      quantity
    }
  }
}

# Queries
query GetBillingItemsAdvanced(
  $limit: Int = 50
  $offset: Int = 0
  $where: BillingItemsBoolExp
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
) {
  billingItems(
    limit: $limit
    offset: $offset
    where: $where
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
  }
}

query GetBillingItemByIdAdvanced($id: uuid!) {
  billingItemsByPk(id: $id) {
    ...BillingItemWithRelations
  }
}

query GetBillingItemsStatsAdvanced(
  $where: BillingItemsBoolExp = {}
) {
  billingItemsAggregate(where: $where) {
    ...BillingItemStats
  }
  
  pending: billingItemsAggregate(
    where: { 
      _and: [
        $where,
        { status: { _eq: "pending" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  approved: billingItemsAggregate(
    where: { 
      _and: [
        $where,
        { status: { _eq: "approved" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  rejected: billingItemsAggregate(
    where: { 
      _and: [
        $where,
        { status: { _eq: "rejected" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
}

query GetBillingItemsByClientAdvanced(
  $clientId: uuid!
  $limit: Int = 50
  $offset: Int = 0
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
) {
  billingItems(
    where: { clientId: { _eq: $clientId } }
    limit: $limit
    offset: $offset
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
  }
}

query GetBillingItemsByUserAdvanced(
  $userId: uuid!
  $limit: Int = 50
  $offset: Int = 0
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
) {
  billingItems(
    where: { staffUserId: { _eq: $userId } }
    limit: $limit
    offset: $offset
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
  }
}

query GetRecentBillingItemsAdvanced(
  $limit: Int = 10
  $days: Int = 30
) {
  billingItems(
    where: {
      createdAt: {
        _gte: "date_trunc('day', now() - interval '$days days')"
      }
    }
    limit: $limit
    orderBy: { createdAt: DESC }
  ) {
    ...BillingItemWithRelations
  }
}

# Mutations
mutation CreateBillingItemAdvanced($input: BillingItemsInsertInput!) {
  insertBillingItemsOne(object: $input) {
    ...BillingItemWithRelations
  }
}

mutation UpdateBillingItemAdvanced(
  $id: uuid!
  $updates: BillingItemsSetInput!
) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: $updates
  ) {
    ...BillingItemWithRelations
  }
}

mutation DeleteBillingItemAdvanced($id: uuid!) {
  deleteBillingItemsByPk(id: $id) {
    id
    description
  }
}

mutation BulkUpdateBillingItemsStatusAdvanced(
  $ids: [uuid!]!
  $status: String!
  $approvedBy: uuid
) {
  updateBillingItemsMany(
    updates: [{
      where: { id: { _in: $ids } }
      _set: {
        status: $status
        approvedBy: $approvedBy
        approvalDate: "now()"
        isApproved: true
      }
    }]
  ) {
    affectedRows
  }
}

mutation ApproveBillingItemAdvanced(
  $id: uuid!
  $approvedBy: uuid!
) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: {
      status: "approved"
      approvedBy: $approvedBy
      approvalDate: "now()"
      isApproved: true
    }
  ) {
    ...BillingItemWithRelations
  }
}

mutation RejectBillingItemAdvanced(
  $id: uuid!
  $approvedBy: uuid!
  $notes: String
) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: {
      status: "rejected"
      approvedBy: $approvedBy
      approvalDate: "now()"
      isApproved: false
      notes: $notes
    }
  ) {
    ...BillingItemWithRelations
  }
}

mutation ArchiveBillingItemAdvanced($id: uuid!) {
  updateBillingItemsByPk(
    pkColumns: { id: $id }
    _set: {
      status: "archived"
    }
  ) {
    ...BillingItemWithRelations
  }
}

# Subscriptions
subscription BillingItemsSubscriptionAdvanced(
  $where: BillingItemsBoolExp
  $limit: Int = 50
) {
  billingItems(
    where: $where
    limit: $limit
    orderBy: { createdAt: DESC }
  ) {
    ...BillingItemWithRelations
  }
}

subscription BillingItemByIdSubscriptionAdvanced($id: uuid!) {
  billingItemsByPk(id: $id) {
    ...BillingItemWithRelations
  }
}

subscription BillingItemsStatsSubscriptionAdvanced(
  $where: BillingItemsBoolExp
) {
  billingItemsAggregate(where: $where) {
    ...BillingItemStats
  }
}

# Payroll Date Completion Operations
mutation CompletePayrollDate($id: uuid!, $completedBy: uuid!) {
  updatePayrollDatesByPk(
    pkColumns: { id: $id }
    _set: { 
      status: "completed"
      completedAt: "now()"
      completedBy: $completedBy
    }
  ) {
    id
    status
    completedAt
    completedBy
    totalTimeSpentMinutes
    completionNotes
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
  }
}

# Complete payroll date with time tracking
mutation CompletePayrollDateWithTime(
  $id: uuid!
  $completedBy: uuid!
  $timeSpentMinutes: Int = 0
  $completionNotes: String
) {
  updatePayrollDatesByPk(
    pkColumns: { id: $id }
    _set: { 
      status: "completed"
      completedAt: "now()"
      completedBy: $completedBy
      completionNotes: $completionNotes
    }
  ) {
    id
    status
    completedAt
    completedBy
    totalTimeSpentMinutes
    completionNotes
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
  }
}

# Add time entry for payroll date work
mutation AddPayrollDateTimeEntry(
  $payrollDateId: uuid!
  $userId: uuid!
  $timeSpentMinutes: Int!
  $description: String
  $workDate: date
) {
  insertPayrollDateTimeEntriesOne(
    object: {
      payrollDateId: $payrollDateId
      userId: $userId
      timeSpentMinutes: $timeSpentMinutes
      description: $description
      workDate: $workDate
    }
    onConflict: {
      constraint: payroll_date_time_entries_payroll_date_id_user_id_work_date_key
      updateColumns: [timeSpentMinutes, description, updatedAt]
    }
  ) {
    id
    payrollDateId
    userId
    timeSpentMinutes
    description
    workDate
    createdAt
    updatedAt
  }
}

mutation UpdatePayrollDateStatus($id: uuid!, $status: String!, $updatedBy: uuid) {
  updatePayrollDatesByPk(
    pkColumns: { id: $id }
    _set: { 
      status: $status
      updatedAt: "now()"
      completedBy: $updatedBy
    }
  ) {
    id
    status
    completedAt
    completedBy
    payrollId
  }
}

query GetPayrollDatesByStatus($payrollId: uuid!, $status: String) {
  payrollDates(
    where: { 
      payrollId: { _eq: $payrollId }
      _and: { status: { _eq: $status } }
    }
    orderBy: { adjustedEftDate: ASC }
  ) {
    id
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
    status
    completedAt
    completedBy
    notes
    createdAt
    updatedAt
  }
}

query GetPayrollDatesWithStatus($payrollId: uuid!) {
  payrollDates(
    where: { payrollId: { _eq: $payrollId } }
    orderBy: { adjustedEftDate: ASC }
  ) {
    id
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
    status
    completedAt
    completedBy
    notes
    createdAt
    updatedAt
  }
}

# Consolidated Billing Dashboard Query - Replaces multiple separate queries
query GetBillingDashboardComplete(
  $limit: Int = 50
  $offset: Int = 0
  $orderBy: [BillingItemsOrderBy!] = [{ createdAt: DESC }]
  $timeRangeFilter: BillingItemsBoolExp = {}
  $statsFilter: BillingItemsBoolExp = {}
) {
  # Core billing items with all relationships
  billingItems(
    limit: $limit
    offset: $offset
    where: $timeRangeFilter
    orderBy: $orderBy
  ) {
    ...BillingItemWithRelations
    # Additional fields for dashboard
    invoiceId
    timeEntries {
      id
      hoursSpent
      workDate
      description
    }
  }
  
  # Comprehensive billing statistics
  billingStats: billingItemsAggregate(where: $statsFilter) {
    ...BillingItemStats
  }
  
  pendingStats: billingItemsAggregate(
    where: { 
      _and: [
        $statsFilter,
        { status: { _eq: "pending" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  approvedStats: billingItemsAggregate(
    where: { 
      _and: [
        $statsFilter,
        { status: { _eq: "approved" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  draftStats: billingItemsAggregate(
    where: { 
      _and: [
        $statsFilter,
        { status: { _eq: "draft" } }
      ]
    }
  ) {
    ...BillingItemStats
  }
  
  # Recent activity for overview
  recentBillingItems: billingItems(
    limit: 10
    orderBy: [{ createdAt: DESC }]
    where: {
      createdAt: {
        _gte: "date_trunc('day', now() - interval '7 days')"
      }
    }
  ) {
    ...BillingItemCore
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
    }
  }
  
  # Active clients for context
  activeClients: clients(
    where: { active: { _eq: true } }
    orderBy: { name: ASC }
  ) {
    id
    name
    contactEmail
    active
    # Client billing summary
    billingItems(
      where: {
        createdAt: {
          _gte: "date_trunc('month', now())"
        }
      }
    ) {
      id
      amount
      status
    }
  }
  
  # Active services for recurring services
  recurringServices: services(
    where: { 
      chargeBasis: { _in: ["per_client_monthly", "per_payroll_monthly"] }
      isActive: { _eq: true }
    }
    orderBy: { category: ASC }
  ) {
    id
    name
    serviceCode
    description
    baseRate
    category
    chargeBasis
    approvalLevel
    billingUnit
    defaultRate
    currency
    serviceType
  }
  
  # Payroll completion tracking for integration
  payrollCompletionStats: payrollDatesAggregate(
    where: { 
      adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" }
    }
  ) {
    aggregate {
      count
    }
  }
  
  completedPayrollDates: payrollDatesAggregate(
    where: { 
      status: { _eq: "completed" }
      adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" }
    }
  ) {
    aggregate {
      count
    }
  }
  
  # Recent payroll dates ready for billing
  payrollDatesReadyForBilling: payrollDates(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '7 days')" } }
        { _not: { billingItems: {} } }
      ]
    }
    limit: 10
    orderBy: { completedAt: DESC }
  ) {
    id
    payrollId
    adjustedEftDate
    completedAt
    completedBy
    payroll {
      id
      name
      client {
        id
        name
      }
      primaryConsultant {
        id
        firstName
        lastName
      }
    }
  }
  
  # Time entries for analytics
  recentTimeEntries: timeEntries(
    where: {
      workDate: {
        _gte: "date_trunc('day', now() - interval '7 days')"
      }
    }
    limit: 20
    orderBy: { workDate: DESC }
  ) {
    id
    hoursSpent
    workDate
    description
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
    }
    payroll {
      id
      name
    }
  }
  
  # User performance data
  staffUsers: users(
    where: { 
      isActive: { _eq: true }
      role: { _in: ["consultant", "manager", "org_admin"] }
    }
    orderBy: [{ firstName: ASC }, { lastName: ASC }]
  ) {
    id
    firstName
    lastName
    email
    role
  }
}

# Additional Queries for Client and User Selection
query GetClientsForBillingItemsAdvanced {
  clients(
    where: { active: { _eq: true } }
    orderBy: { name: ASC }
  ) {
    id
    name
    contactEmail
    active
  }
}

query GetUsersForBillingItemsAdvanced {
  users(
    where: { isActive: { _eq: true } }
    orderBy: [{ firstName: ASC }, { lastName: ASC }]
  ) {
    id
    firstName
    lastName
    email
    role
  }
}

# Audit Queries
query GetBillingItemAuditLogAdvanced(
  $billingItemId: String!
  $limit: Int = 50
  $offset: Int = 0
) {
  auditAuditLog(
    where: {
      _and: [
        { resourceType: { _eq: "billing_items" } }
        { resourceId: { _eq: $billingItemId } }
      ]
    }
    limit: $limit
    offset: $offset
    orderBy: { createdAt: DESC }
  ) {
    id
    action
    oldValues
    newValues
    createdAt
    ipAddress
    userAgent
    userId
    userEmail
    userRole
  }
}

# Time Entries Operations for Billing Integration
query GetTimeEntriesByPayrollDocument(
  $payrollId: uuid!
  $limit: Int = 100
  $offset: Int = 0
) {
  timeEntries(
    where: { payrollId: { _eq: $payrollId } }
    limit: $limit
    offset: $offset
    orderBy: { workDate: DESC }
  ) {
    id
    payrollId
    clientId
    staffUserId
    hoursSpent
    description
    workDate
    createdAt
    updatedAt
    client {
      id
      name
      contactEmail
    }
    staffUser {
      id
      firstName
      lastName
      computedName
      email
    }
    payroll {
      id
      name
      status
    }
  }
  
  timeEntriesAggregate(
    where: { payrollId: { _eq: $payrollId } }
  ) {
    aggregate {
      count
      sum {
        hoursSpent
      }
      avg {
        hoursSpent
      }
    }
  }
}

query GetTimeEntriesByPayrollDateDocument(
  $payrollDateId: uuid!
  $limit: Int = 100
  $offset: Int = 0
) {
  timeEntries(
    where: { payrollDateId: { _eq: $payrollDateId } }
    limit: $limit
    offset: $offset
    orderBy: { workDate: DESC }
  ) {
    id
    payrollId
    payrollDateId
    clientId
    staffUserId
    hoursSpent
    description
    workDate
    createdAt
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
      computedName
    }
  }
}

query GetTimeEntriesForBillingDocument(
  $payrollId: uuid
  $clientId: uuid
  $staffUserId: uuid
  $startDate: date
  $endDate: date
) {
  timeEntries(
    where: {
      _and: [
        { payrollId: { _eq: $payrollId } }
        { clientId: { _eq: $clientId } }
        { staffUserId: { _eq: $staffUserId } }
        { workDate: { _gte: $startDate, _lte: $endDate } }
      ]
    }
    orderBy: { workDate: DESC }
  ) {
    id
    payrollId
    clientId
    staffUserId
    hoursSpent
    description
    workDate
    createdAt
    client {
      id
      name
    }
    staffUser {
      id
      firstName
      lastName
      computedName
      email
    }
  }
  
  timeEntriesAggregate(
    where: {
      _and: [
        { payrollId: { _eq: $payrollId } }
        { clientId: { _eq: $clientId } }
        { staffUserId: { _eq: $staffUserId } }
        { workDate: { _gte: $startDate, _lte: $endDate } }
      ]
    }
  ) {
    aggregate {
      count
      sum {
        hoursSpent
      }
    }
  }
}

# Time Entry Operations (removed fields that don't exist in schema)

# Payroll Integration Operations for Billing System

# Get a specific payroll by ID for billing interface
query GetPayrollByIdForBillingDocument($payrollId: uuid!) {
  payrollsByPk(id: $payrollId) {
    id
    name
    clientId
    billingStatus
    payslipCount
    employeeCount
    newEmployees
    terminatedEmployees
    estimatedRevenue
    actualRevenue
    estimatedHours
    actualHours
    profitMargin
    lastBilledDate
    client {
      id
      name
    }
    billingItems(where: { status: { _neq: "draft" } }) {
      id
      amount
      status
    }
  }
}

query GetPayrollDatesWithBillingStatusDocument(
  $limit: Int = 50
  $offset: Int = 0
  $status: String
  $includeCompleted: Boolean = true
) {
  payrollDates(
    where: {
      _and: [
        { status: { _eq: $status } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" } }
      ]
    }
    limit: $limit
    offset: $offset
    orderBy: { adjustedEftDate: DESC }
  ) {
    id
    payrollId
    originalEftDate
    adjustedEftDate
    processingDate
    status
    completedAt
    completedBy
    totalTimeSpentMinutes
    completionNotes
    notes
    createdAt
    updatedAt
    payroll {
      id
      name
      status
      clientId
      employeeCount
      client {
        id
        name
        contactEmail
      }
      primaryConsultant {
        id
        firstName
        lastName
        computedName
      }
      backupConsultant {
        id
        firstName
        lastName
        computedName
      }
    }
    # Check if billing has been generated for this payroll date
    billingItems: billingItemsAggregate(
      where: { payrollId: { _eq: payrollId } }
    ) {
      aggregate {
        count
      }
    }
  }
}

query GetPayrollCompletionStatsDocument {
  # All pending payroll dates
  pendingPayrollDates: payrollDatesAggregate(
    where: { 
      status: { _in: ["pending", "processing"] }
      adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" }
    }
  ) {
    aggregate {
      count
    }
  }
  
  # All completed payroll dates
  completedPayrollDates: payrollDatesAggregate(
    where: { 
      status: { _eq: "completed" }
      adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" }
    }
  ) {
    aggregate {
      count
    }
  }
  
  # Completed but billing not generated
  readyForBilling: payrollDatesAggregate(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" } }
        { _not: { billingItems: {} } }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
  
  # Completed with billing generated
  billingGenerated: payrollDatesAggregate(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '30 days')" } }
        { billingItems: {} }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
}

query GetPayrollDatesBillingReadyDocument(
  $limit: Int = 20
) {
  payrollDates(
    where: {
      _and: [
        { status: { _eq: "completed" } }
        { adjustedEftDate: { _gte: "date_trunc('day', now() - interval '7 days')" } }
        { _not: { billingItems: {} } }
      ]
    }
    limit: $limit
    orderBy: { completedAt: DESC }
  ) {
    id
    payrollId
    adjustedEftDate
    completedAt
    completedBy
    payroll {
      id
      name
      client {
        id
        name
      }
    }
  }
}

# Generate billing items from completed payroll date (simplified approach)
mutation GenerateBillingFromPayrollDateDocument(
  $payrollDateId: uuid!
  $generatedBy: uuid!
) {
  # This mutation will need to be implemented as an API endpoint
  # For now, we'll create a simple billing item as a placeholder
  insertBillingItemsOne(
    object: {
      description: "Auto-generated from payroll completion"
      quantity: 1
      unitPrice: 0
      totalAmount: 0
      status: "draft"
      staffUserId: $generatedBy
    }
  ) {
    id
    description
    status
    createdAt
  }
}

# Profitability Analytics Operations
query GetPayrollProfitabilityAnalytics(
  $clientId: uuid
  $dateFrom: timestamptz
  $dateTo: timestamptz
  $limit: Int = 50
  $offset: Int = 0
) {
  payrolls(
    where: {
      _and: [
        { clientId: { _eq: $clientId } }
        { createdAt: { _gte: $dateFrom } }
        { createdAt: { _lte: $dateTo } }
        { supersededDate: { _isNull: true } }
      ]
    }
    limit: $limit
    offset: $offset
    orderBy: { createdAt: DESC }
  ) {
    id
    name
    clientId
    client {
      id
      name
    }
    status
    createdAt
    primaryConsultant {
      id
      firstName
      lastName
    }
    backupConsultant {
      id
      firstName
      lastName
    }
    billingItems(
      where: { status: { _eq: "approved" } }
    ) {
      id
      amount
      totalAmount
      quantity
      serviceName
      createdAt
    }
    timeEntries {
      id
      hoursSpent
      workDate
      createdAt
    }
  }
}

query GetStaffBillingPerformanceAnalytics(
  $staffUserId: uuid
  $timestampFrom: timestamp
  $timestampTo: timestamp
  $dateFrom: date
  $dateTo: date
  $limit: Int = 50
) {
  billingItems(
    where: {
      _and: [
        { staffUserId: { _eq: $staffUserId } }
        { createdAt: { _gte: $timestampFrom } }
        { createdAt: { _lte: $timestampTo } }
        { status: { _eq: "approved" } }
      ]
    }
    limit: $limit
    orderBy: { createdAt: DESC }
  ) {
    id
    amount
    totalAmount
    quantity
    serviceName
    createdAt
    staffUser {
      id
      firstName
      lastName
      email
      role
    }
    client {
      id
      name
    }
    payroll {
      id
      name
    }
  }
  
  timeEntries(
    where: {
      _and: [
        { staffUserId: { _eq: $staffUserId } }
        { workDate: { _gte: $dateFrom } }
        { workDate: { _lte: $dateTo } }
      ]
    }
    orderBy: { workDate: DESC }
  ) {
    id
    hoursSpent
    workDate
    description
    staffUser {
      id
      firstName
      lastName
    }
    client {
      id
      name
    }
    payroll {
      id
      name
    }
  }
}

query GetProfitabilityStatsAdvanced(
  $clientId: uuid
  $staffUserId: uuid
  $timestampFrom: timestamp
  $timestampTo: timestamp
  $dateFrom: date
  $dateTo: date
) {
  # Total revenue from approved billing items
  totalRevenue: billingItemsAggregate(
    where: {
      _and: [
        { createdAt: { _gte: $timestampFrom } }
        { createdAt: { _lte: $timestampTo } }
        { status: { _eq: "approved" } }
      ]
    }
  ) {
    aggregate {
      sum {
        totalAmount
      }
      count
    }
  }
  
  # Total hours from time entries
  totalHours: timeEntriesAggregate(
    where: {
      _and: [
        { workDate: { _gte: $dateFrom } }
        { workDate: { _lte: $dateTo } }
      ]
    }
  ) {
    aggregate {
      sum {
        hoursSpent
      }
      count
    }
  }
  
  # Pending billing items  
  pendingRevenue: billingItemsAggregate(
    where: {
      _and: [
        { createdAt: { _gte: $timestampFrom } }
        { createdAt: { _lte: $timestampTo } }
        { status: { _eq: "pending" } }
      ]
    }
  ) {
    aggregate {
      sum {
        totalAmount
      }
      count
    }
  }
}