schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  refresh the cache entry
  """
  refresh: Boolean! = false
  """
  measured in seconds
  """
  ttl: Int! = 60
) on QUERY

type AffectedAssignment {
  adjusted_eft_date: String!
  id: String!
  new_consultant_id: String!
  original_consultant_id: String!
  payroll_date_id: String!
}

input AuditEventInput {
  action: String!
  ipAddress: String
  metadata: json
  resourceId: String
  resourceType: String!
  userAgent: String
  userId: String!
}

type AuditEventResponse {
  eventId: String
  message: String
  success: Boolean!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type CommitPayrollAssignmentsOutput {
  affected_assignments: [AffectedAssignment!]
  errors: [String!]
  message: String
  success: Boolean!
}

input ComplianceReportInput {
  endDate: String!
  includeDetails: Boolean
  reportType: String!
  startDate: String!
}

type ComplianceReportResponse {
  generatedAt: String!
  reportUrl: String
  success: Boolean!
  summary: json
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input PayrollAssignmentInput {
  date: String!
  fromConsultantId: String!
  payrollId: String!
  toConsultantId: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """
  is the array contained in the given array value
  """
  _contained_in: [String!]
  """
  does the array contain the given value
  """
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean
  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """
  does the column NOT match the given pattern
  """
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type SuspiciousActivityResponse {
  events: [SuspiciousEvent!]
  message: String
  success: Boolean!
  suspicious: Boolean!
}

type SuspiciousEvent {
  count: Int!
  eventType: String!
  severity: String!
  timeframe: String!
}

"""
Scalar _Any
"""
scalar _Any

"""
A union of all types that use the @key directive
"""
union _Entity =
  | adjustment_rules
  | client_external_systems
  | clients
  | external_systems
  | holidays
  | leave
  | notes
  | payroll_cycles
  | payroll_date_types
  | payroll_dates
  | payrolls
  | users
  | work_schedule

type _Service {
  """
  SDL representation of schema
  """
  sdl: String!
}

"""
columns and relationships of "adjustment_rules"
"""
type adjustment_rules {
  """
  Timestamp when the rule was created
  """
  created_at: timestamptz
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: uuid!
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: uuid!
  """
  Unique identifier for the adjustment rule
  """
  id: uuid!
  """
  An object relationship
  """
  payroll_cycle: payroll_cycles!
  """
  An object relationship
  """
  payroll_date_type: payroll_date_types!
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: String!
  """
  Human-readable description of the adjustment rule
  """
  rule_description: String!
  """
  Timestamp when the rule was last updated
  """
  updated_at: timestamptz
}

"""
aggregated selection of "adjustment_rules"
"""
type adjustment_rules_aggregate {
  aggregate: adjustment_rules_aggregate_fields
  nodes: [adjustment_rules!]!
}

input adjustment_rules_aggregate_bool_exp {
  count: adjustment_rules_aggregate_bool_exp_count
}

input adjustment_rules_aggregate_bool_exp_count {
  arguments: [adjustment_rules_select_column!]
  distinct: Boolean
  filter: adjustment_rules_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "adjustment_rules"
"""
type adjustment_rules_aggregate_fields {
  count(columns: [adjustment_rules_select_column!], distinct: Boolean): Int!
  max: adjustment_rules_max_fields
  min: adjustment_rules_min_fields
}

"""
order by aggregate values of table "adjustment_rules"
"""
input adjustment_rules_aggregate_order_by {
  count: order_by
  max: adjustment_rules_max_order_by
  min: adjustment_rules_min_order_by
}

"""
input type for inserting array relation for remote table "adjustment_rules"
"""
input adjustment_rules_arr_rel_insert_input {
  data: [adjustment_rules_insert_input!]!
  """
  upsert condition
  """
  on_conflict: adjustment_rules_on_conflict
}

"""
Boolean expression to filter rows from the table "adjustment_rules". All fields are combined with a logical 'AND'.
"""
input adjustment_rules_bool_exp {
  _and: [adjustment_rules_bool_exp!]
  _not: adjustment_rules_bool_exp
  _or: [adjustment_rules_bool_exp!]
  created_at: timestamptz_comparison_exp
  cycle_id: uuid_comparison_exp
  date_type_id: uuid_comparison_exp
  id: uuid_comparison_exp
  payroll_cycle: payroll_cycles_bool_exp
  payroll_date_type: payroll_date_types_bool_exp
  rule_code: String_comparison_exp
  rule_description: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "adjustment_rules"
"""
enum adjustment_rules_constraint {
  """
  unique or primary key constraint on columns "date_type_id", "cycle_id"
  """
  adjustment_rules_cycle_id_date_type_id_key
  """
  unique or primary key constraint on columns "id"
  """
  adjustment_rules_pkey
}

"""
input type for inserting data into table "adjustment_rules"
"""
input adjustment_rules_insert_input {
  """
  Timestamp when the rule was created
  """
  created_at: timestamptz
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: uuid
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: uuid
  """
  Unique identifier for the adjustment rule
  """
  id: uuid
  payroll_cycle: payroll_cycles_obj_rel_insert_input
  payroll_date_type: payroll_date_types_obj_rel_insert_input
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: String
  """
  Human-readable description of the adjustment rule
  """
  rule_description: String
  """
  Timestamp when the rule was last updated
  """
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type adjustment_rules_max_fields {
  """
  Timestamp when the rule was created
  """
  created_at: timestamptz
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: uuid
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: uuid
  """
  Unique identifier for the adjustment rule
  """
  id: uuid
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: String
  """
  Human-readable description of the adjustment rule
  """
  rule_description: String
  """
  Timestamp when the rule was last updated
  """
  updated_at: timestamptz
}

"""
order by max() on columns of table "adjustment_rules"
"""
input adjustment_rules_max_order_by {
  """
  Timestamp when the rule was created
  """
  created_at: order_by
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: order_by
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: order_by
  """
  Unique identifier for the adjustment rule
  """
  id: order_by
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: order_by
  """
  Human-readable description of the adjustment rule
  """
  rule_description: order_by
  """
  Timestamp when the rule was last updated
  """
  updated_at: order_by
}

"""
aggregate min on columns
"""
type adjustment_rules_min_fields {
  """
  Timestamp when the rule was created
  """
  created_at: timestamptz
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: uuid
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: uuid
  """
  Unique identifier for the adjustment rule
  """
  id: uuid
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: String
  """
  Human-readable description of the adjustment rule
  """
  rule_description: String
  """
  Timestamp when the rule was last updated
  """
  updated_at: timestamptz
}

"""
order by min() on columns of table "adjustment_rules"
"""
input adjustment_rules_min_order_by {
  """
  Timestamp when the rule was created
  """
  created_at: order_by
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: order_by
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: order_by
  """
  Unique identifier for the adjustment rule
  """
  id: order_by
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: order_by
  """
  Human-readable description of the adjustment rule
  """
  rule_description: order_by
  """
  Timestamp when the rule was last updated
  """
  updated_at: order_by
}

"""
response of any mutation on the table "adjustment_rules"
"""
type adjustment_rules_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [adjustment_rules!]!
}

"""
on_conflict condition type for table "adjustment_rules"
"""
input adjustment_rules_on_conflict {
  constraint: adjustment_rules_constraint!
  update_columns: [adjustment_rules_update_column!]! = []
  where: adjustment_rules_bool_exp
}

"""
Ordering options when selecting data from "adjustment_rules".
"""
input adjustment_rules_order_by {
  created_at: order_by
  cycle_id: order_by
  date_type_id: order_by
  id: order_by
  payroll_cycle: payroll_cycles_order_by
  payroll_date_type: payroll_date_types_order_by
  rule_code: order_by
  rule_description: order_by
  updated_at: order_by
}

"""
primary key columns input for table: adjustment_rules
"""
input adjustment_rules_pk_columns_input {
  """
  Unique identifier for the adjustment rule
  """
  id: uuid!
}

"""
select columns of table "adjustment_rules"
"""
enum adjustment_rules_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  cycle_id
  """
  column name
  """
  date_type_id
  """
  column name
  """
  id
  """
  column name
  """
  rule_code
  """
  column name
  """
  rule_description
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "adjustment_rules"
"""
input adjustment_rules_set_input {
  """
  Timestamp when the rule was created
  """
  created_at: timestamptz
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: uuid
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: uuid
  """
  Unique identifier for the adjustment rule
  """
  id: uuid
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: String
  """
  Human-readable description of the adjustment rule
  """
  rule_description: String
  """
  Timestamp when the rule was last updated
  """
  updated_at: timestamptz
}

"""
Streaming cursor of the table "adjustment_rules"
"""
input adjustment_rules_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: adjustment_rules_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input adjustment_rules_stream_cursor_value_input {
  """
  Timestamp when the rule was created
  """
  created_at: timestamptz
  """
  Reference to the payroll cycle this rule applies to
  """
  cycle_id: uuid
  """
  Reference to the payroll date type this rule affects
  """
  date_type_id: uuid
  """
  Unique identifier for the adjustment rule
  """
  id: uuid
  """
  Code/formula used to calculate date adjustments
  """
  rule_code: String
  """
  Human-readable description of the adjustment rule
  """
  rule_description: String
  """
  Timestamp when the rule was last updated
  """
  updated_at: timestamptz
}

"""
update columns of table "adjustment_rules"
"""
enum adjustment_rules_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  cycle_id
  """
  column name
  """
  date_type_id
  """
  column name
  """
  id
  """
  column name
  """
  rule_code
  """
  column name
  """
  rule_description
  """
  column name
  """
  updated_at
}

input adjustment_rules_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: adjustment_rules_set_input
  """
  filter the rows which have to be updated
  """
  where: adjustment_rules_bool_exp!
}

"""
columns and relationships of "app_settings"
"""
type app_settings {
  """
  Unique identifier for application setting
  """
  id: String!
  """
  JSON structure containing application permission configurations
  """
  permissions(
    """
    JSON select path
    """
    path: String
  ): jsonb
}

"""
aggregated selection of "app_settings"
"""
type app_settings_aggregate {
  aggregate: app_settings_aggregate_fields
  nodes: [app_settings!]!
}

"""
aggregate fields of "app_settings"
"""
type app_settings_aggregate_fields {
  count(columns: [app_settings_select_column!], distinct: Boolean): Int!
  max: app_settings_max_fields
  min: app_settings_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input app_settings_append_input {
  """
  JSON structure containing application permission configurations
  """
  permissions: jsonb
}

"""
Boolean expression to filter rows from the table "app_settings". All fields are combined with a logical 'AND'.
"""
input app_settings_bool_exp {
  _and: [app_settings_bool_exp!]
  _not: app_settings_bool_exp
  _or: [app_settings_bool_exp!]
  id: String_comparison_exp
  permissions: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "app_settings"
"""
enum app_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input app_settings_delete_at_path_input {
  """
  JSON structure containing application permission configurations
  """
  permissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input app_settings_delete_elem_input {
  """
  JSON structure containing application permission configurations
  """
  permissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input app_settings_delete_key_input {
  """
  JSON structure containing application permission configurations
  """
  permissions: String
}

"""
input type for inserting data into table "app_settings"
"""
input app_settings_insert_input {
  """
  Unique identifier for application setting
  """
  id: String
  """
  JSON structure containing application permission configurations
  """
  permissions: jsonb
}

"""
aggregate max on columns
"""
type app_settings_max_fields {
  """
  Unique identifier for application setting
  """
  id: String
}

"""
aggregate min on columns
"""
type app_settings_min_fields {
  """
  Unique identifier for application setting
  """
  id: String
}

"""
response of any mutation on the table "app_settings"
"""
type app_settings_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [app_settings!]!
}

"""
on_conflict condition type for table "app_settings"
"""
input app_settings_on_conflict {
  constraint: app_settings_constraint!
  update_columns: [app_settings_update_column!]! = []
  where: app_settings_bool_exp
}

"""
Ordering options when selecting data from "app_settings".
"""
input app_settings_order_by {
  id: order_by
  permissions: order_by
}

"""
primary key columns input for table: app_settings
"""
input app_settings_pk_columns_input {
  """
  Unique identifier for application setting
  """
  id: String!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input app_settings_prepend_input {
  """
  JSON structure containing application permission configurations
  """
  permissions: jsonb
}

"""
select columns of table "app_settings"
"""
enum app_settings_select_column {
  """
  column name
  """
  id
  """
  column name
  """
  permissions
}

"""
input type for updating data in table "app_settings"
"""
input app_settings_set_input {
  """
  Unique identifier for application setting
  """
  id: String
  """
  JSON structure containing application permission configurations
  """
  permissions: jsonb
}

"""
Streaming cursor of the table "app_settings"
"""
input app_settings_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: app_settings_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input app_settings_stream_cursor_value_input {
  """
  Unique identifier for application setting
  """
  id: String
  """
  JSON structure containing application permission configurations
  """
  permissions: jsonb
}

"""
update columns of table "app_settings"
"""
enum app_settings_update_column {
  """
  column name
  """
  id
  """
  column name
  """
  permissions
}

input app_settings_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: app_settings_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: app_settings_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: app_settings_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: app_settings_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: app_settings_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: app_settings_set_input
  """
  filter the rows which have to be updated
  """
  where: app_settings_bool_exp!
}

"""
columns and relationships of "audit.audit_log"
"""
type audit_audit_log {
  action: String!
  created_at: timestamptz
  error_message: String
  eventTime: timestamptz!
  id: uuid!
  ipAddress: inet
  metadata(
    """
    JSON select path
    """
    path: String
  ): jsonb
  newValues(
    """
    JSON select path
    """
    path: String
  ): jsonb
  oldValues(
    """
    JSON select path
    """
    path: String
  ): jsonb
  request_id: String
  resourceId: String
  resourceType: String!
  sessionId: String
  success: Boolean
  userAgent: String
  userId: uuid
  user_email: String
  user_role: String
}

"""
aggregated selection of "audit.audit_log"
"""
type audit_audit_log_aggregate {
  aggregate: audit_audit_log_aggregate_fields
  nodes: [audit_audit_log!]!
}

"""
aggregate fields of "audit.audit_log"
"""
type audit_audit_log_aggregate_fields {
  count(columns: [audit_audit_log_select_column!], distinct: Boolean): Int!
  max: audit_audit_log_max_fields
  min: audit_audit_log_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input audit_audit_log_append_input {
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
}

"""
Boolean expression to filter rows from the table "audit.audit_log". All fields are combined with a logical 'AND'.
"""
input audit_audit_log_bool_exp {
  _and: [audit_audit_log_bool_exp!]
  _not: audit_audit_log_bool_exp
  _or: [audit_audit_log_bool_exp!]
  action: String_comparison_exp
  created_at: timestamptz_comparison_exp
  error_message: String_comparison_exp
  eventTime: timestamptz_comparison_exp
  id: uuid_comparison_exp
  ipAddress: inet_comparison_exp
  metadata: jsonb_comparison_exp
  newValues: jsonb_comparison_exp
  oldValues: jsonb_comparison_exp
  request_id: String_comparison_exp
  resourceId: String_comparison_exp
  resourceType: String_comparison_exp
  sessionId: String_comparison_exp
  success: Boolean_comparison_exp
  userAgent: String_comparison_exp
  userId: uuid_comparison_exp
  user_email: String_comparison_exp
  user_role: String_comparison_exp
}

"""
unique or primary key constraints on table "audit.audit_log"
"""
enum audit_audit_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_audit_log_delete_at_path_input {
  metadata: [String!]
  newValues: [String!]
  oldValues: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_audit_log_delete_elem_input {
  metadata: Int
  newValues: Int
  oldValues: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_audit_log_delete_key_input {
  metadata: String
  newValues: String
  oldValues: String
}

"""
input type for inserting data into table "audit.audit_log"
"""
input audit_audit_log_insert_input {
  action: String
  created_at: timestamptz
  error_message: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  request_id: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userId: uuid
  user_email: String
  user_role: String
}

"""
aggregate max on columns
"""
type audit_audit_log_max_fields {
  action: String
  created_at: timestamptz
  error_message: String
  eventTime: timestamptz
  id: uuid
  request_id: String
  resourceId: String
  resourceType: String
  sessionId: String
  userAgent: String
  userId: uuid
  user_email: String
  user_role: String
}

"""
aggregate min on columns
"""
type audit_audit_log_min_fields {
  action: String
  created_at: timestamptz
  error_message: String
  eventTime: timestamptz
  id: uuid
  request_id: String
  resourceId: String
  resourceType: String
  sessionId: String
  userAgent: String
  userId: uuid
  user_email: String
  user_role: String
}

"""
response of any mutation on the table "audit.audit_log"
"""
type audit_audit_log_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [audit_audit_log!]!
}

"""
on_conflict condition type for table "audit.audit_log"
"""
input audit_audit_log_on_conflict {
  constraint: audit_audit_log_constraint!
  update_columns: [audit_audit_log_update_column!]! = []
  where: audit_audit_log_bool_exp
}

"""
Ordering options when selecting data from "audit.audit_log".
"""
input audit_audit_log_order_by {
  action: order_by
  created_at: order_by
  error_message: order_by
  eventTime: order_by
  id: order_by
  ipAddress: order_by
  metadata: order_by
  newValues: order_by
  oldValues: order_by
  request_id: order_by
  resourceId: order_by
  resourceType: order_by
  sessionId: order_by
  success: order_by
  userAgent: order_by
  userId: order_by
  user_email: order_by
  user_role: order_by
}

"""
primary key columns input for table: audit.audit_log
"""
input audit_audit_log_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input audit_audit_log_prepend_input {
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
}

"""
select columns of table "audit.audit_log"
"""
enum audit_audit_log_select_column {
  """
  column name
  """
  action
  """
  column name
  """
  created_at
  """
  column name
  """
  error_message
  """
  column name
  """
  eventTime
  """
  column name
  """
  id
  """
  column name
  """
  ipAddress
  """
  column name
  """
  metadata
  """
  column name
  """
  newValues
  """
  column name
  """
  oldValues
  """
  column name
  """
  request_id
  """
  column name
  """
  resourceId
  """
  column name
  """
  resourceType
  """
  column name
  """
  sessionId
  """
  column name
  """
  success
  """
  column name
  """
  userAgent
  """
  column name
  """
  userId
  """
  column name
  """
  user_email
  """
  column name
  """
  user_role
}

"""
input type for updating data in table "audit.audit_log"
"""
input audit_audit_log_set_input {
  action: String
  created_at: timestamptz
  error_message: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  request_id: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userId: uuid
  user_email: String
  user_role: String
}

"""
Streaming cursor of the table "audit_audit_log"
"""
input audit_audit_log_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: audit_audit_log_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input audit_audit_log_stream_cursor_value_input {
  action: String
  created_at: timestamptz
  error_message: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  request_id: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userId: uuid
  user_email: String
  user_role: String
}

"""
update columns of table "audit.audit_log"
"""
enum audit_audit_log_update_column {
  """
  column name
  """
  action
  """
  column name
  """
  created_at
  """
  column name
  """
  error_message
  """
  column name
  """
  eventTime
  """
  column name
  """
  id
  """
  column name
  """
  ipAddress
  """
  column name
  """
  metadata
  """
  column name
  """
  newValues
  """
  column name
  """
  oldValues
  """
  column name
  """
  request_id
  """
  column name
  """
  resourceId
  """
  column name
  """
  resourceType
  """
  column name
  """
  sessionId
  """
  column name
  """
  success
  """
  column name
  """
  userAgent
  """
  column name
  """
  userId
  """
  column name
  """
  user_email
  """
  column name
  """
  user_role
}

input audit_audit_log_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: audit_audit_log_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_audit_log_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_audit_log_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_audit_log_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: audit_audit_log_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: audit_audit_log_set_input
  """
  filter the rows which have to be updated
  """
  where: audit_audit_log_bool_exp!
}

"""
columns and relationships of "audit.auth_events"
"""
type audit_auth_events {
  createdAt: timestamptz
  eventTime: timestamptz!
  eventType: String!
  failureReason: String
  id: uuid!
  ipAddress: inet
  metadata(
    """
    JSON select path
    """
    path: String
  ): jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
aggregated selection of "audit.auth_events"
"""
type audit_auth_events_aggregate {
  aggregate: audit_auth_events_aggregate_fields
  nodes: [audit_auth_events!]!
}

"""
aggregate fields of "audit.auth_events"
"""
type audit_auth_events_aggregate_fields {
  count(columns: [audit_auth_events_select_column!], distinct: Boolean): Int!
  max: audit_auth_events_max_fields
  min: audit_auth_events_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input audit_auth_events_append_input {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "audit.auth_events". All fields are combined with a logical 'AND'.
"""
input audit_auth_events_bool_exp {
  _and: [audit_auth_events_bool_exp!]
  _not: audit_auth_events_bool_exp
  _or: [audit_auth_events_bool_exp!]
  createdAt: timestamptz_comparison_exp
  eventTime: timestamptz_comparison_exp
  eventType: String_comparison_exp
  failureReason: String_comparison_exp
  id: uuid_comparison_exp
  ipAddress: inet_comparison_exp
  metadata: jsonb_comparison_exp
  success: Boolean_comparison_exp
  userAgent: String_comparison_exp
  userEmail: String_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "audit.auth_events"
"""
enum audit_auth_events_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  auth_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_auth_events_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_auth_events_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_auth_events_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "audit.auth_events"
"""
input audit_auth_events_insert_input {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
aggregate max on columns
"""
type audit_auth_events_max_fields {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
aggregate min on columns
"""
type audit_auth_events_min_fields {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
response of any mutation on the table "audit.auth_events"
"""
type audit_auth_events_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [audit_auth_events!]!
}

"""
on_conflict condition type for table "audit.auth_events"
"""
input audit_auth_events_on_conflict {
  constraint: audit_auth_events_constraint!
  update_columns: [audit_auth_events_update_column!]! = []
  where: audit_auth_events_bool_exp
}

"""
Ordering options when selecting data from "audit.auth_events".
"""
input audit_auth_events_order_by {
  createdAt: order_by
  eventTime: order_by
  eventType: order_by
  failureReason: order_by
  id: order_by
  ipAddress: order_by
  metadata: order_by
  success: order_by
  userAgent: order_by
  userEmail: order_by
  userId: order_by
}

"""
primary key columns input for table: audit.auth_events
"""
input audit_auth_events_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input audit_auth_events_prepend_input {
  metadata: jsonb
}

"""
select columns of table "audit.auth_events"
"""
enum audit_auth_events_select_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  eventTime
  """
  column name
  """
  eventType
  """
  column name
  """
  failureReason
  """
  column name
  """
  id
  """
  column name
  """
  ipAddress
  """
  column name
  """
  metadata
  """
  column name
  """
  success
  """
  column name
  """
  userAgent
  """
  column name
  """
  userEmail
  """
  column name
  """
  userId
}

"""
input type for updating data in table "audit.auth_events"
"""
input audit_auth_events_set_input {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
Streaming cursor of the table "audit_auth_events"
"""
input audit_auth_events_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: audit_auth_events_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input audit_auth_events_stream_cursor_value_input {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
update columns of table "audit.auth_events"
"""
enum audit_auth_events_update_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  eventTime
  """
  column name
  """
  eventType
  """
  column name
  """
  failureReason
  """
  column name
  """
  id
  """
  column name
  """
  ipAddress
  """
  column name
  """
  metadata
  """
  column name
  """
  success
  """
  column name
  """
  userAgent
  """
  column name
  """
  userEmail
  """
  column name
  """
  userId
}

input audit_auth_events_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: audit_auth_events_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_auth_events_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_auth_events_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_auth_events_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: audit_auth_events_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: audit_auth_events_set_input
  """
  filter the rows which have to be updated
  """
  where: audit_auth_events_bool_exp!
}

"""
columns and relationships of "audit.data_access_log"
"""
type audit_data_access_log {
  accessType: String!
  accessedAt: timestamptz!
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid!
  ipAddress: inet
  metadata(
    """
    JSON select path
    """
    path: String
  ): jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String!
  rowCount: Int
  sessionId: String
  userId: uuid!
}

"""
aggregated selection of "audit.data_access_log"
"""
type audit_data_access_log_aggregate {
  aggregate: audit_data_access_log_aggregate_fields
  nodes: [audit_data_access_log!]!
}

"""
aggregate fields of "audit.data_access_log"
"""
type audit_data_access_log_aggregate_fields {
  avg: audit_data_access_log_avg_fields
  count(
    columns: [audit_data_access_log_select_column!]
    distinct: Boolean
  ): Int!
  max: audit_data_access_log_max_fields
  min: audit_data_access_log_min_fields
  stddev: audit_data_access_log_stddev_fields
  stddev_pop: audit_data_access_log_stddev_pop_fields
  stddev_samp: audit_data_access_log_stddev_samp_fields
  sum: audit_data_access_log_sum_fields
  var_pop: audit_data_access_log_var_pop_fields
  var_samp: audit_data_access_log_var_samp_fields
  variance: audit_data_access_log_variance_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input audit_data_access_log_append_input {
  metadata: jsonb
}

"""
aggregate avg on columns
"""
type audit_data_access_log_avg_fields {
  rowCount: Float
}

"""
Boolean expression to filter rows from the table "audit.data_access_log". All fields are combined with a logical 'AND'.
"""
input audit_data_access_log_bool_exp {
  _and: [audit_data_access_log_bool_exp!]
  _not: audit_data_access_log_bool_exp
  _or: [audit_data_access_log_bool_exp!]
  accessType: String_comparison_exp
  accessedAt: timestamptz_comparison_exp
  dataClassification: String_comparison_exp
  fieldsAccessed: String_array_comparison_exp
  id: uuid_comparison_exp
  ipAddress: inet_comparison_exp
  metadata: jsonb_comparison_exp
  queryExecuted: String_comparison_exp
  resourceId: String_comparison_exp
  resourceType: String_comparison_exp
  rowCount: Int_comparison_exp
  sessionId: String_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "audit.data_access_log"
"""
enum audit_data_access_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  data_access_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_data_access_log_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_data_access_log_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_data_access_log_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "audit.data_access_log"
"""
input audit_data_access_log_inc_input {
  rowCount: Int
}

"""
input type for inserting data into table "audit.data_access_log"
"""
input audit_data_access_log_insert_input {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""
aggregate max on columns
"""
type audit_data_access_log_max_fields {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""
aggregate min on columns
"""
type audit_data_access_log_min_fields {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""
response of any mutation on the table "audit.data_access_log"
"""
type audit_data_access_log_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [audit_data_access_log!]!
}

"""
on_conflict condition type for table "audit.data_access_log"
"""
input audit_data_access_log_on_conflict {
  constraint: audit_data_access_log_constraint!
  update_columns: [audit_data_access_log_update_column!]! = []
  where: audit_data_access_log_bool_exp
}

"""
Ordering options when selecting data from "audit.data_access_log".
"""
input audit_data_access_log_order_by {
  accessType: order_by
  accessedAt: order_by
  dataClassification: order_by
  fieldsAccessed: order_by
  id: order_by
  ipAddress: order_by
  metadata: order_by
  queryExecuted: order_by
  resourceId: order_by
  resourceType: order_by
  rowCount: order_by
  sessionId: order_by
  userId: order_by
}

"""
primary key columns input for table: audit.data_access_log
"""
input audit_data_access_log_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input audit_data_access_log_prepend_input {
  metadata: jsonb
}

"""
select columns of table "audit.data_access_log"
"""
enum audit_data_access_log_select_column {
  """
  column name
  """
  accessType
  """
  column name
  """
  accessedAt
  """
  column name
  """
  dataClassification
  """
  column name
  """
  fieldsAccessed
  """
  column name
  """
  id
  """
  column name
  """
  ipAddress
  """
  column name
  """
  metadata
  """
  column name
  """
  queryExecuted
  """
  column name
  """
  resourceId
  """
  column name
  """
  resourceType
  """
  column name
  """
  rowCount
  """
  column name
  """
  sessionId
  """
  column name
  """
  userId
}

"""
input type for updating data in table "audit.data_access_log"
"""
input audit_data_access_log_set_input {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""
aggregate stddev on columns
"""
type audit_data_access_log_stddev_fields {
  rowCount: Float
}

"""
aggregate stddev_pop on columns
"""
type audit_data_access_log_stddev_pop_fields {
  rowCount: Float
}

"""
aggregate stddev_samp on columns
"""
type audit_data_access_log_stddev_samp_fields {
  rowCount: Float
}

"""
Streaming cursor of the table "audit_data_access_log"
"""
input audit_data_access_log_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: audit_data_access_log_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input audit_data_access_log_stream_cursor_value_input {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""
aggregate sum on columns
"""
type audit_data_access_log_sum_fields {
  rowCount: Int
}

"""
update columns of table "audit.data_access_log"
"""
enum audit_data_access_log_update_column {
  """
  column name
  """
  accessType
  """
  column name
  """
  accessedAt
  """
  column name
  """
  dataClassification
  """
  column name
  """
  fieldsAccessed
  """
  column name
  """
  id
  """
  column name
  """
  ipAddress
  """
  column name
  """
  metadata
  """
  column name
  """
  queryExecuted
  """
  column name
  """
  resourceId
  """
  column name
  """
  resourceType
  """
  column name
  """
  rowCount
  """
  column name
  """
  sessionId
  """
  column name
  """
  userId
}

input audit_data_access_log_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: audit_data_access_log_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_data_access_log_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_data_access_log_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_data_access_log_delete_key_input
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: audit_data_access_log_inc_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: audit_data_access_log_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: audit_data_access_log_set_input
  """
  filter the rows which have to be updated
  """
  where: audit_data_access_log_bool_exp!
}

"""
aggregate var_pop on columns
"""
type audit_data_access_log_var_pop_fields {
  rowCount: Float
}

"""
aggregate var_samp on columns
"""
type audit_data_access_log_var_samp_fields {
  rowCount: Float
}

"""
aggregate variance on columns
"""
type audit_data_access_log_variance_fields {
  rowCount: Float
}

"""
columns and relationships of "audit.permission_changes"
"""
type audit_permission_changes {
  approvedByUserId: uuid
  changeType: String!
  changedAt: timestamptz!
  changedByUserId: uuid!
  id: uuid!
  metadata(
    """
    JSON select path
    """
    path: String
  ): jsonb
  newPermissions(
    """
    JSON select path
    """
    path: String
  ): jsonb
  oldPermissions(
    """
    JSON select path
    """
    path: String
  ): jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
aggregated selection of "audit.permission_changes"
"""
type audit_permission_changes_aggregate {
  aggregate: audit_permission_changes_aggregate_fields
  nodes: [audit_permission_changes!]!
}

"""
aggregate fields of "audit.permission_changes"
"""
type audit_permission_changes_aggregate_fields {
  count(
    columns: [audit_permission_changes_select_column!]
    distinct: Boolean
  ): Int!
  max: audit_permission_changes_max_fields
  min: audit_permission_changes_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input audit_permission_changes_append_input {
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
}

"""
Boolean expression to filter rows from the table "audit.permission_changes". All fields are combined with a logical 'AND'.
"""
input audit_permission_changes_bool_exp {
  _and: [audit_permission_changes_bool_exp!]
  _not: audit_permission_changes_bool_exp
  _or: [audit_permission_changes_bool_exp!]
  approvedByUserId: uuid_comparison_exp
  changeType: String_comparison_exp
  changedAt: timestamptz_comparison_exp
  changedByUserId: uuid_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  newPermissions: jsonb_comparison_exp
  oldPermissions: jsonb_comparison_exp
  permissionType: String_comparison_exp
  reason: String_comparison_exp
  targetRoleId: uuid_comparison_exp
  targetUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "audit.permission_changes"
"""
enum audit_permission_changes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_changes_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input audit_permission_changes_delete_at_path_input {
  metadata: [String!]
  newPermissions: [String!]
  oldPermissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input audit_permission_changes_delete_elem_input {
  metadata: Int
  newPermissions: Int
  oldPermissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input audit_permission_changes_delete_key_input {
  metadata: String
  newPermissions: String
  oldPermissions: String
}

"""
input type for inserting data into table "audit.permission_changes"
"""
input audit_permission_changes_insert_input {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
aggregate max on columns
"""
type audit_permission_changes_max_fields {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
aggregate min on columns
"""
type audit_permission_changes_min_fields {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
response of any mutation on the table "audit.permission_changes"
"""
type audit_permission_changes_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [audit_permission_changes!]!
}

"""
on_conflict condition type for table "audit.permission_changes"
"""
input audit_permission_changes_on_conflict {
  constraint: audit_permission_changes_constraint!
  update_columns: [audit_permission_changes_update_column!]! = []
  where: audit_permission_changes_bool_exp
}

"""
Ordering options when selecting data from "audit.permission_changes".
"""
input audit_permission_changes_order_by {
  approvedByUserId: order_by
  changeType: order_by
  changedAt: order_by
  changedByUserId: order_by
  id: order_by
  metadata: order_by
  newPermissions: order_by
  oldPermissions: order_by
  permissionType: order_by
  reason: order_by
  targetRoleId: order_by
  targetUserId: order_by
}

"""
primary key columns input for table: audit.permission_changes
"""
input audit_permission_changes_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input audit_permission_changes_prepend_input {
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
}

"""
select columns of table "audit.permission_changes"
"""
enum audit_permission_changes_select_column {
  """
  column name
  """
  approvedByUserId
  """
  column name
  """
  changeType
  """
  column name
  """
  changedAt
  """
  column name
  """
  changedByUserId
  """
  column name
  """
  id
  """
  column name
  """
  metadata
  """
  column name
  """
  newPermissions
  """
  column name
  """
  oldPermissions
  """
  column name
  """
  permissionType
  """
  column name
  """
  reason
  """
  column name
  """
  targetRoleId
  """
  column name
  """
  targetUserId
}

"""
input type for updating data in table "audit.permission_changes"
"""
input audit_permission_changes_set_input {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
Streaming cursor of the table "audit_permission_changes"
"""
input audit_permission_changes_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: audit_permission_changes_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input audit_permission_changes_stream_cursor_value_input {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
update columns of table "audit.permission_changes"
"""
enum audit_permission_changes_update_column {
  """
  column name
  """
  approvedByUserId
  """
  column name
  """
  changeType
  """
  column name
  """
  changedAt
  """
  column name
  """
  changedByUserId
  """
  column name
  """
  id
  """
  column name
  """
  metadata
  """
  column name
  """
  newPermissions
  """
  column name
  """
  oldPermissions
  """
  column name
  """
  permissionType
  """
  column name
  """
  reason
  """
  column name
  """
  targetRoleId
  """
  column name
  """
  targetUserId
}

input audit_permission_changes_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: audit_permission_changes_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: audit_permission_changes_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: audit_permission_changes_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: audit_permission_changes_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: audit_permission_changes_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: audit_permission_changes_set_input
  """
  filter the rows which have to be updated
  """
  where: audit_permission_changes_bool_exp!
}

"""
columns and relationships of "audit.permission_usage_report"
"""
type audit_permission_usage_report {
  action: permission_action
  last_used: timestamptz
  resource_name: String
  role_name: String
  total_usage_count: bigint
  users_who_used_permission: bigint
  users_with_permission: bigint
}

"""
aggregated selection of "audit.permission_usage_report"
"""
type audit_permission_usage_report_aggregate {
  aggregate: audit_permission_usage_report_aggregate_fields
  nodes: [audit_permission_usage_report!]!
}

"""
aggregate fields of "audit.permission_usage_report"
"""
type audit_permission_usage_report_aggregate_fields {
  avg: audit_permission_usage_report_avg_fields
  count(
    columns: [audit_permission_usage_report_select_column!]
    distinct: Boolean
  ): Int!
  max: audit_permission_usage_report_max_fields
  min: audit_permission_usage_report_min_fields
  stddev: audit_permission_usage_report_stddev_fields
  stddev_pop: audit_permission_usage_report_stddev_pop_fields
  stddev_samp: audit_permission_usage_report_stddev_samp_fields
  sum: audit_permission_usage_report_sum_fields
  var_pop: audit_permission_usage_report_var_pop_fields
  var_samp: audit_permission_usage_report_var_samp_fields
  variance: audit_permission_usage_report_variance_fields
}

"""
aggregate avg on columns
"""
type audit_permission_usage_report_avg_fields {
  total_usage_count: Float
  users_who_used_permission: Float
  users_with_permission: Float
}

"""
Boolean expression to filter rows from the table "audit.permission_usage_report". All fields are combined with a logical 'AND'.
"""
input audit_permission_usage_report_bool_exp {
  _and: [audit_permission_usage_report_bool_exp!]
  _not: audit_permission_usage_report_bool_exp
  _or: [audit_permission_usage_report_bool_exp!]
  action: permission_action_comparison_exp
  last_used: timestamptz_comparison_exp
  resource_name: String_comparison_exp
  role_name: String_comparison_exp
  total_usage_count: bigint_comparison_exp
  users_who_used_permission: bigint_comparison_exp
  users_with_permission: bigint_comparison_exp
}

"""
aggregate max on columns
"""
type audit_permission_usage_report_max_fields {
  action: permission_action
  last_used: timestamptz
  resource_name: String
  role_name: String
  total_usage_count: bigint
  users_who_used_permission: bigint
  users_with_permission: bigint
}

"""
aggregate min on columns
"""
type audit_permission_usage_report_min_fields {
  action: permission_action
  last_used: timestamptz
  resource_name: String
  role_name: String
  total_usage_count: bigint
  users_who_used_permission: bigint
  users_with_permission: bigint
}

"""
Ordering options when selecting data from "audit.permission_usage_report".
"""
input audit_permission_usage_report_order_by {
  action: order_by
  last_used: order_by
  resource_name: order_by
  role_name: order_by
  total_usage_count: order_by
  users_who_used_permission: order_by
  users_with_permission: order_by
}

"""
select columns of table "audit.permission_usage_report"
"""
enum audit_permission_usage_report_select_column {
  """
  column name
  """
  action
  """
  column name
  """
  last_used
  """
  column name
  """
  resource_name
  """
  column name
  """
  role_name
  """
  column name
  """
  total_usage_count
  """
  column name
  """
  users_who_used_permission
  """
  column name
  """
  users_with_permission
}

"""
aggregate stddev on columns
"""
type audit_permission_usage_report_stddev_fields {
  total_usage_count: Float
  users_who_used_permission: Float
  users_with_permission: Float
}

"""
aggregate stddev_pop on columns
"""
type audit_permission_usage_report_stddev_pop_fields {
  total_usage_count: Float
  users_who_used_permission: Float
  users_with_permission: Float
}

"""
aggregate stddev_samp on columns
"""
type audit_permission_usage_report_stddev_samp_fields {
  total_usage_count: Float
  users_who_used_permission: Float
  users_with_permission: Float
}

"""
Streaming cursor of the table "audit_permission_usage_report"
"""
input audit_permission_usage_report_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: audit_permission_usage_report_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input audit_permission_usage_report_stream_cursor_value_input {
  action: permission_action
  last_used: timestamptz
  resource_name: String
  role_name: String
  total_usage_count: bigint
  users_who_used_permission: bigint
  users_with_permission: bigint
}

"""
aggregate sum on columns
"""
type audit_permission_usage_report_sum_fields {
  total_usage_count: bigint
  users_who_used_permission: bigint
  users_with_permission: bigint
}

"""
aggregate var_pop on columns
"""
type audit_permission_usage_report_var_pop_fields {
  total_usage_count: Float
  users_who_used_permission: Float
  users_with_permission: Float
}

"""
aggregate var_samp on columns
"""
type audit_permission_usage_report_var_samp_fields {
  total_usage_count: Float
  users_who_used_permission: Float
  users_with_permission: Float
}

"""
aggregate variance on columns
"""
type audit_permission_usage_report_variance_fields {
  total_usage_count: Float
  users_who_used_permission: Float
  users_with_permission: Float
}

"""
columns and relationships of "audit.slow_queries"
"""
type audit_slow_queries {
  application_name: String
  client_addr: inet
  created_at: timestamptz
  id: uuid!
  query: String!
  query_duration: interval!
  query_start: timestamptz!
  user_id: uuid
}

"""
aggregated selection of "audit.slow_queries"
"""
type audit_slow_queries_aggregate {
  aggregate: audit_slow_queries_aggregate_fields
  nodes: [audit_slow_queries!]!
}

"""
aggregate fields of "audit.slow_queries"
"""
type audit_slow_queries_aggregate_fields {
  count(columns: [audit_slow_queries_select_column!], distinct: Boolean): Int!
  max: audit_slow_queries_max_fields
  min: audit_slow_queries_min_fields
}

"""
Boolean expression to filter rows from the table "audit.slow_queries". All fields are combined with a logical 'AND'.
"""
input audit_slow_queries_bool_exp {
  _and: [audit_slow_queries_bool_exp!]
  _not: audit_slow_queries_bool_exp
  _or: [audit_slow_queries_bool_exp!]
  application_name: String_comparison_exp
  client_addr: inet_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  query: String_comparison_exp
  query_duration: interval_comparison_exp
  query_start: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "audit.slow_queries"
"""
enum audit_slow_queries_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  slow_queries_pkey
}

"""
input type for inserting data into table "audit.slow_queries"
"""
input audit_slow_queries_insert_input {
  application_name: String
  client_addr: inet
  created_at: timestamptz
  id: uuid
  query: String
  query_duration: interval
  query_start: timestamptz
  user_id: uuid
}

"""
aggregate max on columns
"""
type audit_slow_queries_max_fields {
  application_name: String
  created_at: timestamptz
  id: uuid
  query: String
  query_start: timestamptz
  user_id: uuid
}

"""
aggregate min on columns
"""
type audit_slow_queries_min_fields {
  application_name: String
  created_at: timestamptz
  id: uuid
  query: String
  query_start: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "audit.slow_queries"
"""
type audit_slow_queries_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [audit_slow_queries!]!
}

"""
on_conflict condition type for table "audit.slow_queries"
"""
input audit_slow_queries_on_conflict {
  constraint: audit_slow_queries_constraint!
  update_columns: [audit_slow_queries_update_column!]! = []
  where: audit_slow_queries_bool_exp
}

"""
Ordering options when selecting data from "audit.slow_queries".
"""
input audit_slow_queries_order_by {
  application_name: order_by
  client_addr: order_by
  created_at: order_by
  id: order_by
  query: order_by
  query_duration: order_by
  query_start: order_by
  user_id: order_by
}

"""
primary key columns input for table: audit.slow_queries
"""
input audit_slow_queries_pk_columns_input {
  id: uuid!
}

"""
select columns of table "audit.slow_queries"
"""
enum audit_slow_queries_select_column {
  """
  column name
  """
  application_name
  """
  column name
  """
  client_addr
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  query
  """
  column name
  """
  query_duration
  """
  column name
  """
  query_start
  """
  column name
  """
  user_id
}

"""
input type for updating data in table "audit.slow_queries"
"""
input audit_slow_queries_set_input {
  application_name: String
  client_addr: inet
  created_at: timestamptz
  id: uuid
  query: String
  query_duration: interval
  query_start: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "audit_slow_queries"
"""
input audit_slow_queries_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: audit_slow_queries_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input audit_slow_queries_stream_cursor_value_input {
  application_name: String
  client_addr: inet
  created_at: timestamptz
  id: uuid
  query: String
  query_duration: interval
  query_start: timestamptz
  user_id: uuid
}

"""
update columns of table "audit.slow_queries"
"""
enum audit_slow_queries_update_column {
  """
  column name
  """
  application_name
  """
  column name
  """
  client_addr
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  query
  """
  column name
  """
  query_duration
  """
  column name
  """
  query_start
  """
  column name
  """
  user_id
}

input audit_slow_queries_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: audit_slow_queries_set_input
  """
  filter the rows which have to be updated
  """
  where: audit_slow_queries_bool_exp!
}

"""
columns and relationships of "audit.user_access_summary"
"""
type audit_user_access_summary {
  created_at: timestamptz
  email: String
  id: uuid
  is_active: Boolean
  is_staff: Boolean
  name: String
  role: user_role
  updated_at: timestamptz
}

"""
aggregated selection of "audit.user_access_summary"
"""
type audit_user_access_summary_aggregate {
  aggregate: audit_user_access_summary_aggregate_fields
  nodes: [audit_user_access_summary!]!
}

"""
aggregate fields of "audit.user_access_summary"
"""
type audit_user_access_summary_aggregate_fields {
  count(
    columns: [audit_user_access_summary_select_column!]
    distinct: Boolean
  ): Int!
  max: audit_user_access_summary_max_fields
  min: audit_user_access_summary_min_fields
}

"""
Boolean expression to filter rows from the table "audit.user_access_summary". All fields are combined with a logical 'AND'.
"""
input audit_user_access_summary_bool_exp {
  _and: [audit_user_access_summary_bool_exp!]
  _not: audit_user_access_summary_bool_exp
  _or: [audit_user_access_summary_bool_exp!]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  is_staff: Boolean_comparison_exp
  name: String_comparison_exp
  role: user_role_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
input type for inserting data into table "audit.user_access_summary"
"""
input audit_user_access_summary_insert_input {
  created_at: timestamptz
  email: String
  id: uuid
  is_active: Boolean
  is_staff: Boolean
  name: String
  role: user_role
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type audit_user_access_summary_max_fields {
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  role: user_role
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type audit_user_access_summary_min_fields {
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  role: user_role
  updated_at: timestamptz
}

"""
response of any mutation on the table "audit.user_access_summary"
"""
type audit_user_access_summary_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [audit_user_access_summary!]!
}

"""
Ordering options when selecting data from "audit.user_access_summary".
"""
input audit_user_access_summary_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  is_active: order_by
  is_staff: order_by
  name: order_by
  role: order_by
  updated_at: order_by
}

"""
select columns of table "audit.user_access_summary"
"""
enum audit_user_access_summary_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  is_active
  """
  column name
  """
  is_staff
  """
  column name
  """
  name
  """
  column name
  """
  role
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "audit.user_access_summary"
"""
input audit_user_access_summary_set_input {
  created_at: timestamptz
  email: String
  id: uuid
  is_active: Boolean
  is_staff: Boolean
  name: String
  role: user_role
  updated_at: timestamptz
}

"""
Streaming cursor of the table "audit_user_access_summary"
"""
input audit_user_access_summary_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: audit_user_access_summary_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input audit_user_access_summary_stream_cursor_value_input {
  created_at: timestamptz
  email: String
  id: uuid
  is_active: Boolean
  is_staff: Boolean
  name: String
  role: user_role
  updated_at: timestamptz
}

input audit_user_access_summary_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: audit_user_access_summary_set_input
  """
  filter the rows which have to be updated
  """
  where: audit_user_access_summary_bool_exp!
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "billing_event_log"
"""
type billing_event_log {
  """
  An object relationship
  """
  billing_invoice: billing_invoice
  created_at: timestamptz
  created_by: uuid
  event_type: String!
  id: uuid!
  invoice_id: uuid
  message: String
  """
  An object relationship
  """
  user: users
}

"""
aggregated selection of "billing_event_log"
"""
type billing_event_log_aggregate {
  aggregate: billing_event_log_aggregate_fields
  nodes: [billing_event_log!]!
}

input billing_event_log_aggregate_bool_exp {
  count: billing_event_log_aggregate_bool_exp_count
}

input billing_event_log_aggregate_bool_exp_count {
  arguments: [billing_event_log_select_column!]
  distinct: Boolean
  filter: billing_event_log_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_event_log"
"""
type billing_event_log_aggregate_fields {
  count(columns: [billing_event_log_select_column!], distinct: Boolean): Int!
  max: billing_event_log_max_fields
  min: billing_event_log_min_fields
}

"""
order by aggregate values of table "billing_event_log"
"""
input billing_event_log_aggregate_order_by {
  count: order_by
  max: billing_event_log_max_order_by
  min: billing_event_log_min_order_by
}

"""
input type for inserting array relation for remote table "billing_event_log"
"""
input billing_event_log_arr_rel_insert_input {
  data: [billing_event_log_insert_input!]!
  """
  upsert condition
  """
  on_conflict: billing_event_log_on_conflict
}

"""
Boolean expression to filter rows from the table "billing_event_log". All fields are combined with a logical 'AND'.
"""
input billing_event_log_bool_exp {
  _and: [billing_event_log_bool_exp!]
  _not: billing_event_log_bool_exp
  _or: [billing_event_log_bool_exp!]
  billing_invoice: billing_invoice_bool_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  event_type: String_comparison_exp
  id: uuid_comparison_exp
  invoice_id: uuid_comparison_exp
  message: String_comparison_exp
  user: users_bool_exp
}

"""
unique or primary key constraints on table "billing_event_log"
"""
enum billing_event_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_event_log_pkey
}

"""
input type for inserting data into table "billing_event_log"
"""
input billing_event_log_insert_input {
  billing_invoice: billing_invoice_obj_rel_insert_input
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
  user: users_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type billing_event_log_max_fields {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
order by max() on columns of table "billing_event_log"
"""
input billing_event_log_max_order_by {
  created_at: order_by
  created_by: order_by
  event_type: order_by
  id: order_by
  invoice_id: order_by
  message: order_by
}

"""
aggregate min on columns
"""
type billing_event_log_min_fields {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
order by min() on columns of table "billing_event_log"
"""
input billing_event_log_min_order_by {
  created_at: order_by
  created_by: order_by
  event_type: order_by
  id: order_by
  invoice_id: order_by
  message: order_by
}

"""
response of any mutation on the table "billing_event_log"
"""
type billing_event_log_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [billing_event_log!]!
}

"""
on_conflict condition type for table "billing_event_log"
"""
input billing_event_log_on_conflict {
  constraint: billing_event_log_constraint!
  update_columns: [billing_event_log_update_column!]! = []
  where: billing_event_log_bool_exp
}

"""
Ordering options when selecting data from "billing_event_log".
"""
input billing_event_log_order_by {
  billing_invoice: billing_invoice_order_by
  created_at: order_by
  created_by: order_by
  event_type: order_by
  id: order_by
  invoice_id: order_by
  message: order_by
  user: users_order_by
}

"""
primary key columns input for table: billing_event_log
"""
input billing_event_log_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_event_log"
"""
enum billing_event_log_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  created_by
  """
  column name
  """
  event_type
  """
  column name
  """
  id
  """
  column name
  """
  invoice_id
  """
  column name
  """
  message
}

"""
input type for updating data in table "billing_event_log"
"""
input billing_event_log_set_input {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
Streaming cursor of the table "billing_event_log"
"""
input billing_event_log_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: billing_event_log_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input billing_event_log_stream_cursor_value_input {
  created_at: timestamptz
  created_by: uuid
  event_type: String
  id: uuid
  invoice_id: uuid
  message: String
}

"""
update columns of table "billing_event_log"
"""
enum billing_event_log_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  created_by
  """
  column name
  """
  event_type
  """
  column name
  """
  id
  """
  column name
  """
  invoice_id
  """
  column name
  """
  message
}

input billing_event_log_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: billing_event_log_set_input
  """
  filter the rows which have to be updated
  """
  where: billing_event_log_bool_exp!
}

"""
columns and relationships of "billing_invoice"
"""
type billing_invoice {
  """
  An array relationship
  """
  billing_event_logs(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!
  """
  An aggregate relationship
  """
  billing_event_logs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!
  """
  An array relationship
  """
  billing_invoice_items(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_item_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_item_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!
  """
  An aggregate relationship
  """
  billing_invoice_items_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_item_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_item_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_item_bool_exp
  ): billing_invoice_item_aggregate!
  billing_period_end: date!
  billing_period_start: date!
  """
  An object relationship
  """
  client: clients!
  client_id: uuid!
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid!
  issued_date: date
  notes: String
  status: String!
  total_amount: numeric!
  updated_at: timestamptz
}

"""
aggregated selection of "billing_invoice"
"""
type billing_invoice_aggregate {
  aggregate: billing_invoice_aggregate_fields
  nodes: [billing_invoice!]!
}

input billing_invoice_aggregate_bool_exp {
  count: billing_invoice_aggregate_bool_exp_count
}

input billing_invoice_aggregate_bool_exp_count {
  arguments: [billing_invoice_select_column!]
  distinct: Boolean
  filter: billing_invoice_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_invoice"
"""
type billing_invoice_aggregate_fields {
  avg: billing_invoice_avg_fields
  count(columns: [billing_invoice_select_column!], distinct: Boolean): Int!
  max: billing_invoice_max_fields
  min: billing_invoice_min_fields
  stddev: billing_invoice_stddev_fields
  stddev_pop: billing_invoice_stddev_pop_fields
  stddev_samp: billing_invoice_stddev_samp_fields
  sum: billing_invoice_sum_fields
  var_pop: billing_invoice_var_pop_fields
  var_samp: billing_invoice_var_samp_fields
  variance: billing_invoice_variance_fields
}

"""
order by aggregate values of table "billing_invoice"
"""
input billing_invoice_aggregate_order_by {
  avg: billing_invoice_avg_order_by
  count: order_by
  max: billing_invoice_max_order_by
  min: billing_invoice_min_order_by
  stddev: billing_invoice_stddev_order_by
  stddev_pop: billing_invoice_stddev_pop_order_by
  stddev_samp: billing_invoice_stddev_samp_order_by
  sum: billing_invoice_sum_order_by
  var_pop: billing_invoice_var_pop_order_by
  var_samp: billing_invoice_var_samp_order_by
  variance: billing_invoice_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_invoice"
"""
input billing_invoice_arr_rel_insert_input {
  data: [billing_invoice_insert_input!]!
  """
  upsert condition
  """
  on_conflict: billing_invoice_on_conflict
}

"""
aggregate avg on columns
"""
type billing_invoice_avg_fields {
  total_amount: Float
}

"""
order by avg() on columns of table "billing_invoice"
"""
input billing_invoice_avg_order_by {
  total_amount: order_by
}

"""
Boolean expression to filter rows from the table "billing_invoice". All fields are combined with a logical 'AND'.
"""
input billing_invoice_bool_exp {
  _and: [billing_invoice_bool_exp!]
  _not: billing_invoice_bool_exp
  _or: [billing_invoice_bool_exp!]
  billing_event_logs: billing_event_log_bool_exp
  billing_event_logs_aggregate: billing_event_log_aggregate_bool_exp
  billing_invoice_items: billing_invoice_item_bool_exp
  billing_invoice_items_aggregate: billing_invoice_item_aggregate_bool_exp
  billing_period_end: date_comparison_exp
  billing_period_start: date_comparison_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  due_date: date_comparison_exp
  id: uuid_comparison_exp
  issued_date: date_comparison_exp
  notes: String_comparison_exp
  status: String_comparison_exp
  total_amount: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "billing_invoice"
"""
enum billing_invoice_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoice_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoice"
"""
input billing_invoice_inc_input {
  total_amount: numeric
}

"""
input type for inserting data into table "billing_invoice"
"""
input billing_invoice_insert_input {
  billing_event_logs: billing_event_log_arr_rel_insert_input
  billing_invoice_items: billing_invoice_item_arr_rel_insert_input
  billing_period_end: date
  billing_period_start: date
  client: clients_obj_rel_insert_input
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
columns and relationships of "billing_invoice_item"
"""
type billing_invoice_item {
  amount: numeric
  created_at: timestamptz
  description: String!
  id: uuid!
  invoice_id: uuid!
  """
  An object relationship
  """
  parent_invoice: billing_invoice!
  quantity: Int!
  unit_price: numeric!
  updated_at: timestamptz
}

"""
aggregated selection of "billing_invoice_item"
"""
type billing_invoice_item_aggregate {
  aggregate: billing_invoice_item_aggregate_fields
  nodes: [billing_invoice_item!]!
}

input billing_invoice_item_aggregate_bool_exp {
  count: billing_invoice_item_aggregate_bool_exp_count
}

input billing_invoice_item_aggregate_bool_exp_count {
  arguments: [billing_invoice_item_select_column!]
  distinct: Boolean
  filter: billing_invoice_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_invoice_item"
"""
type billing_invoice_item_aggregate_fields {
  avg: billing_invoice_item_avg_fields
  count(columns: [billing_invoice_item_select_column!], distinct: Boolean): Int!
  max: billing_invoice_item_max_fields
  min: billing_invoice_item_min_fields
  stddev: billing_invoice_item_stddev_fields
  stddev_pop: billing_invoice_item_stddev_pop_fields
  stddev_samp: billing_invoice_item_stddev_samp_fields
  sum: billing_invoice_item_sum_fields
  var_pop: billing_invoice_item_var_pop_fields
  var_samp: billing_invoice_item_var_samp_fields
  variance: billing_invoice_item_variance_fields
}

"""
order by aggregate values of table "billing_invoice_item"
"""
input billing_invoice_item_aggregate_order_by {
  avg: billing_invoice_item_avg_order_by
  count: order_by
  max: billing_invoice_item_max_order_by
  min: billing_invoice_item_min_order_by
  stddev: billing_invoice_item_stddev_order_by
  stddev_pop: billing_invoice_item_stddev_pop_order_by
  stddev_samp: billing_invoice_item_stddev_samp_order_by
  sum: billing_invoice_item_sum_order_by
  var_pop: billing_invoice_item_var_pop_order_by
  var_samp: billing_invoice_item_var_samp_order_by
  variance: billing_invoice_item_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_invoice_item"
"""
input billing_invoice_item_arr_rel_insert_input {
  data: [billing_invoice_item_insert_input!]!
  """
  upsert condition
  """
  on_conflict: billing_invoice_item_on_conflict
}

"""
aggregate avg on columns
"""
type billing_invoice_item_avg_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by avg() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_avg_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Boolean expression to filter rows from the table "billing_invoice_item". All fields are combined with a logical 'AND'.
"""
input billing_invoice_item_bool_exp {
  _and: [billing_invoice_item_bool_exp!]
  _not: billing_invoice_item_bool_exp
  _or: [billing_invoice_item_bool_exp!]
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  invoice_id: uuid_comparison_exp
  parent_invoice: billing_invoice_bool_exp
  quantity: Int_comparison_exp
  unit_price: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "billing_invoice_item"
"""
enum billing_invoice_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoice_item_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoice_item"
"""
input billing_invoice_item_inc_input {
  quantity: Int
  unit_price: numeric
}

"""
input type for inserting data into table "billing_invoice_item"
"""
input billing_invoice_item_insert_input {
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  parent_invoice: billing_invoice_obj_rel_insert_input
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type billing_invoice_item_max_fields {
  amount: numeric
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""
order by max() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_max_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  quantity: order_by
  unit_price: order_by
  updated_at: order_by
}

"""
aggregate min on columns
"""
type billing_invoice_item_min_fields {
  amount: numeric
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""
order by min() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_min_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  quantity: order_by
  unit_price: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "billing_invoice_item"
"""
type billing_invoice_item_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [billing_invoice_item!]!
}

"""
on_conflict condition type for table "billing_invoice_item"
"""
input billing_invoice_item_on_conflict {
  constraint: billing_invoice_item_constraint!
  update_columns: [billing_invoice_item_update_column!]! = []
  where: billing_invoice_item_bool_exp
}

"""
Ordering options when selecting data from "billing_invoice_item".
"""
input billing_invoice_item_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  parent_invoice: billing_invoice_order_by
  quantity: order_by
  unit_price: order_by
  updated_at: order_by
}

"""
primary key columns input for table: billing_invoice_item
"""
input billing_invoice_item_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_invoice_item"
"""
enum billing_invoice_item_select_column {
  """
  column name
  """
  amount
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  invoice_id
  """
  column name
  """
  quantity
  """
  column name
  """
  unit_price
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "billing_invoice_item"
"""
input billing_invoice_item_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""
aggregate stddev on columns
"""
type billing_invoice_item_stddev_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_stddev_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate stddev_pop on columns
"""
type billing_invoice_item_stddev_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_pop() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_stddev_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate stddev_samp on columns
"""
type billing_invoice_item_stddev_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_samp() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_stddev_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Streaming cursor of the table "billing_invoice_item"
"""
input billing_invoice_item_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: billing_invoice_item_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input billing_invoice_item_stream_cursor_value_input {
  amount: numeric
  created_at: timestamptz
  description: String
  id: uuid
  invoice_id: uuid
  quantity: Int
  unit_price: numeric
  updated_at: timestamptz
}

"""
aggregate sum on columns
"""
type billing_invoice_item_sum_fields {
  amount: numeric
  quantity: Int
  unit_price: numeric
}

"""
order by sum() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_sum_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
update columns of table "billing_invoice_item"
"""
enum billing_invoice_item_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  invoice_id
  """
  column name
  """
  quantity
  """
  column name
  """
  unit_price
  """
  column name
  """
  updated_at
}

input billing_invoice_item_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: billing_invoice_item_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: billing_invoice_item_set_input
  """
  filter the rows which have to be updated
  """
  where: billing_invoice_item_bool_exp!
}

"""
aggregate var_pop on columns
"""
type billing_invoice_item_var_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_pop() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_var_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate var_samp on columns
"""
type billing_invoice_item_var_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_samp() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_var_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate variance on columns
"""
type billing_invoice_item_variance_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by variance() on columns of table "billing_invoice_item"
"""
input billing_invoice_item_variance_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate max on columns
"""
type billing_invoice_max_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
order by max() on columns of table "billing_invoice"
"""
input billing_invoice_max_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  currency: order_by
  due_date: order_by
  id: order_by
  issued_date: order_by
  notes: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
aggregate min on columns
"""
type billing_invoice_min_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
order by min() on columns of table "billing_invoice"
"""
input billing_invoice_min_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  currency: order_by
  due_date: order_by
  id: order_by
  issued_date: order_by
  notes: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "billing_invoice"
"""
type billing_invoice_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [billing_invoice!]!
}

"""
input type for inserting object relation for remote table "billing_invoice"
"""
input billing_invoice_obj_rel_insert_input {
  data: billing_invoice_insert_input!
  """
  upsert condition
  """
  on_conflict: billing_invoice_on_conflict
}

"""
on_conflict condition type for table "billing_invoice"
"""
input billing_invoice_on_conflict {
  constraint: billing_invoice_constraint!
  update_columns: [billing_invoice_update_column!]! = []
  where: billing_invoice_bool_exp
}

"""
Ordering options when selecting data from "billing_invoice".
"""
input billing_invoice_order_by {
  billing_event_logs_aggregate: billing_event_log_aggregate_order_by
  billing_invoice_items_aggregate: billing_invoice_item_aggregate_order_by
  billing_period_end: order_by
  billing_period_start: order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  currency: order_by
  due_date: order_by
  id: order_by
  issued_date: order_by
  notes: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
primary key columns input for table: billing_invoice
"""
input billing_invoice_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_invoice"
"""
enum billing_invoice_select_column {
  """
  column name
  """
  billing_period_end
  """
  column name
  """
  billing_period_start
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  currency
  """
  column name
  """
  due_date
  """
  column name
  """
  id
  """
  column name
  """
  issued_date
  """
  column name
  """
  notes
  """
  column name
  """
  status
  """
  column name
  """
  total_amount
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "billing_invoice"
"""
input billing_invoice_set_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
aggregate stddev on columns
"""
type billing_invoice_stddev_fields {
  total_amount: Float
}

"""
order by stddev() on columns of table "billing_invoice"
"""
input billing_invoice_stddev_order_by {
  total_amount: order_by
}

"""
aggregate stddev_pop on columns
"""
type billing_invoice_stddev_pop_fields {
  total_amount: Float
}

"""
order by stddev_pop() on columns of table "billing_invoice"
"""
input billing_invoice_stddev_pop_order_by {
  total_amount: order_by
}

"""
aggregate stddev_samp on columns
"""
type billing_invoice_stddev_samp_fields {
  total_amount: Float
}

"""
order by stddev_samp() on columns of table "billing_invoice"
"""
input billing_invoice_stddev_samp_order_by {
  total_amount: order_by
}

"""
Streaming cursor of the table "billing_invoice"
"""
input billing_invoice_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: billing_invoice_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input billing_invoice_stream_cursor_value_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamptz
  currency: String
  due_date: date
  id: uuid
  issued_date: date
  notes: String
  status: String
  total_amount: numeric
  updated_at: timestamptz
}

"""
aggregate sum on columns
"""
type billing_invoice_sum_fields {
  total_amount: numeric
}

"""
order by sum() on columns of table "billing_invoice"
"""
input billing_invoice_sum_order_by {
  total_amount: order_by
}

"""
update columns of table "billing_invoice"
"""
enum billing_invoice_update_column {
  """
  column name
  """
  billing_period_end
  """
  column name
  """
  billing_period_start
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  currency
  """
  column name
  """
  due_date
  """
  column name
  """
  id
  """
  column name
  """
  issued_date
  """
  column name
  """
  notes
  """
  column name
  """
  status
  """
  column name
  """
  total_amount
  """
  column name
  """
  updated_at
}

input billing_invoice_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: billing_invoice_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: billing_invoice_set_input
  """
  filter the rows which have to be updated
  """
  where: billing_invoice_bool_exp!
}

"""
aggregate var_pop on columns
"""
type billing_invoice_var_pop_fields {
  total_amount: Float
}

"""
order by var_pop() on columns of table "billing_invoice"
"""
input billing_invoice_var_pop_order_by {
  total_amount: order_by
}

"""
aggregate var_samp on columns
"""
type billing_invoice_var_samp_fields {
  total_amount: Float
}

"""
order by var_samp() on columns of table "billing_invoice"
"""
input billing_invoice_var_samp_order_by {
  total_amount: order_by
}

"""
aggregate variance on columns
"""
type billing_invoice_variance_fields {
  total_amount: Float
}

"""
order by variance() on columns of table "billing_invoice"
"""
input billing_invoice_variance_order_by {
  total_amount: order_by
}

"""
columns and relationships of "billing_invoices"
"""
type billing_invoices {
  """
  An array relationship
  """
  billing_items(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): [billing_items!]!
  """
  An aggregate relationship
  """
  billing_items_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): billing_items_aggregate!
  billing_period_end: date!
  billing_period_start: date!
  """
  An object relationship
  """
  client: clients
  client_id: uuid
  created_at: timestamp
  id: uuid!
  invoice_number: String!
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
aggregated selection of "billing_invoices"
"""
type billing_invoices_aggregate {
  aggregate: billing_invoices_aggregate_fields
  nodes: [billing_invoices!]!
}

input billing_invoices_aggregate_bool_exp {
  count: billing_invoices_aggregate_bool_exp_count
}

input billing_invoices_aggregate_bool_exp_count {
  arguments: [billing_invoices_select_column!]
  distinct: Boolean
  filter: billing_invoices_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_invoices"
"""
type billing_invoices_aggregate_fields {
  avg: billing_invoices_avg_fields
  count(columns: [billing_invoices_select_column!], distinct: Boolean): Int!
  max: billing_invoices_max_fields
  min: billing_invoices_min_fields
  stddev: billing_invoices_stddev_fields
  stddev_pop: billing_invoices_stddev_pop_fields
  stddev_samp: billing_invoices_stddev_samp_fields
  sum: billing_invoices_sum_fields
  var_pop: billing_invoices_var_pop_fields
  var_samp: billing_invoices_var_samp_fields
  variance: billing_invoices_variance_fields
}

"""
order by aggregate values of table "billing_invoices"
"""
input billing_invoices_aggregate_order_by {
  avg: billing_invoices_avg_order_by
  count: order_by
  max: billing_invoices_max_order_by
  min: billing_invoices_min_order_by
  stddev: billing_invoices_stddev_order_by
  stddev_pop: billing_invoices_stddev_pop_order_by
  stddev_samp: billing_invoices_stddev_samp_order_by
  sum: billing_invoices_sum_order_by
  var_pop: billing_invoices_var_pop_order_by
  var_samp: billing_invoices_var_samp_order_by
  variance: billing_invoices_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_invoices"
"""
input billing_invoices_arr_rel_insert_input {
  data: [billing_invoices_insert_input!]!
  """
  upsert condition
  """
  on_conflict: billing_invoices_on_conflict
}

"""
aggregate avg on columns
"""
type billing_invoices_avg_fields {
  total_amount: Float
}

"""
order by avg() on columns of table "billing_invoices"
"""
input billing_invoices_avg_order_by {
  total_amount: order_by
}

"""
Boolean expression to filter rows from the table "billing_invoices". All fields are combined with a logical 'AND'.
"""
input billing_invoices_bool_exp {
  _and: [billing_invoices_bool_exp!]
  _not: billing_invoices_bool_exp
  _or: [billing_invoices_bool_exp!]
  billing_items: billing_items_bool_exp
  billing_items_aggregate: billing_items_aggregate_bool_exp
  billing_period_end: date_comparison_exp
  billing_period_start: date_comparison_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  id: uuid_comparison_exp
  invoice_number: String_comparison_exp
  status: String_comparison_exp
  total_amount: numeric_comparison_exp
  updated_at: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "billing_invoices"
"""
enum billing_invoices_constraint {
  """
  unique or primary key constraint on columns "invoice_number"
  """
  billing_invoices_invoice_number_key
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoices_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoices"
"""
input billing_invoices_inc_input {
  total_amount: numeric
}

"""
input type for inserting data into table "billing_invoices"
"""
input billing_invoices_insert_input {
  billing_items: billing_items_arr_rel_insert_input
  billing_period_end: date
  billing_period_start: date
  client: clients_obj_rel_insert_input
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
aggregate max on columns
"""
type billing_invoices_max_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
order by max() on columns of table "billing_invoices"
"""
input billing_invoices_max_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  id: order_by
  invoice_number: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
aggregate min on columns
"""
type billing_invoices_min_fields {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
order by min() on columns of table "billing_invoices"
"""
input billing_invoices_min_order_by {
  billing_period_end: order_by
  billing_period_start: order_by
  client_id: order_by
  created_at: order_by
  id: order_by
  invoice_number: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "billing_invoices"
"""
type billing_invoices_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [billing_invoices!]!
}

"""
input type for inserting object relation for remote table "billing_invoices"
"""
input billing_invoices_obj_rel_insert_input {
  data: billing_invoices_insert_input!
  """
  upsert condition
  """
  on_conflict: billing_invoices_on_conflict
}

"""
on_conflict condition type for table "billing_invoices"
"""
input billing_invoices_on_conflict {
  constraint: billing_invoices_constraint!
  update_columns: [billing_invoices_update_column!]! = []
  where: billing_invoices_bool_exp
}

"""
Ordering options when selecting data from "billing_invoices".
"""
input billing_invoices_order_by {
  billing_items_aggregate: billing_items_aggregate_order_by
  billing_period_end: order_by
  billing_period_start: order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  id: order_by
  invoice_number: order_by
  status: order_by
  total_amount: order_by
  updated_at: order_by
}

"""
primary key columns input for table: billing_invoices
"""
input billing_invoices_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_invoices"
"""
enum billing_invoices_select_column {
  """
  column name
  """
  billing_period_end
  """
  column name
  """
  billing_period_start
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  invoice_number
  """
  column name
  """
  status
  """
  column name
  """
  total_amount
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "billing_invoices"
"""
input billing_invoices_set_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
aggregate stddev on columns
"""
type billing_invoices_stddev_fields {
  total_amount: Float
}

"""
order by stddev() on columns of table "billing_invoices"
"""
input billing_invoices_stddev_order_by {
  total_amount: order_by
}

"""
aggregate stddev_pop on columns
"""
type billing_invoices_stddev_pop_fields {
  total_amount: Float
}

"""
order by stddev_pop() on columns of table "billing_invoices"
"""
input billing_invoices_stddev_pop_order_by {
  total_amount: order_by
}

"""
aggregate stddev_samp on columns
"""
type billing_invoices_stddev_samp_fields {
  total_amount: Float
}

"""
order by stddev_samp() on columns of table "billing_invoices"
"""
input billing_invoices_stddev_samp_order_by {
  total_amount: order_by
}

"""
Streaming cursor of the table "billing_invoices"
"""
input billing_invoices_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: billing_invoices_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input billing_invoices_stream_cursor_value_input {
  billing_period_end: date
  billing_period_start: date
  client_id: uuid
  created_at: timestamp
  id: uuid
  invoice_number: String
  status: String
  total_amount: numeric
  updated_at: timestamp
}

"""
aggregate sum on columns
"""
type billing_invoices_sum_fields {
  total_amount: numeric
}

"""
order by sum() on columns of table "billing_invoices"
"""
input billing_invoices_sum_order_by {
  total_amount: order_by
}

"""
update columns of table "billing_invoices"
"""
enum billing_invoices_update_column {
  """
  column name
  """
  billing_period_end
  """
  column name
  """
  billing_period_start
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  invoice_number
  """
  column name
  """
  status
  """
  column name
  """
  total_amount
  """
  column name
  """
  updated_at
}

input billing_invoices_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: billing_invoices_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: billing_invoices_set_input
  """
  filter the rows which have to be updated
  """
  where: billing_invoices_bool_exp!
}

"""
aggregate var_pop on columns
"""
type billing_invoices_var_pop_fields {
  total_amount: Float
}

"""
order by var_pop() on columns of table "billing_invoices"
"""
input billing_invoices_var_pop_order_by {
  total_amount: order_by
}

"""
aggregate var_samp on columns
"""
type billing_invoices_var_samp_fields {
  total_amount: Float
}

"""
order by var_samp() on columns of table "billing_invoices"
"""
input billing_invoices_var_samp_order_by {
  total_amount: order_by
}

"""
aggregate variance on columns
"""
type billing_invoices_variance_fields {
  total_amount: Float
}

"""
order by variance() on columns of table "billing_invoices"
"""
input billing_invoices_variance_order_by {
  total_amount: order_by
}

"""
columns and relationships of "billing_items"
"""
type billing_items {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid!
  invoice_id: uuid
  """
  An object relationship
  """
  invoice_reference: billing_invoices
  """
  An object relationship
  """
  payroll: payrolls
  payroll_id: uuid
  quantity: Int!
  unit_price: numeric!
}

"""
aggregated selection of "billing_items"
"""
type billing_items_aggregate {
  aggregate: billing_items_aggregate_fields
  nodes: [billing_items!]!
}

input billing_items_aggregate_bool_exp {
  count: billing_items_aggregate_bool_exp_count
}

input billing_items_aggregate_bool_exp_count {
  arguments: [billing_items_select_column!]
  distinct: Boolean
  filter: billing_items_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "billing_items"
"""
type billing_items_aggregate_fields {
  avg: billing_items_avg_fields
  count(columns: [billing_items_select_column!], distinct: Boolean): Int!
  max: billing_items_max_fields
  min: billing_items_min_fields
  stddev: billing_items_stddev_fields
  stddev_pop: billing_items_stddev_pop_fields
  stddev_samp: billing_items_stddev_samp_fields
  sum: billing_items_sum_fields
  var_pop: billing_items_var_pop_fields
  var_samp: billing_items_var_samp_fields
  variance: billing_items_variance_fields
}

"""
order by aggregate values of table "billing_items"
"""
input billing_items_aggregate_order_by {
  avg: billing_items_avg_order_by
  count: order_by
  max: billing_items_max_order_by
  min: billing_items_min_order_by
  stddev: billing_items_stddev_order_by
  stddev_pop: billing_items_stddev_pop_order_by
  stddev_samp: billing_items_stddev_samp_order_by
  sum: billing_items_sum_order_by
  var_pop: billing_items_var_pop_order_by
  var_samp: billing_items_var_samp_order_by
  variance: billing_items_variance_order_by
}

"""
input type for inserting array relation for remote table "billing_items"
"""
input billing_items_arr_rel_insert_input {
  data: [billing_items_insert_input!]!
  """
  upsert condition
  """
  on_conflict: billing_items_on_conflict
}

"""
aggregate avg on columns
"""
type billing_items_avg_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by avg() on columns of table "billing_items"
"""
input billing_items_avg_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Boolean expression to filter rows from the table "billing_items". All fields are combined with a logical 'AND'.
"""
input billing_items_bool_exp {
  _and: [billing_items_bool_exp!]
  _not: billing_items_bool_exp
  _or: [billing_items_bool_exp!]
  amount: numeric_comparison_exp
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  invoice_id: uuid_comparison_exp
  invoice_reference: billing_invoices_bool_exp
  payroll: payrolls_bool_exp
  payroll_id: uuid_comparison_exp
  quantity: Int_comparison_exp
  unit_price: numeric_comparison_exp
}

"""
unique or primary key constraints on table "billing_items"
"""
enum billing_items_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_items_pkey
}

"""
input type for incrementing numeric columns in table "billing_items"
"""
input billing_items_inc_input {
  quantity: Int
  unit_price: numeric
}

"""
input type for inserting data into table "billing_items"
"""
input billing_items_insert_input {
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  invoice_reference: billing_invoices_obj_rel_insert_input
  payroll: payrolls_obj_rel_insert_input
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""
aggregate max on columns
"""
type billing_items_max_fields {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""
order by max() on columns of table "billing_items"
"""
input billing_items_max_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  payroll_id: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate min on columns
"""
type billing_items_min_fields {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""
order by min() on columns of table "billing_items"
"""
input billing_items_min_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  payroll_id: order_by
  quantity: order_by
  unit_price: order_by
}

"""
response of any mutation on the table "billing_items"
"""
type billing_items_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [billing_items!]!
}

"""
on_conflict condition type for table "billing_items"
"""
input billing_items_on_conflict {
  constraint: billing_items_constraint!
  update_columns: [billing_items_update_column!]! = []
  where: billing_items_bool_exp
}

"""
Ordering options when selecting data from "billing_items".
"""
input billing_items_order_by {
  amount: order_by
  created_at: order_by
  description: order_by
  id: order_by
  invoice_id: order_by
  invoice_reference: billing_invoices_order_by
  payroll: payrolls_order_by
  payroll_id: order_by
  quantity: order_by
  unit_price: order_by
}

"""
primary key columns input for table: billing_items
"""
input billing_items_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_items"
"""
enum billing_items_select_column {
  """
  column name
  """
  amount
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  invoice_id
  """
  column name
  """
  payroll_id
  """
  column name
  """
  quantity
  """
  column name
  """
  unit_price
}

"""
input type for updating data in table "billing_items"
"""
input billing_items_set_input {
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""
aggregate stddev on columns
"""
type billing_items_stddev_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev() on columns of table "billing_items"
"""
input billing_items_stddev_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate stddev_pop on columns
"""
type billing_items_stddev_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_pop() on columns of table "billing_items"
"""
input billing_items_stddev_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate stddev_samp on columns
"""
type billing_items_stddev_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by stddev_samp() on columns of table "billing_items"
"""
input billing_items_stddev_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
Streaming cursor of the table "billing_items"
"""
input billing_items_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: billing_items_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input billing_items_stream_cursor_value_input {
  amount: numeric
  created_at: timestamp
  description: String
  id: uuid
  invoice_id: uuid
  payroll_id: uuid
  quantity: Int
  unit_price: numeric
}

"""
aggregate sum on columns
"""
type billing_items_sum_fields {
  amount: numeric
  quantity: Int
  unit_price: numeric
}

"""
order by sum() on columns of table "billing_items"
"""
input billing_items_sum_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
update columns of table "billing_items"
"""
enum billing_items_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  invoice_id
  """
  column name
  """
  payroll_id
  """
  column name
  """
  quantity
  """
  column name
  """
  unit_price
}

input billing_items_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: billing_items_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: billing_items_set_input
  """
  filter the rows which have to be updated
  """
  where: billing_items_bool_exp!
}

"""
aggregate var_pop on columns
"""
type billing_items_var_pop_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_pop() on columns of table "billing_items"
"""
input billing_items_var_pop_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate var_samp on columns
"""
type billing_items_var_samp_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by var_samp() on columns of table "billing_items"
"""
input billing_items_var_samp_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
aggregate variance on columns
"""
type billing_items_variance_fields {
  amount: Float
  quantity: Float
  unit_price: Float
}

"""
order by variance() on columns of table "billing_items"
"""
input billing_items_variance_order_by {
  amount: order_by
  quantity: order_by
  unit_price: order_by
}

"""
columns and relationships of "billing_plan"
"""
type billing_plan {
  """
  An array relationship
  """
  client_billing_assignments(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!
  """
  An aggregate relationship
  """
  client_billing_assignments_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!
  created_at: timestamptz
  currency: String!
  description: String
  id: uuid!
  name: String!
  rate_per_payroll: numeric!
  updated_at: timestamptz
}

"""
aggregated selection of "billing_plan"
"""
type billing_plan_aggregate {
  aggregate: billing_plan_aggregate_fields
  nodes: [billing_plan!]!
}

"""
aggregate fields of "billing_plan"
"""
type billing_plan_aggregate_fields {
  avg: billing_plan_avg_fields
  count(columns: [billing_plan_select_column!], distinct: Boolean): Int!
  max: billing_plan_max_fields
  min: billing_plan_min_fields
  stddev: billing_plan_stddev_fields
  stddev_pop: billing_plan_stddev_pop_fields
  stddev_samp: billing_plan_stddev_samp_fields
  sum: billing_plan_sum_fields
  var_pop: billing_plan_var_pop_fields
  var_samp: billing_plan_var_samp_fields
  variance: billing_plan_variance_fields
}

"""
aggregate avg on columns
"""
type billing_plan_avg_fields {
  rate_per_payroll: Float
}

"""
Boolean expression to filter rows from the table "billing_plan". All fields are combined with a logical 'AND'.
"""
input billing_plan_bool_exp {
  _and: [billing_plan_bool_exp!]
  _not: billing_plan_bool_exp
  _or: [billing_plan_bool_exp!]
  client_billing_assignments: client_billing_assignment_bool_exp
  client_billing_assignments_aggregate: client_billing_assignment_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  rate_per_payroll: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "billing_plan"
"""
enum billing_plan_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_plan_pkey
}

"""
input type for incrementing numeric columns in table "billing_plan"
"""
input billing_plan_inc_input {
  rate_per_payroll: numeric
}

"""
input type for inserting data into table "billing_plan"
"""
input billing_plan_insert_input {
  client_billing_assignments: client_billing_assignment_arr_rel_insert_input
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type billing_plan_max_fields {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type billing_plan_min_fields {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""
response of any mutation on the table "billing_plan"
"""
type billing_plan_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [billing_plan!]!
}

"""
input type for inserting object relation for remote table "billing_plan"
"""
input billing_plan_obj_rel_insert_input {
  data: billing_plan_insert_input!
  """
  upsert condition
  """
  on_conflict: billing_plan_on_conflict
}

"""
on_conflict condition type for table "billing_plan"
"""
input billing_plan_on_conflict {
  constraint: billing_plan_constraint!
  update_columns: [billing_plan_update_column!]! = []
  where: billing_plan_bool_exp
}

"""
Ordering options when selecting data from "billing_plan".
"""
input billing_plan_order_by {
  client_billing_assignments_aggregate: client_billing_assignment_aggregate_order_by
  created_at: order_by
  currency: order_by
  description: order_by
  id: order_by
  name: order_by
  rate_per_payroll: order_by
  updated_at: order_by
}

"""
primary key columns input for table: billing_plan
"""
input billing_plan_pk_columns_input {
  id: uuid!
}

"""
select columns of table "billing_plan"
"""
enum billing_plan_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  currency
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  rate_per_payroll
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "billing_plan"
"""
input billing_plan_set_input {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""
aggregate stddev on columns
"""
type billing_plan_stddev_fields {
  rate_per_payroll: Float
}

"""
aggregate stddev_pop on columns
"""
type billing_plan_stddev_pop_fields {
  rate_per_payroll: Float
}

"""
aggregate stddev_samp on columns
"""
type billing_plan_stddev_samp_fields {
  rate_per_payroll: Float
}

"""
Streaming cursor of the table "billing_plan"
"""
input billing_plan_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: billing_plan_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input billing_plan_stream_cursor_value_input {
  created_at: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  rate_per_payroll: numeric
  updated_at: timestamptz
}

"""
aggregate sum on columns
"""
type billing_plan_sum_fields {
  rate_per_payroll: numeric
}

"""
update columns of table "billing_plan"
"""
enum billing_plan_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  currency
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  rate_per_payroll
  """
  column name
  """
  updated_at
}

input billing_plan_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: billing_plan_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: billing_plan_set_input
  """
  filter the rows which have to be updated
  """
  where: billing_plan_bool_exp!
}

"""
aggregate var_pop on columns
"""
type billing_plan_var_pop_fields {
  rate_per_payroll: Float
}

"""
aggregate var_samp on columns
"""
type billing_plan_var_samp_fields {
  rate_per_payroll: Float
}

"""
aggregate variance on columns
"""
type billing_plan_variance_fields {
  rate_per_payroll: Float
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar
  """
  does the column match the given case-insensitive pattern
  """
  _ilike: bpchar
  _in: [bpchar!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean
  """
  does the column match the given pattern
  """
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar
  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: bpchar
  _nin: [bpchar!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar
  """
  does the column NOT match the given pattern
  """
  _nlike: bpchar
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar
  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: bpchar
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar
  """
  does the column match the given SQL regular expression
  """
  _similar: bpchar
}

"""
columns and relationships of "client_billing_assignment"
"""
type client_billing_assignment {
  """
  An object relationship
  """
  billing_plan: billing_plan!
  billing_plan_id: uuid!
  """
  An object relationship
  """
  client: clients!
  client_id: uuid!
  created_at: timestamptz
  end_date: date
  id: uuid!
  is_active: Boolean
  start_date: date!
  updated_at: timestamptz
}

"""
aggregated selection of "client_billing_assignment"
"""
type client_billing_assignment_aggregate {
  aggregate: client_billing_assignment_aggregate_fields
  nodes: [client_billing_assignment!]!
}

input client_billing_assignment_aggregate_bool_exp {
  bool_and: client_billing_assignment_aggregate_bool_exp_bool_and
  bool_or: client_billing_assignment_aggregate_bool_exp_bool_or
  count: client_billing_assignment_aggregate_bool_exp_count
}

input client_billing_assignment_aggregate_bool_exp_bool_and {
  arguments: client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: client_billing_assignment_bool_exp
  predicate: Boolean_comparison_exp!
}

input client_billing_assignment_aggregate_bool_exp_bool_or {
  arguments: client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: client_billing_assignment_bool_exp
  predicate: Boolean_comparison_exp!
}

input client_billing_assignment_aggregate_bool_exp_count {
  arguments: [client_billing_assignment_select_column!]
  distinct: Boolean
  filter: client_billing_assignment_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "client_billing_assignment"
"""
type client_billing_assignment_aggregate_fields {
  count(
    columns: [client_billing_assignment_select_column!]
    distinct: Boolean
  ): Int!
  max: client_billing_assignment_max_fields
  min: client_billing_assignment_min_fields
}

"""
order by aggregate values of table "client_billing_assignment"
"""
input client_billing_assignment_aggregate_order_by {
  count: order_by
  max: client_billing_assignment_max_order_by
  min: client_billing_assignment_min_order_by
}

"""
input type for inserting array relation for remote table "client_billing_assignment"
"""
input client_billing_assignment_arr_rel_insert_input {
  data: [client_billing_assignment_insert_input!]!
  """
  upsert condition
  """
  on_conflict: client_billing_assignment_on_conflict
}

"""
Boolean expression to filter rows from the table "client_billing_assignment". All fields are combined with a logical 'AND'.
"""
input client_billing_assignment_bool_exp {
  _and: [client_billing_assignment_bool_exp!]
  _not: client_billing_assignment_bool_exp
  _or: [client_billing_assignment_bool_exp!]
  billing_plan: billing_plan_bool_exp
  billing_plan_id: uuid_comparison_exp
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  start_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "client_billing_assignment"
"""
enum client_billing_assignment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  client_billing_assignment_pkey
}

"""
input type for inserting data into table "client_billing_assignment"
"""
input client_billing_assignment_insert_input {
  billing_plan: billing_plan_obj_rel_insert_input
  billing_plan_id: uuid
  client: clients_obj_rel_insert_input
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  is_active: Boolean
  start_date: date
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type client_billing_assignment_max_fields {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  start_date: date
  updated_at: timestamptz
}

"""
order by max() on columns of table "client_billing_assignment"
"""
input client_billing_assignment_max_order_by {
  billing_plan_id: order_by
  client_id: order_by
  created_at: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  updated_at: order_by
}

"""
aggregate min on columns
"""
type client_billing_assignment_min_fields {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  start_date: date
  updated_at: timestamptz
}

"""
order by min() on columns of table "client_billing_assignment"
"""
input client_billing_assignment_min_order_by {
  billing_plan_id: order_by
  client_id: order_by
  created_at: order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "client_billing_assignment"
"""
type client_billing_assignment_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [client_billing_assignment!]!
}

"""
on_conflict condition type for table "client_billing_assignment"
"""
input client_billing_assignment_on_conflict {
  constraint: client_billing_assignment_constraint!
  update_columns: [client_billing_assignment_update_column!]! = []
  where: client_billing_assignment_bool_exp
}

"""
Ordering options when selecting data from "client_billing_assignment".
"""
input client_billing_assignment_order_by {
  billing_plan: billing_plan_order_by
  billing_plan_id: order_by
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  end_date: order_by
  id: order_by
  is_active: order_by
  start_date: order_by
  updated_at: order_by
}

"""
primary key columns input for table: client_billing_assignment
"""
input client_billing_assignment_pk_columns_input {
  id: uuid!
}

"""
select columns of table "client_billing_assignment"
"""
enum client_billing_assignment_select_column {
  """
  column name
  """
  billing_plan_id
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  end_date
  """
  column name
  """
  id
  """
  column name
  """
  is_active
  """
  column name
  """
  start_date
  """
  column name
  """
  updated_at
}

"""
select "client_billing_assignment_aggregate_bool_exp_bool_and_arguments_columns" columns of table "client_billing_assignment"
"""
enum client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  is_active
}

"""
select "client_billing_assignment_aggregate_bool_exp_bool_or_arguments_columns" columns of table "client_billing_assignment"
"""
enum client_billing_assignment_select_column_client_billing_assignment_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  is_active
}

"""
input type for updating data in table "client_billing_assignment"
"""
input client_billing_assignment_set_input {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  is_active: Boolean
  start_date: date
  updated_at: timestamptz
}

"""
Streaming cursor of the table "client_billing_assignment"
"""
input client_billing_assignment_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: client_billing_assignment_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input client_billing_assignment_stream_cursor_value_input {
  billing_plan_id: uuid
  client_id: uuid
  created_at: timestamptz
  end_date: date
  id: uuid
  is_active: Boolean
  start_date: date
  updated_at: timestamptz
}

"""
update columns of table "client_billing_assignment"
"""
enum client_billing_assignment_update_column {
  """
  column name
  """
  billing_plan_id
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  end_date
  """
  column name
  """
  id
  """
  column name
  """
  is_active
  """
  column name
  """
  start_date
  """
  column name
  """
  updated_at
}

input client_billing_assignment_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: client_billing_assignment_set_input
  """
  filter the rows which have to be updated
  """
  where: client_billing_assignment_bool_exp!
}

"""
columns and relationships of "client_external_systems"
"""
type client_external_systems {
  """
  An object relationship
  """
  client: clients!
  """
  Reference to the client
  """
  client_id: uuid!
  """
  Timestamp when the mapping was created
  """
  created_at: timestamptz
  """
  An object relationship
  """
  external_system: external_systems!
  """
  Unique identifier for the client-system mapping
  """
  id: uuid!
  """
  Client identifier in the external system
  """
  system_client_id: String
  """
  Reference to the external system
  """
  system_id: uuid!
  """
  Timestamp when the mapping was last updated
  """
  updated_at: timestamptz
}

"""
aggregated selection of "client_external_systems"
"""
type client_external_systems_aggregate {
  aggregate: client_external_systems_aggregate_fields
  nodes: [client_external_systems!]!
}

input client_external_systems_aggregate_bool_exp {
  count: client_external_systems_aggregate_bool_exp_count
}

input client_external_systems_aggregate_bool_exp_count {
  arguments: [client_external_systems_select_column!]
  distinct: Boolean
  filter: client_external_systems_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "client_external_systems"
"""
type client_external_systems_aggregate_fields {
  count(
    columns: [client_external_systems_select_column!]
    distinct: Boolean
  ): Int!
  max: client_external_systems_max_fields
  min: client_external_systems_min_fields
}

"""
order by aggregate values of table "client_external_systems"
"""
input client_external_systems_aggregate_order_by {
  count: order_by
  max: client_external_systems_max_order_by
  min: client_external_systems_min_order_by
}

"""
input type for inserting array relation for remote table "client_external_systems"
"""
input client_external_systems_arr_rel_insert_input {
  data: [client_external_systems_insert_input!]!
  """
  upsert condition
  """
  on_conflict: client_external_systems_on_conflict
}

"""
Boolean expression to filter rows from the table "client_external_systems". All fields are combined with a logical 'AND'.
"""
input client_external_systems_bool_exp {
  _and: [client_external_systems_bool_exp!]
  _not: client_external_systems_bool_exp
  _or: [client_external_systems_bool_exp!]
  client: clients_bool_exp
  client_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  external_system: external_systems_bool_exp
  id: uuid_comparison_exp
  system_client_id: String_comparison_exp
  system_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "client_external_systems"
"""
enum client_external_systems_constraint {
  """
  unique or primary key constraint on columns "client_id", "system_id"
  """
  client_external_systems_client_id_system_id_key
  """
  unique or primary key constraint on columns "id"
  """
  client_external_systems_pkey
}

"""
input type for inserting data into table "client_external_systems"
"""
input client_external_systems_insert_input {
  client: clients_obj_rel_insert_input
  """
  Reference to the client
  """
  client_id: uuid
  """
  Timestamp when the mapping was created
  """
  created_at: timestamptz
  external_system: external_systems_obj_rel_insert_input
  """
  Unique identifier for the client-system mapping
  """
  id: uuid
  """
  Client identifier in the external system
  """
  system_client_id: String
  """
  Reference to the external system
  """
  system_id: uuid
  """
  Timestamp when the mapping was last updated
  """
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type client_external_systems_max_fields {
  """
  Reference to the client
  """
  client_id: uuid
  """
  Timestamp when the mapping was created
  """
  created_at: timestamptz
  """
  Unique identifier for the client-system mapping
  """
  id: uuid
  """
  Client identifier in the external system
  """
  system_client_id: String
  """
  Reference to the external system
  """
  system_id: uuid
  """
  Timestamp when the mapping was last updated
  """
  updated_at: timestamptz
}

"""
order by max() on columns of table "client_external_systems"
"""
input client_external_systems_max_order_by {
  """
  Reference to the client
  """
  client_id: order_by
  """
  Timestamp when the mapping was created
  """
  created_at: order_by
  """
  Unique identifier for the client-system mapping
  """
  id: order_by
  """
  Client identifier in the external system
  """
  system_client_id: order_by
  """
  Reference to the external system
  """
  system_id: order_by
  """
  Timestamp when the mapping was last updated
  """
  updated_at: order_by
}

"""
aggregate min on columns
"""
type client_external_systems_min_fields {
  """
  Reference to the client
  """
  client_id: uuid
  """
  Timestamp when the mapping was created
  """
  created_at: timestamptz
  """
  Unique identifier for the client-system mapping
  """
  id: uuid
  """
  Client identifier in the external system
  """
  system_client_id: String
  """
  Reference to the external system
  """
  system_id: uuid
  """
  Timestamp when the mapping was last updated
  """
  updated_at: timestamptz
}

"""
order by min() on columns of table "client_external_systems"
"""
input client_external_systems_min_order_by {
  """
  Reference to the client
  """
  client_id: order_by
  """
  Timestamp when the mapping was created
  """
  created_at: order_by
  """
  Unique identifier for the client-system mapping
  """
  id: order_by
  """
  Client identifier in the external system
  """
  system_client_id: order_by
  """
  Reference to the external system
  """
  system_id: order_by
  """
  Timestamp when the mapping was last updated
  """
  updated_at: order_by
}

"""
response of any mutation on the table "client_external_systems"
"""
type client_external_systems_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [client_external_systems!]!
}

"""
on_conflict condition type for table "client_external_systems"
"""
input client_external_systems_on_conflict {
  constraint: client_external_systems_constraint!
  update_columns: [client_external_systems_update_column!]! = []
  where: client_external_systems_bool_exp
}

"""
Ordering options when selecting data from "client_external_systems".
"""
input client_external_systems_order_by {
  client: clients_order_by
  client_id: order_by
  created_at: order_by
  external_system: external_systems_order_by
  id: order_by
  system_client_id: order_by
  system_id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: client_external_systems
"""
input client_external_systems_pk_columns_input {
  """
  Unique identifier for the client-system mapping
  """
  id: uuid!
}

"""
select columns of table "client_external_systems"
"""
enum client_external_systems_select_column {
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  system_client_id
  """
  column name
  """
  system_id
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "client_external_systems"
"""
input client_external_systems_set_input {
  """
  Reference to the client
  """
  client_id: uuid
  """
  Timestamp when the mapping was created
  """
  created_at: timestamptz
  """
  Unique identifier for the client-system mapping
  """
  id: uuid
  """
  Client identifier in the external system
  """
  system_client_id: String
  """
  Reference to the external system
  """
  system_id: uuid
  """
  Timestamp when the mapping was last updated
  """
  updated_at: timestamptz
}

"""
Streaming cursor of the table "client_external_systems"
"""
input client_external_systems_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: client_external_systems_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input client_external_systems_stream_cursor_value_input {
  """
  Reference to the client
  """
  client_id: uuid
  """
  Timestamp when the mapping was created
  """
  created_at: timestamptz
  """
  Unique identifier for the client-system mapping
  """
  id: uuid
  """
  Client identifier in the external system
  """
  system_client_id: String
  """
  Reference to the external system
  """
  system_id: uuid
  """
  Timestamp when the mapping was last updated
  """
  updated_at: timestamptz
}

"""
update columns of table "client_external_systems"
"""
enum client_external_systems_update_column {
  """
  column name
  """
  client_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  system_client_id
  """
  column name
  """
  system_id
  """
  column name
  """
  updated_at
}

input client_external_systems_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: client_external_systems_set_input
  """
  filter the rows which have to be updated
  """
  where: client_external_systems_bool_exp!
}

"""
columns and relationships of "clients"
"""
type clients {
  """
  Whether the client is currently active
  """
  active: Boolean
  """
  An array relationship
  """
  billingAssignments(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!
  """
  An aggregate relationship
  """
  billingAssignments_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!
  """
  An array relationship
  """
  billingInvoices(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!
  """
  An array relationship
  """
  billingInvoicesList(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoices_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoices_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!
  """
  An aggregate relationship
  """
  billingInvoicesList_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoices_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoices_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoices_bool_exp
  ): billing_invoices_aggregate!
  """
  An aggregate relationship
  """
  billingInvoices_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_bool_exp
  ): billing_invoice_aggregate!
  """
  Email address for the client contact
  """
  contactEmail: String
  """
  Primary contact person at the client
  """
  contactPerson: String
  """
  Phone number for the client contact
  """
  contactPhone: String
  """
  Timestamp when the client was created
  """
  createdAt: timestamptz
  """
  An array relationship
  """
  externalSystems(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!
  """
  An aggregate relationship
  """
  externalSystems_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!
  """
  Unique identifier for the client
  """
  id: uuid!
  """
  Client company name
  """
  name: String!
  """
  An array relationship
  """
  payrolls(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  payrolls_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  Timestamp when the client was last updated
  """
  updatedAt: timestamptz
}

"""
aggregated selection of "clients"
"""
type clients_aggregate {
  aggregate: clients_aggregate_fields
  nodes: [clients!]!
}

input clients_aggregate_bool_exp {
  bool_and: clients_aggregate_bool_exp_bool_and
  bool_or: clients_aggregate_bool_exp_bool_or
  count: clients_aggregate_bool_exp_count
}

input clients_aggregate_bool_exp_bool_and {
  arguments: clients_select_column_clients_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Boolean_comparison_exp!
}

input clients_aggregate_bool_exp_bool_or {
  arguments: clients_select_column_clients_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Boolean_comparison_exp!
}

input clients_aggregate_bool_exp_count {
  arguments: [clients_select_column!]
  distinct: Boolean
  filter: clients_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "clients"
"""
type clients_aggregate_fields {
  count(columns: [clients_select_column!], distinct: Boolean): Int!
  max: clients_max_fields
  min: clients_min_fields
}

"""
order by aggregate values of table "clients"
"""
input clients_aggregate_order_by {
  count: order_by
  max: clients_max_order_by
  min: clients_min_order_by
}

"""
input type for inserting array relation for remote table "clients"
"""
input clients_arr_rel_insert_input {
  data: [clients_insert_input!]!
  """
  upsert condition
  """
  on_conflict: clients_on_conflict
}

"""
Boolean expression to filter rows from the table "clients". All fields are combined with a logical 'AND'.
"""
input clients_bool_exp {
  _and: [clients_bool_exp!]
  _not: clients_bool_exp
  _or: [clients_bool_exp!]
  active: Boolean_comparison_exp
  billingAssignments: client_billing_assignment_bool_exp
  billingAssignments_aggregate: client_billing_assignment_aggregate_bool_exp
  billingInvoices: billing_invoice_bool_exp
  billingInvoicesList: billing_invoices_bool_exp
  billingInvoicesList_aggregate: billing_invoices_aggregate_bool_exp
  billingInvoices_aggregate: billing_invoice_aggregate_bool_exp
  contactEmail: String_comparison_exp
  contactPerson: String_comparison_exp
  contactPhone: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  externalSystems: client_external_systems_bool_exp
  externalSystems_aggregate: client_external_systems_aggregate_bool_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "clients"
"""
enum clients_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  clients_pkey
}

"""
input type for inserting data into table "clients"
"""
input clients_insert_input {
  """
  Whether the client is currently active
  """
  active: Boolean
  billingAssignments: client_billing_assignment_arr_rel_insert_input
  billingInvoices: billing_invoice_arr_rel_insert_input
  billingInvoicesList: billing_invoices_arr_rel_insert_input
  """
  Email address for the client contact
  """
  contactEmail: String
  """
  Primary contact person at the client
  """
  contactPerson: String
  """
  Phone number for the client contact
  """
  contactPhone: String
  """
  Timestamp when the client was created
  """
  createdAt: timestamptz
  externalSystems: client_external_systems_arr_rel_insert_input
  """
  Unique identifier for the client
  """
  id: uuid
  """
  Client company name
  """
  name: String
  payrolls: payrolls_arr_rel_insert_input
  """
  Timestamp when the client was last updated
  """
  updatedAt: timestamptz
}

"""
aggregate max on columns
"""
type clients_max_fields {
  """
  Email address for the client contact
  """
  contactEmail: String
  """
  Primary contact person at the client
  """
  contactPerson: String
  """
  Phone number for the client contact
  """
  contactPhone: String
  """
  Timestamp when the client was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the client
  """
  id: uuid
  """
  Client company name
  """
  name: String
  """
  Timestamp when the client was last updated
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "clients"
"""
input clients_max_order_by {
  """
  Email address for the client contact
  """
  contactEmail: order_by
  """
  Primary contact person at the client
  """
  contactPerson: order_by
  """
  Phone number for the client contact
  """
  contactPhone: order_by
  """
  Timestamp when the client was created
  """
  createdAt: order_by
  """
  Unique identifier for the client
  """
  id: order_by
  """
  Client company name
  """
  name: order_by
  """
  Timestamp when the client was last updated
  """
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type clients_min_fields {
  """
  Email address for the client contact
  """
  contactEmail: String
  """
  Primary contact person at the client
  """
  contactPerson: String
  """
  Phone number for the client contact
  """
  contactPhone: String
  """
  Timestamp when the client was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the client
  """
  id: uuid
  """
  Client company name
  """
  name: String
  """
  Timestamp when the client was last updated
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "clients"
"""
input clients_min_order_by {
  """
  Email address for the client contact
  """
  contactEmail: order_by
  """
  Primary contact person at the client
  """
  contactPerson: order_by
  """
  Phone number for the client contact
  """
  contactPhone: order_by
  """
  Timestamp when the client was created
  """
  createdAt: order_by
  """
  Unique identifier for the client
  """
  id: order_by
  """
  Client company name
  """
  name: order_by
  """
  Timestamp when the client was last updated
  """
  updatedAt: order_by
}

"""
response of any mutation on the table "clients"
"""
type clients_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [clients!]!
}

"""
input type for inserting object relation for remote table "clients"
"""
input clients_obj_rel_insert_input {
  data: clients_insert_input!
  """
  upsert condition
  """
  on_conflict: clients_on_conflict
}

"""
on_conflict condition type for table "clients"
"""
input clients_on_conflict {
  constraint: clients_constraint!
  update_columns: [clients_update_column!]! = []
  where: clients_bool_exp
}

"""
Ordering options when selecting data from "clients".
"""
input clients_order_by {
  active: order_by
  billingAssignments_aggregate: client_billing_assignment_aggregate_order_by
  billingInvoicesList_aggregate: billing_invoices_aggregate_order_by
  billingInvoices_aggregate: billing_invoice_aggregate_order_by
  contactEmail: order_by
  contactPerson: order_by
  contactPhone: order_by
  createdAt: order_by
  externalSystems_aggregate: client_external_systems_aggregate_order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updatedAt: order_by
}

"""
primary key columns input for table: clients
"""
input clients_pk_columns_input {
  """
  Unique identifier for the client
  """
  id: uuid!
}

"""
select columns of table "clients"
"""
enum clients_select_column {
  """
  column name
  """
  active
  """
  column name
  """
  contactEmail
  """
  column name
  """
  contactPerson
  """
  column name
  """
  contactPhone
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updatedAt
}

"""
select "clients_aggregate_bool_exp_bool_and_arguments_columns" columns of table "clients"
"""
enum clients_select_column_clients_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  active
}

"""
select "clients_aggregate_bool_exp_bool_or_arguments_columns" columns of table "clients"
"""
enum clients_select_column_clients_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  active
}

"""
input type for updating data in table "clients"
"""
input clients_set_input {
  """
  Whether the client is currently active
  """
  active: Boolean
  """
  Email address for the client contact
  """
  contactEmail: String
  """
  Primary contact person at the client
  """
  contactPerson: String
  """
  Phone number for the client contact
  """
  contactPhone: String
  """
  Timestamp when the client was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the client
  """
  id: uuid
  """
  Client company name
  """
  name: String
  """
  Timestamp when the client was last updated
  """
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "clients"
"""
input clients_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: clients_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input clients_stream_cursor_value_input {
  """
  Whether the client is currently active
  """
  active: Boolean
  """
  Email address for the client contact
  """
  contactEmail: String
  """
  Primary contact person at the client
  """
  contactPerson: String
  """
  Phone number for the client contact
  """
  contactPhone: String
  """
  Timestamp when the client was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the client
  """
  id: uuid
  """
  Client company name
  """
  name: String
  """
  Timestamp when the client was last updated
  """
  updatedAt: timestamptz
}

"""
update columns of table "clients"
"""
enum clients_update_column {
  """
  column name
  """
  active
  """
  column name
  """
  contactEmail
  """
  column name
  """
  contactPerson
  """
  column name
  """
  contactPhone
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updatedAt
}

input clients_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: clients_set_input
  """
  filter the rows which have to be updated
  """
  where: clients_bool_exp!
}

input create_payroll_version_args {
  p_created_by_user_id: uuid
  p_go_live_date: date
  p_new_backup_consultant_user_id: uuid
  p_new_client_id: uuid
  p_new_cycle_id: uuid
  p_new_date_type_id: uuid
  p_new_date_value: Int
  p_new_manager_user_id: uuid
  p_new_name: String
  p_new_primary_consultant_user_id: uuid
  p_original_payroll_id: uuid
  p_version_reason: String
}

input create_payroll_version_simple_args {
  payroll_id: uuid
  version_reason: String
}

"""
columns and relationships of "current_payrolls"
"""
type current_payrolls {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""
aggregated selection of "current_payrolls"
"""
type current_payrolls_aggregate {
  aggregate: current_payrolls_aggregate_fields
  nodes: [current_payrolls!]!
}

"""
aggregate fields of "current_payrolls"
"""
type current_payrolls_aggregate_fields {
  avg: current_payrolls_avg_fields
  count(columns: [current_payrolls_select_column!], distinct: Boolean): Int!
  max: current_payrolls_max_fields
  min: current_payrolls_min_fields
  stddev: current_payrolls_stddev_fields
  stddev_pop: current_payrolls_stddev_pop_fields
  stddev_samp: current_payrolls_stddev_samp_fields
  sum: current_payrolls_sum_fields
  var_pop: current_payrolls_var_pop_fields
  var_samp: current_payrolls_var_samp_fields
  variance: current_payrolls_variance_fields
}

"""
aggregate avg on columns
"""
type current_payrolls_avg_fields {
  date_value: Float
  version_number: Float
}

"""
Boolean expression to filter rows from the table "current_payrolls". All fields are combined with a logical 'AND'.
"""
input current_payrolls_bool_exp {
  _and: [current_payrolls_bool_exp!]
  _not: current_payrolls_bool_exp
  _or: [current_payrolls_bool_exp!]
  backup_consultant_user_id: uuid_comparison_exp
  client_id: uuid_comparison_exp
  client_name: String_comparison_exp
  created_at: timestamptz_comparison_exp
  cycle_id: uuid_comparison_exp
  date_type_id: uuid_comparison_exp
  date_value: Int_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  manager_user_id: uuid_comparison_exp
  name: String_comparison_exp
  parent_payroll_id: uuid_comparison_exp
  payroll_cycle_name: payroll_cycle_type_comparison_exp
  payroll_date_type_name: payroll_date_type_comparison_exp
  primary_consultant_user_id: uuid_comparison_exp
  superseded_date: date_comparison_exp
  updated_at: timestamptz_comparison_exp
  version_number: Int_comparison_exp
  version_reason: String_comparison_exp
}

"""
aggregate max on columns
"""
type current_payrolls_max_fields {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""
aggregate min on columns
"""
type current_payrolls_min_fields {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""
Ordering options when selecting data from "current_payrolls".
"""
input current_payrolls_order_by {
  backup_consultant_user_id: order_by
  client_id: order_by
  client_name: order_by
  created_at: order_by
  cycle_id: order_by
  date_type_id: order_by
  date_value: order_by
  go_live_date: order_by
  id: order_by
  manager_user_id: order_by
  name: order_by
  parent_payroll_id: order_by
  payroll_cycle_name: order_by
  payroll_date_type_name: order_by
  primary_consultant_user_id: order_by
  superseded_date: order_by
  updated_at: order_by
  version_number: order_by
  version_reason: order_by
}

"""
select columns of table "current_payrolls"
"""
enum current_payrolls_select_column {
  """
  column name
  """
  backup_consultant_user_id
  """
  column name
  """
  client_id
  """
  column name
  """
  client_name
  """
  column name
  """
  created_at
  """
  column name
  """
  cycle_id
  """
  column name
  """
  date_type_id
  """
  column name
  """
  date_value
  """
  column name
  """
  go_live_date
  """
  column name
  """
  id
  """
  column name
  """
  manager_user_id
  """
  column name
  """
  name
  """
  column name
  """
  parent_payroll_id
  """
  column name
  """
  payroll_cycle_name
  """
  column name
  """
  payroll_date_type_name
  """
  column name
  """
  primary_consultant_user_id
  """
  column name
  """
  superseded_date
  """
  column name
  """
  updated_at
  """
  column name
  """
  version_number
  """
  column name
  """
  version_reason
}

"""
aggregate stddev on columns
"""
type current_payrolls_stddev_fields {
  date_value: Float
  version_number: Float
}

"""
aggregate stddev_pop on columns
"""
type current_payrolls_stddev_pop_fields {
  date_value: Float
  version_number: Float
}

"""
aggregate stddev_samp on columns
"""
type current_payrolls_stddev_samp_fields {
  date_value: Float
  version_number: Float
}

"""
Streaming cursor of the table "current_payrolls"
"""
input current_payrolls_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: current_payrolls_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input current_payrolls_stream_cursor_value_input {
  backup_consultant_user_id: uuid
  client_id: uuid
  client_name: String
  created_at: timestamptz
  cycle_id: uuid
  date_type_id: uuid
  date_value: Int
  go_live_date: date
  id: uuid
  manager_user_id: uuid
  name: String
  parent_payroll_id: uuid
  payroll_cycle_name: payroll_cycle_type
  payroll_date_type_name: payroll_date_type
  primary_consultant_user_id: uuid
  superseded_date: date
  updated_at: timestamptz
  version_number: Int
  version_reason: String
}

"""
aggregate sum on columns
"""
type current_payrolls_sum_fields {
  date_value: Int
  version_number: Int
}

"""
aggregate var_pop on columns
"""
type current_payrolls_var_pop_fields {
  date_value: Float
  version_number: Float
}

"""
aggregate var_samp on columns
"""
type current_payrolls_var_samp_fields {
  date_value: Float
  version_number: Float
}

"""
aggregate variance on columns
"""
type current_payrolls_variance_fields {
  date_value: Float
  version_number: Float
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC
  """
  descending ordering of the cursor
  """
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "external_systems"
"""
type external_systems {
  """
  An array relationship
  """
  client_external_systems(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!
  """
  An aggregate relationship
  """
  client_external_systems_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!
  """
  Timestamp when the system was created
  """
  created_at: timestamptz
  """
  Description of the external system and its purpose
  """
  description: String
  """
  Path or reference to the system icon
  """
  icon: String
  """
  Unique identifier for the external system
  """
  id: uuid!
  """
  Name of the external system
  """
  name: String!
  """
  Timestamp when the system was last updated
  """
  updated_at: timestamptz
  """
  URL endpoint for the external system
  """
  url: String!
}

"""
aggregated selection of "external_systems"
"""
type external_systems_aggregate {
  aggregate: external_systems_aggregate_fields
  nodes: [external_systems!]!
}

"""
aggregate fields of "external_systems"
"""
type external_systems_aggregate_fields {
  count(columns: [external_systems_select_column!], distinct: Boolean): Int!
  max: external_systems_max_fields
  min: external_systems_min_fields
}

"""
Boolean expression to filter rows from the table "external_systems". All fields are combined with a logical 'AND'.
"""
input external_systems_bool_exp {
  _and: [external_systems_bool_exp!]
  _not: external_systems_bool_exp
  _or: [external_systems_bool_exp!]
  client_external_systems: client_external_systems_bool_exp
  client_external_systems_aggregate: client_external_systems_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  icon: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  url: String_comparison_exp
}

"""
unique or primary key constraints on table "external_systems"
"""
enum external_systems_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  external_systems_pkey
}

"""
input type for inserting data into table "external_systems"
"""
input external_systems_insert_input {
  client_external_systems: client_external_systems_arr_rel_insert_input
  """
  Timestamp when the system was created
  """
  created_at: timestamptz
  """
  Description of the external system and its purpose
  """
  description: String
  """
  Path or reference to the system icon
  """
  icon: String
  """
  Unique identifier for the external system
  """
  id: uuid
  """
  Name of the external system
  """
  name: String
  """
  Timestamp when the system was last updated
  """
  updated_at: timestamptz
  """
  URL endpoint for the external system
  """
  url: String
}

"""
aggregate max on columns
"""
type external_systems_max_fields {
  """
  Timestamp when the system was created
  """
  created_at: timestamptz
  """
  Description of the external system and its purpose
  """
  description: String
  """
  Path or reference to the system icon
  """
  icon: String
  """
  Unique identifier for the external system
  """
  id: uuid
  """
  Name of the external system
  """
  name: String
  """
  Timestamp when the system was last updated
  """
  updated_at: timestamptz
  """
  URL endpoint for the external system
  """
  url: String
}

"""
aggregate min on columns
"""
type external_systems_min_fields {
  """
  Timestamp when the system was created
  """
  created_at: timestamptz
  """
  Description of the external system and its purpose
  """
  description: String
  """
  Path or reference to the system icon
  """
  icon: String
  """
  Unique identifier for the external system
  """
  id: uuid
  """
  Name of the external system
  """
  name: String
  """
  Timestamp when the system was last updated
  """
  updated_at: timestamptz
  """
  URL endpoint for the external system
  """
  url: String
}

"""
response of any mutation on the table "external_systems"
"""
type external_systems_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [external_systems!]!
}

"""
input type for inserting object relation for remote table "external_systems"
"""
input external_systems_obj_rel_insert_input {
  data: external_systems_insert_input!
  """
  upsert condition
  """
  on_conflict: external_systems_on_conflict
}

"""
on_conflict condition type for table "external_systems"
"""
input external_systems_on_conflict {
  constraint: external_systems_constraint!
  update_columns: [external_systems_update_column!]! = []
  where: external_systems_bool_exp
}

"""
Ordering options when selecting data from "external_systems".
"""
input external_systems_order_by {
  client_external_systems_aggregate: client_external_systems_aggregate_order_by
  created_at: order_by
  description: order_by
  icon: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  url: order_by
}

"""
primary key columns input for table: external_systems
"""
input external_systems_pk_columns_input {
  """
  Unique identifier for the external system
  """
  id: uuid!
}

"""
select columns of table "external_systems"
"""
enum external_systems_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  icon
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updated_at
  """
  column name
  """
  url
}

"""
input type for updating data in table "external_systems"
"""
input external_systems_set_input {
  """
  Timestamp when the system was created
  """
  created_at: timestamptz
  """
  Description of the external system and its purpose
  """
  description: String
  """
  Path or reference to the system icon
  """
  icon: String
  """
  Unique identifier for the external system
  """
  id: uuid
  """
  Name of the external system
  """
  name: String
  """
  Timestamp when the system was last updated
  """
  updated_at: timestamptz
  """
  URL endpoint for the external system
  """
  url: String
}

"""
Streaming cursor of the table "external_systems"
"""
input external_systems_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: external_systems_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input external_systems_stream_cursor_value_input {
  """
  Timestamp when the system was created
  """
  created_at: timestamptz
  """
  Description of the external system and its purpose
  """
  description: String
  """
  Path or reference to the system icon
  """
  icon: String
  """
  Unique identifier for the external system
  """
  id: uuid
  """
  Name of the external system
  """
  name: String
  """
  Timestamp when the system was last updated
  """
  updated_at: timestamptz
  """
  URL endpoint for the external system
  """
  url: String
}

"""
update columns of table "external_systems"
"""
enum external_systems_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  icon
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updated_at
  """
  column name
  """
  url
}

input external_systems_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: external_systems_set_input
  """
  filter the rows which have to be updated
  """
  where: external_systems_bool_exp!
}

"""
columns and relationships of "feature_flags"
"""
type feature_flags {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles(
    """
    JSON select path
    """
    path: String
  ): jsonb!
  """
  Name of the feature controlled by this flag
  """
  feature_name: String!
  """
  Unique identifier for the feature flag
  """
  id: uuid!
  """
  Whether the feature is currently enabled
  """
  is_enabled: Boolean
  """
  Timestamp when the feature flag was last updated
  """
  updated_at: timestamptz
}

"""
aggregated selection of "feature_flags"
"""
type feature_flags_aggregate {
  aggregate: feature_flags_aggregate_fields
  nodes: [feature_flags!]!
}

"""
aggregate fields of "feature_flags"
"""
type feature_flags_aggregate_fields {
  count(columns: [feature_flags_select_column!], distinct: Boolean): Int!
  max: feature_flags_max_fields
  min: feature_flags_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input feature_flags_append_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: jsonb
}

"""
Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'.
"""
input feature_flags_bool_exp {
  _and: [feature_flags_bool_exp!]
  _not: feature_flags_bool_exp
  _or: [feature_flags_bool_exp!]
  allowed_roles: jsonb_comparison_exp
  feature_name: String_comparison_exp
  id: uuid_comparison_exp
  is_enabled: Boolean_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "feature_flags"
"""
enum feature_flags_constraint {
  """
  unique or primary key constraint on columns "feature_name"
  """
  feature_flags_feature_name_key
  """
  unique or primary key constraint on columns "id"
  """
  feature_flags_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input feature_flags_delete_at_path_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input feature_flags_delete_elem_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input feature_flags_delete_key_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: String
}

"""
input type for inserting data into table "feature_flags"
"""
input feature_flags_insert_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: jsonb
  """
  Name of the feature controlled by this flag
  """
  feature_name: String
  """
  Unique identifier for the feature flag
  """
  id: uuid
  """
  Whether the feature is currently enabled
  """
  is_enabled: Boolean
  """
  Timestamp when the feature flag was last updated
  """
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type feature_flags_max_fields {
  """
  Name of the feature controlled by this flag
  """
  feature_name: String
  """
  Unique identifier for the feature flag
  """
  id: uuid
  """
  Timestamp when the feature flag was last updated
  """
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type feature_flags_min_fields {
  """
  Name of the feature controlled by this flag
  """
  feature_name: String
  """
  Unique identifier for the feature flag
  """
  id: uuid
  """
  Timestamp when the feature flag was last updated
  """
  updated_at: timestamptz
}

"""
response of any mutation on the table "feature_flags"
"""
type feature_flags_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [feature_flags!]!
}

"""
on_conflict condition type for table "feature_flags"
"""
input feature_flags_on_conflict {
  constraint: feature_flags_constraint!
  update_columns: [feature_flags_update_column!]! = []
  where: feature_flags_bool_exp
}

"""
Ordering options when selecting data from "feature_flags".
"""
input feature_flags_order_by {
  allowed_roles: order_by
  feature_name: order_by
  id: order_by
  is_enabled: order_by
  updated_at: order_by
}

"""
primary key columns input for table: feature_flags
"""
input feature_flags_pk_columns_input {
  """
  Unique identifier for the feature flag
  """
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input feature_flags_prepend_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: jsonb
}

"""
select columns of table "feature_flags"
"""
enum feature_flags_select_column {
  """
  column name
  """
  allowed_roles
  """
  column name
  """
  feature_name
  """
  column name
  """
  id
  """
  column name
  """
  is_enabled
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "feature_flags"
"""
input feature_flags_set_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: jsonb
  """
  Name of the feature controlled by this flag
  """
  feature_name: String
  """
  Unique identifier for the feature flag
  """
  id: uuid
  """
  Whether the feature is currently enabled
  """
  is_enabled: Boolean
  """
  Timestamp when the feature flag was last updated
  """
  updated_at: timestamptz
}

"""
Streaming cursor of the table "feature_flags"
"""
input feature_flags_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: feature_flags_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input feature_flags_stream_cursor_value_input {
  """
  JSON array of roles that can access this feature
  """
  allowed_roles: jsonb
  """
  Name of the feature controlled by this flag
  """
  feature_name: String
  """
  Unique identifier for the feature flag
  """
  id: uuid
  """
  Whether the feature is currently enabled
  """
  is_enabled: Boolean
  """
  Timestamp when the feature flag was last updated
  """
  updated_at: timestamptz
}

"""
update columns of table "feature_flags"
"""
enum feature_flags_update_column {
  """
  column name
  """
  allowed_roles
  """
  column name
  """
  feature_name
  """
  column name
  """
  id
  """
  column name
  """
  is_enabled
  """
  column name
  """
  updated_at
}

input feature_flags_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: feature_flags_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: feature_flags_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: feature_flags_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: feature_flags_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: feature_flags_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: feature_flags_set_input
  """
  filter the rows which have to be updated
  """
  where: feature_flags_bool_exp!
}

input generate_payroll_dates_args {
  p_end_date: date
  p_max_dates: Int
  p_payroll_id: uuid
  p_start_date: date
}

input get_latest_payroll_version_args {
  payroll_id: uuid
}

input get_payroll_version_history_args {
  payroll_id: uuid
}

"""
columns and relationships of "holidays"
"""
type holidays {
  """
  ISO country code where the holiday is observed
  """
  country_code: bpchar!
  """
  Timestamp when the holiday record was created
  """
  created_at: timestamptz
  """
  Date of the holiday
  """
  date: date!
  """
  Unique identifier for the holiday
  """
  id: uuid!
  """
  Whether the holiday occurs on the same date each year
  """
  is_fixed: Boolean
  """
  Whether the holiday is observed globally
  """
  is_global: Boolean
  """
  First year when the holiday was observed
  """
  launch_year: Int
  """
  Name of the holiday in local language
  """
  local_name: String!
  """
  Name of the holiday in English
  """
  name: String!
  """
  Array of regions within the country where the holiday applies
  """
  region: [String!]
  """
  Array of holiday types (e.g., public, bank, religious)
  """
  types: [String!]!
  """
  Timestamp when the holiday record was last updated
  """
  updated_at: timestamptz
}

"""
aggregated selection of "holidays"
"""
type holidays_aggregate {
  aggregate: holidays_aggregate_fields
  nodes: [holidays!]!
}

"""
aggregate fields of "holidays"
"""
type holidays_aggregate_fields {
  avg: holidays_avg_fields
  count(columns: [holidays_select_column!], distinct: Boolean): Int!
  max: holidays_max_fields
  min: holidays_min_fields
  stddev: holidays_stddev_fields
  stddev_pop: holidays_stddev_pop_fields
  stddev_samp: holidays_stddev_samp_fields
  sum: holidays_sum_fields
  var_pop: holidays_var_pop_fields
  var_samp: holidays_var_samp_fields
  variance: holidays_variance_fields
}

"""
aggregate avg on columns
"""
type holidays_avg_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Float
}

"""
Boolean expression to filter rows from the table "holidays". All fields are combined with a logical 'AND'.
"""
input holidays_bool_exp {
  _and: [holidays_bool_exp!]
  _not: holidays_bool_exp
  _or: [holidays_bool_exp!]
  country_code: bpchar_comparison_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  id: uuid_comparison_exp
  is_fixed: Boolean_comparison_exp
  is_global: Boolean_comparison_exp
  launch_year: Int_comparison_exp
  local_name: String_comparison_exp
  name: String_comparison_exp
  region: String_array_comparison_exp
  types: String_array_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "holidays"
"""
enum holidays_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  holidays_pkey
}

"""
input type for incrementing numeric columns in table "holidays"
"""
input holidays_inc_input {
  """
  First year when the holiday was observed
  """
  launch_year: Int
}

"""
input type for inserting data into table "holidays"
"""
input holidays_insert_input {
  """
  ISO country code where the holiday is observed
  """
  country_code: bpchar
  """
  Timestamp when the holiday record was created
  """
  created_at: timestamptz
  """
  Date of the holiday
  """
  date: date
  """
  Unique identifier for the holiday
  """
  id: uuid
  """
  Whether the holiday occurs on the same date each year
  """
  is_fixed: Boolean
  """
  Whether the holiday is observed globally
  """
  is_global: Boolean
  """
  First year when the holiday was observed
  """
  launch_year: Int
  """
  Name of the holiday in local language
  """
  local_name: String
  """
  Name of the holiday in English
  """
  name: String
  """
  Array of regions within the country where the holiday applies
  """
  region: [String!]
  """
  Array of holiday types (e.g., public, bank, religious)
  """
  types: [String!]
  """
  Timestamp when the holiday record was last updated
  """
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type holidays_max_fields {
  """
  ISO country code where the holiday is observed
  """
  country_code: bpchar
  """
  Timestamp when the holiday record was created
  """
  created_at: timestamptz
  """
  Date of the holiday
  """
  date: date
  """
  Unique identifier for the holiday
  """
  id: uuid
  """
  First year when the holiday was observed
  """
  launch_year: Int
  """
  Name of the holiday in local language
  """
  local_name: String
  """
  Name of the holiday in English
  """
  name: String
  """
  Array of regions within the country where the holiday applies
  """
  region: [String!]
  """
  Array of holiday types (e.g., public, bank, religious)
  """
  types: [String!]
  """
  Timestamp when the holiday record was last updated
  """
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type holidays_min_fields {
  """
  ISO country code where the holiday is observed
  """
  country_code: bpchar
  """
  Timestamp when the holiday record was created
  """
  created_at: timestamptz
  """
  Date of the holiday
  """
  date: date
  """
  Unique identifier for the holiday
  """
  id: uuid
  """
  First year when the holiday was observed
  """
  launch_year: Int
  """
  Name of the holiday in local language
  """
  local_name: String
  """
  Name of the holiday in English
  """
  name: String
  """
  Array of regions within the country where the holiday applies
  """
  region: [String!]
  """
  Array of holiday types (e.g., public, bank, religious)
  """
  types: [String!]
  """
  Timestamp when the holiday record was last updated
  """
  updated_at: timestamptz
}

"""
response of any mutation on the table "holidays"
"""
type holidays_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [holidays!]!
}

"""
on_conflict condition type for table "holidays"
"""
input holidays_on_conflict {
  constraint: holidays_constraint!
  update_columns: [holidays_update_column!]! = []
  where: holidays_bool_exp
}

"""
Ordering options when selecting data from "holidays".
"""
input holidays_order_by {
  country_code: order_by
  created_at: order_by
  date: order_by
  id: order_by
  is_fixed: order_by
  is_global: order_by
  launch_year: order_by
  local_name: order_by
  name: order_by
  region: order_by
  types: order_by
  updated_at: order_by
}

"""
primary key columns input for table: holidays
"""
input holidays_pk_columns_input {
  """
  Unique identifier for the holiday
  """
  id: uuid!
}

"""
select columns of table "holidays"
"""
enum holidays_select_column {
  """
  column name
  """
  country_code
  """
  column name
  """
  created_at
  """
  column name
  """
  date
  """
  column name
  """
  id
  """
  column name
  """
  is_fixed
  """
  column name
  """
  is_global
  """
  column name
  """
  launch_year
  """
  column name
  """
  local_name
  """
  column name
  """
  name
  """
  column name
  """
  region
  """
  column name
  """
  types
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "holidays"
"""
input holidays_set_input {
  """
  ISO country code where the holiday is observed
  """
  country_code: bpchar
  """
  Timestamp when the holiday record was created
  """
  created_at: timestamptz
  """
  Date of the holiday
  """
  date: date
  """
  Unique identifier for the holiday
  """
  id: uuid
  """
  Whether the holiday occurs on the same date each year
  """
  is_fixed: Boolean
  """
  Whether the holiday is observed globally
  """
  is_global: Boolean
  """
  First year when the holiday was observed
  """
  launch_year: Int
  """
  Name of the holiday in local language
  """
  local_name: String
  """
  Name of the holiday in English
  """
  name: String
  """
  Array of regions within the country where the holiday applies
  """
  region: [String!]
  """
  Array of holiday types (e.g., public, bank, religious)
  """
  types: [String!]
  """
  Timestamp when the holiday record was last updated
  """
  updated_at: timestamptz
}

"""
aggregate stddev on columns
"""
type holidays_stddev_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Float
}

"""
aggregate stddev_pop on columns
"""
type holidays_stddev_pop_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Float
}

"""
aggregate stddev_samp on columns
"""
type holidays_stddev_samp_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Float
}

"""
Streaming cursor of the table "holidays"
"""
input holidays_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: holidays_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input holidays_stream_cursor_value_input {
  """
  ISO country code where the holiday is observed
  """
  country_code: bpchar
  """
  Timestamp when the holiday record was created
  """
  created_at: timestamptz
  """
  Date of the holiday
  """
  date: date
  """
  Unique identifier for the holiday
  """
  id: uuid
  """
  Whether the holiday occurs on the same date each year
  """
  is_fixed: Boolean
  """
  Whether the holiday is observed globally
  """
  is_global: Boolean
  """
  First year when the holiday was observed
  """
  launch_year: Int
  """
  Name of the holiday in local language
  """
  local_name: String
  """
  Name of the holiday in English
  """
  name: String
  """
  Array of regions within the country where the holiday applies
  """
  region: [String!]
  """
  Array of holiday types (e.g., public, bank, religious)
  """
  types: [String!]
  """
  Timestamp when the holiday record was last updated
  """
  updated_at: timestamptz
}

"""
aggregate sum on columns
"""
type holidays_sum_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Int
}

"""
update columns of table "holidays"
"""
enum holidays_update_column {
  """
  column name
  """
  country_code
  """
  column name
  """
  created_at
  """
  column name
  """
  date
  """
  column name
  """
  id
  """
  column name
  """
  is_fixed
  """
  column name
  """
  is_global
  """
  column name
  """
  launch_year
  """
  column name
  """
  local_name
  """
  column name
  """
  name
  """
  column name
  """
  region
  """
  column name
  """
  types
  """
  column name
  """
  updated_at
}

input holidays_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: holidays_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: holidays_set_input
  """
  filter the rows which have to be updated
  """
  where: holidays_bool_exp!
}

"""
aggregate var_pop on columns
"""
type holidays_var_pop_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Float
}

"""
aggregate var_samp on columns
"""
type holidays_var_samp_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Float
}

"""
aggregate variance on columns
"""
type holidays_variance_fields {
  """
  First year when the holiday was observed
  """
  launch_year: Float
}

scalar inet

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input inet_comparison_exp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _is_null: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

scalar interval

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input interval_comparison_exp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _is_null: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

scalar json

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb
  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  """
  does the string exist as a top-level key in the column
  """
  _has_key: String
  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]
  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "latest_payroll_version_results"
"""
type latest_payroll_version_results {
  active: Boolean!
  go_live_date: date
  id: uuid!
  name: String!
  payroll_id: uuid!
  queried_at: timestamptz
  version_number: Int!
}

type latest_payroll_version_results_aggregate {
  aggregate: latest_payroll_version_results_aggregate_fields
  nodes: [latest_payroll_version_results!]!
}

"""
aggregate fields of "latest_payroll_version_results"
"""
type latest_payroll_version_results_aggregate_fields {
  avg: latest_payroll_version_results_avg_fields
  count(
    columns: [latest_payroll_version_results_select_column!]
    distinct: Boolean
  ): Int!
  max: latest_payroll_version_results_max_fields
  min: latest_payroll_version_results_min_fields
  stddev: latest_payroll_version_results_stddev_fields
  stddev_pop: latest_payroll_version_results_stddev_pop_fields
  stddev_samp: latest_payroll_version_results_stddev_samp_fields
  sum: latest_payroll_version_results_sum_fields
  var_pop: latest_payroll_version_results_var_pop_fields
  var_samp: latest_payroll_version_results_var_samp_fields
  variance: latest_payroll_version_results_variance_fields
}

"""
aggregate avg on columns
"""
type latest_payroll_version_results_avg_fields {
  version_number: Float
}

"""
Boolean expression to filter rows from the table "latest_payroll_version_results". All fields are combined with a logical 'AND'.
"""
input latest_payroll_version_results_bool_exp {
  _and: [latest_payroll_version_results_bool_exp!]
  _not: latest_payroll_version_results_bool_exp
  _or: [latest_payroll_version_results_bool_exp!]
  active: Boolean_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  payroll_id: uuid_comparison_exp
  queried_at: timestamptz_comparison_exp
  version_number: Int_comparison_exp
}

"""
unique or primary key constraints on table "latest_payroll_version_results"
"""
enum latest_payroll_version_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  latest_payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "latest_payroll_version_results"
"""
input latest_payroll_version_results_inc_input {
  version_number: Int
}

"""
input type for inserting data into table "latest_payroll_version_results"
"""
input latest_payroll_version_results_insert_input {
  active: Boolean
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""
aggregate max on columns
"""
type latest_payroll_version_results_max_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""
aggregate min on columns
"""
type latest_payroll_version_results_min_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""
response of any mutation on the table "latest_payroll_version_results"
"""
type latest_payroll_version_results_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [latest_payroll_version_results!]!
}

"""
on_conflict condition type for table "latest_payroll_version_results"
"""
input latest_payroll_version_results_on_conflict {
  constraint: latest_payroll_version_results_constraint!
  update_columns: [latest_payroll_version_results_update_column!]! = []
  where: latest_payroll_version_results_bool_exp
}

"""
Ordering options when selecting data from "latest_payroll_version_results".
"""
input latest_payroll_version_results_order_by {
  active: order_by
  go_live_date: order_by
  id: order_by
  name: order_by
  payroll_id: order_by
  queried_at: order_by
  version_number: order_by
}

"""
primary key columns input for table: latest_payroll_version_results
"""
input latest_payroll_version_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "latest_payroll_version_results"
"""
enum latest_payroll_version_results_select_column {
  """
  column name
  """
  active
  """
  column name
  """
  go_live_date
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  payroll_id
  """
  column name
  """
  queried_at
  """
  column name
  """
  version_number
}

"""
input type for updating data in table "latest_payroll_version_results"
"""
input latest_payroll_version_results_set_input {
  active: Boolean
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""
aggregate stddev on columns
"""
type latest_payroll_version_results_stddev_fields {
  version_number: Float
}

"""
aggregate stddev_pop on columns
"""
type latest_payroll_version_results_stddev_pop_fields {
  version_number: Float
}

"""
aggregate stddev_samp on columns
"""
type latest_payroll_version_results_stddev_samp_fields {
  version_number: Float
}

"""
Streaming cursor of the table "latest_payroll_version_results"
"""
input latest_payroll_version_results_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: latest_payroll_version_results_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input latest_payroll_version_results_stream_cursor_value_input {
  active: Boolean
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  version_number: Int
}

"""
aggregate sum on columns
"""
type latest_payroll_version_results_sum_fields {
  version_number: Int
}

"""
update columns of table "latest_payroll_version_results"
"""
enum latest_payroll_version_results_update_column {
  """
  column name
  """
  active
  """
  column name
  """
  go_live_date
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  payroll_id
  """
  column name
  """
  queried_at
  """
  column name
  """
  version_number
}

input latest_payroll_version_results_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: latest_payroll_version_results_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: latest_payroll_version_results_set_input
  """
  filter the rows which have to be updated
  """
  where: latest_payroll_version_results_bool_exp!
}

"""
aggregate var_pop on columns
"""
type latest_payroll_version_results_var_pop_fields {
  version_number: Float
}

"""
aggregate var_samp on columns
"""
type latest_payroll_version_results_var_samp_fields {
  version_number: Float
}

"""
aggregate variance on columns
"""
type latest_payroll_version_results_variance_fields {
  version_number: Float
}

"""
columns and relationships of "leave"
"""
type leave {
  """
  Last day of the leave period
  """
  endDate: date!
  """
  Unique identifier for the leave record
  """
  id: uuid!
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: String!
  """
  An object relationship
  """
  leave_user: users!
  """
  Reason provided for the leave request
  """
  reason: String
  """
  First day of the leave period
  """
  startDate: date!
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: leave_status_enum
  """
  An object relationship
  """
  user: users!
  """
  Reference to the user taking leave
  """
  userId: uuid!
}

"""
aggregated selection of "leave"
"""
type leave_aggregate {
  aggregate: leave_aggregate_fields
  nodes: [leave!]!
}

input leave_aggregate_bool_exp {
  count: leave_aggregate_bool_exp_count
}

input leave_aggregate_bool_exp_count {
  arguments: [leave_select_column!]
  distinct: Boolean
  filter: leave_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "leave"
"""
type leave_aggregate_fields {
  count(columns: [leave_select_column!], distinct: Boolean): Int!
  max: leave_max_fields
  min: leave_min_fields
}

"""
order by aggregate values of table "leave"
"""
input leave_aggregate_order_by {
  count: order_by
  max: leave_max_order_by
  min: leave_min_order_by
}

"""
input type for inserting array relation for remote table "leave"
"""
input leave_arr_rel_insert_input {
  data: [leave_insert_input!]!
  """
  upsert condition
  """
  on_conflict: leave_on_conflict
}

"""
Boolean expression to filter rows from the table "leave". All fields are combined with a logical 'AND'.
"""
input leave_bool_exp {
  _and: [leave_bool_exp!]
  _not: leave_bool_exp
  _or: [leave_bool_exp!]
  endDate: date_comparison_exp
  id: uuid_comparison_exp
  leaveType: String_comparison_exp
  leave_user: users_bool_exp
  reason: String_comparison_exp
  startDate: date_comparison_exp
  status: leave_status_enum_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "leave"
"""
enum leave_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_pkey
}

"""
input type for inserting data into table "leave"
"""
input leave_insert_input {
  """
  Last day of the leave period
  """
  endDate: date
  """
  Unique identifier for the leave record
  """
  id: uuid
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: String
  leave_user: users_obj_rel_insert_input
  """
  Reason provided for the leave request
  """
  reason: String
  """
  First day of the leave period
  """
  startDate: date
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: leave_status_enum
  user: users_obj_rel_insert_input
  """
  Reference to the user taking leave
  """
  userId: uuid
}

"""
aggregate max on columns
"""
type leave_max_fields {
  """
  Last day of the leave period
  """
  endDate: date
  """
  Unique identifier for the leave record
  """
  id: uuid
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: String
  """
  Reason provided for the leave request
  """
  reason: String
  """
  First day of the leave period
  """
  startDate: date
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: leave_status_enum
  """
  Reference to the user taking leave
  """
  userId: uuid
}

"""
order by max() on columns of table "leave"
"""
input leave_max_order_by {
  """
  Last day of the leave period
  """
  endDate: order_by
  """
  Unique identifier for the leave record
  """
  id: order_by
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: order_by
  """
  Reason provided for the leave request
  """
  reason: order_by
  """
  First day of the leave period
  """
  startDate: order_by
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: order_by
  """
  Reference to the user taking leave
  """
  userId: order_by
}

"""
aggregate min on columns
"""
type leave_min_fields {
  """
  Last day of the leave period
  """
  endDate: date
  """
  Unique identifier for the leave record
  """
  id: uuid
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: String
  """
  Reason provided for the leave request
  """
  reason: String
  """
  First day of the leave period
  """
  startDate: date
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: leave_status_enum
  """
  Reference to the user taking leave
  """
  userId: uuid
}

"""
order by min() on columns of table "leave"
"""
input leave_min_order_by {
  """
  Last day of the leave period
  """
  endDate: order_by
  """
  Unique identifier for the leave record
  """
  id: order_by
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: order_by
  """
  Reason provided for the leave request
  """
  reason: order_by
  """
  First day of the leave period
  """
  startDate: order_by
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: order_by
  """
  Reference to the user taking leave
  """
  userId: order_by
}

"""
response of any mutation on the table "leave"
"""
type leave_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [leave!]!
}

"""
on_conflict condition type for table "leave"
"""
input leave_on_conflict {
  constraint: leave_constraint!
  update_columns: [leave_update_column!]! = []
  where: leave_bool_exp
}

"""
Ordering options when selecting data from "leave".
"""
input leave_order_by {
  endDate: order_by
  id: order_by
  leaveType: order_by
  leave_user: users_order_by
  reason: order_by
  startDate: order_by
  status: order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: leave
"""
input leave_pk_columns_input {
  """
  Unique identifier for the leave record
  """
  id: uuid!
}

"""
select columns of table "leave"
"""
enum leave_select_column {
  """
  column name
  """
  endDate
  """
  column name
  """
  id
  """
  column name
  """
  leaveType
  """
  column name
  """
  reason
  """
  column name
  """
  startDate
  """
  column name
  """
  status
  """
  column name
  """
  userId
}

"""
input type for updating data in table "leave"
"""
input leave_set_input {
  """
  Last day of the leave period
  """
  endDate: date
  """
  Unique identifier for the leave record
  """
  id: uuid
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: String
  """
  Reason provided for the leave request
  """
  reason: String
  """
  First day of the leave period
  """
  startDate: date
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: leave_status_enum
  """
  Reference to the user taking leave
  """
  userId: uuid
}

scalar leave_status_enum

"""
Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'.
"""
input leave_status_enum_comparison_exp {
  _eq: leave_status_enum
  _gt: leave_status_enum
  _gte: leave_status_enum
  _in: [leave_status_enum!]
  _is_null: Boolean
  _lt: leave_status_enum
  _lte: leave_status_enum
  _neq: leave_status_enum
  _nin: [leave_status_enum!]
}

"""
Streaming cursor of the table "leave"
"""
input leave_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: leave_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input leave_stream_cursor_value_input {
  """
  Last day of the leave period
  """
  endDate: date
  """
  Unique identifier for the leave record
  """
  id: uuid
  """
  Type of leave (vacation, sick, personal, etc.)
  """
  leaveType: String
  """
  Reason provided for the leave request
  """
  reason: String
  """
  First day of the leave period
  """
  startDate: date
  """
  Current status of the leave request (Pending, Approved, Denied)
  """
  status: leave_status_enum
  """
  Reference to the user taking leave
  """
  userId: uuid
}

"""
update columns of table "leave"
"""
enum leave_update_column {
  """
  column name
  """
  endDate
  """
  column name
  """
  id
  """
  column name
  """
  leaveType
  """
  column name
  """
  reason
  """
  column name
  """
  startDate
  """
  column name
  """
  status
  """
  column name
  """
  userId
}

input leave_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: leave_set_input
  """
  filter the rows which have to be updated
  """
  where: leave_bool_exp!
}

"""
mutation root
"""
type mutation_root {
  """
  Check for suspicious activity patterns
  """
  checkSuspiciousActivity(
    timeWindow: Int
    userId: String
  ): SuspiciousActivityResponse
  commitPayrollAssignments(
    changes: [PayrollAssignmentInput!]!
  ): CommitPayrollAssignmentsOutput
  """
  delete single row from the table: "audit.audit_log"
  """
  deleteAuditLog(id: uuid!): audit_audit_log
  """
  delete data from the table: "audit.audit_log"
  """
  deleteAuditLogs(
    """
    filter the rows which have to be deleted
    """
    where: audit_audit_log_bool_exp!
  ): audit_audit_log_mutation_response
  """
  delete single row from the table: "audit.auth_events"
  """
  deleteAuthEvent(id: uuid!): audit_auth_events
  """
  delete data from the table: "audit.auth_events"
  """
  deleteAuthEvents(
    """
    filter the rows which have to be deleted
    """
    where: audit_auth_events_bool_exp!
  ): audit_auth_events_mutation_response
  """
  delete single row from the table: "clients"
  """
  deleteClient(
    """
    Unique identifier for the client
    """
    id: uuid!
  ): clients
  """
  delete data from the table: "clients"
  """
  deleteClients(
    """
    filter the rows which have to be deleted
    """
    where: clients_bool_exp!
  ): clients_mutation_response
  """
  delete single row from the table: "audit.data_access_log"
  """
  deleteDataAccessLog(id: uuid!): audit_data_access_log
  """
  delete data from the table: "audit.data_access_log"
  """
  deleteDataAccessLogs(
    """
    filter the rows which have to be deleted
    """
    where: audit_data_access_log_bool_exp!
  ): audit_data_access_log_mutation_response
  """
  delete single row from the table: "leave"
  """
  deleteLeave(
    """
    Unique identifier for the leave record
    """
    id: uuid!
  ): leave
  """
  delete data from the table: "leave"
  """
  deleteLeaves(
    """
    filter the rows which have to be deleted
    """
    where: leave_bool_exp!
  ): leave_mutation_response
  """
  delete single row from the table: "payrolls"
  """
  deletePayroll(
    """
    Unique identifier for the payroll
    """
    id: uuid!
  ): payrolls
  """
  delete single row from the table: "payroll_assignments"
  """
  deletePayrollAssignment(id: uuid!): payroll_assignments
  """
  delete data from the table: "payroll_assignments"
  """
  deletePayrollAssignments(
    """
    filter the rows which have to be deleted
    """
    where: payroll_assignments_bool_exp!
  ): payroll_assignments_mutation_response
  """
  delete single row from the table: "payroll_dates"
  """
  deletePayrollDate(
    """
    Unique identifier for the payroll date
    """
    id: uuid!
  ): payroll_dates
  """
  delete data from the table: "payroll_dates"
  """
  deletePayrollDates(
    """
    filter the rows which have to be deleted
    """
    where: payroll_dates_bool_exp!
  ): payroll_dates_mutation_response
  """
  delete data from the table: "payrolls"
  """
  deletePayrolls(
    """
    filter the rows which have to be deleted
    """
    where: payrolls_bool_exp!
  ): payrolls_mutation_response
  """
  delete single row from the table: "permissions"
  """
  deletePermission(id: uuid!): permissions
  """
  delete single row from the table: "permission_audit_log"
  """
  deletePermissionAuditLog(id: uuid!): permission_audit_log
  """
  delete data from the table: "permission_audit_log"
  """
  deletePermissionAuditLogs(
    """
    filter the rows which have to be deleted
    """
    where: permission_audit_log_bool_exp!
  ): permission_audit_log_mutation_response
  """
  delete single row from the table: "audit.permission_changes"
  """
  deletePermissionChange(id: uuid!): audit_permission_changes
  """
  delete data from the table: "audit.permission_changes"
  """
  deletePermissionChanges(
    """
    filter the rows which have to be deleted
    """
    where: audit_permission_changes_bool_exp!
  ): audit_permission_changes_mutation_response
  """
  delete single row from the table: "permission_overrides"
  """
  deletePermissionOverride(id: uuid!): permission_overrides
  """
  delete data from the table: "permission_overrides"
  """
  deletePermissionOverrides(
    """
    filter the rows which have to be deleted
    """
    where: permission_overrides_bool_exp!
  ): permission_overrides_mutation_response
  """
  delete data from the table: "permissions"
  """
  deletePermissions(
    """
    filter the rows which have to be deleted
    """
    where: permissions_bool_exp!
  ): permissions_mutation_response
  """
  delete single row from the table: "resources"
  """
  deleteResource(id: uuid!): resources
  """
  delete data from the table: "resources"
  """
  deleteResources(
    """
    filter the rows which have to be deleted
    """
    where: resources_bool_exp!
  ): resources_mutation_response
  """
  delete single row from the table: "roles"
  """
  deleteRole(id: uuid!): roles
  """
  delete single row from the table: "role_permissions"
  """
  deleteRolePermission(id: uuid!): role_permissions
  """
  delete data from the table: "role_permissions"
  """
  deleteRolePermissions(
    """
    filter the rows which have to be deleted
    """
    where: role_permissions_bool_exp!
  ): role_permissions_mutation_response
  """
  delete data from the table: "roles"
  """
  deleteRoles(
    """
    filter the rows which have to be deleted
    """
    where: roles_bool_exp!
  ): roles_mutation_response
  """
  delete single row from the table: "users"
  """
  deleteUser(
    """
    Unique identifier for the user
    """
    id: uuid!
  ): users
  """
  delete single row from the table: "user_roles"
  """
  deleteUserRole(id: uuid!): user_roles
  """
  delete data from the table: "user_roles"
  """
  deleteUserRoles(
    """
    filter the rows which have to be deleted
    """
    where: user_roles_bool_exp!
  ): user_roles_mutation_response
  """
  delete data from the table: "users"
  """
  deleteUsers(
    """
    filter the rows which have to be deleted
    """
    where: users_bool_exp!
  ): users_mutation_response
  """
  delete single row from the table: "work_schedule"
  """
  deleteWorkSchedule(
    """
    Unique identifier for the work schedule entry
    """
    id: uuid!
  ): work_schedule
  """
  delete data from the table: "work_schedule"
  """
  deleteWorkSchedules(
    """
    filter the rows which have to be deleted
    """
    where: work_schedule_bool_exp!
  ): work_schedule_mutation_response
  """
  delete data from the table: "adjustment_rules"
  """
  delete_adjustment_rules(
    """
    filter the rows which have to be deleted
    """
    where: adjustment_rules_bool_exp!
  ): adjustment_rules_mutation_response
  """
  delete single row from the table: "adjustment_rules"
  """
  delete_adjustment_rules_by_pk(
    """
    Unique identifier for the adjustment rule
    """
    id: uuid!
  ): adjustment_rules
  """
  delete data from the table: "app_settings"
  """
  delete_app_settings(
    """
    filter the rows which have to be deleted
    """
    where: app_settings_bool_exp!
  ): app_settings_mutation_response
  """
  delete single row from the table: "app_settings"
  """
  delete_app_settings_by_pk(
    """
    Unique identifier for application setting
    """
    id: String!
  ): app_settings
  """
  delete data from the table: "audit.slow_queries"
  """
  delete_audit_slow_queries(
    """
    filter the rows which have to be deleted
    """
    where: audit_slow_queries_bool_exp!
  ): audit_slow_queries_mutation_response
  """
  delete single row from the table: "audit.slow_queries"
  """
  delete_audit_slow_queries_by_pk(id: uuid!): audit_slow_queries
  """
  delete data from the table: "audit.user_access_summary"
  """
  delete_audit_user_access_summary(
    """
    filter the rows which have to be deleted
    """
    where: audit_user_access_summary_bool_exp!
  ): audit_user_access_summary_mutation_response
  """
  delete data from the table: "billing_event_log"
  """
  delete_billing_event_log(
    """
    filter the rows which have to be deleted
    """
    where: billing_event_log_bool_exp!
  ): billing_event_log_mutation_response
  """
  delete single row from the table: "billing_event_log"
  """
  delete_billing_event_log_by_pk(id: uuid!): billing_event_log
  """
  delete data from the table: "billing_invoice"
  """
  delete_billing_invoice(
    """
    filter the rows which have to be deleted
    """
    where: billing_invoice_bool_exp!
  ): billing_invoice_mutation_response
  """
  delete single row from the table: "billing_invoice"
  """
  delete_billing_invoice_by_pk(id: uuid!): billing_invoice
  """
  delete data from the table: "billing_invoice_item"
  """
  delete_billing_invoice_item(
    """
    filter the rows which have to be deleted
    """
    where: billing_invoice_item_bool_exp!
  ): billing_invoice_item_mutation_response
  """
  delete single row from the table: "billing_invoice_item"
  """
  delete_billing_invoice_item_by_pk(id: uuid!): billing_invoice_item
  """
  delete data from the table: "billing_invoices"
  """
  delete_billing_invoices(
    """
    filter the rows which have to be deleted
    """
    where: billing_invoices_bool_exp!
  ): billing_invoices_mutation_response
  """
  delete single row from the table: "billing_invoices"
  """
  delete_billing_invoices_by_pk(id: uuid!): billing_invoices
  """
  delete data from the table: "billing_items"
  """
  delete_billing_items(
    """
    filter the rows which have to be deleted
    """
    where: billing_items_bool_exp!
  ): billing_items_mutation_response
  """
  delete single row from the table: "billing_items"
  """
  delete_billing_items_by_pk(id: uuid!): billing_items
  """
  delete data from the table: "billing_plan"
  """
  delete_billing_plan(
    """
    filter the rows which have to be deleted
    """
    where: billing_plan_bool_exp!
  ): billing_plan_mutation_response
  """
  delete single row from the table: "billing_plan"
  """
  delete_billing_plan_by_pk(id: uuid!): billing_plan
  """
  delete data from the table: "client_billing_assignment"
  """
  delete_client_billing_assignment(
    """
    filter the rows which have to be deleted
    """
    where: client_billing_assignment_bool_exp!
  ): client_billing_assignment_mutation_response
  """
  delete single row from the table: "client_billing_assignment"
  """
  delete_client_billing_assignment_by_pk(id: uuid!): client_billing_assignment
  """
  delete data from the table: "client_external_systems"
  """
  delete_client_external_systems(
    """
    filter the rows which have to be deleted
    """
    where: client_external_systems_bool_exp!
  ): client_external_systems_mutation_response
  """
  delete single row from the table: "client_external_systems"
  """
  delete_client_external_systems_by_pk(
    """
    Unique identifier for the client-system mapping
    """
    id: uuid!
  ): client_external_systems
  """
  delete data from the table: "external_systems"
  """
  delete_external_systems(
    """
    filter the rows which have to be deleted
    """
    where: external_systems_bool_exp!
  ): external_systems_mutation_response
  """
  delete single row from the table: "external_systems"
  """
  delete_external_systems_by_pk(
    """
    Unique identifier for the external system
    """
    id: uuid!
  ): external_systems
  """
  delete data from the table: "feature_flags"
  """
  delete_feature_flags(
    """
    filter the rows which have to be deleted
    """
    where: feature_flags_bool_exp!
  ): feature_flags_mutation_response
  """
  delete single row from the table: "feature_flags"
  """
  delete_feature_flags_by_pk(
    """
    Unique identifier for the feature flag
    """
    id: uuid!
  ): feature_flags
  """
  delete data from the table: "holidays"
  """
  delete_holidays(
    """
    filter the rows which have to be deleted
    """
    where: holidays_bool_exp!
  ): holidays_mutation_response
  """
  delete single row from the table: "holidays"
  """
  delete_holidays_by_pk(
    """
    Unique identifier for the holiday
    """
    id: uuid!
  ): holidays
  """
  delete data from the table: "latest_payroll_version_results"
  """
  delete_latest_payroll_version_results(
    """
    filter the rows which have to be deleted
    """
    where: latest_payroll_version_results_bool_exp!
  ): latest_payroll_version_results_mutation_response
  """
  delete single row from the table: "latest_payroll_version_results"
  """
  delete_latest_payroll_version_results_by_pk(
    id: uuid!
  ): latest_payroll_version_results
  """
  delete data from the table: "neon_auth.users_sync"
  """
  delete_neon_auth_users_sync(
    """
    filter the rows which have to be deleted
    """
    where: neon_auth_users_sync_bool_exp!
  ): neon_auth_users_sync_mutation_response
  """
  delete single row from the table: "neon_auth.users_sync"
  """
  delete_neon_auth_users_sync_by_pk(
    """
    Unique identifier from the authentication provider
    """
    id: String!
  ): neon_auth_users_sync
  """
  delete data from the table: "notes"
  """
  delete_notes(
    """
    filter the rows which have to be deleted
    """
    where: notes_bool_exp!
  ): notes_mutation_response
  """
  delete single row from the table: "notes"
  """
  delete_notes_by_pk(
    """
    Unique identifier for the note
    """
    id: uuid!
  ): notes
  """
  delete data from the table: "payroll_activation_results"
  """
  delete_payroll_activation_results(
    """
    filter the rows which have to be deleted
    """
    where: payroll_activation_results_bool_exp!
  ): payroll_activation_results_mutation_response
  """
  delete single row from the table: "payroll_activation_results"
  """
  delete_payroll_activation_results_by_pk(id: uuid!): payroll_activation_results
  """
  delete data from the table: "payroll_assignment_audit"
  """
  delete_payroll_assignment_audit(
    """
    filter the rows which have to be deleted
    """
    where: payroll_assignment_audit_bool_exp!
  ): payroll_assignment_audit_mutation_response
  """
  delete single row from the table: "payroll_assignment_audit"
  """
  delete_payroll_assignment_audit_by_pk(id: uuid!): payroll_assignment_audit
  """
  delete data from the table: "payroll_cycles"
  """
  delete_payroll_cycles(
    """
    filter the rows which have to be deleted
    """
    where: payroll_cycles_bool_exp!
  ): payroll_cycles_mutation_response
  """
  delete single row from the table: "payroll_cycles"
  """
  delete_payroll_cycles_by_pk(
    """
    Unique identifier for the payroll cycle
    """
    id: uuid!
  ): payroll_cycles
  """
  delete data from the table: "payroll_date_types"
  """
  delete_payroll_date_types(
    """
    filter the rows which have to be deleted
    """
    where: payroll_date_types_bool_exp!
  ): payroll_date_types_mutation_response
  """
  delete single row from the table: "payroll_date_types"
  """
  delete_payroll_date_types_by_pk(
    """
    Unique identifier for the payroll date type
    """
    id: uuid!
  ): payroll_date_types
  """
  delete data from the table: "payroll_version_history_results"
  """
  delete_payroll_version_history_results(
    """
    filter the rows which have to be deleted
    """
    where: payroll_version_history_results_bool_exp!
  ): payroll_version_history_results_mutation_response
  """
  delete single row from the table: "payroll_version_history_results"
  """
  delete_payroll_version_history_results_by_pk(
    id: uuid!
  ): payroll_version_history_results
  """
  delete data from the table: "payroll_version_results"
  """
  delete_payroll_version_results(
    """
    filter the rows which have to be deleted
    """
    where: payroll_version_results_bool_exp!
  ): payroll_version_results_mutation_response
  """
  delete single row from the table: "payroll_version_results"
  """
  delete_payroll_version_results_by_pk(id: uuid!): payroll_version_results
  """
  delete data from the table: "users_role_backup"
  """
  delete_users_role_backup(
    """
    filter the rows which have to be deleted
    """
    where: users_role_backup_bool_exp!
  ): users_role_backup_mutation_response
  """
  Generate SOC2 compliance reports
  """
  generateComplianceReport(
    input: ComplianceReportInput!
  ): ComplianceReportResponse
  """
  insert a single row into the table: "audit.audit_log"
  """
  insertAuditLog(
    """
    the row to be inserted
    """
    object: audit_audit_log_insert_input!
    """
    upsert condition
    """
    on_conflict: audit_audit_log_on_conflict
  ): audit_audit_log
  """
  insert data into the table: "audit.audit_log"
  """
  insertAuditLogs(
    """
    the rows to be inserted
    """
    objects: [audit_audit_log_insert_input!]!
    """
    upsert condition
    """
    on_conflict: audit_audit_log_on_conflict
  ): audit_audit_log_mutation_response
  """
  insert a single row into the table: "audit.auth_events"
  """
  insertAuthEvent(
    """
    the row to be inserted
    """
    object: audit_auth_events_insert_input!
    """
    upsert condition
    """
    on_conflict: audit_auth_events_on_conflict
  ): audit_auth_events
  """
  insert data into the table: "audit.auth_events"
  """
  insertAuthEvents(
    """
    the rows to be inserted
    """
    objects: [audit_auth_events_insert_input!]!
    """
    upsert condition
    """
    on_conflict: audit_auth_events_on_conflict
  ): audit_auth_events_mutation_response
  """
  insert a single row into the table: "clients"
  """
  insertClient(
    """
    the row to be inserted
    """
    object: clients_insert_input!
    """
    upsert condition
    """
    on_conflict: clients_on_conflict
  ): clients
  """
  insert data into the table: "clients"
  """
  insertClients(
    """
    the rows to be inserted
    """
    objects: [clients_insert_input!]!
    """
    upsert condition
    """
    on_conflict: clients_on_conflict
  ): clients_mutation_response
  """
  insert a single row into the table: "audit.data_access_log"
  """
  insertDataAccessLog(
    """
    the row to be inserted
    """
    object: audit_data_access_log_insert_input!
    """
    upsert condition
    """
    on_conflict: audit_data_access_log_on_conflict
  ): audit_data_access_log
  """
  insert data into the table: "audit.data_access_log"
  """
  insertDataAccessLogs(
    """
    the rows to be inserted
    """
    objects: [audit_data_access_log_insert_input!]!
    """
    upsert condition
    """
    on_conflict: audit_data_access_log_on_conflict
  ): audit_data_access_log_mutation_response
  """
  insert a single row into the table: "leave"
  """
  insertLeave(
    """
    the row to be inserted
    """
    object: leave_insert_input!
    """
    upsert condition
    """
    on_conflict: leave_on_conflict
  ): leave
  """
  insert data into the table: "leave"
  """
  insertLeaves(
    """
    the rows to be inserted
    """
    objects: [leave_insert_input!]!
    """
    upsert condition
    """
    on_conflict: leave_on_conflict
  ): leave_mutation_response
  """
  insert a single row into the table: "payrolls"
  """
  insertPayroll(
    """
    the row to be inserted
    """
    object: payrolls_insert_input!
    """
    upsert condition
    """
    on_conflict: payrolls_on_conflict
  ): payrolls
  """
  insert a single row into the table: "payroll_assignments"
  """
  insertPayrollAssignment(
    """
    the row to be inserted
    """
    object: payroll_assignments_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_assignments_on_conflict
  ): payroll_assignments
  """
  insert data into the table: "payroll_assignments"
  """
  insertPayrollAssignments(
    """
    the rows to be inserted
    """
    objects: [payroll_assignments_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_assignments_on_conflict
  ): payroll_assignments_mutation_response
  """
  insert a single row into the table: "payroll_dates"
  """
  insertPayrollDate(
    """
    the row to be inserted
    """
    object: payroll_dates_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_dates_on_conflict
  ): payroll_dates
  """
  insert data into the table: "payroll_dates"
  """
  insertPayrollDates(
    """
    the rows to be inserted
    """
    objects: [payroll_dates_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_dates_on_conflict
  ): payroll_dates_mutation_response
  """
  insert data into the table: "payrolls"
  """
  insertPayrolls(
    """
    the rows to be inserted
    """
    objects: [payrolls_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payrolls_on_conflict
  ): payrolls_mutation_response
  """
  insert a single row into the table: "permissions"
  """
  insertPermission(
    """
    the row to be inserted
    """
    object: permissions_insert_input!
    """
    upsert condition
    """
    on_conflict: permissions_on_conflict
  ): permissions
  """
  insert a single row into the table: "permission_audit_log"
  """
  insertPermissionAuditLog(
    """
    the row to be inserted
    """
    object: permission_audit_log_insert_input!
    """
    upsert condition
    """
    on_conflict: permission_audit_log_on_conflict
  ): permission_audit_log
  """
  insert data into the table: "permission_audit_log"
  """
  insertPermissionAuditLogs(
    """
    the rows to be inserted
    """
    objects: [permission_audit_log_insert_input!]!
    """
    upsert condition
    """
    on_conflict: permission_audit_log_on_conflict
  ): permission_audit_log_mutation_response
  """
  insert a single row into the table: "audit.permission_changes"
  """
  insertPermissionChange(
    """
    the row to be inserted
    """
    object: audit_permission_changes_insert_input!
    """
    upsert condition
    """
    on_conflict: audit_permission_changes_on_conflict
  ): audit_permission_changes
  """
  insert data into the table: "audit.permission_changes"
  """
  insertPermissionChanges(
    """
    the rows to be inserted
    """
    objects: [audit_permission_changes_insert_input!]!
    """
    upsert condition
    """
    on_conflict: audit_permission_changes_on_conflict
  ): audit_permission_changes_mutation_response
  """
  insert a single row into the table: "permission_overrides"
  """
  insertPermissionOverride(
    """
    the row to be inserted
    """
    object: permission_overrides_insert_input!
    """
    upsert condition
    """
    on_conflict: permission_overrides_on_conflict
  ): permission_overrides
  """
  insert data into the table: "permission_overrides"
  """
  insertPermissionOverrides(
    """
    the rows to be inserted
    """
    objects: [permission_overrides_insert_input!]!
    """
    upsert condition
    """
    on_conflict: permission_overrides_on_conflict
  ): permission_overrides_mutation_response
  """
  insert data into the table: "permissions"
  """
  insertPermissions(
    """
    the rows to be inserted
    """
    objects: [permissions_insert_input!]!
    """
    upsert condition
    """
    on_conflict: permissions_on_conflict
  ): permissions_mutation_response
  """
  insert a single row into the table: "resources"
  """
  insertResource(
    """
    the row to be inserted
    """
    object: resources_insert_input!
    """
    upsert condition
    """
    on_conflict: resources_on_conflict
  ): resources
  """
  insert data into the table: "resources"
  """
  insertResources(
    """
    the rows to be inserted
    """
    objects: [resources_insert_input!]!
    """
    upsert condition
    """
    on_conflict: resources_on_conflict
  ): resources_mutation_response
  """
  insert a single row into the table: "roles"
  """
  insertRole(
    """
    the row to be inserted
    """
    object: roles_insert_input!
    """
    upsert condition
    """
    on_conflict: roles_on_conflict
  ): roles
  """
  insert a single row into the table: "role_permissions"
  """
  insertRolePermission(
    """
    the row to be inserted
    """
    object: role_permissions_insert_input!
    """
    upsert condition
    """
    on_conflict: role_permissions_on_conflict
  ): role_permissions
  """
  insert data into the table: "role_permissions"
  """
  insertRolePermissions(
    """
    the rows to be inserted
    """
    objects: [role_permissions_insert_input!]!
    """
    upsert condition
    """
    on_conflict: role_permissions_on_conflict
  ): role_permissions_mutation_response
  """
  insert data into the table: "roles"
  """
  insertRoles(
    """
    the rows to be inserted
    """
    objects: [roles_insert_input!]!
    """
    upsert condition
    """
    on_conflict: roles_on_conflict
  ): roles_mutation_response
  """
  insert a single row into the table: "users"
  """
  insertUser(
    """
    the row to be inserted
    """
    object: users_insert_input!
    """
    upsert condition
    """
    on_conflict: users_on_conflict
  ): users
  """
  insert a single row into the table: "user_roles"
  """
  insertUserRole(
    """
    the row to be inserted
    """
    object: user_roles_insert_input!
    """
    upsert condition
    """
    on_conflict: user_roles_on_conflict
  ): user_roles
  """
  insert data into the table: "user_roles"
  """
  insertUserRoles(
    """
    the rows to be inserted
    """
    objects: [user_roles_insert_input!]!
    """
    upsert condition
    """
    on_conflict: user_roles_on_conflict
  ): user_roles_mutation_response
  """
  insert data into the table: "users"
  """
  insertUsers(
    """
    the rows to be inserted
    """
    objects: [users_insert_input!]!
    """
    upsert condition
    """
    on_conflict: users_on_conflict
  ): users_mutation_response
  """
  insert a single row into the table: "work_schedule"
  """
  insertWorkSchedule(
    """
    the row to be inserted
    """
    object: work_schedule_insert_input!
    """
    upsert condition
    """
    on_conflict: work_schedule_on_conflict
  ): work_schedule
  """
  insert data into the table: "work_schedule"
  """
  insertWorkSchedules(
    """
    the rows to be inserted
    """
    objects: [work_schedule_insert_input!]!
    """
    upsert condition
    """
    on_conflict: work_schedule_on_conflict
  ): work_schedule_mutation_response
  """
  insert data into the table: "adjustment_rules"
  """
  insert_adjustment_rules(
    """
    the rows to be inserted
    """
    objects: [adjustment_rules_insert_input!]!
    """
    upsert condition
    """
    on_conflict: adjustment_rules_on_conflict
  ): adjustment_rules_mutation_response
  """
  insert a single row into the table: "adjustment_rules"
  """
  insert_adjustment_rules_one(
    """
    the row to be inserted
    """
    object: adjustment_rules_insert_input!
    """
    upsert condition
    """
    on_conflict: adjustment_rules_on_conflict
  ): adjustment_rules
  """
  insert data into the table: "app_settings"
  """
  insert_app_settings(
    """
    the rows to be inserted
    """
    objects: [app_settings_insert_input!]!
    """
    upsert condition
    """
    on_conflict: app_settings_on_conflict
  ): app_settings_mutation_response
  """
  insert a single row into the table: "app_settings"
  """
  insert_app_settings_one(
    """
    the row to be inserted
    """
    object: app_settings_insert_input!
    """
    upsert condition
    """
    on_conflict: app_settings_on_conflict
  ): app_settings
  """
  insert data into the table: "audit.slow_queries"
  """
  insert_audit_slow_queries(
    """
    the rows to be inserted
    """
    objects: [audit_slow_queries_insert_input!]!
    """
    upsert condition
    """
    on_conflict: audit_slow_queries_on_conflict
  ): audit_slow_queries_mutation_response
  """
  insert a single row into the table: "audit.slow_queries"
  """
  insert_audit_slow_queries_one(
    """
    the row to be inserted
    """
    object: audit_slow_queries_insert_input!
    """
    upsert condition
    """
    on_conflict: audit_slow_queries_on_conflict
  ): audit_slow_queries
  """
  insert data into the table: "audit.user_access_summary"
  """
  insert_audit_user_access_summary(
    """
    the rows to be inserted
    """
    objects: [audit_user_access_summary_insert_input!]!
  ): audit_user_access_summary_mutation_response
  """
  insert a single row into the table: "audit.user_access_summary"
  """
  insert_audit_user_access_summary_one(
    """
    the row to be inserted
    """
    object: audit_user_access_summary_insert_input!
  ): audit_user_access_summary
  """
  insert data into the table: "billing_event_log"
  """
  insert_billing_event_log(
    """
    the rows to be inserted
    """
    objects: [billing_event_log_insert_input!]!
    """
    upsert condition
    """
    on_conflict: billing_event_log_on_conflict
  ): billing_event_log_mutation_response
  """
  insert a single row into the table: "billing_event_log"
  """
  insert_billing_event_log_one(
    """
    the row to be inserted
    """
    object: billing_event_log_insert_input!
    """
    upsert condition
    """
    on_conflict: billing_event_log_on_conflict
  ): billing_event_log
  """
  insert data into the table: "billing_invoice"
  """
  insert_billing_invoice(
    """
    the rows to be inserted
    """
    objects: [billing_invoice_insert_input!]!
    """
    upsert condition
    """
    on_conflict: billing_invoice_on_conflict
  ): billing_invoice_mutation_response
  """
  insert data into the table: "billing_invoice_item"
  """
  insert_billing_invoice_item(
    """
    the rows to be inserted
    """
    objects: [billing_invoice_item_insert_input!]!
    """
    upsert condition
    """
    on_conflict: billing_invoice_item_on_conflict
  ): billing_invoice_item_mutation_response
  """
  insert a single row into the table: "billing_invoice_item"
  """
  insert_billing_invoice_item_one(
    """
    the row to be inserted
    """
    object: billing_invoice_item_insert_input!
    """
    upsert condition
    """
    on_conflict: billing_invoice_item_on_conflict
  ): billing_invoice_item
  """
  insert a single row into the table: "billing_invoice"
  """
  insert_billing_invoice_one(
    """
    the row to be inserted
    """
    object: billing_invoice_insert_input!
    """
    upsert condition
    """
    on_conflict: billing_invoice_on_conflict
  ): billing_invoice
  """
  insert data into the table: "billing_invoices"
  """
  insert_billing_invoices(
    """
    the rows to be inserted
    """
    objects: [billing_invoices_insert_input!]!
    """
    upsert condition
    """
    on_conflict: billing_invoices_on_conflict
  ): billing_invoices_mutation_response
  """
  insert a single row into the table: "billing_invoices"
  """
  insert_billing_invoices_one(
    """
    the row to be inserted
    """
    object: billing_invoices_insert_input!
    """
    upsert condition
    """
    on_conflict: billing_invoices_on_conflict
  ): billing_invoices
  """
  insert data into the table: "billing_items"
  """
  insert_billing_items(
    """
    the rows to be inserted
    """
    objects: [billing_items_insert_input!]!
    """
    upsert condition
    """
    on_conflict: billing_items_on_conflict
  ): billing_items_mutation_response
  """
  insert a single row into the table: "billing_items"
  """
  insert_billing_items_one(
    """
    the row to be inserted
    """
    object: billing_items_insert_input!
    """
    upsert condition
    """
    on_conflict: billing_items_on_conflict
  ): billing_items
  """
  insert data into the table: "billing_plan"
  """
  insert_billing_plan(
    """
    the rows to be inserted
    """
    objects: [billing_plan_insert_input!]!
    """
    upsert condition
    """
    on_conflict: billing_plan_on_conflict
  ): billing_plan_mutation_response
  """
  insert a single row into the table: "billing_plan"
  """
  insert_billing_plan_one(
    """
    the row to be inserted
    """
    object: billing_plan_insert_input!
    """
    upsert condition
    """
    on_conflict: billing_plan_on_conflict
  ): billing_plan
  """
  insert data into the table: "client_billing_assignment"
  """
  insert_client_billing_assignment(
    """
    the rows to be inserted
    """
    objects: [client_billing_assignment_insert_input!]!
    """
    upsert condition
    """
    on_conflict: client_billing_assignment_on_conflict
  ): client_billing_assignment_mutation_response
  """
  insert a single row into the table: "client_billing_assignment"
  """
  insert_client_billing_assignment_one(
    """
    the row to be inserted
    """
    object: client_billing_assignment_insert_input!
    """
    upsert condition
    """
    on_conflict: client_billing_assignment_on_conflict
  ): client_billing_assignment
  """
  insert data into the table: "client_external_systems"
  """
  insert_client_external_systems(
    """
    the rows to be inserted
    """
    objects: [client_external_systems_insert_input!]!
    """
    upsert condition
    """
    on_conflict: client_external_systems_on_conflict
  ): client_external_systems_mutation_response
  """
  insert a single row into the table: "client_external_systems"
  """
  insert_client_external_systems_one(
    """
    the row to be inserted
    """
    object: client_external_systems_insert_input!
    """
    upsert condition
    """
    on_conflict: client_external_systems_on_conflict
  ): client_external_systems
  """
  insert data into the table: "external_systems"
  """
  insert_external_systems(
    """
    the rows to be inserted
    """
    objects: [external_systems_insert_input!]!
    """
    upsert condition
    """
    on_conflict: external_systems_on_conflict
  ): external_systems_mutation_response
  """
  insert a single row into the table: "external_systems"
  """
  insert_external_systems_one(
    """
    the row to be inserted
    """
    object: external_systems_insert_input!
    """
    upsert condition
    """
    on_conflict: external_systems_on_conflict
  ): external_systems
  """
  insert data into the table: "feature_flags"
  """
  insert_feature_flags(
    """
    the rows to be inserted
    """
    objects: [feature_flags_insert_input!]!
    """
    upsert condition
    """
    on_conflict: feature_flags_on_conflict
  ): feature_flags_mutation_response
  """
  insert a single row into the table: "feature_flags"
  """
  insert_feature_flags_one(
    """
    the row to be inserted
    """
    object: feature_flags_insert_input!
    """
    upsert condition
    """
    on_conflict: feature_flags_on_conflict
  ): feature_flags
  """
  insert data into the table: "holidays"
  """
  insert_holidays(
    """
    the rows to be inserted
    """
    objects: [holidays_insert_input!]!
    """
    upsert condition
    """
    on_conflict: holidays_on_conflict
  ): holidays_mutation_response
  """
  insert a single row into the table: "holidays"
  """
  insert_holidays_one(
    """
    the row to be inserted
    """
    object: holidays_insert_input!
    """
    upsert condition
    """
    on_conflict: holidays_on_conflict
  ): holidays
  """
  insert data into the table: "latest_payroll_version_results"
  """
  insert_latest_payroll_version_results(
    """
    the rows to be inserted
    """
    objects: [latest_payroll_version_results_insert_input!]!
    """
    upsert condition
    """
    on_conflict: latest_payroll_version_results_on_conflict
  ): latest_payroll_version_results_mutation_response
  """
  insert a single row into the table: "latest_payroll_version_results"
  """
  insert_latest_payroll_version_results_one(
    """
    the row to be inserted
    """
    object: latest_payroll_version_results_insert_input!
    """
    upsert condition
    """
    on_conflict: latest_payroll_version_results_on_conflict
  ): latest_payroll_version_results
  """
  insert data into the table: "neon_auth.users_sync"
  """
  insert_neon_auth_users_sync(
    """
    the rows to be inserted
    """
    objects: [neon_auth_users_sync_insert_input!]!
    """
    upsert condition
    """
    on_conflict: neon_auth_users_sync_on_conflict
  ): neon_auth_users_sync_mutation_response
  """
  insert a single row into the table: "neon_auth.users_sync"
  """
  insert_neon_auth_users_sync_one(
    """
    the row to be inserted
    """
    object: neon_auth_users_sync_insert_input!
    """
    upsert condition
    """
    on_conflict: neon_auth_users_sync_on_conflict
  ): neon_auth_users_sync
  """
  insert data into the table: "notes"
  """
  insert_notes(
    """
    the rows to be inserted
    """
    objects: [notes_insert_input!]!
    """
    upsert condition
    """
    on_conflict: notes_on_conflict
  ): notes_mutation_response
  """
  insert a single row into the table: "notes"
  """
  insert_notes_one(
    """
    the row to be inserted
    """
    object: notes_insert_input!
    """
    upsert condition
    """
    on_conflict: notes_on_conflict
  ): notes
  """
  insert data into the table: "payroll_activation_results"
  """
  insert_payroll_activation_results(
    """
    the rows to be inserted
    """
    objects: [payroll_activation_results_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_activation_results_on_conflict
  ): payroll_activation_results_mutation_response
  """
  insert a single row into the table: "payroll_activation_results"
  """
  insert_payroll_activation_results_one(
    """
    the row to be inserted
    """
    object: payroll_activation_results_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_activation_results_on_conflict
  ): payroll_activation_results
  """
  insert data into the table: "payroll_assignment_audit"
  """
  insert_payroll_assignment_audit(
    """
    the rows to be inserted
    """
    objects: [payroll_assignment_audit_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_assignment_audit_on_conflict
  ): payroll_assignment_audit_mutation_response
  """
  insert a single row into the table: "payroll_assignment_audit"
  """
  insert_payroll_assignment_audit_one(
    """
    the row to be inserted
    """
    object: payroll_assignment_audit_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_assignment_audit_on_conflict
  ): payroll_assignment_audit
  """
  insert data into the table: "payroll_cycles"
  """
  insert_payroll_cycles(
    """
    the rows to be inserted
    """
    objects: [payroll_cycles_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_cycles_on_conflict
  ): payroll_cycles_mutation_response
  """
  insert a single row into the table: "payroll_cycles"
  """
  insert_payroll_cycles_one(
    """
    the row to be inserted
    """
    object: payroll_cycles_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_cycles_on_conflict
  ): payroll_cycles
  """
  insert data into the table: "payroll_date_types"
  """
  insert_payroll_date_types(
    """
    the rows to be inserted
    """
    objects: [payroll_date_types_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_date_types_on_conflict
  ): payroll_date_types_mutation_response
  """
  insert a single row into the table: "payroll_date_types"
  """
  insert_payroll_date_types_one(
    """
    the row to be inserted
    """
    object: payroll_date_types_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_date_types_on_conflict
  ): payroll_date_types
  """
  insert data into the table: "payroll_version_history_results"
  """
  insert_payroll_version_history_results(
    """
    the rows to be inserted
    """
    objects: [payroll_version_history_results_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_version_history_results_on_conflict
  ): payroll_version_history_results_mutation_response
  """
  insert a single row into the table: "payroll_version_history_results"
  """
  insert_payroll_version_history_results_one(
    """
    the row to be inserted
    """
    object: payroll_version_history_results_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_version_history_results_on_conflict
  ): payroll_version_history_results
  """
  insert data into the table: "payroll_version_results"
  """
  insert_payroll_version_results(
    """
    the rows to be inserted
    """
    objects: [payroll_version_results_insert_input!]!
    """
    upsert condition
    """
    on_conflict: payroll_version_results_on_conflict
  ): payroll_version_results_mutation_response
  """
  insert a single row into the table: "payroll_version_results"
  """
  insert_payroll_version_results_one(
    """
    the row to be inserted
    """
    object: payroll_version_results_insert_input!
    """
    upsert condition
    """
    on_conflict: payroll_version_results_on_conflict
  ): payroll_version_results
  """
  insert data into the table: "users_role_backup"
  """
  insert_users_role_backup(
    """
    the rows to be inserted
    """
    objects: [users_role_backup_insert_input!]!
  ): users_role_backup_mutation_response
  """
  insert a single row into the table: "users_role_backup"
  """
  insert_users_role_backup_one(
    """
    the row to be inserted
    """
    object: users_role_backup_insert_input!
  ): users_role_backup
  """
  Log audit events for SOC2 compliance
  """
  logAuditEvent(event: AuditEventInput!): AuditEventResponse
  """
  update single row of the table: "audit.audit_log"
  """
  updateAuditLog(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_audit_log_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_audit_log_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_audit_log_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_audit_log_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_audit_log_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_audit_log_set_input
    pk_columns: audit_audit_log_pk_columns_input!
  ): audit_audit_log
  """
  update data of the table: "audit.audit_log"
  """
  updateAuditLogs(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_audit_log_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_audit_log_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_audit_log_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_audit_log_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_audit_log_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_audit_log_set_input
    """
    filter the rows which have to be updated
    """
    where: audit_audit_log_bool_exp!
  ): audit_audit_log_mutation_response
  """
  update single row of the table: "audit.auth_events"
  """
  updateAuthEvent(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_auth_events_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_auth_events_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_auth_events_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_auth_events_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_auth_events_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_auth_events_set_input
    pk_columns: audit_auth_events_pk_columns_input!
  ): audit_auth_events
  """
  update data of the table: "audit.auth_events"
  """
  updateAuthEvents(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_auth_events_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_auth_events_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_auth_events_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_auth_events_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_auth_events_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_auth_events_set_input
    """
    filter the rows which have to be updated
    """
    where: audit_auth_events_bool_exp!
  ): audit_auth_events_mutation_response
  """
  update single row of the table: "clients"
  """
  updateClient(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: clients_set_input
    pk_columns: clients_pk_columns_input!
  ): clients
  """
  update data of the table: "clients"
  """
  updateClients(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: clients_set_input
    """
    filter the rows which have to be updated
    """
    where: clients_bool_exp!
  ): clients_mutation_response
  """
  update single row of the table: "audit.data_access_log"
  """
  updateDataAccessLog(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_data_access_log_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_data_access_log_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_data_access_log_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_data_access_log_delete_key_input
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: audit_data_access_log_inc_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_data_access_log_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_data_access_log_set_input
    pk_columns: audit_data_access_log_pk_columns_input!
  ): audit_data_access_log
  """
  update data of the table: "audit.data_access_log"
  """
  updateDataAccessLogs(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_data_access_log_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_data_access_log_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_data_access_log_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_data_access_log_delete_key_input
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: audit_data_access_log_inc_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_data_access_log_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_data_access_log_set_input
    """
    filter the rows which have to be updated
    """
    where: audit_data_access_log_bool_exp!
  ): audit_data_access_log_mutation_response
  """
  update single row of the table: "leave"
  """
  updateLeave(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: leave_set_input
    pk_columns: leave_pk_columns_input!
  ): leave
  """
  update data of the table: "leave"
  """
  updateLeaves(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: leave_set_input
    """
    filter the rows which have to be updated
    """
    where: leave_bool_exp!
  ): leave_mutation_response
  """
  update single row of the table: "payrolls"
  """
  updatePayroll(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payrolls_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payrolls_set_input
    pk_columns: payrolls_pk_columns_input!
  ): payrolls
  """
  update single row of the table: "payroll_assignments"
  """
  updatePayrollAssignment(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_assignments_set_input
    pk_columns: payroll_assignments_pk_columns_input!
  ): payroll_assignments
  """
  update data of the table: "payroll_assignments"
  """
  updatePayrollAssignments(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_assignments_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_assignments_bool_exp!
  ): payroll_assignments_mutation_response
  """
  update single row of the table: "payroll_dates"
  """
  updatePayrollDate(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_dates_set_input
    pk_columns: payroll_dates_pk_columns_input!
  ): payroll_dates
  """
  update data of the table: "payroll_dates"
  """
  updatePayrollDates(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_dates_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_dates_bool_exp!
  ): payroll_dates_mutation_response
  """
  update data of the table: "payrolls"
  """
  updatePayrolls(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payrolls_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payrolls_set_input
    """
    filter the rows which have to be updated
    """
    where: payrolls_bool_exp!
  ): payrolls_mutation_response
  """
  update single row of the table: "permissions"
  """
  updatePermission(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: permissions_set_input
    pk_columns: permissions_pk_columns_input!
  ): permissions
  """
  update single row of the table: "permission_audit_log"
  """
  updatePermissionAuditLog(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: permission_audit_log_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_audit_log_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_audit_log_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_audit_log_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: permission_audit_log_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: permission_audit_log_set_input
    pk_columns: permission_audit_log_pk_columns_input!
  ): permission_audit_log
  """
  update data of the table: "permission_audit_log"
  """
  updatePermissionAuditLogs(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: permission_audit_log_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_audit_log_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_audit_log_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_audit_log_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: permission_audit_log_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: permission_audit_log_set_input
    """
    filter the rows which have to be updated
    """
    where: permission_audit_log_bool_exp!
  ): permission_audit_log_mutation_response
  """
  update single row of the table: "audit.permission_changes"
  """
  updatePermissionChange(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_permission_changes_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_permission_changes_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_permission_changes_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_permission_changes_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_permission_changes_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_permission_changes_set_input
    pk_columns: audit_permission_changes_pk_columns_input!
  ): audit_permission_changes
  """
  update data of the table: "audit.permission_changes"
  """
  updatePermissionChanges(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: audit_permission_changes_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: audit_permission_changes_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: audit_permission_changes_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: audit_permission_changes_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: audit_permission_changes_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_permission_changes_set_input
    """
    filter the rows which have to be updated
    """
    where: audit_permission_changes_bool_exp!
  ): audit_permission_changes_mutation_response
  """
  update single row of the table: "permission_overrides"
  """
  updatePermissionOverride(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: permission_overrides_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_overrides_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_overrides_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_overrides_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: permission_overrides_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: permission_overrides_set_input
    pk_columns: permission_overrides_pk_columns_input!
  ): permission_overrides
  """
  update data of the table: "permission_overrides"
  """
  updatePermissionOverrides(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: permission_overrides_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: permission_overrides_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: permission_overrides_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: permission_overrides_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: permission_overrides_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: permission_overrides_set_input
    """
    filter the rows which have to be updated
    """
    where: permission_overrides_bool_exp!
  ): permission_overrides_mutation_response
  """
  update data of the table: "permissions"
  """
  updatePermissions(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: permissions_set_input
    """
    filter the rows which have to be updated
    """
    where: permissions_bool_exp!
  ): permissions_mutation_response
  """
  update single row of the table: "resources"
  """
  updateResource(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: resources_set_input
    pk_columns: resources_pk_columns_input!
  ): resources
  """
  update data of the table: "resources"
  """
  updateResources(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: resources_set_input
    """
    filter the rows which have to be updated
    """
    where: resources_bool_exp!
  ): resources_mutation_response
  """
  update single row of the table: "roles"
  """
  updateRole(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: roles_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: roles_set_input
    pk_columns: roles_pk_columns_input!
  ): roles
  """
  update single row of the table: "role_permissions"
  """
  updateRolePermission(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: role_permissions_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: role_permissions_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: role_permissions_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: role_permissions_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: role_permissions_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: role_permissions_set_input
    pk_columns: role_permissions_pk_columns_input!
  ): role_permissions
  """
  update data of the table: "role_permissions"
  """
  updateRolePermissions(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: role_permissions_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: role_permissions_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: role_permissions_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: role_permissions_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: role_permissions_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: role_permissions_set_input
    """
    filter the rows which have to be updated
    """
    where: role_permissions_bool_exp!
  ): role_permissions_mutation_response
  """
  update data of the table: "roles"
  """
  updateRoles(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: roles_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: roles_set_input
    """
    filter the rows which have to be updated
    """
    where: roles_bool_exp!
  ): roles_mutation_response
  """
  update single row of the table: "users"
  """
  updateUser(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
  """
  update single row of the table: "user_roles"
  """
  updateUserRole(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_roles_set_input
    pk_columns: user_roles_pk_columns_input!
  ): user_roles
  """
  update data of the table: "user_roles"
  """
  updateUserRoles(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_roles_set_input
    """
    filter the rows which have to be updated
    """
    where: user_roles_bool_exp!
  ): user_roles_mutation_response
  """
  update data of the table: "users"
  """
  updateUsers(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input
    """
    filter the rows which have to be updated
    """
    where: users_bool_exp!
  ): users_mutation_response
  """
  update single row of the table: "work_schedule"
  """
  updateWorkSchedule(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: work_schedule_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: work_schedule_set_input
    pk_columns: work_schedule_pk_columns_input!
  ): work_schedule
  """
  update data of the table: "work_schedule"
  """
  updateWorkSchedules(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: work_schedule_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: work_schedule_set_input
    """
    filter the rows which have to be updated
    """
    where: work_schedule_bool_exp!
  ): work_schedule_mutation_response
  """
  update data of the table: "adjustment_rules"
  """
  update_adjustment_rules(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: adjustment_rules_set_input
    """
    filter the rows which have to be updated
    """
    where: adjustment_rules_bool_exp!
  ): adjustment_rules_mutation_response
  """
  update single row of the table: "adjustment_rules"
  """
  update_adjustment_rules_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: adjustment_rules_set_input
    pk_columns: adjustment_rules_pk_columns_input!
  ): adjustment_rules
  """
  update multiples rows of table: "adjustment_rules"
  """
  update_adjustment_rules_many(
    """
    updates to execute, in order
    """
    updates: [adjustment_rules_updates!]!
  ): [adjustment_rules_mutation_response]
  """
  update data of the table: "app_settings"
  """
  update_app_settings(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: app_settings_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: app_settings_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: app_settings_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: app_settings_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: app_settings_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: app_settings_set_input
    """
    filter the rows which have to be updated
    """
    where: app_settings_bool_exp!
  ): app_settings_mutation_response
  """
  update single row of the table: "app_settings"
  """
  update_app_settings_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: app_settings_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: app_settings_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: app_settings_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: app_settings_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: app_settings_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: app_settings_set_input
    pk_columns: app_settings_pk_columns_input!
  ): app_settings
  """
  update multiples rows of table: "app_settings"
  """
  update_app_settings_many(
    """
    updates to execute, in order
    """
    updates: [app_settings_updates!]!
  ): [app_settings_mutation_response]
  """
  update multiples rows of table: "audit.audit_log"
  """
  update_audit_audit_log_many(
    """
    updates to execute, in order
    """
    updates: [audit_audit_log_updates!]!
  ): [audit_audit_log_mutation_response]
  """
  update multiples rows of table: "audit.auth_events"
  """
  update_audit_auth_events_many(
    """
    updates to execute, in order
    """
    updates: [audit_auth_events_updates!]!
  ): [audit_auth_events_mutation_response]
  """
  update multiples rows of table: "audit.data_access_log"
  """
  update_audit_data_access_log_many(
    """
    updates to execute, in order
    """
    updates: [audit_data_access_log_updates!]!
  ): [audit_data_access_log_mutation_response]
  """
  update multiples rows of table: "audit.permission_changes"
  """
  update_audit_permission_changes_many(
    """
    updates to execute, in order
    """
    updates: [audit_permission_changes_updates!]!
  ): [audit_permission_changes_mutation_response]
  """
  update data of the table: "audit.slow_queries"
  """
  update_audit_slow_queries(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_slow_queries_set_input
    """
    filter the rows which have to be updated
    """
    where: audit_slow_queries_bool_exp!
  ): audit_slow_queries_mutation_response
  """
  update single row of the table: "audit.slow_queries"
  """
  update_audit_slow_queries_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_slow_queries_set_input
    pk_columns: audit_slow_queries_pk_columns_input!
  ): audit_slow_queries
  """
  update multiples rows of table: "audit.slow_queries"
  """
  update_audit_slow_queries_many(
    """
    updates to execute, in order
    """
    updates: [audit_slow_queries_updates!]!
  ): [audit_slow_queries_mutation_response]
  """
  update data of the table: "audit.user_access_summary"
  """
  update_audit_user_access_summary(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: audit_user_access_summary_set_input
    """
    filter the rows which have to be updated
    """
    where: audit_user_access_summary_bool_exp!
  ): audit_user_access_summary_mutation_response
  """
  update multiples rows of table: "audit.user_access_summary"
  """
  update_audit_user_access_summary_many(
    """
    updates to execute, in order
    """
    updates: [audit_user_access_summary_updates!]!
  ): [audit_user_access_summary_mutation_response]
  """
  update data of the table: "billing_event_log"
  """
  update_billing_event_log(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_event_log_set_input
    """
    filter the rows which have to be updated
    """
    where: billing_event_log_bool_exp!
  ): billing_event_log_mutation_response
  """
  update single row of the table: "billing_event_log"
  """
  update_billing_event_log_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_event_log_set_input
    pk_columns: billing_event_log_pk_columns_input!
  ): billing_event_log
  """
  update multiples rows of table: "billing_event_log"
  """
  update_billing_event_log_many(
    """
    updates to execute, in order
    """
    updates: [billing_event_log_updates!]!
  ): [billing_event_log_mutation_response]
  """
  update data of the table: "billing_invoice"
  """
  update_billing_invoice(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_invoice_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_invoice_set_input
    """
    filter the rows which have to be updated
    """
    where: billing_invoice_bool_exp!
  ): billing_invoice_mutation_response
  """
  update single row of the table: "billing_invoice"
  """
  update_billing_invoice_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_invoice_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_invoice_set_input
    pk_columns: billing_invoice_pk_columns_input!
  ): billing_invoice
  """
  update data of the table: "billing_invoice_item"
  """
  update_billing_invoice_item(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_invoice_item_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_invoice_item_set_input
    """
    filter the rows which have to be updated
    """
    where: billing_invoice_item_bool_exp!
  ): billing_invoice_item_mutation_response
  """
  update single row of the table: "billing_invoice_item"
  """
  update_billing_invoice_item_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_invoice_item_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_invoice_item_set_input
    pk_columns: billing_invoice_item_pk_columns_input!
  ): billing_invoice_item
  """
  update multiples rows of table: "billing_invoice_item"
  """
  update_billing_invoice_item_many(
    """
    updates to execute, in order
    """
    updates: [billing_invoice_item_updates!]!
  ): [billing_invoice_item_mutation_response]
  """
  update multiples rows of table: "billing_invoice"
  """
  update_billing_invoice_many(
    """
    updates to execute, in order
    """
    updates: [billing_invoice_updates!]!
  ): [billing_invoice_mutation_response]
  """
  update data of the table: "billing_invoices"
  """
  update_billing_invoices(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_invoices_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_invoices_set_input
    """
    filter the rows which have to be updated
    """
    where: billing_invoices_bool_exp!
  ): billing_invoices_mutation_response
  """
  update single row of the table: "billing_invoices"
  """
  update_billing_invoices_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_invoices_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_invoices_set_input
    pk_columns: billing_invoices_pk_columns_input!
  ): billing_invoices
  """
  update multiples rows of table: "billing_invoices"
  """
  update_billing_invoices_many(
    """
    updates to execute, in order
    """
    updates: [billing_invoices_updates!]!
  ): [billing_invoices_mutation_response]
  """
  update data of the table: "billing_items"
  """
  update_billing_items(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_items_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_items_set_input
    """
    filter the rows which have to be updated
    """
    where: billing_items_bool_exp!
  ): billing_items_mutation_response
  """
  update single row of the table: "billing_items"
  """
  update_billing_items_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_items_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_items_set_input
    pk_columns: billing_items_pk_columns_input!
  ): billing_items
  """
  update multiples rows of table: "billing_items"
  """
  update_billing_items_many(
    """
    updates to execute, in order
    """
    updates: [billing_items_updates!]!
  ): [billing_items_mutation_response]
  """
  update data of the table: "billing_plan"
  """
  update_billing_plan(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_plan_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_plan_set_input
    """
    filter the rows which have to be updated
    """
    where: billing_plan_bool_exp!
  ): billing_plan_mutation_response
  """
  update single row of the table: "billing_plan"
  """
  update_billing_plan_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: billing_plan_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: billing_plan_set_input
    pk_columns: billing_plan_pk_columns_input!
  ): billing_plan
  """
  update multiples rows of table: "billing_plan"
  """
  update_billing_plan_many(
    """
    updates to execute, in order
    """
    updates: [billing_plan_updates!]!
  ): [billing_plan_mutation_response]
  """
  update data of the table: "client_billing_assignment"
  """
  update_client_billing_assignment(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: client_billing_assignment_set_input
    """
    filter the rows which have to be updated
    """
    where: client_billing_assignment_bool_exp!
  ): client_billing_assignment_mutation_response
  """
  update single row of the table: "client_billing_assignment"
  """
  update_client_billing_assignment_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: client_billing_assignment_set_input
    pk_columns: client_billing_assignment_pk_columns_input!
  ): client_billing_assignment
  """
  update multiples rows of table: "client_billing_assignment"
  """
  update_client_billing_assignment_many(
    """
    updates to execute, in order
    """
    updates: [client_billing_assignment_updates!]!
  ): [client_billing_assignment_mutation_response]
  """
  update data of the table: "client_external_systems"
  """
  update_client_external_systems(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: client_external_systems_set_input
    """
    filter the rows which have to be updated
    """
    where: client_external_systems_bool_exp!
  ): client_external_systems_mutation_response
  """
  update single row of the table: "client_external_systems"
  """
  update_client_external_systems_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: client_external_systems_set_input
    pk_columns: client_external_systems_pk_columns_input!
  ): client_external_systems
  """
  update multiples rows of table: "client_external_systems"
  """
  update_client_external_systems_many(
    """
    updates to execute, in order
    """
    updates: [client_external_systems_updates!]!
  ): [client_external_systems_mutation_response]
  """
  update multiples rows of table: "clients"
  """
  update_clients_many(
    """
    updates to execute, in order
    """
    updates: [clients_updates!]!
  ): [clients_mutation_response]
  """
  update data of the table: "external_systems"
  """
  update_external_systems(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: external_systems_set_input
    """
    filter the rows which have to be updated
    """
    where: external_systems_bool_exp!
  ): external_systems_mutation_response
  """
  update single row of the table: "external_systems"
  """
  update_external_systems_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: external_systems_set_input
    pk_columns: external_systems_pk_columns_input!
  ): external_systems
  """
  update multiples rows of table: "external_systems"
  """
  update_external_systems_many(
    """
    updates to execute, in order
    """
    updates: [external_systems_updates!]!
  ): [external_systems_mutation_response]
  """
  update data of the table: "feature_flags"
  """
  update_feature_flags(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: feature_flags_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_flags_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_flags_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_flags_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: feature_flags_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: feature_flags_set_input
    """
    filter the rows which have to be updated
    """
    where: feature_flags_bool_exp!
  ): feature_flags_mutation_response
  """
  update single row of the table: "feature_flags"
  """
  update_feature_flags_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: feature_flags_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: feature_flags_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: feature_flags_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: feature_flags_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: feature_flags_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: feature_flags_set_input
    pk_columns: feature_flags_pk_columns_input!
  ): feature_flags
  """
  update multiples rows of table: "feature_flags"
  """
  update_feature_flags_many(
    """
    updates to execute, in order
    """
    updates: [feature_flags_updates!]!
  ): [feature_flags_mutation_response]
  """
  update data of the table: "holidays"
  """
  update_holidays(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: holidays_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: holidays_set_input
    """
    filter the rows which have to be updated
    """
    where: holidays_bool_exp!
  ): holidays_mutation_response
  """
  update single row of the table: "holidays"
  """
  update_holidays_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: holidays_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: holidays_set_input
    pk_columns: holidays_pk_columns_input!
  ): holidays
  """
  update multiples rows of table: "holidays"
  """
  update_holidays_many(
    """
    updates to execute, in order
    """
    updates: [holidays_updates!]!
  ): [holidays_mutation_response]
  """
  update data of the table: "latest_payroll_version_results"
  """
  update_latest_payroll_version_results(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: latest_payroll_version_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: latest_payroll_version_results_set_input
    """
    filter the rows which have to be updated
    """
    where: latest_payroll_version_results_bool_exp!
  ): latest_payroll_version_results_mutation_response
  """
  update single row of the table: "latest_payroll_version_results"
  """
  update_latest_payroll_version_results_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: latest_payroll_version_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: latest_payroll_version_results_set_input
    pk_columns: latest_payroll_version_results_pk_columns_input!
  ): latest_payroll_version_results
  """
  update multiples rows of table: "latest_payroll_version_results"
  """
  update_latest_payroll_version_results_many(
    """
    updates to execute, in order
    """
    updates: [latest_payroll_version_results_updates!]!
  ): [latest_payroll_version_results_mutation_response]
  """
  update multiples rows of table: "leave"
  """
  update_leave_many(
    """
    updates to execute, in order
    """
    updates: [leave_updates!]!
  ): [leave_mutation_response]
  """
  update data of the table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: neon_auth_users_sync_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: neon_auth_users_sync_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: neon_auth_users_sync_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: neon_auth_users_sync_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: neon_auth_users_sync_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: neon_auth_users_sync_set_input
    """
    filter the rows which have to be updated
    """
    where: neon_auth_users_sync_bool_exp!
  ): neon_auth_users_sync_mutation_response
  """
  update single row of the table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync_by_pk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: neon_auth_users_sync_append_input
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: neon_auth_users_sync_delete_at_path_input
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: neon_auth_users_sync_delete_elem_input
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: neon_auth_users_sync_delete_key_input
    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: neon_auth_users_sync_prepend_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: neon_auth_users_sync_set_input
    pk_columns: neon_auth_users_sync_pk_columns_input!
  ): neon_auth_users_sync
  """
  update multiples rows of table: "neon_auth.users_sync"
  """
  update_neon_auth_users_sync_many(
    """
    updates to execute, in order
    """
    updates: [neon_auth_users_sync_updates!]!
  ): [neon_auth_users_sync_mutation_response]
  """
  update data of the table: "notes"
  """
  update_notes(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: notes_set_input
    """
    filter the rows which have to be updated
    """
    where: notes_bool_exp!
  ): notes_mutation_response
  """
  update single row of the table: "notes"
  """
  update_notes_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: notes_set_input
    pk_columns: notes_pk_columns_input!
  ): notes
  """
  update multiples rows of table: "notes"
  """
  update_notes_many(
    """
    updates to execute, in order
    """
    updates: [notes_updates!]!
  ): [notes_mutation_response]
  """
  update data of the table: "payroll_activation_results"
  """
  update_payroll_activation_results(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payroll_activation_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_activation_results_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_activation_results_bool_exp!
  ): payroll_activation_results_mutation_response
  """
  update single row of the table: "payroll_activation_results"
  """
  update_payroll_activation_results_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payroll_activation_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_activation_results_set_input
    pk_columns: payroll_activation_results_pk_columns_input!
  ): payroll_activation_results
  """
  update multiples rows of table: "payroll_activation_results"
  """
  update_payroll_activation_results_many(
    """
    updates to execute, in order
    """
    updates: [payroll_activation_results_updates!]!
  ): [payroll_activation_results_mutation_response]
  """
  update data of the table: "payroll_assignment_audit"
  """
  update_payroll_assignment_audit(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_assignment_audit_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_assignment_audit_bool_exp!
  ): payroll_assignment_audit_mutation_response
  """
  update single row of the table: "payroll_assignment_audit"
  """
  update_payroll_assignment_audit_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_assignment_audit_set_input
    pk_columns: payroll_assignment_audit_pk_columns_input!
  ): payroll_assignment_audit
  """
  update multiples rows of table: "payroll_assignment_audit"
  """
  update_payroll_assignment_audit_many(
    """
    updates to execute, in order
    """
    updates: [payroll_assignment_audit_updates!]!
  ): [payroll_assignment_audit_mutation_response]
  """
  update multiples rows of table: "payroll_assignments"
  """
  update_payroll_assignments_many(
    """
    updates to execute, in order
    """
    updates: [payroll_assignments_updates!]!
  ): [payroll_assignments_mutation_response]
  """
  update data of the table: "payroll_cycles"
  """
  update_payroll_cycles(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_cycles_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_cycles_bool_exp!
  ): payroll_cycles_mutation_response
  """
  update single row of the table: "payroll_cycles"
  """
  update_payroll_cycles_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_cycles_set_input
    pk_columns: payroll_cycles_pk_columns_input!
  ): payroll_cycles
  """
  update multiples rows of table: "payroll_cycles"
  """
  update_payroll_cycles_many(
    """
    updates to execute, in order
    """
    updates: [payroll_cycles_updates!]!
  ): [payroll_cycles_mutation_response]
  """
  update data of the table: "payroll_date_types"
  """
  update_payroll_date_types(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_date_types_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_date_types_bool_exp!
  ): payroll_date_types_mutation_response
  """
  update single row of the table: "payroll_date_types"
  """
  update_payroll_date_types_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_date_types_set_input
    pk_columns: payroll_date_types_pk_columns_input!
  ): payroll_date_types
  """
  update multiples rows of table: "payroll_date_types"
  """
  update_payroll_date_types_many(
    """
    updates to execute, in order
    """
    updates: [payroll_date_types_updates!]!
  ): [payroll_date_types_mutation_response]
  """
  update multiples rows of table: "payroll_dates"
  """
  update_payroll_dates_many(
    """
    updates to execute, in order
    """
    updates: [payroll_dates_updates!]!
  ): [payroll_dates_mutation_response]
  """
  update data of the table: "payroll_version_history_results"
  """
  update_payroll_version_history_results(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payroll_version_history_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_version_history_results_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_version_history_results_bool_exp!
  ): payroll_version_history_results_mutation_response
  """
  update single row of the table: "payroll_version_history_results"
  """
  update_payroll_version_history_results_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payroll_version_history_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_version_history_results_set_input
    pk_columns: payroll_version_history_results_pk_columns_input!
  ): payroll_version_history_results
  """
  update multiples rows of table: "payroll_version_history_results"
  """
  update_payroll_version_history_results_many(
    """
    updates to execute, in order
    """
    updates: [payroll_version_history_results_updates!]!
  ): [payroll_version_history_results_mutation_response]
  """
  update data of the table: "payroll_version_results"
  """
  update_payroll_version_results(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payroll_version_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_version_results_set_input
    """
    filter the rows which have to be updated
    """
    where: payroll_version_results_bool_exp!
  ): payroll_version_results_mutation_response
  """
  update single row of the table: "payroll_version_results"
  """
  update_payroll_version_results_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: payroll_version_results_inc_input
    """
    sets the columns of the filtered rows to the given values
    """
    _set: payroll_version_results_set_input
    pk_columns: payroll_version_results_pk_columns_input!
  ): payroll_version_results
  """
  update multiples rows of table: "payroll_version_results"
  """
  update_payroll_version_results_many(
    """
    updates to execute, in order
    """
    updates: [payroll_version_results_updates!]!
  ): [payroll_version_results_mutation_response]
  """
  update multiples rows of table: "payrolls"
  """
  update_payrolls_many(
    """
    updates to execute, in order
    """
    updates: [payrolls_updates!]!
  ): [payrolls_mutation_response]
  """
  update multiples rows of table: "permission_audit_log"
  """
  update_permission_audit_log_many(
    """
    updates to execute, in order
    """
    updates: [permission_audit_log_updates!]!
  ): [permission_audit_log_mutation_response]
  """
  update multiples rows of table: "permission_overrides"
  """
  update_permission_overrides_many(
    """
    updates to execute, in order
    """
    updates: [permission_overrides_updates!]!
  ): [permission_overrides_mutation_response]
  """
  update multiples rows of table: "permissions"
  """
  update_permissions_many(
    """
    updates to execute, in order
    """
    updates: [permissions_updates!]!
  ): [permissions_mutation_response]
  """
  update multiples rows of table: "resources"
  """
  update_resources_many(
    """
    updates to execute, in order
    """
    updates: [resources_updates!]!
  ): [resources_mutation_response]
  """
  update multiples rows of table: "role_permissions"
  """
  update_role_permissions_many(
    """
    updates to execute, in order
    """
    updates: [role_permissions_updates!]!
  ): [role_permissions_mutation_response]
  """
  update multiples rows of table: "roles"
  """
  update_roles_many(
    """
    updates to execute, in order
    """
    updates: [roles_updates!]!
  ): [roles_mutation_response]
  """
  update multiples rows of table: "user_roles"
  """
  update_user_roles_many(
    """
    updates to execute, in order
    """
    updates: [user_roles_updates!]!
  ): [user_roles_mutation_response]
  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """
    updates to execute, in order
    """
    updates: [users_updates!]!
  ): [users_mutation_response]
  """
  update data of the table: "users_role_backup"
  """
  update_users_role_backup(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_role_backup_set_input
    """
    filter the rows which have to be updated
    """
    where: users_role_backup_bool_exp!
  ): users_role_backup_mutation_response
  """
  update multiples rows of table: "users_role_backup"
  """
  update_users_role_backup_many(
    """
    updates to execute, in order
    """
    updates: [users_role_backup_updates!]!
  ): [users_role_backup_mutation_response]
  """
  update multiples rows of table: "work_schedule"
  """
  update_work_schedule_many(
    """
    updates to execute, in order
    """
    updates: [work_schedule_updates!]!
  ): [work_schedule_mutation_response]
}

scalar name

"""
Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'.
"""
input name_comparison_exp {
  _eq: name
  _gt: name
  _gte: name
  _in: [name!]
  _is_null: Boolean
  _lt: name
  _lte: name
  _neq: name
  _nin: [name!]
}

"""
columns and relationships of "neon_auth.users_sync"
"""
type neon_auth_users_sync {
  """
  Timestamp when the user was created in the auth system
  """
  created_at: timestamptz
  """
  Timestamp when the user was deleted in the auth system
  """
  deleted_at: timestamptz
  """
  User's email address from authentication provider
  """
  email: String
  """
  Unique identifier from the authentication provider
  """
  id: String!
  """
  User's full name from authentication provider
  """
  name: String
  """
  Complete JSON data from the authentication provider
  """
  raw_json(
    """
    JSON select path
    """
    path: String
  ): jsonb!
  """
  Timestamp when the user was last updated in the auth system
  """
  updated_at: timestamptz
}

"""
aggregated selection of "neon_auth.users_sync"
"""
type neon_auth_users_sync_aggregate {
  aggregate: neon_auth_users_sync_aggregate_fields
  nodes: [neon_auth_users_sync!]!
}

"""
aggregate fields of "neon_auth.users_sync"
"""
type neon_auth_users_sync_aggregate_fields {
  count(columns: [neon_auth_users_sync_select_column!], distinct: Boolean): Int!
  max: neon_auth_users_sync_max_fields
  min: neon_auth_users_sync_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input neon_auth_users_sync_append_input {
  """
  Complete JSON data from the authentication provider
  """
  raw_json: jsonb
}

"""
Boolean expression to filter rows from the table "neon_auth.users_sync". All fields are combined with a logical 'AND'.
"""
input neon_auth_users_sync_bool_exp {
  _and: [neon_auth_users_sync_bool_exp!]
  _not: neon_auth_users_sync_bool_exp
  _or: [neon_auth_users_sync_bool_exp!]
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  raw_json: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_sync_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input neon_auth_users_sync_delete_at_path_input {
  """
  Complete JSON data from the authentication provider
  """
  raw_json: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input neon_auth_users_sync_delete_elem_input {
  """
  Complete JSON data from the authentication provider
  """
  raw_json: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input neon_auth_users_sync_delete_key_input {
  """
  Complete JSON data from the authentication provider
  """
  raw_json: String
}

"""
input type for inserting data into table "neon_auth.users_sync"
"""
input neon_auth_users_sync_insert_input {
  """
  Timestamp when the user was deleted in the auth system
  """
  deleted_at: timestamptz
  """
  Complete JSON data from the authentication provider
  """
  raw_json: jsonb
  """
  Timestamp when the user was last updated in the auth system
  """
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type neon_auth_users_sync_max_fields {
  """
  Timestamp when the user was created in the auth system
  """
  created_at: timestamptz
  """
  Timestamp when the user was deleted in the auth system
  """
  deleted_at: timestamptz
  """
  User's email address from authentication provider
  """
  email: String
  """
  Unique identifier from the authentication provider
  """
  id: String
  """
  User's full name from authentication provider
  """
  name: String
  """
  Timestamp when the user was last updated in the auth system
  """
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type neon_auth_users_sync_min_fields {
  """
  Timestamp when the user was created in the auth system
  """
  created_at: timestamptz
  """
  Timestamp when the user was deleted in the auth system
  """
  deleted_at: timestamptz
  """
  User's email address from authentication provider
  """
  email: String
  """
  Unique identifier from the authentication provider
  """
  id: String
  """
  User's full name from authentication provider
  """
  name: String
  """
  Timestamp when the user was last updated in the auth system
  """
  updated_at: timestamptz
}

"""
response of any mutation on the table "neon_auth.users_sync"
"""
type neon_auth_users_sync_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [neon_auth_users_sync!]!
}

"""
on_conflict condition type for table "neon_auth.users_sync"
"""
input neon_auth_users_sync_on_conflict {
  constraint: neon_auth_users_sync_constraint!
  update_columns: [neon_auth_users_sync_update_column!]! = []
  where: neon_auth_users_sync_bool_exp
}

"""
Ordering options when selecting data from "neon_auth.users_sync".
"""
input neon_auth_users_sync_order_by {
  created_at: order_by
  deleted_at: order_by
  email: order_by
  id: order_by
  name: order_by
  raw_json: order_by
  updated_at: order_by
}

"""
primary key columns input for table: neon_auth.users_sync
"""
input neon_auth_users_sync_pk_columns_input {
  """
  Unique identifier from the authentication provider
  """
  id: String!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input neon_auth_users_sync_prepend_input {
  """
  Complete JSON data from the authentication provider
  """
  raw_json: jsonb
}

"""
select columns of table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  deleted_at
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  raw_json
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "neon_auth.users_sync"
"""
input neon_auth_users_sync_set_input {
  """
  Timestamp when the user was deleted in the auth system
  """
  deleted_at: timestamptz
  """
  Complete JSON data from the authentication provider
  """
  raw_json: jsonb
  """
  Timestamp when the user was last updated in the auth system
  """
  updated_at: timestamptz
}

"""
Streaming cursor of the table "neon_auth_users_sync"
"""
input neon_auth_users_sync_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: neon_auth_users_sync_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input neon_auth_users_sync_stream_cursor_value_input {
  """
  Timestamp when the user was created in the auth system
  """
  created_at: timestamptz
  """
  Timestamp when the user was deleted in the auth system
  """
  deleted_at: timestamptz
  """
  User's email address from authentication provider
  """
  email: String
  """
  Unique identifier from the authentication provider
  """
  id: String
  """
  User's full name from authentication provider
  """
  name: String
  """
  Complete JSON data from the authentication provider
  """
  raw_json: jsonb
  """
  Timestamp when the user was last updated in the auth system
  """
  updated_at: timestamptz
}

"""
update columns of table "neon_auth.users_sync"
"""
enum neon_auth_users_sync_update_column {
  """
  column name
  """
  deleted_at
  """
  column name
  """
  raw_json
  """
  column name
  """
  updated_at
}

input neon_auth_users_sync_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: neon_auth_users_sync_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: neon_auth_users_sync_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: neon_auth_users_sync_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: neon_auth_users_sync_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: neon_auth_users_sync_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: neon_auth_users_sync_set_input
  """
  filter the rows which have to be updated
  """
  where: neon_auth_users_sync_bool_exp!
}

"""
columns and relationships of "notes"
"""
type notes {
  """
  Content of the note
  """
  content: String!
  """
  Timestamp when the note was created
  """
  created_at: timestamp
  """
  Identifier of the entity this note is attached to
  """
  entity_id: uuid!
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: String!
  """
  Unique identifier for the note
  """
  id: uuid!
  """
  Whether the note is flagged as important
  """
  is_important: Boolean
  """
  An array relationship
  """
  notes_by_client(
    """
    distinct select on columns
    """
    distinct_on: [clients_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [clients_order_by!]
    """
    filter the rows returned
    """
    where: clients_bool_exp
  ): [clients!]!
  """
  An aggregate relationship
  """
  notes_by_client_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [clients_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [clients_order_by!]
    """
    filter the rows returned
    """
    where: clients_bool_exp
  ): clients_aggregate!
  """
  An array relationship
  """
  notes_by_payroll(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  notes_by_payroll_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  Timestamp when the note was last updated
  """
  updated_at: timestamp
  """
  An object relationship
  """
  user: users
  """
  User who created the note
  """
  user_id: uuid
}

"""
aggregated selection of "notes"
"""
type notes_aggregate {
  aggregate: notes_aggregate_fields
  nodes: [notes!]!
}

input notes_aggregate_bool_exp {
  bool_and: notes_aggregate_bool_exp_bool_and
  bool_or: notes_aggregate_bool_exp_bool_or
  count: notes_aggregate_bool_exp_count
}

input notes_aggregate_bool_exp_bool_and {
  arguments: notes_select_column_notes_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Boolean_comparison_exp!
}

input notes_aggregate_bool_exp_bool_or {
  arguments: notes_select_column_notes_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Boolean_comparison_exp!
}

input notes_aggregate_bool_exp_count {
  arguments: [notes_select_column!]
  distinct: Boolean
  filter: notes_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notes"
"""
type notes_aggregate_fields {
  count(columns: [notes_select_column!], distinct: Boolean): Int!
  max: notes_max_fields
  min: notes_min_fields
}

"""
order by aggregate values of table "notes"
"""
input notes_aggregate_order_by {
  count: order_by
  max: notes_max_order_by
  min: notes_min_order_by
}

"""
input type for inserting array relation for remote table "notes"
"""
input notes_arr_rel_insert_input {
  data: [notes_insert_input!]!
  """
  upsert condition
  """
  on_conflict: notes_on_conflict
}

"""
Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'.
"""
input notes_bool_exp {
  _and: [notes_bool_exp!]
  _not: notes_bool_exp
  _or: [notes_bool_exp!]
  content: String_comparison_exp
  created_at: timestamp_comparison_exp
  entity_id: uuid_comparison_exp
  entity_type: String_comparison_exp
  id: uuid_comparison_exp
  is_important: Boolean_comparison_exp
  notes_by_client: clients_bool_exp
  notes_by_client_aggregate: clients_aggregate_bool_exp
  notes_by_payroll: payrolls_bool_exp
  notes_by_payroll_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamp_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "notes"
"""
enum notes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  notes_pkey
}

"""
input type for inserting data into table "notes"
"""
input notes_insert_input {
  """
  Content of the note
  """
  content: String
  """
  Timestamp when the note was created
  """
  created_at: timestamp
  """
  Identifier of the entity this note is attached to
  """
  entity_id: uuid
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: String
  """
  Unique identifier for the note
  """
  id: uuid
  """
  Whether the note is flagged as important
  """
  is_important: Boolean
  notes_by_client: clients_arr_rel_insert_input
  notes_by_payroll: payrolls_arr_rel_insert_input
  """
  Timestamp when the note was last updated
  """
  updated_at: timestamp
  user: users_obj_rel_insert_input
  """
  User who created the note
  """
  user_id: uuid
}

"""
aggregate max on columns
"""
type notes_max_fields {
  """
  Content of the note
  """
  content: String
  """
  Timestamp when the note was created
  """
  created_at: timestamp
  """
  Identifier of the entity this note is attached to
  """
  entity_id: uuid
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: String
  """
  Unique identifier for the note
  """
  id: uuid
  """
  Timestamp when the note was last updated
  """
  updated_at: timestamp
  """
  User who created the note
  """
  user_id: uuid
}

"""
order by max() on columns of table "notes"
"""
input notes_max_order_by {
  """
  Content of the note
  """
  content: order_by
  """
  Timestamp when the note was created
  """
  created_at: order_by
  """
  Identifier of the entity this note is attached to
  """
  entity_id: order_by
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: order_by
  """
  Unique identifier for the note
  """
  id: order_by
  """
  Timestamp when the note was last updated
  """
  updated_at: order_by
  """
  User who created the note
  """
  user_id: order_by
}

"""
aggregate min on columns
"""
type notes_min_fields {
  """
  Content of the note
  """
  content: String
  """
  Timestamp when the note was created
  """
  created_at: timestamp
  """
  Identifier of the entity this note is attached to
  """
  entity_id: uuid
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: String
  """
  Unique identifier for the note
  """
  id: uuid
  """
  Timestamp when the note was last updated
  """
  updated_at: timestamp
  """
  User who created the note
  """
  user_id: uuid
}

"""
order by min() on columns of table "notes"
"""
input notes_min_order_by {
  """
  Content of the note
  """
  content: order_by
  """
  Timestamp when the note was created
  """
  created_at: order_by
  """
  Identifier of the entity this note is attached to
  """
  entity_id: order_by
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: order_by
  """
  Unique identifier for the note
  """
  id: order_by
  """
  Timestamp when the note was last updated
  """
  updated_at: order_by
  """
  User who created the note
  """
  user_id: order_by
}

"""
response of any mutation on the table "notes"
"""
type notes_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [notes!]!
}

"""
on_conflict condition type for table "notes"
"""
input notes_on_conflict {
  constraint: notes_constraint!
  update_columns: [notes_update_column!]! = []
  where: notes_bool_exp
}

"""
Ordering options when selecting data from "notes".
"""
input notes_order_by {
  content: order_by
  created_at: order_by
  entity_id: order_by
  entity_type: order_by
  id: order_by
  is_important: order_by
  notes_by_client_aggregate: clients_aggregate_order_by
  notes_by_payroll_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""
primary key columns input for table: notes
"""
input notes_pk_columns_input {
  """
  Unique identifier for the note
  """
  id: uuid!
}

"""
select columns of table "notes"
"""
enum notes_select_column {
  """
  column name
  """
  content
  """
  column name
  """
  created_at
  """
  column name
  """
  entity_id
  """
  column name
  """
  entity_type
  """
  column name
  """
  id
  """
  column name
  """
  is_important
  """
  column name
  """
  updated_at
  """
  column name
  """
  user_id
}

"""
select "notes_aggregate_bool_exp_bool_and_arguments_columns" columns of table "notes"
"""
enum notes_select_column_notes_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  is_important
}

"""
select "notes_aggregate_bool_exp_bool_or_arguments_columns" columns of table "notes"
"""
enum notes_select_column_notes_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  is_important
}

"""
input type for updating data in table "notes"
"""
input notes_set_input {
  """
  Content of the note
  """
  content: String
  """
  Timestamp when the note was created
  """
  created_at: timestamp
  """
  Identifier of the entity this note is attached to
  """
  entity_id: uuid
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: String
  """
  Unique identifier for the note
  """
  id: uuid
  """
  Whether the note is flagged as important
  """
  is_important: Boolean
  """
  Timestamp when the note was last updated
  """
  updated_at: timestamp
  """
  User who created the note
  """
  user_id: uuid
}

"""
Streaming cursor of the table "notes"
"""
input notes_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: notes_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input notes_stream_cursor_value_input {
  """
  Content of the note
  """
  content: String
  """
  Timestamp when the note was created
  """
  created_at: timestamp
  """
  Identifier of the entity this note is attached to
  """
  entity_id: uuid
  """
  Type of entity this note is attached to (client, payroll, etc.)
  """
  entity_type: String
  """
  Unique identifier for the note
  """
  id: uuid
  """
  Whether the note is flagged as important
  """
  is_important: Boolean
  """
  Timestamp when the note was last updated
  """
  updated_at: timestamp
  """
  User who created the note
  """
  user_id: uuid
}

"""
update columns of table "notes"
"""
enum notes_update_column {
  """
  column name
  """
  content
  """
  column name
  """
  created_at
  """
  column name
  """
  entity_id
  """
  column name
  """
  entity_type
  """
  column name
  """
  id
  """
  column name
  """
  is_important
  """
  column name
  """
  updated_at
  """
  column name
  """
  user_id
}

input notes_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: notes_set_input
  """
  filter the rows which have to be updated
  """
  where: notes_bool_exp!
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc
  """
  in ascending order, nulls first
  """
  asc_nulls_first
  """
  in ascending order, nulls last
  """
  asc_nulls_last
  """
  in descending order, nulls first
  """
  desc
  """
  in descending order, nulls first
  """
  desc_nulls_first
  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "payroll_activation_results"
"""
type payroll_activation_results {
  action_taken: String!
  executed_at: timestamptz
  id: uuid!
  payroll_id: uuid!
  version_number: Int!
}

type payroll_activation_results_aggregate {
  aggregate: payroll_activation_results_aggregate_fields
  nodes: [payroll_activation_results!]!
}

"""
aggregate fields of "payroll_activation_results"
"""
type payroll_activation_results_aggregate_fields {
  avg: payroll_activation_results_avg_fields
  count(
    columns: [payroll_activation_results_select_column!]
    distinct: Boolean
  ): Int!
  max: payroll_activation_results_max_fields
  min: payroll_activation_results_min_fields
  stddev: payroll_activation_results_stddev_fields
  stddev_pop: payroll_activation_results_stddev_pop_fields
  stddev_samp: payroll_activation_results_stddev_samp_fields
  sum: payroll_activation_results_sum_fields
  var_pop: payroll_activation_results_var_pop_fields
  var_samp: payroll_activation_results_var_samp_fields
  variance: payroll_activation_results_variance_fields
}

"""
aggregate avg on columns
"""
type payroll_activation_results_avg_fields {
  version_number: Float
}

"""
Boolean expression to filter rows from the table "payroll_activation_results". All fields are combined with a logical 'AND'.
"""
input payroll_activation_results_bool_exp {
  _and: [payroll_activation_results_bool_exp!]
  _not: payroll_activation_results_bool_exp
  _or: [payroll_activation_results_bool_exp!]
  action_taken: String_comparison_exp
  executed_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  payroll_id: uuid_comparison_exp
  version_number: Int_comparison_exp
}

"""
unique or primary key constraints on table "payroll_activation_results"
"""
enum payroll_activation_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_activation_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_activation_results"
"""
input payroll_activation_results_inc_input {
  version_number: Int
}

"""
input type for inserting data into table "payroll_activation_results"
"""
input payroll_activation_results_insert_input {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""
aggregate max on columns
"""
type payroll_activation_results_max_fields {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""
aggregate min on columns
"""
type payroll_activation_results_min_fields {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""
response of any mutation on the table "payroll_activation_results"
"""
type payroll_activation_results_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_activation_results!]!
}

"""
on_conflict condition type for table "payroll_activation_results"
"""
input payroll_activation_results_on_conflict {
  constraint: payroll_activation_results_constraint!
  update_columns: [payroll_activation_results_update_column!]! = []
  where: payroll_activation_results_bool_exp
}

"""
Ordering options when selecting data from "payroll_activation_results".
"""
input payroll_activation_results_order_by {
  action_taken: order_by
  executed_at: order_by
  id: order_by
  payroll_id: order_by
  version_number: order_by
}

"""
primary key columns input for table: payroll_activation_results
"""
input payroll_activation_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_activation_results"
"""
enum payroll_activation_results_select_column {
  """
  column name
  """
  action_taken
  """
  column name
  """
  executed_at
  """
  column name
  """
  id
  """
  column name
  """
  payroll_id
  """
  column name
  """
  version_number
}

"""
input type for updating data in table "payroll_activation_results"
"""
input payroll_activation_results_set_input {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""
aggregate stddev on columns
"""
type payroll_activation_results_stddev_fields {
  version_number: Float
}

"""
aggregate stddev_pop on columns
"""
type payroll_activation_results_stddev_pop_fields {
  version_number: Float
}

"""
aggregate stddev_samp on columns
"""
type payroll_activation_results_stddev_samp_fields {
  version_number: Float
}

"""
Streaming cursor of the table "payroll_activation_results"
"""
input payroll_activation_results_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_activation_results_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_activation_results_stream_cursor_value_input {
  action_taken: String
  executed_at: timestamptz
  id: uuid
  payroll_id: uuid
  version_number: Int
}

"""
aggregate sum on columns
"""
type payroll_activation_results_sum_fields {
  version_number: Int
}

"""
update columns of table "payroll_activation_results"
"""
enum payroll_activation_results_update_column {
  """
  column name
  """
  action_taken
  """
  column name
  """
  executed_at
  """
  column name
  """
  id
  """
  column name
  """
  payroll_id
  """
  column name
  """
  version_number
}

input payroll_activation_results_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: payroll_activation_results_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_activation_results_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_activation_results_bool_exp!
}

"""
aggregate var_pop on columns
"""
type payroll_activation_results_var_pop_fields {
  version_number: Float
}

"""
aggregate var_samp on columns
"""
type payroll_activation_results_var_samp_fields {
  version_number: Float
}

"""
aggregate variance on columns
"""
type payroll_activation_results_variance_fields {
  version_number: Float
}

"""
columns and relationships of "payroll_assignment_audit"
"""
type payroll_assignment_audit {
  assignment_id: uuid
  change_reason: String
  changed_by: uuid
  created_at: timestamptz
  from_consultant_id: uuid
  id: uuid!
  """
  An object relationship
  """
  payroll_assignment: payroll_assignments
  """
  An object relationship
  """
  payroll_date: payroll_dates!
  payroll_date_id: uuid!
  to_consultant_id: uuid!
  """
  An object relationship
  """
  user: users
  """
  An object relationship
  """
  userByFromConsultantId: users
  """
  An object relationship
  """
  userByToConsultantId: users!
}

"""
aggregated selection of "payroll_assignment_audit"
"""
type payroll_assignment_audit_aggregate {
  aggregate: payroll_assignment_audit_aggregate_fields
  nodes: [payroll_assignment_audit!]!
}

input payroll_assignment_audit_aggregate_bool_exp {
  count: payroll_assignment_audit_aggregate_bool_exp_count
}

input payroll_assignment_audit_aggregate_bool_exp_count {
  arguments: [payroll_assignment_audit_select_column!]
  distinct: Boolean
  filter: payroll_assignment_audit_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payroll_assignment_audit"
"""
type payroll_assignment_audit_aggregate_fields {
  count(
    columns: [payroll_assignment_audit_select_column!]
    distinct: Boolean
  ): Int!
  max: payroll_assignment_audit_max_fields
  min: payroll_assignment_audit_min_fields
}

"""
order by aggregate values of table "payroll_assignment_audit"
"""
input payroll_assignment_audit_aggregate_order_by {
  count: order_by
  max: payroll_assignment_audit_max_order_by
  min: payroll_assignment_audit_min_order_by
}

"""
input type for inserting array relation for remote table "payroll_assignment_audit"
"""
input payroll_assignment_audit_arr_rel_insert_input {
  data: [payroll_assignment_audit_insert_input!]!
  """
  upsert condition
  """
  on_conflict: payroll_assignment_audit_on_conflict
}

"""
Boolean expression to filter rows from the table "payroll_assignment_audit". All fields are combined with a logical 'AND'.
"""
input payroll_assignment_audit_bool_exp {
  _and: [payroll_assignment_audit_bool_exp!]
  _not: payroll_assignment_audit_bool_exp
  _or: [payroll_assignment_audit_bool_exp!]
  assignment_id: uuid_comparison_exp
  change_reason: String_comparison_exp
  changed_by: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  from_consultant_id: uuid_comparison_exp
  id: uuid_comparison_exp
  payroll_assignment: payroll_assignments_bool_exp
  payroll_date: payroll_dates_bool_exp
  payroll_date_id: uuid_comparison_exp
  to_consultant_id: uuid_comparison_exp
  user: users_bool_exp
  userByFromConsultantId: users_bool_exp
  userByToConsultantId: users_bool_exp
}

"""
unique or primary key constraints on table "payroll_assignment_audit"
"""
enum payroll_assignment_audit_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_assignment_audit_pkey
}

"""
input type for inserting data into table "payroll_assignment_audit"
"""
input payroll_assignment_audit_insert_input {
  assignment_id: uuid
  change_reason: String
  changed_by: uuid
  created_at: timestamptz
  from_consultant_id: uuid
  id: uuid
  payroll_assignment: payroll_assignments_obj_rel_insert_input
  payroll_date: payroll_dates_obj_rel_insert_input
  payroll_date_id: uuid
  to_consultant_id: uuid
  user: users_obj_rel_insert_input
  userByFromConsultantId: users_obj_rel_insert_input
  userByToConsultantId: users_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type payroll_assignment_audit_max_fields {
  assignment_id: uuid
  change_reason: String
  changed_by: uuid
  created_at: timestamptz
  from_consultant_id: uuid
  id: uuid
  payroll_date_id: uuid
  to_consultant_id: uuid
}

"""
order by max() on columns of table "payroll_assignment_audit"
"""
input payroll_assignment_audit_max_order_by {
  assignment_id: order_by
  change_reason: order_by
  changed_by: order_by
  created_at: order_by
  from_consultant_id: order_by
  id: order_by
  payroll_date_id: order_by
  to_consultant_id: order_by
}

"""
aggregate min on columns
"""
type payroll_assignment_audit_min_fields {
  assignment_id: uuid
  change_reason: String
  changed_by: uuid
  created_at: timestamptz
  from_consultant_id: uuid
  id: uuid
  payroll_date_id: uuid
  to_consultant_id: uuid
}

"""
order by min() on columns of table "payroll_assignment_audit"
"""
input payroll_assignment_audit_min_order_by {
  assignment_id: order_by
  change_reason: order_by
  changed_by: order_by
  created_at: order_by
  from_consultant_id: order_by
  id: order_by
  payroll_date_id: order_by
  to_consultant_id: order_by
}

"""
response of any mutation on the table "payroll_assignment_audit"
"""
type payroll_assignment_audit_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_assignment_audit!]!
}

"""
on_conflict condition type for table "payroll_assignment_audit"
"""
input payroll_assignment_audit_on_conflict {
  constraint: payroll_assignment_audit_constraint!
  update_columns: [payroll_assignment_audit_update_column!]! = []
  where: payroll_assignment_audit_bool_exp
}

"""
Ordering options when selecting data from "payroll_assignment_audit".
"""
input payroll_assignment_audit_order_by {
  assignment_id: order_by
  change_reason: order_by
  changed_by: order_by
  created_at: order_by
  from_consultant_id: order_by
  id: order_by
  payroll_assignment: payroll_assignments_order_by
  payroll_date: payroll_dates_order_by
  payroll_date_id: order_by
  to_consultant_id: order_by
  user: users_order_by
  userByFromConsultantId: users_order_by
  userByToConsultantId: users_order_by
}

"""
primary key columns input for table: payroll_assignment_audit
"""
input payroll_assignment_audit_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_assignment_audit"
"""
enum payroll_assignment_audit_select_column {
  """
  column name
  """
  assignment_id
  """
  column name
  """
  change_reason
  """
  column name
  """
  changed_by
  """
  column name
  """
  created_at
  """
  column name
  """
  from_consultant_id
  """
  column name
  """
  id
  """
  column name
  """
  payroll_date_id
  """
  column name
  """
  to_consultant_id
}

"""
input type for updating data in table "payroll_assignment_audit"
"""
input payroll_assignment_audit_set_input {
  assignment_id: uuid
  change_reason: String
  changed_by: uuid
  created_at: timestamptz
  from_consultant_id: uuid
  id: uuid
  payroll_date_id: uuid
  to_consultant_id: uuid
}

"""
Streaming cursor of the table "payroll_assignment_audit"
"""
input payroll_assignment_audit_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_assignment_audit_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_assignment_audit_stream_cursor_value_input {
  assignment_id: uuid
  change_reason: String
  changed_by: uuid
  created_at: timestamptz
  from_consultant_id: uuid
  id: uuid
  payroll_date_id: uuid
  to_consultant_id: uuid
}

"""
update columns of table "payroll_assignment_audit"
"""
enum payroll_assignment_audit_update_column {
  """
  column name
  """
  assignment_id
  """
  column name
  """
  change_reason
  """
  column name
  """
  changed_by
  """
  column name
  """
  created_at
  """
  column name
  """
  from_consultant_id
  """
  column name
  """
  id
  """
  column name
  """
  payroll_date_id
  """
  column name
  """
  to_consultant_id
}

input payroll_assignment_audit_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_assignment_audit_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_assignment_audit_bool_exp!
}

"""
columns and relationships of "payroll_assignments"
"""
type payroll_assignments {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid!
  createdAt: timestamptz
  id: uuid!
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid!
  """
  An array relationship
  """
  payroll_assignment_audits(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  An aggregate relationship
  """
  payroll_assignment_audits_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): payroll_assignment_audit_aggregate!
  """
  An object relationship
  """
  payroll_date: payroll_dates!
  updatedAt: timestamptz
  """
  An object relationship
  """
  user: users
  """
  An object relationship
  """
  userByConsultantId: users!
  """
  An object relationship
  """
  userByOriginalConsultantId: users
}

"""
aggregated selection of "payroll_assignments"
"""
type payroll_assignments_aggregate {
  aggregate: payroll_assignments_aggregate_fields
  nodes: [payroll_assignments!]!
}

input payroll_assignments_aggregate_bool_exp {
  bool_and: payroll_assignments_aggregate_bool_exp_bool_and
  bool_or: payroll_assignments_aggregate_bool_exp_bool_or
  count: payroll_assignments_aggregate_bool_exp_count
}

input payroll_assignments_aggregate_bool_exp_bool_and {
  arguments: payroll_assignments_select_column_payroll_assignments_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: payroll_assignments_bool_exp
  predicate: Boolean_comparison_exp!
}

input payroll_assignments_aggregate_bool_exp_bool_or {
  arguments: payroll_assignments_select_column_payroll_assignments_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: payroll_assignments_bool_exp
  predicate: Boolean_comparison_exp!
}

input payroll_assignments_aggregate_bool_exp_count {
  arguments: [payroll_assignments_select_column!]
  distinct: Boolean
  filter: payroll_assignments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payroll_assignments"
"""
type payroll_assignments_aggregate_fields {
  count(columns: [payroll_assignments_select_column!], distinct: Boolean): Int!
  max: payroll_assignments_max_fields
  min: payroll_assignments_min_fields
}

"""
order by aggregate values of table "payroll_assignments"
"""
input payroll_assignments_aggregate_order_by {
  count: order_by
  max: payroll_assignments_max_order_by
  min: payroll_assignments_min_order_by
}

"""
input type for inserting array relation for remote table "payroll_assignments"
"""
input payroll_assignments_arr_rel_insert_input {
  data: [payroll_assignments_insert_input!]!
  """
  upsert condition
  """
  on_conflict: payroll_assignments_on_conflict
}

"""
Boolean expression to filter rows from the table "payroll_assignments". All fields are combined with a logical 'AND'.
"""
input payroll_assignments_bool_exp {
  _and: [payroll_assignments_bool_exp!]
  _not: payroll_assignments_bool_exp
  _or: [payroll_assignments_bool_exp!]
  assignedBy: uuid_comparison_exp
  assignedDate: timestamptz_comparison_exp
  consultantId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  isBackup: Boolean_comparison_exp
  originalConsultantId: uuid_comparison_exp
  payrollDateId: uuid_comparison_exp
  payroll_assignment_audits: payroll_assignment_audit_bool_exp
  payroll_assignment_audits_aggregate: payroll_assignment_audit_aggregate_bool_exp
  payroll_date: payroll_dates_bool_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userByConsultantId: users_bool_exp
  userByOriginalConsultantId: users_bool_exp
}

"""
unique or primary key constraints on table "payroll_assignments"
"""
enum payroll_assignments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_assignments_pkey
  """
  unique or primary key constraint on columns "payroll_date_id"
  """
  uq_payroll_assignment_payroll_date
}

"""
input type for inserting data into table "payroll_assignments"
"""
input payroll_assignments_insert_input {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid
  payroll_assignment_audits: payroll_assignment_audit_arr_rel_insert_input
  payroll_date: payroll_dates_obj_rel_insert_input
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userByConsultantId: users_obj_rel_insert_input
  userByOriginalConsultantId: users_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type payroll_assignments_max_fields {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "payroll_assignments"
"""
input payroll_assignments_max_order_by {
  assignedBy: order_by
  assignedDate: order_by
  consultantId: order_by
  createdAt: order_by
  id: order_by
  originalConsultantId: order_by
  payrollDateId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type payroll_assignments_min_fields {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "payroll_assignments"
"""
input payroll_assignments_min_order_by {
  assignedBy: order_by
  assignedDate: order_by
  consultantId: order_by
  createdAt: order_by
  id: order_by
  originalConsultantId: order_by
  payrollDateId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "payroll_assignments"
"""
type payroll_assignments_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_assignments!]!
}

"""
input type for inserting object relation for remote table "payroll_assignments"
"""
input payroll_assignments_obj_rel_insert_input {
  data: payroll_assignments_insert_input!
  """
  upsert condition
  """
  on_conflict: payroll_assignments_on_conflict
}

"""
on_conflict condition type for table "payroll_assignments"
"""
input payroll_assignments_on_conflict {
  constraint: payroll_assignments_constraint!
  update_columns: [payroll_assignments_update_column!]! = []
  where: payroll_assignments_bool_exp
}

"""
Ordering options when selecting data from "payroll_assignments".
"""
input payroll_assignments_order_by {
  assignedBy: order_by
  assignedDate: order_by
  consultantId: order_by
  createdAt: order_by
  id: order_by
  isBackup: order_by
  originalConsultantId: order_by
  payrollDateId: order_by
  payroll_assignment_audits_aggregate: payroll_assignment_audit_aggregate_order_by
  payroll_date: payroll_dates_order_by
  updatedAt: order_by
  user: users_order_by
  userByConsultantId: users_order_by
  userByOriginalConsultantId: users_order_by
}

"""
primary key columns input for table: payroll_assignments
"""
input payroll_assignments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_assignments"
"""
enum payroll_assignments_select_column {
  """
  column name
  """
  assignedBy
  """
  column name
  """
  assignedDate
  """
  column name
  """
  consultantId
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  isBackup
  """
  column name
  """
  originalConsultantId
  """
  column name
  """
  payrollDateId
  """
  column name
  """
  updatedAt
}

"""
select "payroll_assignments_aggregate_bool_exp_bool_and_arguments_columns" columns of table "payroll_assignments"
"""
enum payroll_assignments_select_column_payroll_assignments_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  isBackup
}

"""
select "payroll_assignments_aggregate_bool_exp_bool_or_arguments_columns" columns of table "payroll_assignments"
"""
enum payroll_assignments_select_column_payroll_assignments_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  isBackup
}

"""
input type for updating data in table "payroll_assignments"
"""
input payroll_assignments_set_input {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payroll_assignments"
"""
input payroll_assignments_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_assignments_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_assignments_stream_cursor_value_input {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "payroll_assignments"
"""
enum payroll_assignments_update_column {
  """
  column name
  """
  assignedBy
  """
  column name
  """
  assignedDate
  """
  column name
  """
  consultantId
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  isBackup
  """
  column name
  """
  originalConsultantId
  """
  column name
  """
  payrollDateId
  """
  column name
  """
  updatedAt
}

input payroll_assignments_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_assignments_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_assignments_bool_exp!
}

scalar payroll_cycle_type

"""
Boolean expression to compare columns of type "payroll_cycle_type". All fields are combined with logical 'AND'.
"""
input payroll_cycle_type_comparison_exp {
  _eq: payroll_cycle_type
  _gt: payroll_cycle_type
  _gte: payroll_cycle_type
  _in: [payroll_cycle_type!]
  _is_null: Boolean
  _lt: payroll_cycle_type
  _lte: payroll_cycle_type
  _neq: payroll_cycle_type
  _nin: [payroll_cycle_type!]
}

"""
columns and relationships of "payroll_cycles"
"""
type payroll_cycles {
  """
  An array relationship
  """
  adjustment_rules(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!
  """
  An aggregate relationship
  """
  adjustment_rules_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!
  """
  Timestamp when the cycle was created
  """
  created_at: timestamptz
  """
  Detailed description of the payroll cycle
  """
  description: String
  """
  Unique identifier for the payroll cycle
  """
  id: uuid!
  """
  Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)
  """
  name: payroll_cycle_type!
  """
  An array relationship
  """
  payrolls(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  payrolls_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  Timestamp when the cycle was last updated
  """
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_cycles"
"""
type payroll_cycles_aggregate {
  aggregate: payroll_cycles_aggregate_fields
  nodes: [payroll_cycles!]!
}

"""
aggregate fields of "payroll_cycles"
"""
type payroll_cycles_aggregate_fields {
  count(columns: [payroll_cycles_select_column!], distinct: Boolean): Int!
  max: payroll_cycles_max_fields
  min: payroll_cycles_min_fields
}

"""
Boolean expression to filter rows from the table "payroll_cycles". All fields are combined with a logical 'AND'.
"""
input payroll_cycles_bool_exp {
  _and: [payroll_cycles_bool_exp!]
  _not: payroll_cycles_bool_exp
  _or: [payroll_cycles_bool_exp!]
  adjustment_rules: adjustment_rules_bool_exp
  adjustment_rules_aggregate: adjustment_rules_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: payroll_cycle_type_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_cycles"
"""
enum payroll_cycles_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_cycles_name_key
  """
  unique or primary key constraint on columns "id"
  """
  payroll_cycles_pkey
}

"""
input type for inserting data into table "payroll_cycles"
"""
input payroll_cycles_insert_input {
  adjustment_rules: adjustment_rules_arr_rel_insert_input
  """
  Timestamp when the cycle was created
  """
  created_at: timestamptz
  """
  Detailed description of the payroll cycle
  """
  description: String
  """
  Unique identifier for the payroll cycle
  """
  id: uuid
  """
  Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)
  """
  name: payroll_cycle_type
  payrolls: payrolls_arr_rel_insert_input
  """
  Timestamp when the cycle was last updated
  """
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type payroll_cycles_max_fields {
  """
  Timestamp when the cycle was created
  """
  created_at: timestamptz
  """
  Detailed description of the payroll cycle
  """
  description: String
  """
  Unique identifier for the payroll cycle
  """
  id: uuid
  """
  Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)
  """
  name: payroll_cycle_type
  """
  Timestamp when the cycle was last updated
  """
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type payroll_cycles_min_fields {
  """
  Timestamp when the cycle was created
  """
  created_at: timestamptz
  """
  Detailed description of the payroll cycle
  """
  description: String
  """
  Unique identifier for the payroll cycle
  """
  id: uuid
  """
  Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)
  """
  name: payroll_cycle_type
  """
  Timestamp when the cycle was last updated
  """
  updated_at: timestamptz
}

"""
response of any mutation on the table "payroll_cycles"
"""
type payroll_cycles_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_cycles!]!
}

"""
input type for inserting object relation for remote table "payroll_cycles"
"""
input payroll_cycles_obj_rel_insert_input {
  data: payroll_cycles_insert_input!
  """
  upsert condition
  """
  on_conflict: payroll_cycles_on_conflict
}

"""
on_conflict condition type for table "payroll_cycles"
"""
input payroll_cycles_on_conflict {
  constraint: payroll_cycles_constraint!
  update_columns: [payroll_cycles_update_column!]! = []
  where: payroll_cycles_bool_exp
}

"""
Ordering options when selecting data from "payroll_cycles".
"""
input payroll_cycles_order_by {
  adjustment_rules_aggregate: adjustment_rules_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: payroll_cycles
"""
input payroll_cycles_pk_columns_input {
  """
  Unique identifier for the payroll cycle
  """
  id: uuid!
}

"""
select columns of table "payroll_cycles"
"""
enum payroll_cycles_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "payroll_cycles"
"""
input payroll_cycles_set_input {
  """
  Timestamp when the cycle was created
  """
  created_at: timestamptz
  """
  Detailed description of the payroll cycle
  """
  description: String
  """
  Unique identifier for the payroll cycle
  """
  id: uuid
  """
  Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)
  """
  name: payroll_cycle_type
  """
  Timestamp when the cycle was last updated
  """
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_cycles"
"""
input payroll_cycles_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_cycles_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_cycles_stream_cursor_value_input {
  """
  Timestamp when the cycle was created
  """
  created_at: timestamptz
  """
  Detailed description of the payroll cycle
  """
  description: String
  """
  Unique identifier for the payroll cycle
  """
  id: uuid
  """
  Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)
  """
  name: payroll_cycle_type
  """
  Timestamp when the cycle was last updated
  """
  updated_at: timestamptz
}

"""
update columns of table "payroll_cycles"
"""
enum payroll_cycles_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updated_at
}

input payroll_cycles_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_cycles_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_cycles_bool_exp!
}

"""
columns and relationships of "payroll_dashboard_stats"
"""
type payroll_dashboard_stats {
  backup_consultant_user_id: uuid
  client_name: String
  cycle_name: payroll_cycle_type
  future_dates: bigint
  id: uuid
  manager_user_id: uuid
  name: String
  next_eft_date: date
  past_dates: bigint
  primary_consultant_user_id: uuid
  status: payroll_status
  total_dates: bigint
}

"""
aggregated selection of "payroll_dashboard_stats"
"""
type payroll_dashboard_stats_aggregate {
  aggregate: payroll_dashboard_stats_aggregate_fields
  nodes: [payroll_dashboard_stats!]!
}

"""
aggregate fields of "payroll_dashboard_stats"
"""
type payroll_dashboard_stats_aggregate_fields {
  avg: payroll_dashboard_stats_avg_fields
  count(
    columns: [payroll_dashboard_stats_select_column!]
    distinct: Boolean
  ): Int!
  max: payroll_dashboard_stats_max_fields
  min: payroll_dashboard_stats_min_fields
  stddev: payroll_dashboard_stats_stddev_fields
  stddev_pop: payroll_dashboard_stats_stddev_pop_fields
  stddev_samp: payroll_dashboard_stats_stddev_samp_fields
  sum: payroll_dashboard_stats_sum_fields
  var_pop: payroll_dashboard_stats_var_pop_fields
  var_samp: payroll_dashboard_stats_var_samp_fields
  variance: payroll_dashboard_stats_variance_fields
}

"""
aggregate avg on columns
"""
type payroll_dashboard_stats_avg_fields {
  future_dates: Float
  past_dates: Float
  total_dates: Float
}

"""
Boolean expression to filter rows from the table "payroll_dashboard_stats". All fields are combined with a logical 'AND'.
"""
input payroll_dashboard_stats_bool_exp {
  _and: [payroll_dashboard_stats_bool_exp!]
  _not: payroll_dashboard_stats_bool_exp
  _or: [payroll_dashboard_stats_bool_exp!]
  backup_consultant_user_id: uuid_comparison_exp
  client_name: String_comparison_exp
  cycle_name: payroll_cycle_type_comparison_exp
  future_dates: bigint_comparison_exp
  id: uuid_comparison_exp
  manager_user_id: uuid_comparison_exp
  name: String_comparison_exp
  next_eft_date: date_comparison_exp
  past_dates: bigint_comparison_exp
  primary_consultant_user_id: uuid_comparison_exp
  status: payroll_status_comparison_exp
  total_dates: bigint_comparison_exp
}

"""
aggregate max on columns
"""
type payroll_dashboard_stats_max_fields {
  backup_consultant_user_id: uuid
  client_name: String
  cycle_name: payroll_cycle_type
  future_dates: bigint
  id: uuid
  manager_user_id: uuid
  name: String
  next_eft_date: date
  past_dates: bigint
  primary_consultant_user_id: uuid
  status: payroll_status
  total_dates: bigint
}

"""
aggregate min on columns
"""
type payroll_dashboard_stats_min_fields {
  backup_consultant_user_id: uuid
  client_name: String
  cycle_name: payroll_cycle_type
  future_dates: bigint
  id: uuid
  manager_user_id: uuid
  name: String
  next_eft_date: date
  past_dates: bigint
  primary_consultant_user_id: uuid
  status: payroll_status
  total_dates: bigint
}

"""
Ordering options when selecting data from "payroll_dashboard_stats".
"""
input payroll_dashboard_stats_order_by {
  backup_consultant_user_id: order_by
  client_name: order_by
  cycle_name: order_by
  future_dates: order_by
  id: order_by
  manager_user_id: order_by
  name: order_by
  next_eft_date: order_by
  past_dates: order_by
  primary_consultant_user_id: order_by
  status: order_by
  total_dates: order_by
}

"""
select columns of table "payroll_dashboard_stats"
"""
enum payroll_dashboard_stats_select_column {
  """
  column name
  """
  backup_consultant_user_id
  """
  column name
  """
  client_name
  """
  column name
  """
  cycle_name
  """
  column name
  """
  future_dates
  """
  column name
  """
  id
  """
  column name
  """
  manager_user_id
  """
  column name
  """
  name
  """
  column name
  """
  next_eft_date
  """
  column name
  """
  past_dates
  """
  column name
  """
  primary_consultant_user_id
  """
  column name
  """
  status
  """
  column name
  """
  total_dates
}

"""
aggregate stddev on columns
"""
type payroll_dashboard_stats_stddev_fields {
  future_dates: Float
  past_dates: Float
  total_dates: Float
}

"""
aggregate stddev_pop on columns
"""
type payroll_dashboard_stats_stddev_pop_fields {
  future_dates: Float
  past_dates: Float
  total_dates: Float
}

"""
aggregate stddev_samp on columns
"""
type payroll_dashboard_stats_stddev_samp_fields {
  future_dates: Float
  past_dates: Float
  total_dates: Float
}

"""
Streaming cursor of the table "payroll_dashboard_stats"
"""
input payroll_dashboard_stats_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_dashboard_stats_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_dashboard_stats_stream_cursor_value_input {
  backup_consultant_user_id: uuid
  client_name: String
  cycle_name: payroll_cycle_type
  future_dates: bigint
  id: uuid
  manager_user_id: uuid
  name: String
  next_eft_date: date
  past_dates: bigint
  primary_consultant_user_id: uuid
  status: payroll_status
  total_dates: bigint
}

"""
aggregate sum on columns
"""
type payroll_dashboard_stats_sum_fields {
  future_dates: bigint
  past_dates: bigint
  total_dates: bigint
}

"""
aggregate var_pop on columns
"""
type payroll_dashboard_stats_var_pop_fields {
  future_dates: Float
  past_dates: Float
  total_dates: Float
}

"""
aggregate var_samp on columns
"""
type payroll_dashboard_stats_var_samp_fields {
  future_dates: Float
  past_dates: Float
  total_dates: Float
}

"""
aggregate variance on columns
"""
type payroll_dashboard_stats_variance_fields {
  future_dates: Float
  past_dates: Float
  total_dates: Float
}

scalar payroll_date_type

"""
Boolean expression to compare columns of type "payroll_date_type". All fields are combined with logical 'AND'.
"""
input payroll_date_type_comparison_exp {
  _eq: payroll_date_type
  _gt: payroll_date_type
  _gte: payroll_date_type
  _in: [payroll_date_type!]
  _is_null: Boolean
  _lt: payroll_date_type
  _lte: payroll_date_type
  _neq: payroll_date_type
  _nin: [payroll_date_type!]
}

"""
columns and relationships of "payroll_date_types"
"""
type payroll_date_types {
  """
  An array relationship
  """
  adjustment_rules(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!
  """
  An aggregate relationship
  """
  adjustment_rules_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!
  """
  Timestamp when the date type was created
  """
  created_at: timestamptz
  """
  Detailed description of how this date type works
  """
  description: String
  """
  Unique identifier for the payroll date type
  """
  id: uuid!
  """
  Name of the date type (Fixed, Last Working Day, etc.)
  """
  name: payroll_date_type!
  """
  An array relationship
  """
  payrolls(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  payrolls_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  Timestamp when the date type was last updated
  """
  updated_at: timestamptz
}

"""
aggregated selection of "payroll_date_types"
"""
type payroll_date_types_aggregate {
  aggregate: payroll_date_types_aggregate_fields
  nodes: [payroll_date_types!]!
}

"""
aggregate fields of "payroll_date_types"
"""
type payroll_date_types_aggregate_fields {
  count(columns: [payroll_date_types_select_column!], distinct: Boolean): Int!
  max: payroll_date_types_max_fields
  min: payroll_date_types_min_fields
}

"""
Boolean expression to filter rows from the table "payroll_date_types". All fields are combined with a logical 'AND'.
"""
input payroll_date_types_bool_exp {
  _and: [payroll_date_types_bool_exp!]
  _not: payroll_date_types_bool_exp
  _or: [payroll_date_types_bool_exp!]
  adjustment_rules: adjustment_rules_bool_exp
  adjustment_rules_aggregate: adjustment_rules_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: payroll_date_type_comparison_exp
  payrolls: payrolls_bool_exp
  payrolls_aggregate: payrolls_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_date_types"
"""
enum payroll_date_types_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_date_types_name_key
  """
  unique or primary key constraint on columns "id"
  """
  payroll_date_types_pkey
}

"""
input type for inserting data into table "payroll_date_types"
"""
input payroll_date_types_insert_input {
  adjustment_rules: adjustment_rules_arr_rel_insert_input
  """
  Timestamp when the date type was created
  """
  created_at: timestamptz
  """
  Detailed description of how this date type works
  """
  description: String
  """
  Unique identifier for the payroll date type
  """
  id: uuid
  """
  Name of the date type (Fixed, Last Working Day, etc.)
  """
  name: payroll_date_type
  payrolls: payrolls_arr_rel_insert_input
  """
  Timestamp when the date type was last updated
  """
  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type payroll_date_types_max_fields {
  """
  Timestamp when the date type was created
  """
  created_at: timestamptz
  """
  Detailed description of how this date type works
  """
  description: String
  """
  Unique identifier for the payroll date type
  """
  id: uuid
  """
  Name of the date type (Fixed, Last Working Day, etc.)
  """
  name: payroll_date_type
  """
  Timestamp when the date type was last updated
  """
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type payroll_date_types_min_fields {
  """
  Timestamp when the date type was created
  """
  created_at: timestamptz
  """
  Detailed description of how this date type works
  """
  description: String
  """
  Unique identifier for the payroll date type
  """
  id: uuid
  """
  Name of the date type (Fixed, Last Working Day, etc.)
  """
  name: payroll_date_type
  """
  Timestamp when the date type was last updated
  """
  updated_at: timestamptz
}

"""
response of any mutation on the table "payroll_date_types"
"""
type payroll_date_types_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_date_types!]!
}

"""
input type for inserting object relation for remote table "payroll_date_types"
"""
input payroll_date_types_obj_rel_insert_input {
  data: payroll_date_types_insert_input!
  """
  upsert condition
  """
  on_conflict: payroll_date_types_on_conflict
}

"""
on_conflict condition type for table "payroll_date_types"
"""
input payroll_date_types_on_conflict {
  constraint: payroll_date_types_constraint!
  update_columns: [payroll_date_types_update_column!]! = []
  where: payroll_date_types_bool_exp
}

"""
Ordering options when selecting data from "payroll_date_types".
"""
input payroll_date_types_order_by {
  adjustment_rules_aggregate: adjustment_rules_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  payrolls_aggregate: payrolls_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: payroll_date_types
"""
input payroll_date_types_pk_columns_input {
  """
  Unique identifier for the payroll date type
  """
  id: uuid!
}

"""
select columns of table "payroll_date_types"
"""
enum payroll_date_types_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "payroll_date_types"
"""
input payroll_date_types_set_input {
  """
  Timestamp when the date type was created
  """
  created_at: timestamptz
  """
  Detailed description of how this date type works
  """
  description: String
  """
  Unique identifier for the payroll date type
  """
  id: uuid
  """
  Name of the date type (Fixed, Last Working Day, etc.)
  """
  name: payroll_date_type
  """
  Timestamp when the date type was last updated
  """
  updated_at: timestamptz
}

"""
Streaming cursor of the table "payroll_date_types"
"""
input payroll_date_types_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_date_types_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_date_types_stream_cursor_value_input {
  """
  Timestamp when the date type was created
  """
  created_at: timestamptz
  """
  Detailed description of how this date type works
  """
  description: String
  """
  Unique identifier for the payroll date type
  """
  id: uuid
  """
  Name of the date type (Fixed, Last Working Day, etc.)
  """
  name: payroll_date_type
  """
  Timestamp when the date type was last updated
  """
  updated_at: timestamptz
}

"""
update columns of table "payroll_date_types"
"""
enum payroll_date_types_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updated_at
}

input payroll_date_types_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_date_types_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_date_types_bool_exp!
}

"""
columns and relationships of "payroll_dates"
"""
type payroll_dates {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: date!
  """
  Timestamp when the date record was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the payroll date
  """
  id: uuid!
  """
  Additional notes about this payroll date
  """
  notes: String
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: date!
  """
  An object relationship
  """
  payroll: payrolls!
  """
  Reference to the payroll this date belongs to
  """
  payrollId: uuid!
  """
  An object relationship
  """
  payroll_assignment: payroll_assignments
  """
  An array relationship
  """
  payroll_assignment_audits(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  An aggregate relationship
  """
  payroll_assignment_audits_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): payroll_assignment_audit_aggregate!
  """
  Date when payroll processing must be completed
  """
  processingDate: date!
  """
  Timestamp when the date record was last updated
  """
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_dates"
"""
type payroll_dates_aggregate {
  aggregate: payroll_dates_aggregate_fields
  nodes: [payroll_dates!]!
}

input payroll_dates_aggregate_bool_exp {
  count: payroll_dates_aggregate_bool_exp_count
}

input payroll_dates_aggregate_bool_exp_count {
  arguments: [payroll_dates_select_column!]
  distinct: Boolean
  filter: payroll_dates_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payroll_dates"
"""
type payroll_dates_aggregate_fields {
  count(columns: [payroll_dates_select_column!], distinct: Boolean): Int!
  max: payroll_dates_max_fields
  min: payroll_dates_min_fields
}

"""
order by aggregate values of table "payroll_dates"
"""
input payroll_dates_aggregate_order_by {
  count: order_by
  max: payroll_dates_max_order_by
  min: payroll_dates_min_order_by
}

"""
input type for inserting array relation for remote table "payroll_dates"
"""
input payroll_dates_arr_rel_insert_input {
  data: [payroll_dates_insert_input!]!
  """
  upsert condition
  """
  on_conflict: payroll_dates_on_conflict
}

"""
Boolean expression to filter rows from the table "payroll_dates". All fields are combined with a logical 'AND'.
"""
input payroll_dates_bool_exp {
  _and: [payroll_dates_bool_exp!]
  _not: payroll_dates_bool_exp
  _or: [payroll_dates_bool_exp!]
  adjustedEftDate: date_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  notes: String_comparison_exp
  originalEftDate: date_comparison_exp
  payroll: payrolls_bool_exp
  payrollId: uuid_comparison_exp
  payroll_assignment: payroll_assignments_bool_exp
  payroll_assignment_audits: payroll_assignment_audit_bool_exp
  payroll_assignment_audits_aggregate: payroll_assignment_audit_aggregate_bool_exp
  processingDate: date_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "payroll_dates"
"""
enum payroll_dates_constraint {
  """
  unique or primary key constraint on columns "original_eft_date", "payroll_id"
  """
  idx_unique_payroll_date
  """
  unique or primary key constraint on columns "id"
  """
  payroll_dates_pkey
}

"""
input type for inserting data into table "payroll_dates"
"""
input payroll_dates_insert_input {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: date
  """
  Timestamp when the date record was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the payroll date
  """
  id: uuid
  """
  Additional notes about this payroll date
  """
  notes: String
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: date
  payroll: payrolls_obj_rel_insert_input
  """
  Reference to the payroll this date belongs to
  """
  payrollId: uuid
  payroll_assignment: payroll_assignments_obj_rel_insert_input
  payroll_assignment_audits: payroll_assignment_audit_arr_rel_insert_input
  """
  Date when payroll processing must be completed
  """
  processingDate: date
  """
  Timestamp when the date record was last updated
  """
  updatedAt: timestamptz
}

"""
aggregate max on columns
"""
type payroll_dates_max_fields {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: date
  """
  Timestamp when the date record was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the payroll date
  """
  id: uuid
  """
  Additional notes about this payroll date
  """
  notes: String
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: date
  """
  Reference to the payroll this date belongs to
  """
  payrollId: uuid
  """
  Date when payroll processing must be completed
  """
  processingDate: date
  """
  Timestamp when the date record was last updated
  """
  updatedAt: timestamptz
}

"""
order by max() on columns of table "payroll_dates"
"""
input payroll_dates_max_order_by {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: order_by
  """
  Timestamp when the date record was created
  """
  createdAt: order_by
  """
  Unique identifier for the payroll date
  """
  id: order_by
  """
  Additional notes about this payroll date
  """
  notes: order_by
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: order_by
  """
  Reference to the payroll this date belongs to
  """
  payrollId: order_by
  """
  Date when payroll processing must be completed
  """
  processingDate: order_by
  """
  Timestamp when the date record was last updated
  """
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type payroll_dates_min_fields {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: date
  """
  Timestamp when the date record was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the payroll date
  """
  id: uuid
  """
  Additional notes about this payroll date
  """
  notes: String
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: date
  """
  Reference to the payroll this date belongs to
  """
  payrollId: uuid
  """
  Date when payroll processing must be completed
  """
  processingDate: date
  """
  Timestamp when the date record was last updated
  """
  updatedAt: timestamptz
}

"""
order by min() on columns of table "payroll_dates"
"""
input payroll_dates_min_order_by {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: order_by
  """
  Timestamp when the date record was created
  """
  createdAt: order_by
  """
  Unique identifier for the payroll date
  """
  id: order_by
  """
  Additional notes about this payroll date
  """
  notes: order_by
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: order_by
  """
  Reference to the payroll this date belongs to
  """
  payrollId: order_by
  """
  Date when payroll processing must be completed
  """
  processingDate: order_by
  """
  Timestamp when the date record was last updated
  """
  updatedAt: order_by
}

"""
response of any mutation on the table "payroll_dates"
"""
type payroll_dates_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_dates!]!
}

"""
input type for inserting object relation for remote table "payroll_dates"
"""
input payroll_dates_obj_rel_insert_input {
  data: payroll_dates_insert_input!
  """
  upsert condition
  """
  on_conflict: payroll_dates_on_conflict
}

"""
on_conflict condition type for table "payroll_dates"
"""
input payroll_dates_on_conflict {
  constraint: payroll_dates_constraint!
  update_columns: [payroll_dates_update_column!]! = []
  where: payroll_dates_bool_exp
}

"""
Ordering options when selecting data from "payroll_dates".
"""
input payroll_dates_order_by {
  adjustedEftDate: order_by
  createdAt: order_by
  id: order_by
  notes: order_by
  originalEftDate: order_by
  payroll: payrolls_order_by
  payrollId: order_by
  payroll_assignment: payroll_assignments_order_by
  payroll_assignment_audits_aggregate: payroll_assignment_audit_aggregate_order_by
  processingDate: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: payroll_dates
"""
input payroll_dates_pk_columns_input {
  """
  Unique identifier for the payroll date
  """
  id: uuid!
}

"""
select columns of table "payroll_dates"
"""
enum payroll_dates_select_column {
  """
  column name
  """
  adjustedEftDate
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  notes
  """
  column name
  """
  originalEftDate
  """
  column name
  """
  payrollId
  """
  column name
  """
  processingDate
  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "payroll_dates"
"""
input payroll_dates_set_input {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: date
  """
  Timestamp when the date record was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the payroll date
  """
  id: uuid
  """
  Additional notes about this payroll date
  """
  notes: String
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: date
  """
  Reference to the payroll this date belongs to
  """
  payrollId: uuid
  """
  Date when payroll processing must be completed
  """
  processingDate: date
  """
  Timestamp when the date record was last updated
  """
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payroll_dates"
"""
input payroll_dates_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_dates_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_dates_stream_cursor_value_input {
  """
  Final EFT date after holiday and weekend adjustments
  """
  adjustedEftDate: date
  """
  Timestamp when the date record was created
  """
  createdAt: timestamptz
  """
  Unique identifier for the payroll date
  """
  id: uuid
  """
  Additional notes about this payroll date
  """
  notes: String
  """
  Originally calculated EFT date before adjustments
  """
  originalEftDate: date
  """
  Reference to the payroll this date belongs to
  """
  payrollId: uuid
  """
  Date when payroll processing must be completed
  """
  processingDate: date
  """
  Timestamp when the date record was last updated
  """
  updatedAt: timestamptz
}

"""
update columns of table "payroll_dates"
"""
enum payroll_dates_update_column {
  """
  column name
  """
  adjustedEftDate
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  notes
  """
  column name
  """
  originalEftDate
  """
  column name
  """
  payrollId
  """
  column name
  """
  processingDate
  """
  column name
  """
  updatedAt
}

input payroll_dates_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_dates_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_dates_bool_exp!
}

scalar payroll_status

"""
Boolean expression to compare columns of type "payroll_status". All fields are combined with logical 'AND'.
"""
input payroll_status_comparison_exp {
  _eq: payroll_status
  _gt: payroll_status
  _gte: payroll_status
  _in: [payroll_status!]
  _is_null: Boolean
  _lt: payroll_status
  _lte: payroll_status
  _neq: payroll_status
  _nin: [payroll_status!]
}

"""
columns and relationships of "payroll_triggers_status"
"""
type payroll_triggers_status {
  action_statement: String
  action_timing: String
  event_manipulation: String
  event_object_table: name
  trigger_name: name
}

"""
aggregated selection of "payroll_triggers_status"
"""
type payroll_triggers_status_aggregate {
  aggregate: payroll_triggers_status_aggregate_fields
  nodes: [payroll_triggers_status!]!
}

"""
aggregate fields of "payroll_triggers_status"
"""
type payroll_triggers_status_aggregate_fields {
  count(
    columns: [payroll_triggers_status_select_column!]
    distinct: Boolean
  ): Int!
  max: payroll_triggers_status_max_fields
  min: payroll_triggers_status_min_fields
}

"""
Boolean expression to filter rows from the table "payroll_triggers_status". All fields are combined with a logical 'AND'.
"""
input payroll_triggers_status_bool_exp {
  _and: [payroll_triggers_status_bool_exp!]
  _not: payroll_triggers_status_bool_exp
  _or: [payroll_triggers_status_bool_exp!]
  action_statement: String_comparison_exp
  action_timing: String_comparison_exp
  event_manipulation: String_comparison_exp
  event_object_table: name_comparison_exp
  trigger_name: name_comparison_exp
}

"""
aggregate max on columns
"""
type payroll_triggers_status_max_fields {
  action_statement: String
  action_timing: String
  event_manipulation: String
}

"""
aggregate min on columns
"""
type payroll_triggers_status_min_fields {
  action_statement: String
  action_timing: String
  event_manipulation: String
}

"""
Ordering options when selecting data from "payroll_triggers_status".
"""
input payroll_triggers_status_order_by {
  action_statement: order_by
  action_timing: order_by
  event_manipulation: order_by
  event_object_table: order_by
  trigger_name: order_by
}

"""
select columns of table "payroll_triggers_status"
"""
enum payroll_triggers_status_select_column {
  """
  column name
  """
  action_statement
  """
  column name
  """
  action_timing
  """
  column name
  """
  event_manipulation
  """
  column name
  """
  event_object_table
  """
  column name
  """
  trigger_name
}

"""
Streaming cursor of the table "payroll_triggers_status"
"""
input payroll_triggers_status_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_triggers_status_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_triggers_status_stream_cursor_value_input {
  action_statement: String
  action_timing: String
  event_manipulation: String
  event_object_table: name
  trigger_name: name
}

"""
columns and relationships of "payroll_version_history_results"
"""
type payroll_version_history_results {
  active: Boolean!
  go_live_date: date
  id: uuid!
  is_current: Boolean!
  name: String!
  payroll_id: uuid!
  queried_at: timestamptz
  superseded_date: date
  version_number: Int!
  version_reason: String
}

type payroll_version_history_results_aggregate {
  aggregate: payroll_version_history_results_aggregate_fields
  nodes: [payroll_version_history_results!]!
}

"""
aggregate fields of "payroll_version_history_results"
"""
type payroll_version_history_results_aggregate_fields {
  avg: payroll_version_history_results_avg_fields
  count(
    columns: [payroll_version_history_results_select_column!]
    distinct: Boolean
  ): Int!
  max: payroll_version_history_results_max_fields
  min: payroll_version_history_results_min_fields
  stddev: payroll_version_history_results_stddev_fields
  stddev_pop: payroll_version_history_results_stddev_pop_fields
  stddev_samp: payroll_version_history_results_stddev_samp_fields
  sum: payroll_version_history_results_sum_fields
  var_pop: payroll_version_history_results_var_pop_fields
  var_samp: payroll_version_history_results_var_samp_fields
  variance: payroll_version_history_results_variance_fields
}

"""
aggregate avg on columns
"""
type payroll_version_history_results_avg_fields {
  version_number: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_history_results". All fields are combined with a logical 'AND'.
"""
input payroll_version_history_results_bool_exp {
  _and: [payroll_version_history_results_bool_exp!]
  _not: payroll_version_history_results_bool_exp
  _or: [payroll_version_history_results_bool_exp!]
  active: Boolean_comparison_exp
  go_live_date: date_comparison_exp
  id: uuid_comparison_exp
  is_current: Boolean_comparison_exp
  name: String_comparison_exp
  payroll_id: uuid_comparison_exp
  queried_at: timestamptz_comparison_exp
  superseded_date: date_comparison_exp
  version_number: Int_comparison_exp
  version_reason: String_comparison_exp
}

"""
unique or primary key constraints on table "payroll_version_history_results"
"""
enum payroll_version_history_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_history_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_history_results"
"""
input payroll_version_history_results_inc_input {
  version_number: Int
}

"""
input type for inserting data into table "payroll_version_history_results"
"""
input payroll_version_history_results_insert_input {
  active: Boolean
  go_live_date: date
  id: uuid
  is_current: Boolean
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""
aggregate max on columns
"""
type payroll_version_history_results_max_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""
aggregate min on columns
"""
type payroll_version_history_results_min_fields {
  go_live_date: date
  id: uuid
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""
response of any mutation on the table "payroll_version_history_results"
"""
type payroll_version_history_results_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_version_history_results!]!
}

"""
on_conflict condition type for table "payroll_version_history_results"
"""
input payroll_version_history_results_on_conflict {
  constraint: payroll_version_history_results_constraint!
  update_columns: [payroll_version_history_results_update_column!]! = []
  where: payroll_version_history_results_bool_exp
}

"""
Ordering options when selecting data from "payroll_version_history_results".
"""
input payroll_version_history_results_order_by {
  active: order_by
  go_live_date: order_by
  id: order_by
  is_current: order_by
  name: order_by
  payroll_id: order_by
  queried_at: order_by
  superseded_date: order_by
  version_number: order_by
  version_reason: order_by
}

"""
primary key columns input for table: payroll_version_history_results
"""
input payroll_version_history_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_version_history_results"
"""
enum payroll_version_history_results_select_column {
  """
  column name
  """
  active
  """
  column name
  """
  go_live_date
  """
  column name
  """
  id
  """
  column name
  """
  is_current
  """
  column name
  """
  name
  """
  column name
  """
  payroll_id
  """
  column name
  """
  queried_at
  """
  column name
  """
  superseded_date
  """
  column name
  """
  version_number
  """
  column name
  """
  version_reason
}

"""
input type for updating data in table "payroll_version_history_results"
"""
input payroll_version_history_results_set_input {
  active: Boolean
  go_live_date: date
  id: uuid
  is_current: Boolean
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""
aggregate stddev on columns
"""
type payroll_version_history_results_stddev_fields {
  version_number: Float
}

"""
aggregate stddev_pop on columns
"""
type payroll_version_history_results_stddev_pop_fields {
  version_number: Float
}

"""
aggregate stddev_samp on columns
"""
type payroll_version_history_results_stddev_samp_fields {
  version_number: Float
}

"""
Streaming cursor of the table "payroll_version_history_results"
"""
input payroll_version_history_results_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_version_history_results_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_version_history_results_stream_cursor_value_input {
  active: Boolean
  go_live_date: date
  id: uuid
  is_current: Boolean
  name: String
  payroll_id: uuid
  queried_at: timestamptz
  superseded_date: date
  version_number: Int
  version_reason: String
}

"""
aggregate sum on columns
"""
type payroll_version_history_results_sum_fields {
  version_number: Int
}

"""
update columns of table "payroll_version_history_results"
"""
enum payroll_version_history_results_update_column {
  """
  column name
  """
  active
  """
  column name
  """
  go_live_date
  """
  column name
  """
  id
  """
  column name
  """
  is_current
  """
  column name
  """
  name
  """
  column name
  """
  payroll_id
  """
  column name
  """
  queried_at
  """
  column name
  """
  superseded_date
  """
  column name
  """
  version_number
  """
  column name
  """
  version_reason
}

input payroll_version_history_results_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: payroll_version_history_results_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_version_history_results_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_version_history_results_bool_exp!
}

"""
aggregate var_pop on columns
"""
type payroll_version_history_results_var_pop_fields {
  version_number: Float
}

"""
aggregate var_samp on columns
"""
type payroll_version_history_results_var_samp_fields {
  version_number: Float
}

"""
aggregate variance on columns
"""
type payroll_version_history_results_variance_fields {
  version_number: Float
}

"""
columns and relationships of "payroll_version_results"
"""
type payroll_version_results {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int!
  id: uuid!
  message: String!
  new_payroll_id: uuid!
  new_version_number: Int!
  old_payroll_id: uuid!
}

type payroll_version_results_aggregate {
  aggregate: payroll_version_results_aggregate_fields
  nodes: [payroll_version_results!]!
}

"""
aggregate fields of "payroll_version_results"
"""
type payroll_version_results_aggregate_fields {
  avg: payroll_version_results_avg_fields
  count(
    columns: [payroll_version_results_select_column!]
    distinct: Boolean
  ): Int!
  max: payroll_version_results_max_fields
  min: payroll_version_results_min_fields
  stddev: payroll_version_results_stddev_fields
  stddev_pop: payroll_version_results_stddev_pop_fields
  stddev_samp: payroll_version_results_stddev_samp_fields
  sum: payroll_version_results_sum_fields
  var_pop: payroll_version_results_var_pop_fields
  var_samp: payroll_version_results_var_samp_fields
  variance: payroll_version_results_variance_fields
}

"""
aggregate avg on columns
"""
type payroll_version_results_avg_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_results". All fields are combined with a logical 'AND'.
"""
input payroll_version_results_bool_exp {
  _and: [payroll_version_results_bool_exp!]
  _not: payroll_version_results_bool_exp
  _or: [payroll_version_results_bool_exp!]
  created_at: timestamptz_comparison_exp
  created_by_user_id: uuid_comparison_exp
  dates_deleted: Int_comparison_exp
  id: uuid_comparison_exp
  message: String_comparison_exp
  new_payroll_id: uuid_comparison_exp
  new_version_number: Int_comparison_exp
  old_payroll_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "payroll_version_results"
"""
enum payroll_version_results_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_results"
"""
input payroll_version_results_inc_input {
  dates_deleted: Int
  new_version_number: Int
}

"""
input type for inserting data into table "payroll_version_results"
"""
input payroll_version_results_insert_input {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""
aggregate max on columns
"""
type payroll_version_results_max_fields {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""
aggregate min on columns
"""
type payroll_version_results_min_fields {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""
response of any mutation on the table "payroll_version_results"
"""
type payroll_version_results_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payroll_version_results!]!
}

"""
on_conflict condition type for table "payroll_version_results"
"""
input payroll_version_results_on_conflict {
  constraint: payroll_version_results_constraint!
  update_columns: [payroll_version_results_update_column!]! = []
  where: payroll_version_results_bool_exp
}

"""
Ordering options when selecting data from "payroll_version_results".
"""
input payroll_version_results_order_by {
  created_at: order_by
  created_by_user_id: order_by
  dates_deleted: order_by
  id: order_by
  message: order_by
  new_payroll_id: order_by
  new_version_number: order_by
  old_payroll_id: order_by
}

"""
primary key columns input for table: payroll_version_results
"""
input payroll_version_results_pk_columns_input {
  id: uuid!
}

"""
select columns of table "payroll_version_results"
"""
enum payroll_version_results_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  created_by_user_id
  """
  column name
  """
  dates_deleted
  """
  column name
  """
  id
  """
  column name
  """
  message
  """
  column name
  """
  new_payroll_id
  """
  column name
  """
  new_version_number
  """
  column name
  """
  old_payroll_id
}

"""
input type for updating data in table "payroll_version_results"
"""
input payroll_version_results_set_input {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""
aggregate stddev on columns
"""
type payroll_version_results_stddev_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
aggregate stddev_pop on columns
"""
type payroll_version_results_stddev_pop_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
aggregate stddev_samp on columns
"""
type payroll_version_results_stddev_samp_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
Streaming cursor of the table "payroll_version_results"
"""
input payroll_version_results_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payroll_version_results_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payroll_version_results_stream_cursor_value_input {
  created_at: timestamptz
  created_by_user_id: uuid
  dates_deleted: Int
  id: uuid
  message: String
  new_payroll_id: uuid
  new_version_number: Int
  old_payroll_id: uuid
}

"""
aggregate sum on columns
"""
type payroll_version_results_sum_fields {
  dates_deleted: Int
  new_version_number: Int
}

"""
update columns of table "payroll_version_results"
"""
enum payroll_version_results_update_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  created_by_user_id
  """
  column name
  """
  dates_deleted
  """
  column name
  """
  id
  """
  column name
  """
  message
  """
  column name
  """
  new_payroll_id
  """
  column name
  """
  new_version_number
  """
  column name
  """
  old_payroll_id
}

input payroll_version_results_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: payroll_version_results_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payroll_version_results_set_input
  """
  filter the rows which have to be updated
  """
  where: payroll_version_results_bool_exp!
}

"""
aggregate var_pop on columns
"""
type payroll_version_results_var_pop_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
aggregate var_samp on columns
"""
type payroll_version_results_var_samp_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
aggregate variance on columns
"""
type payroll_version_results_variance_fields {
  dates_deleted: Float
  new_version_number: Float
}

"""
columns and relationships of "payrolls"
"""
type payrolls {
  """
  An object relationship
  """
  backupConsultant: users
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: uuid
  """
  An array relationship
  """
  billingItems(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): [billing_items!]!
  """
  An aggregate relationship
  """
  billingItems_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): billing_items_aggregate!
  """
  An array relationship
  """
  childPayrolls(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  childPayrolls_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  An object relationship
  """
  client: clients!
  """
  Reference to the client this payroll belongs to
  """
  clientId: uuid!
  """
  Timestamp when the payroll was created
  """
  createdAt: timestamptz
  createdByUserId: uuid
  """
  Reference to the payroll cycle
  """
  cycleId: uuid!
  """
  Reference to the payroll date type
  """
  dateTypeId: uuid!
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  The date when the payroll went live in the system
  """
  goLiveDate: date
  """
  Unique identifier for the payroll
  """
  id: uuid!
  """
  An object relationship
  """
  manager: users
  """
  Manager overseeing this payroll
  """
  managerUserId: uuid
  """
  Name of the payroll
  """
  name: String!
  """
  An object relationship
  """
  parentPayroll: payrolls
  parentPayrollId: uuid
  """
  An object relationship
  """
  payrollCycle: payroll_cycles!
  """
  An object relationship
  """
  payrollDateType: payroll_date_types!
  """
  An array relationship
  """
  payrollDates(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!
  """
  An aggregate relationship
  """
  payrollDates_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!
  """
  External payroll system used for this client
  """
  payrollSystem: String
  """
  An object relationship
  """
  primaryConsultant: users
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: uuid
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int!
  """
  Number of hours required to process this payroll
  """
  processingTime: Int!
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: payroll_status!
  supersededDate: date
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregated selection of "payrolls"
"""
type payrolls_aggregate {
  aggregate: payrolls_aggregate_fields
  nodes: [payrolls!]!
}

input payrolls_aggregate_bool_exp {
  count: payrolls_aggregate_bool_exp_count
}

input payrolls_aggregate_bool_exp_count {
  arguments: [payrolls_select_column!]
  distinct: Boolean
  filter: payrolls_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "payrolls"
"""
type payrolls_aggregate_fields {
  avg: payrolls_avg_fields
  count(columns: [payrolls_select_column!], distinct: Boolean): Int!
  max: payrolls_max_fields
  min: payrolls_min_fields
  stddev: payrolls_stddev_fields
  stddev_pop: payrolls_stddev_pop_fields
  stddev_samp: payrolls_stddev_samp_fields
  sum: payrolls_sum_fields
  var_pop: payrolls_var_pop_fields
  var_samp: payrolls_var_samp_fields
  variance: payrolls_variance_fields
}

"""
order by aggregate values of table "payrolls"
"""
input payrolls_aggregate_order_by {
  avg: payrolls_avg_order_by
  count: order_by
  max: payrolls_max_order_by
  min: payrolls_min_order_by
  stddev: payrolls_stddev_order_by
  stddev_pop: payrolls_stddev_pop_order_by
  stddev_samp: payrolls_stddev_samp_order_by
  sum: payrolls_sum_order_by
  var_pop: payrolls_var_pop_order_by
  var_samp: payrolls_var_samp_order_by
  variance: payrolls_variance_order_by
}

"""
input type for inserting array relation for remote table "payrolls"
"""
input payrolls_arr_rel_insert_input {
  data: [payrolls_insert_input!]!
  """
  upsert condition
  """
  on_conflict: payrolls_on_conflict
}

"""
aggregate avg on columns
"""
type payrolls_avg_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Float
  """
  Number of employees in this payroll
  """
  employeeCount: Float
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Float
  """
  Number of hours required to process this payroll
  """
  processingTime: Float
  versionNumber: Float
}

"""
order by avg() on columns of table "payrolls"
"""
input payrolls_avg_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

"""
Boolean expression to filter rows from the table "payrolls". All fields are combined with a logical 'AND'.
"""
input payrolls_bool_exp {
  _and: [payrolls_bool_exp!]
  _not: payrolls_bool_exp
  _or: [payrolls_bool_exp!]
  backupConsultant: users_bool_exp
  backupConsultantUserId: uuid_comparison_exp
  billingItems: billing_items_bool_exp
  billingItems_aggregate: billing_items_aggregate_bool_exp
  childPayrolls: payrolls_bool_exp
  childPayrolls_aggregate: payrolls_aggregate_bool_exp
  client: clients_bool_exp
  clientId: uuid_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdByUserId: uuid_comparison_exp
  cycleId: uuid_comparison_exp
  dateTypeId: uuid_comparison_exp
  dateValue: Int_comparison_exp
  employeeCount: Int_comparison_exp
  goLiveDate: date_comparison_exp
  id: uuid_comparison_exp
  manager: users_bool_exp
  managerUserId: uuid_comparison_exp
  name: String_comparison_exp
  parentPayroll: payrolls_bool_exp
  parentPayrollId: uuid_comparison_exp
  payrollCycle: payroll_cycles_bool_exp
  payrollDateType: payroll_date_types_bool_exp
  payrollDates: payroll_dates_bool_exp
  payrollDates_aggregate: payroll_dates_aggregate_bool_exp
  payrollSystem: String_comparison_exp
  primaryConsultant: users_bool_exp
  primaryConsultantUserId: uuid_comparison_exp
  processingDaysBeforeEft: Int_comparison_exp
  processingTime: Int_comparison_exp
  status: payroll_status_comparison_exp
  supersededDate: date_comparison_exp
  updatedAt: timestamptz_comparison_exp
  versionNumber: Int_comparison_exp
  versionReason: String_comparison_exp
}

"""
unique or primary key constraints on table "payrolls"
"""
enum payrolls_constraint {
  """
  unique or primary key constraint on columns
  """
  only_one_current_version_per_family
  """
  unique or primary key constraint on columns "id"
  """
  payrolls_pkey
}

"""
input type for incrementing numeric columns in table "payrolls"
"""
input payrolls_inc_input {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int
  """
  Number of hours required to process this payroll
  """
  processingTime: Int
  versionNumber: Int
}

"""
input type for inserting data into table "payrolls"
"""
input payrolls_insert_input {
  backupConsultant: users_obj_rel_insert_input
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: uuid
  billingItems: billing_items_arr_rel_insert_input
  childPayrolls: payrolls_arr_rel_insert_input
  client: clients_obj_rel_insert_input
  """
  Reference to the client this payroll belongs to
  """
  clientId: uuid
  """
  Timestamp when the payroll was created
  """
  createdAt: timestamptz
  createdByUserId: uuid
  """
  Reference to the payroll cycle
  """
  cycleId: uuid
  """
  Reference to the payroll date type
  """
  dateTypeId: uuid
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  The date when the payroll went live in the system
  """
  goLiveDate: date
  """
  Unique identifier for the payroll
  """
  id: uuid
  manager: users_obj_rel_insert_input
  """
  Manager overseeing this payroll
  """
  managerUserId: uuid
  """
  Name of the payroll
  """
  name: String
  parentPayroll: payrolls_obj_rel_insert_input
  parentPayrollId: uuid
  payrollCycle: payroll_cycles_obj_rel_insert_input
  payrollDateType: payroll_date_types_obj_rel_insert_input
  payrollDates: payroll_dates_arr_rel_insert_input
  """
  External payroll system used for this client
  """
  payrollSystem: String
  primaryConsultant: users_obj_rel_insert_input
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: uuid
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int
  """
  Number of hours required to process this payroll
  """
  processingTime: Int
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: payroll_status
  supersededDate: date
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregate max on columns
"""
type payrolls_max_fields {
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: uuid
  """
  Reference to the client this payroll belongs to
  """
  clientId: uuid
  """
  Timestamp when the payroll was created
  """
  createdAt: timestamptz
  createdByUserId: uuid
  """
  Reference to the payroll cycle
  """
  cycleId: uuid
  """
  Reference to the payroll date type
  """
  dateTypeId: uuid
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  The date when the payroll went live in the system
  """
  goLiveDate: date
  """
  Unique identifier for the payroll
  """
  id: uuid
  """
  Manager overseeing this payroll
  """
  managerUserId: uuid
  """
  Name of the payroll
  """
  name: String
  parentPayrollId: uuid
  """
  External payroll system used for this client
  """
  payrollSystem: String
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: uuid
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int
  """
  Number of hours required to process this payroll
  """
  processingTime: Int
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: payroll_status
  supersededDate: date
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
order by max() on columns of table "payrolls"
"""
input payrolls_max_order_by {
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: order_by
  """
  Reference to the client this payroll belongs to
  """
  clientId: order_by
  """
  Timestamp when the payroll was created
  """
  createdAt: order_by
  createdByUserId: order_by
  """
  Reference to the payroll cycle
  """
  cycleId: order_by
  """
  Reference to the payroll date type
  """
  dateTypeId: order_by
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  The date when the payroll went live in the system
  """
  goLiveDate: order_by
  """
  Unique identifier for the payroll
  """
  id: order_by
  """
  Manager overseeing this payroll
  """
  managerUserId: order_by
  """
  Name of the payroll
  """
  name: order_by
  parentPayrollId: order_by
  """
  External payroll system used for this client
  """
  payrollSystem: order_by
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: order_by
  supersededDate: order_by
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: order_by
  versionNumber: order_by
  versionReason: order_by
}

"""
aggregate min on columns
"""
type payrolls_min_fields {
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: uuid
  """
  Reference to the client this payroll belongs to
  """
  clientId: uuid
  """
  Timestamp when the payroll was created
  """
  createdAt: timestamptz
  createdByUserId: uuid
  """
  Reference to the payroll cycle
  """
  cycleId: uuid
  """
  Reference to the payroll date type
  """
  dateTypeId: uuid
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  The date when the payroll went live in the system
  """
  goLiveDate: date
  """
  Unique identifier for the payroll
  """
  id: uuid
  """
  Manager overseeing this payroll
  """
  managerUserId: uuid
  """
  Name of the payroll
  """
  name: String
  parentPayrollId: uuid
  """
  External payroll system used for this client
  """
  payrollSystem: String
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: uuid
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int
  """
  Number of hours required to process this payroll
  """
  processingTime: Int
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: payroll_status
  supersededDate: date
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
order by min() on columns of table "payrolls"
"""
input payrolls_min_order_by {
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: order_by
  """
  Reference to the client this payroll belongs to
  """
  clientId: order_by
  """
  Timestamp when the payroll was created
  """
  createdAt: order_by
  createdByUserId: order_by
  """
  Reference to the payroll cycle
  """
  cycleId: order_by
  """
  Reference to the payroll date type
  """
  dateTypeId: order_by
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  The date when the payroll went live in the system
  """
  goLiveDate: order_by
  """
  Unique identifier for the payroll
  """
  id: order_by
  """
  Manager overseeing this payroll
  """
  managerUserId: order_by
  """
  Name of the payroll
  """
  name: order_by
  parentPayrollId: order_by
  """
  External payroll system used for this client
  """
  payrollSystem: order_by
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: order_by
  supersededDate: order_by
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: order_by
  versionNumber: order_by
  versionReason: order_by
}

"""
response of any mutation on the table "payrolls"
"""
type payrolls_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [payrolls!]!
}

"""
input type for inserting object relation for remote table "payrolls"
"""
input payrolls_obj_rel_insert_input {
  data: payrolls_insert_input!
  """
  upsert condition
  """
  on_conflict: payrolls_on_conflict
}

"""
on_conflict condition type for table "payrolls"
"""
input payrolls_on_conflict {
  constraint: payrolls_constraint!
  update_columns: [payrolls_update_column!]! = []
  where: payrolls_bool_exp
}

"""
Ordering options when selecting data from "payrolls".
"""
input payrolls_order_by {
  backupConsultant: users_order_by
  backupConsultantUserId: order_by
  billingItems_aggregate: billing_items_aggregate_order_by
  childPayrolls_aggregate: payrolls_aggregate_order_by
  client: clients_order_by
  clientId: order_by
  createdAt: order_by
  createdByUserId: order_by
  cycleId: order_by
  dateTypeId: order_by
  dateValue: order_by
  employeeCount: order_by
  goLiveDate: order_by
  id: order_by
  manager: users_order_by
  managerUserId: order_by
  name: order_by
  parentPayroll: payrolls_order_by
  parentPayrollId: order_by
  payrollCycle: payroll_cycles_order_by
  payrollDateType: payroll_date_types_order_by
  payrollDates_aggregate: payroll_dates_aggregate_order_by
  payrollSystem: order_by
  primaryConsultant: users_order_by
  primaryConsultantUserId: order_by
  processingDaysBeforeEft: order_by
  processingTime: order_by
  status: order_by
  supersededDate: order_by
  updatedAt: order_by
  versionNumber: order_by
  versionReason: order_by
}

"""
primary key columns input for table: payrolls
"""
input payrolls_pk_columns_input {
  """
  Unique identifier for the payroll
  """
  id: uuid!
}

"""
select columns of table "payrolls"
"""
enum payrolls_select_column {
  """
  column name
  """
  backupConsultantUserId
  """
  column name
  """
  clientId
  """
  column name
  """
  createdAt
  """
  column name
  """
  createdByUserId
  """
  column name
  """
  cycleId
  """
  column name
  """
  dateTypeId
  """
  column name
  """
  dateValue
  """
  column name
  """
  employeeCount
  """
  column name
  """
  goLiveDate
  """
  column name
  """
  id
  """
  column name
  """
  managerUserId
  """
  column name
  """
  name
  """
  column name
  """
  parentPayrollId
  """
  column name
  """
  payrollSystem
  """
  column name
  """
  primaryConsultantUserId
  """
  column name
  """
  processingDaysBeforeEft
  """
  column name
  """
  processingTime
  """
  column name
  """
  status
  """
  column name
  """
  supersededDate
  """
  column name
  """
  updatedAt
  """
  column name
  """
  versionNumber
  """
  column name
  """
  versionReason
}

"""
input type for updating data in table "payrolls"
"""
input payrolls_set_input {
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: uuid
  """
  Reference to the client this payroll belongs to
  """
  clientId: uuid
  """
  Timestamp when the payroll was created
  """
  createdAt: timestamptz
  createdByUserId: uuid
  """
  Reference to the payroll cycle
  """
  cycleId: uuid
  """
  Reference to the payroll date type
  """
  dateTypeId: uuid
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  The date when the payroll went live in the system
  """
  goLiveDate: date
  """
  Unique identifier for the payroll
  """
  id: uuid
  """
  Manager overseeing this payroll
  """
  managerUserId: uuid
  """
  Name of the payroll
  """
  name: String
  parentPayrollId: uuid
  """
  External payroll system used for this client
  """
  payrollSystem: String
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: uuid
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int
  """
  Number of hours required to process this payroll
  """
  processingTime: Int
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: payroll_status
  supersededDate: date
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregate stddev on columns
"""
type payrolls_stddev_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Float
  """
  Number of employees in this payroll
  """
  employeeCount: Float
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Float
  """
  Number of hours required to process this payroll
  """
  processingTime: Float
  versionNumber: Float
}

"""
order by stddev() on columns of table "payrolls"
"""
input payrolls_stddev_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

"""
aggregate stddev_pop on columns
"""
type payrolls_stddev_pop_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Float
  """
  Number of employees in this payroll
  """
  employeeCount: Float
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Float
  """
  Number of hours required to process this payroll
  """
  processingTime: Float
  versionNumber: Float
}

"""
order by stddev_pop() on columns of table "payrolls"
"""
input payrolls_stddev_pop_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

"""
aggregate stddev_samp on columns
"""
type payrolls_stddev_samp_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Float
  """
  Number of employees in this payroll
  """
  employeeCount: Float
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Float
  """
  Number of hours required to process this payroll
  """
  processingTime: Float
  versionNumber: Float
}

"""
order by stddev_samp() on columns of table "payrolls"
"""
input payrolls_stddev_samp_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

"""
Streaming cursor of the table "payrolls"
"""
input payrolls_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: payrolls_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input payrolls_stream_cursor_value_input {
  """
  Backup consultant for this payroll
  """
  backupConsultantUserId: uuid
  """
  Reference to the client this payroll belongs to
  """
  clientId: uuid
  """
  Timestamp when the payroll was created
  """
  createdAt: timestamptz
  createdByUserId: uuid
  """
  Reference to the payroll cycle
  """
  cycleId: uuid
  """
  Reference to the payroll date type
  """
  dateTypeId: uuid
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  The date when the payroll went live in the system
  """
  goLiveDate: date
  """
  Unique identifier for the payroll
  """
  id: uuid
  """
  Manager overseeing this payroll
  """
  managerUserId: uuid
  """
  Name of the payroll
  """
  name: String
  parentPayrollId: uuid
  """
  External payroll system used for this client
  """
  payrollSystem: String
  """
  Primary consultant responsible for this payroll
  """
  primaryConsultantUserId: uuid
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int
  """
  Number of hours required to process this payroll
  """
  processingTime: Int
  """
  Current status of the payroll (Implementation, Active, Inactive)
  """
  status: payroll_status
  supersededDate: date
  """
  Timestamp when the payroll was last updated
  """
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregate sum on columns
"""
type payrolls_sum_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Int
  """
  Number of employees in this payroll
  """
  employeeCount: Int
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Int
  """
  Number of hours required to process this payroll
  """
  processingTime: Int
  versionNumber: Int
}

"""
order by sum() on columns of table "payrolls"
"""
input payrolls_sum_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

"""
update columns of table "payrolls"
"""
enum payrolls_update_column {
  """
  column name
  """
  backupConsultantUserId
  """
  column name
  """
  clientId
  """
  column name
  """
  createdAt
  """
  column name
  """
  createdByUserId
  """
  column name
  """
  cycleId
  """
  column name
  """
  dateTypeId
  """
  column name
  """
  dateValue
  """
  column name
  """
  employeeCount
  """
  column name
  """
  goLiveDate
  """
  column name
  """
  id
  """
  column name
  """
  managerUserId
  """
  column name
  """
  name
  """
  column name
  """
  parentPayrollId
  """
  column name
  """
  payrollSystem
  """
  column name
  """
  primaryConsultantUserId
  """
  column name
  """
  processingDaysBeforeEft
  """
  column name
  """
  processingTime
  """
  column name
  """
  status
  """
  column name
  """
  supersededDate
  """
  column name
  """
  updatedAt
  """
  column name
  """
  versionNumber
  """
  column name
  """
  versionReason
}

input payrolls_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: payrolls_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: payrolls_set_input
  """
  filter the rows which have to be updated
  """
  where: payrolls_bool_exp!
}

"""
aggregate var_pop on columns
"""
type payrolls_var_pop_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Float
  """
  Number of employees in this payroll
  """
  employeeCount: Float
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Float
  """
  Number of hours required to process this payroll
  """
  processingTime: Float
  versionNumber: Float
}

"""
order by var_pop() on columns of table "payrolls"
"""
input payrolls_var_pop_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

"""
aggregate var_samp on columns
"""
type payrolls_var_samp_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Float
  """
  Number of employees in this payroll
  """
  employeeCount: Float
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Float
  """
  Number of hours required to process this payroll
  """
  processingTime: Float
  versionNumber: Float
}

"""
order by var_samp() on columns of table "payrolls"
"""
input payrolls_var_samp_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

"""
aggregate variance on columns
"""
type payrolls_variance_fields {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: Float
  """
  Number of employees in this payroll
  """
  employeeCount: Float
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: Float
  """
  Number of hours required to process this payroll
  """
  processingTime: Float
  versionNumber: Float
}

"""
order by variance() on columns of table "payrolls"
"""
input payrolls_variance_order_by {
  """
  Specific value for date calculation (e.g., day of month)
  """
  dateValue: order_by
  """
  Number of employees in this payroll
  """
  employeeCount: order_by
  """
  Number of days before EFT that processing must complete
  """
  processingDaysBeforeEft: order_by
  """
  Number of hours required to process this payroll
  """
  processingTime: order_by
  versionNumber: order_by
}

scalar permission_action

"""
Boolean expression to compare columns of type "permission_action". All fields are combined with logical 'AND'.
"""
input permission_action_comparison_exp {
  _eq: permission_action
  _gt: permission_action
  _gte: permission_action
  _in: [permission_action!]
  _is_null: Boolean
  _lt: permission_action
  _lte: permission_action
  _neq: permission_action
  _nin: [permission_action!]
}

"""
Audit log for permission changes and access attempts
"""
type permission_audit_log {
  action: String!
  created_at: timestamptz!
  id: uuid!
  new_value(
    """
    JSON select path
    """
    path: String
  ): jsonb
  operation: String!
  """
  An object relationship
  """
  performed_by_user: users
  previous_value(
    """
    JSON select path
    """
    path: String
  ): jsonb
  reason: String
  resource: String!
  targetUserId: uuid
  target_role: String
  """
  An object relationship
  """
  target_user: users
  timestamp: timestamptz!
  userId: uuid
}

"""
aggregated selection of "permission_audit_log"
"""
type permission_audit_log_aggregate {
  aggregate: permission_audit_log_aggregate_fields
  nodes: [permission_audit_log!]!
}

"""
aggregate fields of "permission_audit_log"
"""
type permission_audit_log_aggregate_fields {
  count(columns: [permission_audit_log_select_column!], distinct: Boolean): Int!
  max: permission_audit_log_max_fields
  min: permission_audit_log_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input permission_audit_log_append_input {
  new_value: jsonb
  previous_value: jsonb
}

"""
Boolean expression to filter rows from the table "permission_audit_log". All fields are combined with a logical 'AND'.
"""
input permission_audit_log_bool_exp {
  _and: [permission_audit_log_bool_exp!]
  _not: permission_audit_log_bool_exp
  _or: [permission_audit_log_bool_exp!]
  action: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  new_value: jsonb_comparison_exp
  operation: String_comparison_exp
  performed_by_user: users_bool_exp
  previous_value: jsonb_comparison_exp
  reason: String_comparison_exp
  resource: String_comparison_exp
  targetUserId: uuid_comparison_exp
  target_role: String_comparison_exp
  target_user: users_bool_exp
  timestamp: timestamptz_comparison_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "permission_audit_log"
"""
enum permission_audit_log_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input permission_audit_log_delete_at_path_input {
  new_value: [String!]
  previous_value: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input permission_audit_log_delete_elem_input {
  new_value: Int
  previous_value: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input permission_audit_log_delete_key_input {
  new_value: String
  previous_value: String
}

"""
input type for inserting data into table "permission_audit_log"
"""
input permission_audit_log_insert_input {
  action: String
  created_at: timestamptz
  id: uuid
  new_value: jsonb
  operation: String
  performed_by_user: users_obj_rel_insert_input
  previous_value: jsonb
  reason: String
  resource: String
  targetUserId: uuid
  target_role: String
  target_user: users_obj_rel_insert_input
  timestamp: timestamptz
  userId: uuid
}

"""
aggregate max on columns
"""
type permission_audit_log_max_fields {
  action: String
  created_at: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  targetUserId: uuid
  target_role: String
  timestamp: timestamptz
  userId: uuid
}

"""
aggregate min on columns
"""
type permission_audit_log_min_fields {
  action: String
  created_at: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  targetUserId: uuid
  target_role: String
  timestamp: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "permission_audit_log"
"""
type permission_audit_log_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [permission_audit_log!]!
}

"""
on_conflict condition type for table "permission_audit_log"
"""
input permission_audit_log_on_conflict {
  constraint: permission_audit_log_constraint!
  update_columns: [permission_audit_log_update_column!]! = []
  where: permission_audit_log_bool_exp
}

"""
Ordering options when selecting data from "permission_audit_log".
"""
input permission_audit_log_order_by {
  action: order_by
  created_at: order_by
  id: order_by
  new_value: order_by
  operation: order_by
  performed_by_user: users_order_by
  previous_value: order_by
  reason: order_by
  resource: order_by
  targetUserId: order_by
  target_role: order_by
  target_user: users_order_by
  timestamp: order_by
  userId: order_by
}

"""
primary key columns input for table: permission_audit_log
"""
input permission_audit_log_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input permission_audit_log_prepend_input {
  new_value: jsonb
  previous_value: jsonb
}

"""
select columns of table "permission_audit_log"
"""
enum permission_audit_log_select_column {
  """
  column name
  """
  action
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  new_value
  """
  column name
  """
  operation
  """
  column name
  """
  previous_value
  """
  column name
  """
  reason
  """
  column name
  """
  resource
  """
  column name
  """
  targetUserId
  """
  column name
  """
  target_role
  """
  column name
  """
  timestamp
  """
  column name
  """
  userId
}

"""
input type for updating data in table "permission_audit_log"
"""
input permission_audit_log_set_input {
  action: String
  created_at: timestamptz
  id: uuid
  new_value: jsonb
  operation: String
  previous_value: jsonb
  reason: String
  resource: String
  targetUserId: uuid
  target_role: String
  timestamp: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "permission_audit_log"
"""
input permission_audit_log_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: permission_audit_log_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input permission_audit_log_stream_cursor_value_input {
  action: String
  created_at: timestamptz
  id: uuid
  new_value: jsonb
  operation: String
  previous_value: jsonb
  reason: String
  resource: String
  targetUserId: uuid
  target_role: String
  timestamp: timestamptz
  userId: uuid
}

"""
update columns of table "permission_audit_log"
"""
enum permission_audit_log_update_column {
  """
  column name
  """
  action
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  new_value
  """
  column name
  """
  operation
  """
  column name
  """
  previous_value
  """
  column name
  """
  reason
  """
  column name
  """
  resource
  """
  column name
  """
  targetUserId
  """
  column name
  """
  target_role
  """
  column name
  """
  timestamp
  """
  column name
  """
  userId
}

input permission_audit_log_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: permission_audit_log_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: permission_audit_log_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: permission_audit_log_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: permission_audit_log_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: permission_audit_log_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: permission_audit_log_set_input
  """
  filter the rows which have to be updated
  """
  where: permission_audit_log_bool_exp!
}

"""
User-specific and role-specific permission overrides
"""
type permission_overrides {
  """
  JSON conditions for conditional permissions
  """
  conditions(
    """
    JSON select path
    """
    path: String
  ): jsonb
  createdAt: timestamptz!
  createdBy: uuid
  """
  An object relationship
  """
  created_by_user: users
  """
  When this override expires (NULL for permanent)
  """
  expiresAt: timestamptz
  """
  Whether the permission is granted (true) or denied (false)
  """
  granted: Boolean!
  id: uuid!
  operation: String!
  """
  An object relationship
  """
  override_user: users
  reason: String
  resource: String!
  """
  Role name for role-based overrides (mutually exclusive with user_id)
  """
  role: String
  updatedAt: timestamptz!
  """
  An object relationship
  """
  user: users
  """
  User ID for user-specific overrides (mutually exclusive with role)
  """
  userId: uuid
}

"""
aggregated selection of "permission_overrides"
"""
type permission_overrides_aggregate {
  aggregate: permission_overrides_aggregate_fields
  nodes: [permission_overrides!]!
}

"""
aggregate fields of "permission_overrides"
"""
type permission_overrides_aggregate_fields {
  count(columns: [permission_overrides_select_column!], distinct: Boolean): Int!
  max: permission_overrides_max_fields
  min: permission_overrides_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input permission_overrides_append_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: jsonb
}

"""
Boolean expression to filter rows from the table "permission_overrides". All fields are combined with a logical 'AND'.
"""
input permission_overrides_bool_exp {
  _and: [permission_overrides_bool_exp!]
  _not: permission_overrides_bool_exp
  _or: [permission_overrides_bool_exp!]
  conditions: jsonb_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdBy: uuid_comparison_exp
  created_by_user: users_bool_exp
  expiresAt: timestamptz_comparison_exp
  granted: Boolean_comparison_exp
  id: uuid_comparison_exp
  operation: String_comparison_exp
  override_user: users_bool_exp
  reason: String_comparison_exp
  resource: String_comparison_exp
  role: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "permission_overrides"
"""
enum permission_overrides_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_overrides_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input permission_overrides_delete_at_path_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input permission_overrides_delete_elem_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input permission_overrides_delete_key_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: String
}

"""
input type for inserting data into table "permission_overrides"
"""
input permission_overrides_insert_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  created_by_user: users_obj_rel_insert_input
  """
  When this override expires (NULL for permanent)
  """
  expiresAt: timestamptz
  """
  Whether the permission is granted (true) or denied (false)
  """
  granted: Boolean
  id: uuid
  operation: String
  override_user: users_obj_rel_insert_input
  reason: String
  resource: String
  """
  Role name for role-based overrides (mutually exclusive with user_id)
  """
  role: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  """
  User ID for user-specific overrides (mutually exclusive with role)
  """
  userId: uuid
}

"""
aggregate max on columns
"""
type permission_overrides_max_fields {
  createdAt: timestamptz
  createdBy: uuid
  """
  When this override expires (NULL for permanent)
  """
  expiresAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  """
  Role name for role-based overrides (mutually exclusive with user_id)
  """
  role: String
  updatedAt: timestamptz
  """
  User ID for user-specific overrides (mutually exclusive with role)
  """
  userId: uuid
}

"""
aggregate min on columns
"""
type permission_overrides_min_fields {
  createdAt: timestamptz
  createdBy: uuid
  """
  When this override expires (NULL for permanent)
  """
  expiresAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  """
  Role name for role-based overrides (mutually exclusive with user_id)
  """
  role: String
  updatedAt: timestamptz
  """
  User ID for user-specific overrides (mutually exclusive with role)
  """
  userId: uuid
}

"""
response of any mutation on the table "permission_overrides"
"""
type permission_overrides_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [permission_overrides!]!
}

"""
on_conflict condition type for table "permission_overrides"
"""
input permission_overrides_on_conflict {
  constraint: permission_overrides_constraint!
  update_columns: [permission_overrides_update_column!]! = []
  where: permission_overrides_bool_exp
}

"""
Ordering options when selecting data from "permission_overrides".
"""
input permission_overrides_order_by {
  conditions: order_by
  createdAt: order_by
  createdBy: order_by
  created_by_user: users_order_by
  expiresAt: order_by
  granted: order_by
  id: order_by
  operation: order_by
  override_user: users_order_by
  reason: order_by
  resource: order_by
  role: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: permission_overrides
"""
input permission_overrides_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input permission_overrides_prepend_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: jsonb
}

"""
select columns of table "permission_overrides"
"""
enum permission_overrides_select_column {
  """
  column name
  """
  conditions
  """
  column name
  """
  createdAt
  """
  column name
  """
  createdBy
  """
  column name
  """
  expiresAt
  """
  column name
  """
  granted
  """
  column name
  """
  id
  """
  column name
  """
  operation
  """
  column name
  """
  reason
  """
  column name
  """
  resource
  """
  column name
  """
  role
  """
  column name
  """
  updatedAt
  """
  column name
  """
  userId
}

"""
input type for updating data in table "permission_overrides"
"""
input permission_overrides_set_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  """
  When this override expires (NULL for permanent)
  """
  expiresAt: timestamptz
  """
  Whether the permission is granted (true) or denied (false)
  """
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """
  Role name for role-based overrides (mutually exclusive with user_id)
  """
  role: String
  updatedAt: timestamptz
  """
  User ID for user-specific overrides (mutually exclusive with role)
  """
  userId: uuid
}

"""
Streaming cursor of the table "permission_overrides"
"""
input permission_overrides_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: permission_overrides_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input permission_overrides_stream_cursor_value_input {
  """
  JSON conditions for conditional permissions
  """
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  """
  When this override expires (NULL for permanent)
  """
  expiresAt: timestamptz
  """
  Whether the permission is granted (true) or denied (false)
  """
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """
  Role name for role-based overrides (mutually exclusive with user_id)
  """
  role: String
  updatedAt: timestamptz
  """
  User ID for user-specific overrides (mutually exclusive with role)
  """
  userId: uuid
}

"""
update columns of table "permission_overrides"
"""
enum permission_overrides_update_column {
  """
  column name
  """
  conditions
  """
  column name
  """
  createdAt
  """
  column name
  """
  createdBy
  """
  column name
  """
  expiresAt
  """
  column name
  """
  granted
  """
  column name
  """
  id
  """
  column name
  """
  operation
  """
  column name
  """
  reason
  """
  column name
  """
  resource
  """
  column name
  """
  role
  """
  column name
  """
  updatedAt
  """
  column name
  """
  userId
}

input permission_overrides_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: permission_overrides_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: permission_overrides_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: permission_overrides_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: permission_overrides_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: permission_overrides_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: permission_overrides_set_input
  """
  filter the rows which have to be updated
  """
  where: permission_overrides_bool_exp!
}

"""
columns and relationships of "permissions"
"""
type permissions {
  action: permission_action!
  createdAt: timestamptz!
  description: String
  id: uuid!
  legacy_permission_name: String
  """
  An object relationship
  """
  resource: resources!
  resourceId: uuid!
  """
  An array relationship
  """
  role_permissions(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): [role_permissions!]!
  """
  An aggregate relationship
  """
  role_permissions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "permissions"
"""
type permissions_aggregate {
  aggregate: permissions_aggregate_fields
  nodes: [permissions!]!
}

input permissions_aggregate_bool_exp {
  count: permissions_aggregate_bool_exp_count
}

input permissions_aggregate_bool_exp_count {
  arguments: [permissions_select_column!]
  distinct: Boolean
  filter: permissions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "permissions"
"""
type permissions_aggregate_fields {
  count(columns: [permissions_select_column!], distinct: Boolean): Int!
  max: permissions_max_fields
  min: permissions_min_fields
}

"""
order by aggregate values of table "permissions"
"""
input permissions_aggregate_order_by {
  count: order_by
  max: permissions_max_order_by
  min: permissions_min_order_by
}

"""
input type for inserting array relation for remote table "permissions"
"""
input permissions_arr_rel_insert_input {
  data: [permissions_insert_input!]!
  """
  upsert condition
  """
  on_conflict: permissions_on_conflict
}

"""
Boolean expression to filter rows from the table "permissions". All fields are combined with a logical 'AND'.
"""
input permissions_bool_exp {
  _and: [permissions_bool_exp!]
  _not: permissions_bool_exp
  _or: [permissions_bool_exp!]
  action: permission_action_comparison_exp
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  legacy_permission_name: String_comparison_exp
  resource: resources_bool_exp
  resourceId: uuid_comparison_exp
  role_permissions: role_permissions_bool_exp
  role_permissions_aggregate: role_permissions_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "permissions"
"""
enum permissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  permissions_pkey
  """
  unique or primary key constraint on columns "action", "resource_id"
  """
  permissions_resource_id_action_key
}

"""
input type for inserting data into table "permissions"
"""
input permissions_insert_input {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resource: resources_obj_rel_insert_input
  resourceId: uuid
  role_permissions: role_permissions_arr_rel_insert_input
  updatedAt: timestamptz
}

"""
aggregate max on columns
"""
type permissions_max_fields {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "permissions"
"""
input permissions_max_order_by {
  action: order_by
  createdAt: order_by
  description: order_by
  id: order_by
  legacy_permission_name: order_by
  resourceId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type permissions_min_fields {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "permissions"
"""
input permissions_min_order_by {
  action: order_by
  createdAt: order_by
  description: order_by
  id: order_by
  legacy_permission_name: order_by
  resourceId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "permissions"
"""
type permissions_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [permissions!]!
}

"""
input type for inserting object relation for remote table "permissions"
"""
input permissions_obj_rel_insert_input {
  data: permissions_insert_input!
  """
  upsert condition
  """
  on_conflict: permissions_on_conflict
}

"""
on_conflict condition type for table "permissions"
"""
input permissions_on_conflict {
  constraint: permissions_constraint!
  update_columns: [permissions_update_column!]! = []
  where: permissions_bool_exp
}

"""
Ordering options when selecting data from "permissions".
"""
input permissions_order_by {
  action: order_by
  createdAt: order_by
  description: order_by
  id: order_by
  legacy_permission_name: order_by
  resource: resources_order_by
  resourceId: order_by
  role_permissions_aggregate: role_permissions_aggregate_order_by
  updatedAt: order_by
}

"""
primary key columns input for table: permissions
"""
input permissions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "permissions"
"""
enum permissions_select_column {
  """
  column name
  """
  action
  """
  column name
  """
  createdAt
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  legacy_permission_name
  """
  column name
  """
  resourceId
  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "permissions"
"""
input permissions_set_input {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "permissions"
"""
input permissions_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: permissions_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input permissions_stream_cursor_value_input {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacy_permission_name: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "permissions"
"""
enum permissions_update_column {
  """
  column name
  """
  action
  """
  column name
  """
  createdAt
  """
  column name
  """
  description
  """
  column name
  """
  id
  """
  column name
  """
  legacy_permission_name
  """
  column name
  """
  resourceId
  """
  column name
  """
  updatedAt
}

input permissions_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: permissions_set_input
  """
  filter the rows which have to be updated
  """
  where: permissions_bool_exp!
}

type query_root {
  """
  query _Entity union
  """
  _entities(representations: [_Any!]!): _Entity
  _service: _Service!
  """
  execute function "activate_payroll_versions" which returns "payroll_activation_results"
  """
  activatePayrollVersions(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!
  """
  execute function "activate_payroll_versions" and query aggregates on result of table type "payroll_activation_results"
  """
  activatePayrollVersionsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): payroll_activation_results_aggregate!
  """
  An array relationship
  """
  adjustment_rules(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!
  """
  An aggregate relationship
  """
  adjustment_rules_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!
  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustment_rules_by_pk(
    """
    Unique identifier for the adjustment rule
    """
    id: uuid!
  ): adjustment_rules
  """
  fetch data from the table: "app_settings"
  """
  app_settings(
    """
    distinct select on columns
    """
    distinct_on: [app_settings_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [app_settings_order_by!]
    """
    filter the rows returned
    """
    where: app_settings_bool_exp
  ): [app_settings!]!
  """
  fetch aggregated fields from the table: "app_settings"
  """
  app_settings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [app_settings_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [app_settings_order_by!]
    """
    filter the rows returned
    """
    where: app_settings_bool_exp
  ): app_settings_aggregate!
  """
  fetch data from the table: "app_settings" using primary key columns
  """
  app_settings_by_pk(
    """
    Unique identifier for application setting
    """
    id: String!
  ): app_settings
  """
  fetch data from the table: "audit.audit_log" using primary key columns
  """
  auditLog(id: uuid!): audit_audit_log
  """
  fetch data from the table: "audit.audit_log"
  """
  auditLogs(
    """
    distinct select on columns
    """
    distinct_on: [audit_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_audit_log_bool_exp
  ): [audit_audit_log!]!
  """
  fetch aggregated fields from the table: "audit.audit_log"
  """
  auditLogsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_audit_log_bool_exp
  ): audit_audit_log_aggregate!
  """
  fetch data from the table: "audit.permission_usage_report"
  """
  audit_permission_usage_report(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_usage_report_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_usage_report_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_usage_report_bool_exp
  ): [audit_permission_usage_report!]!
  """
  fetch aggregated fields from the table: "audit.permission_usage_report"
  """
  audit_permission_usage_report_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_usage_report_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_usage_report_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_usage_report_bool_exp
  ): audit_permission_usage_report_aggregate!
  """
  fetch data from the table: "audit.slow_queries"
  """
  audit_slow_queries(
    """
    distinct select on columns
    """
    distinct_on: [audit_slow_queries_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_slow_queries_order_by!]
    """
    filter the rows returned
    """
    where: audit_slow_queries_bool_exp
  ): [audit_slow_queries!]!
  """
  fetch aggregated fields from the table: "audit.slow_queries"
  """
  audit_slow_queries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_slow_queries_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_slow_queries_order_by!]
    """
    filter the rows returned
    """
    where: audit_slow_queries_bool_exp
  ): audit_slow_queries_aggregate!
  """
  fetch data from the table: "audit.slow_queries" using primary key columns
  """
  audit_slow_queries_by_pk(id: uuid!): audit_slow_queries
  """
  fetch data from the table: "audit.user_access_summary"
  """
  audit_user_access_summary(
    """
    distinct select on columns
    """
    distinct_on: [audit_user_access_summary_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_user_access_summary_order_by!]
    """
    filter the rows returned
    """
    where: audit_user_access_summary_bool_exp
  ): [audit_user_access_summary!]!
  """
  fetch aggregated fields from the table: "audit.user_access_summary"
  """
  audit_user_access_summary_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_user_access_summary_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_user_access_summary_order_by!]
    """
    filter the rows returned
    """
    where: audit_user_access_summary_bool_exp
  ): audit_user_access_summary_aggregate!
  """
  fetch data from the table: "audit.auth_events" using primary key columns
  """
  authEvent(id: uuid!): audit_auth_events
  """
  fetch data from the table: "audit.auth_events"
  """
  authEvents(
    """
    distinct select on columns
    """
    distinct_on: [audit_auth_events_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_auth_events_order_by!]
    """
    filter the rows returned
    """
    where: audit_auth_events_bool_exp
  ): [audit_auth_events!]!
  """
  fetch aggregated fields from the table: "audit.auth_events"
  """
  authEventsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_auth_events_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_auth_events_order_by!]
    """
    filter the rows returned
    """
    where: audit_auth_events_bool_exp
  ): audit_auth_events_aggregate!
  """
  fetch data from the table: "billing_event_log"
  """
  billing_event_log(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!
  """
  fetch aggregated fields from the table: "billing_event_log"
  """
  billing_event_log_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!
  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billing_event_log_by_pk(id: uuid!): billing_event_log
  """
  fetch data from the table: "billing_invoice"
  """
  billing_invoice(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!
  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billing_invoice_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_bool_exp
  ): billing_invoice_aggregate!
  """
  fetch data from the table: "billing_invoice" using primary key columns
  """
  billing_invoice_by_pk(id: uuid!): billing_invoice
  """
  fetch data from the table: "billing_invoice_item"
  """
  billing_invoice_item(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_item_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_item_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!
  """
  fetch aggregated fields from the table: "billing_invoice_item"
  """
  billing_invoice_item_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_item_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_item_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_item_bool_exp
  ): billing_invoice_item_aggregate!
  """
  fetch data from the table: "billing_invoice_item" using primary key columns
  """
  billing_invoice_item_by_pk(id: uuid!): billing_invoice_item
  """
  fetch data from the table: "billing_invoices"
  """
  billing_invoices(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoices_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoices_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!
  """
  fetch aggregated fields from the table: "billing_invoices"
  """
  billing_invoices_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoices_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoices_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoices_bool_exp
  ): billing_invoices_aggregate!
  """
  fetch data from the table: "billing_invoices" using primary key columns
  """
  billing_invoices_by_pk(id: uuid!): billing_invoices
  """
  An array relationship
  """
  billing_items(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): [billing_items!]!
  """
  An aggregate relationship
  """
  billing_items_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): billing_items_aggregate!
  """
  fetch data from the table: "billing_items" using primary key columns
  """
  billing_items_by_pk(id: uuid!): billing_items
  """
  fetch data from the table: "billing_plan"
  """
  billing_plan(
    """
    distinct select on columns
    """
    distinct_on: [billing_plan_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_plan_order_by!]
    """
    filter the rows returned
    """
    where: billing_plan_bool_exp
  ): [billing_plan!]!
  """
  fetch aggregated fields from the table: "billing_plan"
  """
  billing_plan_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_plan_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_plan_order_by!]
    """
    filter the rows returned
    """
    where: billing_plan_bool_exp
  ): billing_plan_aggregate!
  """
  fetch data from the table: "billing_plan" using primary key columns
  """
  billing_plan_by_pk(id: uuid!): billing_plan
  """
  fetch data from the table: "clients" using primary key columns
  """
  client(
    """
    Unique identifier for the client
    """
    id: uuid!
  ): clients
  """
  fetch data from the table: "client_billing_assignment"
  """
  client_billing_assignment(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!
  """
  fetch aggregated fields from the table: "client_billing_assignment"
  """
  client_billing_assignment_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!
  """
  fetch data from the table: "client_billing_assignment" using primary key columns
  """
  client_billing_assignment_by_pk(id: uuid!): client_billing_assignment
  """
  An array relationship
  """
  client_external_systems(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!
  """
  An aggregate relationship
  """
  client_external_systems_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!
  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  client_external_systems_by_pk(
    """
    Unique identifier for the client-system mapping
    """
    id: uuid!
  ): client_external_systems
  """
  fetch data from the table: "clients"
  """
  clients(
    """
    distinct select on columns
    """
    distinct_on: [clients_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [clients_order_by!]
    """
    filter the rows returned
    """
    where: clients_bool_exp
  ): [clients!]!
  """
  fetch aggregated fields from the table: "clients"
  """
  clientsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [clients_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [clients_order_by!]
    """
    filter the rows returned
    """
    where: clients_bool_exp
  ): clients_aggregate!
  """
  execute function "create_payroll_version" which returns "payroll_version_results"
  """
  createPayrollVersion(
    """
    input parameters for function "createPayrollVersion"
    """
    args: create_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!
  """
  execute function "create_payroll_version" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionAggregate(
    """
    input parameters for function "createPayrollVersionAggregate"
    """
    args: create_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!
  """
  execute function "create_payroll_version_simple" which returns "payroll_version_results"
  """
  createPayrollVersionSimple(
    """
    input parameters for function "createPayrollVersionSimple"
    """
    args: create_payroll_version_simple_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!
  """
  execute function "create_payroll_version_simple" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionSimpleAggregate(
    """
    input parameters for function "createPayrollVersionSimpleAggregate"
    """
    args: create_payroll_version_simple_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!
  """
  fetch data from the table: "current_payrolls"
  """
  current_payrolls(
    """
    distinct select on columns
    """
    distinct_on: [current_payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [current_payrolls_order_by!]
    """
    filter the rows returned
    """
    where: current_payrolls_bool_exp
  ): [current_payrolls!]!
  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  current_payrolls_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [current_payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [current_payrolls_order_by!]
    """
    filter the rows returned
    """
    where: current_payrolls_bool_exp
  ): current_payrolls_aggregate!
  """
  fetch data from the table: "audit.data_access_log" using primary key columns
  """
  dataAccessLog(id: uuid!): audit_data_access_log
  """
  fetch data from the table: "audit.data_access_log"
  """
  dataAccessLogs(
    """
    distinct select on columns
    """
    distinct_on: [audit_data_access_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_data_access_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_data_access_log_bool_exp
  ): [audit_data_access_log!]!
  """
  fetch aggregated fields from the table: "audit.data_access_log"
  """
  dataAccessLogsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_data_access_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_data_access_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_data_access_log_bool_exp
  ): audit_data_access_log_aggregate!
  """
  fetch data from the table: "external_systems"
  """
  external_systems(
    """
    distinct select on columns
    """
    distinct_on: [external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [external_systems_order_by!]
    """
    filter the rows returned
    """
    where: external_systems_bool_exp
  ): [external_systems!]!
  """
  fetch aggregated fields from the table: "external_systems"
  """
  external_systems_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [external_systems_order_by!]
    """
    filter the rows returned
    """
    where: external_systems_bool_exp
  ): external_systems_aggregate!
  """
  fetch data from the table: "external_systems" using primary key columns
  """
  external_systems_by_pk(
    """
    Unique identifier for the external system
    """
    id: uuid!
  ): external_systems
  """
  fetch data from the table: "feature_flags"
  """
  feature_flags(
    """
    distinct select on columns
    """
    distinct_on: [feature_flags_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [feature_flags_order_by!]
    """
    filter the rows returned
    """
    where: feature_flags_bool_exp
  ): [feature_flags!]!
  """
  fetch aggregated fields from the table: "feature_flags"
  """
  feature_flags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [feature_flags_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [feature_flags_order_by!]
    """
    filter the rows returned
    """
    where: feature_flags_bool_exp
  ): feature_flags_aggregate!
  """
  fetch data from the table: "feature_flags" using primary key columns
  """
  feature_flags_by_pk(
    """
    Unique identifier for the feature flag
    """
    id: uuid!
  ): feature_flags
  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generatePayrollDates(
    """
    input parameters for function "generatePayrollDates"
    """
    args: generate_payroll_dates_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!
  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generatePayrollDatesAggregate(
    """
    input parameters for function "generatePayrollDatesAggregate"
    """
    args: generate_payroll_dates_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!
  """
  execute function "get_latest_payroll_version" which returns "latest_payroll_version_results"
  """
  getLatestPayrollVersion(
    """
    input parameters for function "getLatestPayrollVersion"
    """
    args: get_latest_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!
  """
  execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results"
  """
  getLatestPayrollVersionAggregate(
    """
    input parameters for function "getLatestPayrollVersionAggregate"
    """
    args: get_latest_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): latest_payroll_version_results_aggregate!
  """
  execute function "get_payroll_version_history" which returns "payroll_version_history_results"
  """
  getPayrollVersionHistory(
    """
    input parameters for function "getPayrollVersionHistory"
    """
    args: get_payroll_version_history_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!
  """
  execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results"
  """
  getPayrollVersionHistoryAggregate(
    """
    input parameters for function "getPayrollVersionHistoryAggregate"
    """
    args: get_payroll_version_history_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): payroll_version_history_results_aggregate!
  """
  fetch data from the table: "holidays"
  """
  holidays(
    """
    distinct select on columns
    """
    distinct_on: [holidays_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [holidays_order_by!]
    """
    filter the rows returned
    """
    where: holidays_bool_exp
  ): [holidays!]!
  """
  fetch aggregated fields from the table: "holidays"
  """
  holidays_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [holidays_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [holidays_order_by!]
    """
    filter the rows returned
    """
    where: holidays_bool_exp
  ): holidays_aggregate!
  """
  fetch data from the table: "holidays" using primary key columns
  """
  holidays_by_pk(
    """
    Unique identifier for the holiday
    """
    id: uuid!
  ): holidays
  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results(
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!
  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): latest_payroll_version_results_aggregate!
  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latest_payroll_version_results_by_pk(
    id: uuid!
  ): latest_payroll_version_results
  """
  fetch data from the table: "leave" using primary key columns
  """
  leave(
    """
    Unique identifier for the leave record
    """
    id: uuid!
  ): leave
  """
  An array relationship
  """
  leaves(
    """
    distinct select on columns
    """
    distinct_on: [leave_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [leave_order_by!]
    """
    filter the rows returned
    """
    where: leave_bool_exp
  ): [leave!]!
  """
  fetch aggregated fields from the table: "leave"
  """
  leavesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [leave_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [leave_order_by!]
    """
    filter the rows returned
    """
    where: leave_bool_exp
  ): leave_aggregate!
  """
  fetch data from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync(
    """
    distinct select on columns
    """
    distinct_on: [neon_auth_users_sync_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [neon_auth_users_sync_order_by!]
    """
    filter the rows returned
    """
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!
  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [neon_auth_users_sync_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [neon_auth_users_sync_order_by!]
    """
    filter the rows returned
    """
    where: neon_auth_users_sync_bool_exp
  ): neon_auth_users_sync_aggregate!
  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  neon_auth_users_sync_by_pk(
    """
    Unique identifier from the authentication provider
    """
    id: String!
  ): neon_auth_users_sync
  """
  fetch data from the table: "notes"
  """
  notes(
    """
    distinct select on columns
    """
    distinct_on: [notes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [notes_order_by!]
    """
    filter the rows returned
    """
    where: notes_bool_exp
  ): [notes!]!
  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [notes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [notes_order_by!]
    """
    filter the rows returned
    """
    where: notes_bool_exp
  ): notes_aggregate!
  """
  fetch data from the table: "notes" using primary key columns
  """
  notes_by_pk(
    """
    Unique identifier for the note
    """
    id: uuid!
  ): notes
  """
  fetch data from the table: "payrolls" using primary key columns
  """
  payroll(
    """
    Unique identifier for the payroll
    """
    id: uuid!
  ): payrolls
  """
  fetch data from the table: "payroll_assignments" using primary key columns
  """
  payrollAssignment(id: uuid!): payroll_assignments
  """
  fetch data from the table: "payroll_assignments"
  """
  payrollAssignments(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): [payroll_assignments!]!
  """
  fetch aggregated fields from the table: "payroll_assignments"
  """
  payrollAssignmentsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): payroll_assignments_aggregate!
  """
  fetch data from the table: "payroll_dates" using primary key columns
  """
  payrollDate(
    """
    Unique identifier for the payroll date
    """
    id: uuid!
  ): payroll_dates
  """
  An array relationship
  """
  payrollDates(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!
  """
  fetch aggregated fields from the table: "payroll_dates"
  """
  payrollDatesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!
  """
  fetch data from the table: "payroll_activation_results"
  """
  payroll_activation_results(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!
  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payroll_activation_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): payroll_activation_results_aggregate!
  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payroll_activation_results_by_pk(id: uuid!): payroll_activation_results
  """
  fetch data from the table: "payroll_assignment_audit"
  """
  payroll_assignment_audit(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  fetch aggregated fields from the table: "payroll_assignment_audit"
  """
  payroll_assignment_audit_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): payroll_assignment_audit_aggregate!
  """
  fetch data from the table: "payroll_assignment_audit" using primary key columns
  """
  payroll_assignment_audit_by_pk(id: uuid!): payroll_assignment_audit
  """
  fetch data from the table: "payroll_cycles"
  """
  payroll_cycles(
    """
    distinct select on columns
    """
    distinct_on: [payroll_cycles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_cycles_order_by!]
    """
    filter the rows returned
    """
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!
  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payroll_cycles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_cycles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_cycles_order_by!]
    """
    filter the rows returned
    """
    where: payroll_cycles_bool_exp
  ): payroll_cycles_aggregate!
  """
  fetch data from the table: "payroll_cycles" using primary key columns
  """
  payroll_cycles_by_pk(
    """
    Unique identifier for the payroll cycle
    """
    id: uuid!
  ): payroll_cycles
  """
  fetch data from the table: "payroll_dashboard_stats"
  """
  payroll_dashboard_stats(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dashboard_stats_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dashboard_stats_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dashboard_stats_bool_exp
  ): [payroll_dashboard_stats!]!
  """
  fetch aggregated fields from the table: "payroll_dashboard_stats"
  """
  payroll_dashboard_stats_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dashboard_stats_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dashboard_stats_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dashboard_stats_bool_exp
  ): payroll_dashboard_stats_aggregate!
  """
  fetch data from the table: "payroll_date_types"
  """
  payroll_date_types(
    """
    distinct select on columns
    """
    distinct_on: [payroll_date_types_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_date_types_order_by!]
    """
    filter the rows returned
    """
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!
  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payroll_date_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_date_types_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_date_types_order_by!]
    """
    filter the rows returned
    """
    where: payroll_date_types_bool_exp
  ): payroll_date_types_aggregate!
  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payroll_date_types_by_pk(
    """
    Unique identifier for the payroll date type
    """
    id: uuid!
  ): payroll_date_types
  """
  fetch data from the table: "payroll_triggers_status"
  """
  payroll_triggers_status(
    """
    distinct select on columns
    """
    distinct_on: [payroll_triggers_status_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_triggers_status_order_by!]
    """
    filter the rows returned
    """
    where: payroll_triggers_status_bool_exp
  ): [payroll_triggers_status!]!
  """
  fetch aggregated fields from the table: "payroll_triggers_status"
  """
  payroll_triggers_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_triggers_status_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_triggers_status_order_by!]
    """
    filter the rows returned
    """
    where: payroll_triggers_status_bool_exp
  ): payroll_triggers_status_aggregate!
  """
  fetch data from the table: "payroll_version_history_results"
  """
  payroll_version_history_results(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!
  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payroll_version_history_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): payroll_version_history_results_aggregate!
  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payroll_version_history_results_by_pk(
    id: uuid!
  ): payroll_version_history_results
  """
  fetch data from the table: "payroll_version_results"
  """
  payroll_version_results(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!
  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payroll_version_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!
  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payroll_version_results_by_pk(id: uuid!): payroll_version_results
  """
  An array relationship
  """
  payrolls(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  fetch aggregated fields from the table: "payrolls"
  """
  payrollsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  fetch data from the table: "permissions" using primary key columns
  """
  permission(id: uuid!): permissions
  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permissionAuditLog(id: uuid!): permission_audit_log
  """
  fetch data from the table: "permission_audit_log"
  """
  permissionAuditLogs(
    """
    distinct select on columns
    """
    distinct_on: [permission_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!
  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permissionAuditLogsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [permission_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: permission_audit_log_bool_exp
  ): permission_audit_log_aggregate!
  """
  fetch data from the table: "audit.permission_changes" using primary key columns
  """
  permissionChange(id: uuid!): audit_permission_changes
  """
  fetch data from the table: "audit.permission_changes"
  """
  permissionChanges(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_changes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_changes_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_changes_bool_exp
  ): [audit_permission_changes!]!
  """
  fetch aggregated fields from the table: "audit.permission_changes"
  """
  permissionChangesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_changes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_changes_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_changes_bool_exp
  ): audit_permission_changes_aggregate!
  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permissionOverride(id: uuid!): permission_overrides
  """
  fetch data from the table: "permission_overrides"
  """
  permissionOverrides(
    """
    distinct select on columns
    """
    distinct_on: [permission_overrides_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_overrides_order_by!]
    """
    filter the rows returned
    """
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!
  """
  fetch aggregated fields from the table: "permission_overrides"
  """
  permissionOverridesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [permission_overrides_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_overrides_order_by!]
    """
    filter the rows returned
    """
    where: permission_overrides_bool_exp
  ): permission_overrides_aggregate!
  """
  An array relationship
  """
  permissions(
    """
    distinct select on columns
    """
    distinct_on: [permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permissions_order_by!]
    """
    filter the rows returned
    """
    where: permissions_bool_exp
  ): [permissions!]!
  """
  fetch aggregated fields from the table: "permissions"
  """
  permissionsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permissions_order_by!]
    """
    filter the rows returned
    """
    where: permissions_bool_exp
  ): permissions_aggregate!
  """
  fetch data from the table: "resources" using primary key columns
  """
  resource(id: uuid!): resources
  """
  fetch data from the table: "resources"
  """
  resources(
    """
    distinct select on columns
    """
    distinct_on: [resources_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [resources_order_by!]
    """
    filter the rows returned
    """
    where: resources_bool_exp
  ): [resources!]!
  """
  fetch aggregated fields from the table: "resources"
  """
  resourcesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [resources_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [resources_order_by!]
    """
    filter the rows returned
    """
    where: resources_bool_exp
  ): resources_aggregate!
  """
  fetch data from the table: "roles" using primary key columns
  """
  role(id: uuid!): roles
  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  rolePermission(id: uuid!): role_permissions
  """
  An array relationship
  """
  rolePermissions(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): [role_permissions!]!
  """
  fetch aggregated fields from the table: "role_permissions"
  """
  rolePermissionsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!
  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinct_on: [roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [roles_order_by!]
    """
    filter the rows returned
    """
    where: roles_bool_exp
  ): [roles!]!
  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [roles_order_by!]
    """
    filter the rows returned
    """
    where: roles_bool_exp
  ): roles_aggregate!
  """
  fetch data from the table: "users" using primary key columns
  """
  user(
    """
    Unique identifier for the user
    """
    id: uuid!
  ): users
  """
  fetch data from the table: "user_roles" using primary key columns
  """
  userRole(id: uuid!): user_roles
  """
  An array relationship
  """
  userRoles(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): [user_roles!]!
  """
  fetch aggregated fields from the table: "user_roles"
  """
  userRolesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): user_roles_aggregate!
  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!
  """
  fetch data from the table: "users_role_backup"
  """
  users_role_backup(
    """
    distinct select on columns
    """
    distinct_on: [users_role_backup_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_role_backup_order_by!]
    """
    filter the rows returned
    """
    where: users_role_backup_bool_exp
  ): [users_role_backup!]!
  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  users_role_backup_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_role_backup_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_role_backup_order_by!]
    """
    filter the rows returned
    """
    where: users_role_backup_bool_exp
  ): users_role_backup_aggregate!
  """
  fetch data from the table: "work_schedule" using primary key columns
  """
  workSchedule(
    """
    Unique identifier for the work schedule entry
    """
    id: uuid!
  ): work_schedule
  """
  An array relationship
  """
  workSchedules(
    """
    distinct select on columns
    """
    distinct_on: [work_schedule_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [work_schedule_order_by!]
    """
    filter the rows returned
    """
    where: work_schedule_bool_exp
  ): [work_schedule!]!
  """
  fetch aggregated fields from the table: "work_schedule"
  """
  workSchedulesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [work_schedule_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [work_schedule_order_by!]
    """
    filter the rows returned
    """
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!
}

"""
columns and relationships of "resources"
"""
type resources {
  createdAt: timestamptz!
  description: String
  displayName: String!
  id: uuid!
  name: String!
  """
  An array relationship
  """
  permissions(
    """
    distinct select on columns
    """
    distinct_on: [permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permissions_order_by!]
    """
    filter the rows returned
    """
    where: permissions_bool_exp
  ): [permissions!]!
  """
  An aggregate relationship
  """
  permissions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permissions_order_by!]
    """
    filter the rows returned
    """
    where: permissions_bool_exp
  ): permissions_aggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "resources"
"""
type resources_aggregate {
  aggregate: resources_aggregate_fields
  nodes: [resources!]!
}

"""
aggregate fields of "resources"
"""
type resources_aggregate_fields {
  count(columns: [resources_select_column!], distinct: Boolean): Int!
  max: resources_max_fields
  min: resources_min_fields
}

"""
Boolean expression to filter rows from the table "resources". All fields are combined with a logical 'AND'.
"""
input resources_bool_exp {
  _and: [resources_bool_exp!]
  _not: resources_bool_exp
  _or: [resources_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  permissions: permissions_bool_exp
  permissions_aggregate: permissions_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "resources"
"""
enum resources_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  resources_name_key
  """
  unique or primary key constraint on columns "id"
  """
  resources_pkey
}

"""
input type for inserting data into table "resources"
"""
input resources_insert_input {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  permissions: permissions_arr_rel_insert_input
  updatedAt: timestamptz
}

"""
aggregate max on columns
"""
type resources_max_fields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
aggregate min on columns
"""
type resources_min_fields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "resources"
"""
type resources_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [resources!]!
}

"""
input type for inserting object relation for remote table "resources"
"""
input resources_obj_rel_insert_input {
  data: resources_insert_input!
  """
  upsert condition
  """
  on_conflict: resources_on_conflict
}

"""
on_conflict condition type for table "resources"
"""
input resources_on_conflict {
  constraint: resources_constraint!
  update_columns: [resources_update_column!]! = []
  where: resources_bool_exp
}

"""
Ordering options when selecting data from "resources".
"""
input resources_order_by {
  createdAt: order_by
  description: order_by
  displayName: order_by
  id: order_by
  name: order_by
  permissions_aggregate: permissions_aggregate_order_by
  updatedAt: order_by
}

"""
primary key columns input for table: resources
"""
input resources_pk_columns_input {
  id: uuid!
}

"""
select columns of table "resources"
"""
enum resources_select_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  description
  """
  column name
  """
  displayName
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "resources"
"""
input resources_set_input {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "resources"
"""
input resources_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: resources_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input resources_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
update columns of table "resources"
"""
enum resources_update_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  description
  """
  column name
  """
  displayName
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  updatedAt
}

input resources_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: resources_set_input
  """
  filter the rows which have to be updated
  """
  where: resources_bool_exp!
}

"""
columns and relationships of "role_permissions"
"""
type role_permissions {
  conditions(
    """
    JSON select path
    """
    path: String
  ): jsonb
  createdAt: timestamptz!
  id: uuid!
  """
  An object relationship
  """
  permission: permissions!
  permissionId: uuid!
  """
  An object relationship
  """
  role: roles!
  roleId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "role_permissions"
"""
type role_permissions_aggregate {
  aggregate: role_permissions_aggregate_fields
  nodes: [role_permissions!]!
}

input role_permissions_aggregate_bool_exp {
  count: role_permissions_aggregate_bool_exp_count
}

input role_permissions_aggregate_bool_exp_count {
  arguments: [role_permissions_select_column!]
  distinct: Boolean
  filter: role_permissions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "role_permissions"
"""
type role_permissions_aggregate_fields {
  count(columns: [role_permissions_select_column!], distinct: Boolean): Int!
  max: role_permissions_max_fields
  min: role_permissions_min_fields
}

"""
order by aggregate values of table "role_permissions"
"""
input role_permissions_aggregate_order_by {
  count: order_by
  max: role_permissions_max_order_by
  min: role_permissions_min_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input role_permissions_append_input {
  conditions: jsonb
}

"""
input type for inserting array relation for remote table "role_permissions"
"""
input role_permissions_arr_rel_insert_input {
  data: [role_permissions_insert_input!]!
  """
  upsert condition
  """
  on_conflict: role_permissions_on_conflict
}

"""
Boolean expression to filter rows from the table "role_permissions". All fields are combined with a logical 'AND'.
"""
input role_permissions_bool_exp {
  _and: [role_permissions_bool_exp!]
  _not: role_permissions_bool_exp
  _or: [role_permissions_bool_exp!]
  conditions: jsonb_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  permission: permissions_bool_exp
  permissionId: uuid_comparison_exp
  role: roles_bool_exp
  roleId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "role_permissions"
"""
enum role_permissions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  role_permissions_pkey
  """
  unique or primary key constraint on columns "permission_id", "role_id"
  """
  role_permissions_role_id_permission_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input role_permissions_delete_at_path_input {
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input role_permissions_delete_elem_input {
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input role_permissions_delete_key_input {
  conditions: String
}

"""
input type for inserting data into table "role_permissions"
"""
input role_permissions_insert_input {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permission: permissions_obj_rel_insert_input
  permissionId: uuid
  role: roles_obj_rel_insert_input
  roleId: uuid
  updatedAt: timestamptz
}

"""
aggregate max on columns
"""
type role_permissions_max_fields {
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "role_permissions"
"""
input role_permissions_max_order_by {
  createdAt: order_by
  id: order_by
  permissionId: order_by
  roleId: order_by
  updatedAt: order_by
}

"""
aggregate min on columns
"""
type role_permissions_min_fields {
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "role_permissions"
"""
input role_permissions_min_order_by {
  createdAt: order_by
  id: order_by
  permissionId: order_by
  roleId: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "role_permissions"
"""
type role_permissions_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [role_permissions!]!
}

"""
on_conflict condition type for table "role_permissions"
"""
input role_permissions_on_conflict {
  constraint: role_permissions_constraint!
  update_columns: [role_permissions_update_column!]! = []
  where: role_permissions_bool_exp
}

"""
Ordering options when selecting data from "role_permissions".
"""
input role_permissions_order_by {
  conditions: order_by
  createdAt: order_by
  id: order_by
  permission: permissions_order_by
  permissionId: order_by
  role: roles_order_by
  roleId: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: role_permissions
"""
input role_permissions_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input role_permissions_prepend_input {
  conditions: jsonb
}

"""
select columns of table "role_permissions"
"""
enum role_permissions_select_column {
  """
  column name
  """
  conditions
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  permissionId
  """
  column name
  """
  roleId
  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "role_permissions"
"""
input role_permissions_set_input {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "role_permissions"
"""
input role_permissions_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: role_permissions_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input role_permissions_stream_cursor_value_input {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "role_permissions"
"""
enum role_permissions_update_column {
  """
  column name
  """
  conditions
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  permissionId
  """
  column name
  """
  roleId
  """
  column name
  """
  updatedAt
}

input role_permissions_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: role_permissions_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: role_permissions_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: role_permissions_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: role_permissions_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: role_permissions_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: role_permissions_set_input
  """
  filter the rows which have to be updated
  """
  where: role_permissions_bool_exp!
}

"""
columns and relationships of "roles"
"""
type roles {
  createdAt: timestamptz!
  description: String
  displayName: String!
  id: uuid!
  isSystemRole: Boolean!
  name: String!
  priority: Int!
  """
  An array relationship
  """
  rolePermissions(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): [role_permissions!]!
  """
  An aggregate relationship
  """
  rolePermissions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!
  updatedAt: timestamptz!
  """
  An array relationship
  """
  userRoles(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): [user_roles!]!
  """
  An aggregate relationship
  """
  userRoles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): user_roles_aggregate!
}

"""
aggregated selection of "roles"
"""
type roles_aggregate {
  aggregate: roles_aggregate_fields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type roles_aggregate_fields {
  avg: roles_avg_fields
  count(columns: [roles_select_column!], distinct: Boolean): Int!
  max: roles_max_fields
  min: roles_min_fields
  stddev: roles_stddev_fields
  stddev_pop: roles_stddev_pop_fields
  stddev_samp: roles_stddev_samp_fields
  sum: roles_sum_fields
  var_pop: roles_var_pop_fields
  var_samp: roles_var_samp_fields
  variance: roles_variance_fields
}

"""
aggregate avg on columns
"""
type roles_avg_fields {
  priority: Float
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input roles_bool_exp {
  _and: [roles_bool_exp!]
  _not: roles_bool_exp
  _or: [roles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  description: String_comparison_exp
  displayName: String_comparison_exp
  id: uuid_comparison_exp
  isSystemRole: Boolean_comparison_exp
  name: String_comparison_exp
  priority: Int_comparison_exp
  rolePermissions: role_permissions_bool_exp
  rolePermissions_aggregate: role_permissions_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  userRoles: user_roles_bool_exp
  userRoles_aggregate: user_roles_aggregate_bool_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum roles_constraint {
  """
  unique or primary key constraint on columns "name"
  """
  roles_name_key
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey
}

"""
input type for incrementing numeric columns in table "roles"
"""
input roles_inc_input {
  priority: Int
}

"""
input type for inserting data into table "roles"
"""
input roles_insert_input {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  rolePermissions: role_permissions_arr_rel_insert_input
  updatedAt: timestamptz
  userRoles: user_roles_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type roles_max_fields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""
aggregate min on columns
"""
type roles_min_fields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "roles"
"""
type roles_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input roles_obj_rel_insert_input {
  data: roles_insert_input!
  """
  upsert condition
  """
  on_conflict: roles_on_conflict
}

"""
on_conflict condition type for table "roles"
"""
input roles_on_conflict {
  constraint: roles_constraint!
  update_columns: [roles_update_column!]! = []
  where: roles_bool_exp
}

"""
Ordering options when selecting data from "roles".
"""
input roles_order_by {
  createdAt: order_by
  description: order_by
  displayName: order_by
  id: order_by
  isSystemRole: order_by
  name: order_by
  priority: order_by
  rolePermissions_aggregate: role_permissions_aggregate_order_by
  updatedAt: order_by
  userRoles_aggregate: user_roles_aggregate_order_by
}

"""
primary key columns input for table: roles
"""
input roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum roles_select_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  description
  """
  column name
  """
  displayName
  """
  column name
  """
  id
  """
  column name
  """
  isSystemRole
  """
  column name
  """
  name
  """
  column name
  """
  priority
  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "roles"
"""
input roles_set_input {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""
aggregate stddev on columns
"""
type roles_stddev_fields {
  priority: Float
}

"""
aggregate stddev_pop on columns
"""
type roles_stddev_pop_fields {
  priority: Float
}

"""
aggregate stddev_samp on columns
"""
type roles_stddev_samp_fields {
  priority: Float
}

"""
Streaming cursor of the table "roles"
"""
input roles_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: roles_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input roles_stream_cursor_value_input {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""
aggregate sum on columns
"""
type roles_sum_fields {
  priority: Int
}

"""
update columns of table "roles"
"""
enum roles_update_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  description
  """
  column name
  """
  displayName
  """
  column name
  """
  id
  """
  column name
  """
  isSystemRole
  """
  column name
  """
  name
  """
  column name
  """
  priority
  """
  column name
  """
  updatedAt
}

input roles_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: roles_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: roles_set_input
  """
  filter the rows which have to be updated
  """
  where: roles_bool_exp!
}

"""
aggregate var_pop on columns
"""
type roles_var_pop_fields {
  priority: Float
}

"""
aggregate var_samp on columns
"""
type roles_var_samp_fields {
  priority: Float
}

"""
aggregate variance on columns
"""
type roles_variance_fields {
  priority: Float
}

type subscription_root {
  """
  execute function "activate_payroll_versions" which returns "payroll_activation_results"
  """
  activatePayrollVersions(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!
  """
  execute function "activate_payroll_versions" and query aggregates on result of table type "payroll_activation_results"
  """
  activatePayrollVersionsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): payroll_activation_results_aggregate!
  """
  An array relationship
  """
  adjustment_rules(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!
  """
  An aggregate relationship
  """
  adjustment_rules_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [adjustment_rules_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [adjustment_rules_order_by!]
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): adjustment_rules_aggregate!
  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustment_rules_by_pk(
    """
    Unique identifier for the adjustment rule
    """
    id: uuid!
  ): adjustment_rules
  """
  fetch data from the table in a streaming manner: "adjustment_rules"
  """
  adjustment_rules_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [adjustment_rules_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: adjustment_rules_bool_exp
  ): [adjustment_rules!]!
  """
  fetch data from the table: "app_settings"
  """
  app_settings(
    """
    distinct select on columns
    """
    distinct_on: [app_settings_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [app_settings_order_by!]
    """
    filter the rows returned
    """
    where: app_settings_bool_exp
  ): [app_settings!]!
  """
  fetch aggregated fields from the table: "app_settings"
  """
  app_settings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [app_settings_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [app_settings_order_by!]
    """
    filter the rows returned
    """
    where: app_settings_bool_exp
  ): app_settings_aggregate!
  """
  fetch data from the table: "app_settings" using primary key columns
  """
  app_settings_by_pk(
    """
    Unique identifier for application setting
    """
    id: String!
  ): app_settings
  """
  fetch data from the table in a streaming manner: "app_settings"
  """
  app_settings_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [app_settings_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: app_settings_bool_exp
  ): [app_settings!]!
  """
  fetch data from the table: "audit.audit_log" using primary key columns
  """
  auditLog(id: uuid!): audit_audit_log
  """
  fetch data from the table: "audit.audit_log"
  """
  auditLogs(
    """
    distinct select on columns
    """
    distinct_on: [audit_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_audit_log_bool_exp
  ): [audit_audit_log!]!
  """
  fetch aggregated fields from the table: "audit.audit_log"
  """
  auditLogsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_audit_log_bool_exp
  ): audit_audit_log_aggregate!
  """
  fetch data from the table in a streaming manner: "audit.audit_log"
  """
  audit_audit_log_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [audit_audit_log_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: audit_audit_log_bool_exp
  ): [audit_audit_log!]!
  """
  fetch data from the table in a streaming manner: "audit.auth_events"
  """
  audit_auth_events_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [audit_auth_events_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: audit_auth_events_bool_exp
  ): [audit_auth_events!]!
  """
  fetch data from the table in a streaming manner: "audit.data_access_log"
  """
  audit_data_access_log_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [audit_data_access_log_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: audit_data_access_log_bool_exp
  ): [audit_data_access_log!]!
  """
  fetch data from the table in a streaming manner: "audit.permission_changes"
  """
  audit_permission_changes_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [audit_permission_changes_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: audit_permission_changes_bool_exp
  ): [audit_permission_changes!]!
  """
  fetch data from the table: "audit.permission_usage_report"
  """
  audit_permission_usage_report(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_usage_report_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_usage_report_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_usage_report_bool_exp
  ): [audit_permission_usage_report!]!
  """
  fetch aggregated fields from the table: "audit.permission_usage_report"
  """
  audit_permission_usage_report_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_usage_report_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_usage_report_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_usage_report_bool_exp
  ): audit_permission_usage_report_aggregate!
  """
  fetch data from the table in a streaming manner: "audit.permission_usage_report"
  """
  audit_permission_usage_report_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [audit_permission_usage_report_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: audit_permission_usage_report_bool_exp
  ): [audit_permission_usage_report!]!
  """
  fetch data from the table: "audit.slow_queries"
  """
  audit_slow_queries(
    """
    distinct select on columns
    """
    distinct_on: [audit_slow_queries_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_slow_queries_order_by!]
    """
    filter the rows returned
    """
    where: audit_slow_queries_bool_exp
  ): [audit_slow_queries!]!
  """
  fetch aggregated fields from the table: "audit.slow_queries"
  """
  audit_slow_queries_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_slow_queries_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_slow_queries_order_by!]
    """
    filter the rows returned
    """
    where: audit_slow_queries_bool_exp
  ): audit_slow_queries_aggregate!
  """
  fetch data from the table: "audit.slow_queries" using primary key columns
  """
  audit_slow_queries_by_pk(id: uuid!): audit_slow_queries
  """
  fetch data from the table in a streaming manner: "audit.slow_queries"
  """
  audit_slow_queries_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [audit_slow_queries_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: audit_slow_queries_bool_exp
  ): [audit_slow_queries!]!
  """
  fetch data from the table: "audit.user_access_summary"
  """
  audit_user_access_summary(
    """
    distinct select on columns
    """
    distinct_on: [audit_user_access_summary_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_user_access_summary_order_by!]
    """
    filter the rows returned
    """
    where: audit_user_access_summary_bool_exp
  ): [audit_user_access_summary!]!
  """
  fetch aggregated fields from the table: "audit.user_access_summary"
  """
  audit_user_access_summary_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_user_access_summary_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_user_access_summary_order_by!]
    """
    filter the rows returned
    """
    where: audit_user_access_summary_bool_exp
  ): audit_user_access_summary_aggregate!
  """
  fetch data from the table in a streaming manner: "audit.user_access_summary"
  """
  audit_user_access_summary_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [audit_user_access_summary_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: audit_user_access_summary_bool_exp
  ): [audit_user_access_summary!]!
  """
  fetch data from the table: "audit.auth_events" using primary key columns
  """
  authEvent(id: uuid!): audit_auth_events
  """
  fetch data from the table: "audit.auth_events"
  """
  authEvents(
    """
    distinct select on columns
    """
    distinct_on: [audit_auth_events_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_auth_events_order_by!]
    """
    filter the rows returned
    """
    where: audit_auth_events_bool_exp
  ): [audit_auth_events!]!
  """
  fetch aggregated fields from the table: "audit.auth_events"
  """
  authEventsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_auth_events_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_auth_events_order_by!]
    """
    filter the rows returned
    """
    where: audit_auth_events_bool_exp
  ): audit_auth_events_aggregate!
  """
  fetch data from the table: "billing_event_log"
  """
  billing_event_log(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!
  """
  fetch aggregated fields from the table: "billing_event_log"
  """
  billing_event_log_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!
  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billing_event_log_by_pk(id: uuid!): billing_event_log
  """
  fetch data from the table in a streaming manner: "billing_event_log"
  """
  billing_event_log_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [billing_event_log_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!
  """
  fetch data from the table: "billing_invoice"
  """
  billing_invoice(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!
  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billing_invoice_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_bool_exp
  ): billing_invoice_aggregate!
  """
  fetch data from the table: "billing_invoice" using primary key columns
  """
  billing_invoice_by_pk(id: uuid!): billing_invoice
  """
  fetch data from the table: "billing_invoice_item"
  """
  billing_invoice_item(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_item_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_item_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!
  """
  fetch aggregated fields from the table: "billing_invoice_item"
  """
  billing_invoice_item_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoice_item_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoice_item_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoice_item_bool_exp
  ): billing_invoice_item_aggregate!
  """
  fetch data from the table: "billing_invoice_item" using primary key columns
  """
  billing_invoice_item_by_pk(id: uuid!): billing_invoice_item
  """
  fetch data from the table in a streaming manner: "billing_invoice_item"
  """
  billing_invoice_item_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [billing_invoice_item_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: billing_invoice_item_bool_exp
  ): [billing_invoice_item!]!
  """
  fetch data from the table in a streaming manner: "billing_invoice"
  """
  billing_invoice_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [billing_invoice_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: billing_invoice_bool_exp
  ): [billing_invoice!]!
  """
  fetch data from the table: "billing_invoices"
  """
  billing_invoices(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoices_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoices_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!
  """
  fetch aggregated fields from the table: "billing_invoices"
  """
  billing_invoices_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_invoices_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_invoices_order_by!]
    """
    filter the rows returned
    """
    where: billing_invoices_bool_exp
  ): billing_invoices_aggregate!
  """
  fetch data from the table: "billing_invoices" using primary key columns
  """
  billing_invoices_by_pk(id: uuid!): billing_invoices
  """
  fetch data from the table in a streaming manner: "billing_invoices"
  """
  billing_invoices_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [billing_invoices_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: billing_invoices_bool_exp
  ): [billing_invoices!]!
  """
  An array relationship
  """
  billing_items(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): [billing_items!]!
  """
  An aggregate relationship
  """
  billing_items_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_items_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_items_order_by!]
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): billing_items_aggregate!
  """
  fetch data from the table: "billing_items" using primary key columns
  """
  billing_items_by_pk(id: uuid!): billing_items
  """
  fetch data from the table in a streaming manner: "billing_items"
  """
  billing_items_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [billing_items_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: billing_items_bool_exp
  ): [billing_items!]!
  """
  fetch data from the table: "billing_plan"
  """
  billing_plan(
    """
    distinct select on columns
    """
    distinct_on: [billing_plan_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_plan_order_by!]
    """
    filter the rows returned
    """
    where: billing_plan_bool_exp
  ): [billing_plan!]!
  """
  fetch aggregated fields from the table: "billing_plan"
  """
  billing_plan_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_plan_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_plan_order_by!]
    """
    filter the rows returned
    """
    where: billing_plan_bool_exp
  ): billing_plan_aggregate!
  """
  fetch data from the table: "billing_plan" using primary key columns
  """
  billing_plan_by_pk(id: uuid!): billing_plan
  """
  fetch data from the table in a streaming manner: "billing_plan"
  """
  billing_plan_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [billing_plan_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: billing_plan_bool_exp
  ): [billing_plan!]!
  """
  fetch data from the table: "clients" using primary key columns
  """
  client(
    """
    Unique identifier for the client
    """
    id: uuid!
  ): clients
  """
  fetch data from the table: "client_billing_assignment"
  """
  client_billing_assignment(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!
  """
  fetch aggregated fields from the table: "client_billing_assignment"
  """
  client_billing_assignment_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_billing_assignment_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_billing_assignment_order_by!]
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): client_billing_assignment_aggregate!
  """
  fetch data from the table: "client_billing_assignment" using primary key columns
  """
  client_billing_assignment_by_pk(id: uuid!): client_billing_assignment
  """
  fetch data from the table in a streaming manner: "client_billing_assignment"
  """
  client_billing_assignment_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [client_billing_assignment_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: client_billing_assignment_bool_exp
  ): [client_billing_assignment!]!
  """
  An array relationship
  """
  client_external_systems(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!
  """
  An aggregate relationship
  """
  client_external_systems_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [client_external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [client_external_systems_order_by!]
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): client_external_systems_aggregate!
  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  client_external_systems_by_pk(
    """
    Unique identifier for the client-system mapping
    """
    id: uuid!
  ): client_external_systems
  """
  fetch data from the table in a streaming manner: "client_external_systems"
  """
  client_external_systems_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [client_external_systems_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: client_external_systems_bool_exp
  ): [client_external_systems!]!
  """
  fetch data from the table: "clients"
  """
  clients(
    """
    distinct select on columns
    """
    distinct_on: [clients_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [clients_order_by!]
    """
    filter the rows returned
    """
    where: clients_bool_exp
  ): [clients!]!
  """
  fetch aggregated fields from the table: "clients"
  """
  clientsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [clients_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [clients_order_by!]
    """
    filter the rows returned
    """
    where: clients_bool_exp
  ): clients_aggregate!
  """
  fetch data from the table in a streaming manner: "clients"
  """
  clients_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [clients_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: clients_bool_exp
  ): [clients!]!
  """
  execute function "create_payroll_version" which returns "payroll_version_results"
  """
  createPayrollVersion(
    """
    input parameters for function "createPayrollVersion"
    """
    args: create_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!
  """
  execute function "create_payroll_version" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionAggregate(
    """
    input parameters for function "createPayrollVersionAggregate"
    """
    args: create_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!
  """
  execute function "create_payroll_version_simple" which returns "payroll_version_results"
  """
  createPayrollVersionSimple(
    """
    input parameters for function "createPayrollVersionSimple"
    """
    args: create_payroll_version_simple_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!
  """
  execute function "create_payroll_version_simple" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionSimpleAggregate(
    """
    input parameters for function "createPayrollVersionSimpleAggregate"
    """
    args: create_payroll_version_simple_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!
  """
  fetch data from the table: "current_payrolls"
  """
  current_payrolls(
    """
    distinct select on columns
    """
    distinct_on: [current_payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [current_payrolls_order_by!]
    """
    filter the rows returned
    """
    where: current_payrolls_bool_exp
  ): [current_payrolls!]!
  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  current_payrolls_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [current_payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [current_payrolls_order_by!]
    """
    filter the rows returned
    """
    where: current_payrolls_bool_exp
  ): current_payrolls_aggregate!
  """
  fetch data from the table in a streaming manner: "current_payrolls"
  """
  current_payrolls_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [current_payrolls_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: current_payrolls_bool_exp
  ): [current_payrolls!]!
  """
  fetch data from the table: "audit.data_access_log" using primary key columns
  """
  dataAccessLog(id: uuid!): audit_data_access_log
  """
  fetch data from the table: "audit.data_access_log"
  """
  dataAccessLogs(
    """
    distinct select on columns
    """
    distinct_on: [audit_data_access_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_data_access_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_data_access_log_bool_exp
  ): [audit_data_access_log!]!
  """
  fetch aggregated fields from the table: "audit.data_access_log"
  """
  dataAccessLogsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_data_access_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_data_access_log_order_by!]
    """
    filter the rows returned
    """
    where: audit_data_access_log_bool_exp
  ): audit_data_access_log_aggregate!
  """
  fetch data from the table: "external_systems"
  """
  external_systems(
    """
    distinct select on columns
    """
    distinct_on: [external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [external_systems_order_by!]
    """
    filter the rows returned
    """
    where: external_systems_bool_exp
  ): [external_systems!]!
  """
  fetch aggregated fields from the table: "external_systems"
  """
  external_systems_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [external_systems_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [external_systems_order_by!]
    """
    filter the rows returned
    """
    where: external_systems_bool_exp
  ): external_systems_aggregate!
  """
  fetch data from the table: "external_systems" using primary key columns
  """
  external_systems_by_pk(
    """
    Unique identifier for the external system
    """
    id: uuid!
  ): external_systems
  """
  fetch data from the table in a streaming manner: "external_systems"
  """
  external_systems_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [external_systems_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: external_systems_bool_exp
  ): [external_systems!]!
  """
  fetch data from the table: "feature_flags"
  """
  feature_flags(
    """
    distinct select on columns
    """
    distinct_on: [feature_flags_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [feature_flags_order_by!]
    """
    filter the rows returned
    """
    where: feature_flags_bool_exp
  ): [feature_flags!]!
  """
  fetch aggregated fields from the table: "feature_flags"
  """
  feature_flags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [feature_flags_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [feature_flags_order_by!]
    """
    filter the rows returned
    """
    where: feature_flags_bool_exp
  ): feature_flags_aggregate!
  """
  fetch data from the table: "feature_flags" using primary key columns
  """
  feature_flags_by_pk(
    """
    Unique identifier for the feature flag
    """
    id: uuid!
  ): feature_flags
  """
  fetch data from the table in a streaming manner: "feature_flags"
  """
  feature_flags_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [feature_flags_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: feature_flags_bool_exp
  ): [feature_flags!]!
  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generatePayrollDates(
    """
    input parameters for function "generatePayrollDates"
    """
    args: generate_payroll_dates_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!
  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generatePayrollDatesAggregate(
    """
    input parameters for function "generatePayrollDatesAggregate"
    """
    args: generate_payroll_dates_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!
  """
  execute function "get_latest_payroll_version" which returns "latest_payroll_version_results"
  """
  getLatestPayrollVersion(
    """
    input parameters for function "getLatestPayrollVersion"
    """
    args: get_latest_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!
  """
  execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results"
  """
  getLatestPayrollVersionAggregate(
    """
    input parameters for function "getLatestPayrollVersionAggregate"
    """
    args: get_latest_payroll_version_args!
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): latest_payroll_version_results_aggregate!
  """
  execute function "get_payroll_version_history" which returns "payroll_version_history_results"
  """
  getPayrollVersionHistory(
    """
    input parameters for function "getPayrollVersionHistory"
    """
    args: get_payroll_version_history_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!
  """
  execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results"
  """
  getPayrollVersionHistoryAggregate(
    """
    input parameters for function "getPayrollVersionHistoryAggregate"
    """
    args: get_payroll_version_history_args!
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): payroll_version_history_results_aggregate!
  """
  fetch data from the table: "holidays"
  """
  holidays(
    """
    distinct select on columns
    """
    distinct_on: [holidays_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [holidays_order_by!]
    """
    filter the rows returned
    """
    where: holidays_bool_exp
  ): [holidays!]!
  """
  fetch aggregated fields from the table: "holidays"
  """
  holidays_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [holidays_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [holidays_order_by!]
    """
    filter the rows returned
    """
    where: holidays_bool_exp
  ): holidays_aggregate!
  """
  fetch data from the table: "holidays" using primary key columns
  """
  holidays_by_pk(
    """
    Unique identifier for the holiday
    """
    id: uuid!
  ): holidays
  """
  fetch data from the table in a streaming manner: "holidays"
  """
  holidays_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [holidays_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: holidays_bool_exp
  ): [holidays!]!
  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results(
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!
  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latest_payroll_version_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [latest_payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [latest_payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): latest_payroll_version_results_aggregate!
  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latest_payroll_version_results_by_pk(
    id: uuid!
  ): latest_payroll_version_results
  """
  fetch data from the table in a streaming manner: "latest_payroll_version_results"
  """
  latest_payroll_version_results_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [latest_payroll_version_results_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: latest_payroll_version_results_bool_exp
  ): [latest_payroll_version_results!]!
  """
  fetch data from the table: "leave" using primary key columns
  """
  leave(
    """
    Unique identifier for the leave record
    """
    id: uuid!
  ): leave
  """
  fetch data from the table in a streaming manner: "leave"
  """
  leave_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [leave_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: leave_bool_exp
  ): [leave!]!
  """
  An array relationship
  """
  leaves(
    """
    distinct select on columns
    """
    distinct_on: [leave_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [leave_order_by!]
    """
    filter the rows returned
    """
    where: leave_bool_exp
  ): [leave!]!
  """
  fetch aggregated fields from the table: "leave"
  """
  leavesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [leave_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [leave_order_by!]
    """
    filter the rows returned
    """
    where: leave_bool_exp
  ): leave_aggregate!
  """
  fetch data from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync(
    """
    distinct select on columns
    """
    distinct_on: [neon_auth_users_sync_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [neon_auth_users_sync_order_by!]
    """
    filter the rows returned
    """
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!
  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  neon_auth_users_sync_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [neon_auth_users_sync_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [neon_auth_users_sync_order_by!]
    """
    filter the rows returned
    """
    where: neon_auth_users_sync_bool_exp
  ): neon_auth_users_sync_aggregate!
  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  neon_auth_users_sync_by_pk(
    """
    Unique identifier from the authentication provider
    """
    id: String!
  ): neon_auth_users_sync
  """
  fetch data from the table in a streaming manner: "neon_auth.users_sync"
  """
  neon_auth_users_sync_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [neon_auth_users_sync_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: neon_auth_users_sync_bool_exp
  ): [neon_auth_users_sync!]!
  """
  fetch data from the table: "notes"
  """
  notes(
    """
    distinct select on columns
    """
    distinct_on: [notes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [notes_order_by!]
    """
    filter the rows returned
    """
    where: notes_bool_exp
  ): [notes!]!
  """
  fetch aggregated fields from the table: "notes"
  """
  notes_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [notes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [notes_order_by!]
    """
    filter the rows returned
    """
    where: notes_bool_exp
  ): notes_aggregate!
  """
  fetch data from the table: "notes" using primary key columns
  """
  notes_by_pk(
    """
    Unique identifier for the note
    """
    id: uuid!
  ): notes
  """
  fetch data from the table in a streaming manner: "notes"
  """
  notes_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [notes_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: notes_bool_exp
  ): [notes!]!
  """
  fetch data from the table: "payrolls" using primary key columns
  """
  payroll(
    """
    Unique identifier for the payroll
    """
    id: uuid!
  ): payrolls
  """
  fetch data from the table: "payroll_assignments" using primary key columns
  """
  payrollAssignment(id: uuid!): payroll_assignments
  """
  fetch data from the table: "payroll_assignments"
  """
  payrollAssignments(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): [payroll_assignments!]!
  """
  fetch aggregated fields from the table: "payroll_assignments"
  """
  payrollAssignmentsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): payroll_assignments_aggregate!
  """
  fetch data from the table: "payroll_dates" using primary key columns
  """
  payrollDate(
    """
    Unique identifier for the payroll date
    """
    id: uuid!
  ): payroll_dates
  """
  An array relationship
  """
  payrollDates(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!
  """
  fetch aggregated fields from the table: "payroll_dates"
  """
  payrollDatesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dates_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dates_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): payroll_dates_aggregate!
  """
  fetch data from the table: "payroll_activation_results"
  """
  payroll_activation_results(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!
  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payroll_activation_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_activation_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_activation_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): payroll_activation_results_aggregate!
  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payroll_activation_results_by_pk(id: uuid!): payroll_activation_results
  """
  fetch data from the table in a streaming manner: "payroll_activation_results"
  """
  payroll_activation_results_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_activation_results_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_activation_results_bool_exp
  ): [payroll_activation_results!]!
  """
  fetch data from the table: "payroll_assignment_audit"
  """
  payroll_assignment_audit(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  fetch aggregated fields from the table: "payroll_assignment_audit"
  """
  payroll_assignment_audit_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): payroll_assignment_audit_aggregate!
  """
  fetch data from the table: "payroll_assignment_audit" using primary key columns
  """
  payroll_assignment_audit_by_pk(id: uuid!): payroll_assignment_audit
  """
  fetch data from the table in a streaming manner: "payroll_assignment_audit"
  """
  payroll_assignment_audit_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_assignment_audit_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  fetch data from the table in a streaming manner: "payroll_assignments"
  """
  payroll_assignments_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_assignments_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): [payroll_assignments!]!
  """
  fetch data from the table: "payroll_cycles"
  """
  payroll_cycles(
    """
    distinct select on columns
    """
    distinct_on: [payroll_cycles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_cycles_order_by!]
    """
    filter the rows returned
    """
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!
  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payroll_cycles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_cycles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_cycles_order_by!]
    """
    filter the rows returned
    """
    where: payroll_cycles_bool_exp
  ): payroll_cycles_aggregate!
  """
  fetch data from the table: "payroll_cycles" using primary key columns
  """
  payroll_cycles_by_pk(
    """
    Unique identifier for the payroll cycle
    """
    id: uuid!
  ): payroll_cycles
  """
  fetch data from the table in a streaming manner: "payroll_cycles"
  """
  payroll_cycles_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_cycles_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_cycles_bool_exp
  ): [payroll_cycles!]!
  """
  fetch data from the table: "payroll_dashboard_stats"
  """
  payroll_dashboard_stats(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dashboard_stats_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dashboard_stats_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dashboard_stats_bool_exp
  ): [payroll_dashboard_stats!]!
  """
  fetch aggregated fields from the table: "payroll_dashboard_stats"
  """
  payroll_dashboard_stats_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_dashboard_stats_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_dashboard_stats_order_by!]
    """
    filter the rows returned
    """
    where: payroll_dashboard_stats_bool_exp
  ): payroll_dashboard_stats_aggregate!
  """
  fetch data from the table in a streaming manner: "payroll_dashboard_stats"
  """
  payroll_dashboard_stats_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_dashboard_stats_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_dashboard_stats_bool_exp
  ): [payroll_dashboard_stats!]!
  """
  fetch data from the table: "payroll_date_types"
  """
  payroll_date_types(
    """
    distinct select on columns
    """
    distinct_on: [payroll_date_types_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_date_types_order_by!]
    """
    filter the rows returned
    """
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!
  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payroll_date_types_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_date_types_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_date_types_order_by!]
    """
    filter the rows returned
    """
    where: payroll_date_types_bool_exp
  ): payroll_date_types_aggregate!
  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payroll_date_types_by_pk(
    """
    Unique identifier for the payroll date type
    """
    id: uuid!
  ): payroll_date_types
  """
  fetch data from the table in a streaming manner: "payroll_date_types"
  """
  payroll_date_types_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_date_types_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_date_types_bool_exp
  ): [payroll_date_types!]!
  """
  fetch data from the table in a streaming manner: "payroll_dates"
  """
  payroll_dates_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_dates_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_dates_bool_exp
  ): [payroll_dates!]!
  """
  fetch data from the table: "payroll_triggers_status"
  """
  payroll_triggers_status(
    """
    distinct select on columns
    """
    distinct_on: [payroll_triggers_status_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_triggers_status_order_by!]
    """
    filter the rows returned
    """
    where: payroll_triggers_status_bool_exp
  ): [payroll_triggers_status!]!
  """
  fetch aggregated fields from the table: "payroll_triggers_status"
  """
  payroll_triggers_status_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_triggers_status_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_triggers_status_order_by!]
    """
    filter the rows returned
    """
    where: payroll_triggers_status_bool_exp
  ): payroll_triggers_status_aggregate!
  """
  fetch data from the table in a streaming manner: "payroll_triggers_status"
  """
  payroll_triggers_status_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_triggers_status_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_triggers_status_bool_exp
  ): [payroll_triggers_status!]!
  """
  fetch data from the table: "payroll_version_history_results"
  """
  payroll_version_history_results(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!
  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payroll_version_history_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_history_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_history_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): payroll_version_history_results_aggregate!
  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payroll_version_history_results_by_pk(
    id: uuid!
  ): payroll_version_history_results
  """
  fetch data from the table in a streaming manner: "payroll_version_history_results"
  """
  payroll_version_history_results_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_version_history_results_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_version_history_results_bool_exp
  ): [payroll_version_history_results!]!
  """
  fetch data from the table: "payroll_version_results"
  """
  payroll_version_results(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!
  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payroll_version_results_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_version_results_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_version_results_order_by!]
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): payroll_version_results_aggregate!
  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payroll_version_results_by_pk(id: uuid!): payroll_version_results
  """
  fetch data from the table in a streaming manner: "payroll_version_results"
  """
  payroll_version_results_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payroll_version_results_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payroll_version_results_bool_exp
  ): [payroll_version_results!]!
  """
  An array relationship
  """
  payrolls(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  fetch aggregated fields from the table: "payrolls"
  """
  payrollsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  fetch data from the table in a streaming manner: "payrolls"
  """
  payrolls_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [payrolls_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  fetch data from the table: "permissions" using primary key columns
  """
  permission(id: uuid!): permissions
  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permissionAuditLog(id: uuid!): permission_audit_log
  """
  fetch data from the table: "permission_audit_log"
  """
  permissionAuditLogs(
    """
    distinct select on columns
    """
    distinct_on: [permission_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!
  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permissionAuditLogsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [permission_audit_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_audit_log_order_by!]
    """
    filter the rows returned
    """
    where: permission_audit_log_bool_exp
  ): permission_audit_log_aggregate!
  """
  fetch data from the table: "audit.permission_changes" using primary key columns
  """
  permissionChange(id: uuid!): audit_permission_changes
  """
  fetch data from the table: "audit.permission_changes"
  """
  permissionChanges(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_changes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_changes_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_changes_bool_exp
  ): [audit_permission_changes!]!
  """
  fetch aggregated fields from the table: "audit.permission_changes"
  """
  permissionChangesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [audit_permission_changes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [audit_permission_changes_order_by!]
    """
    filter the rows returned
    """
    where: audit_permission_changes_bool_exp
  ): audit_permission_changes_aggregate!
  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permissionOverride(id: uuid!): permission_overrides
  """
  fetch data from the table: "permission_overrides"
  """
  permissionOverrides(
    """
    distinct select on columns
    """
    distinct_on: [permission_overrides_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_overrides_order_by!]
    """
    filter the rows returned
    """
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!
  """
  fetch aggregated fields from the table: "permission_overrides"
  """
  permissionOverridesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [permission_overrides_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permission_overrides_order_by!]
    """
    filter the rows returned
    """
    where: permission_overrides_bool_exp
  ): permission_overrides_aggregate!
  """
  fetch data from the table in a streaming manner: "permission_audit_log"
  """
  permission_audit_log_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [permission_audit_log_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: permission_audit_log_bool_exp
  ): [permission_audit_log!]!
  """
  fetch data from the table in a streaming manner: "permission_overrides"
  """
  permission_overrides_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [permission_overrides_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: permission_overrides_bool_exp
  ): [permission_overrides!]!
  """
  An array relationship
  """
  permissions(
    """
    distinct select on columns
    """
    distinct_on: [permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permissions_order_by!]
    """
    filter the rows returned
    """
    where: permissions_bool_exp
  ): [permissions!]!
  """
  fetch aggregated fields from the table: "permissions"
  """
  permissionsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [permissions_order_by!]
    """
    filter the rows returned
    """
    where: permissions_bool_exp
  ): permissions_aggregate!
  """
  fetch data from the table in a streaming manner: "permissions"
  """
  permissions_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [permissions_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: permissions_bool_exp
  ): [permissions!]!
  """
  fetch data from the table: "resources" using primary key columns
  """
  resource(id: uuid!): resources
  """
  fetch data from the table: "resources"
  """
  resources(
    """
    distinct select on columns
    """
    distinct_on: [resources_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [resources_order_by!]
    """
    filter the rows returned
    """
    where: resources_bool_exp
  ): [resources!]!
  """
  fetch aggregated fields from the table: "resources"
  """
  resourcesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [resources_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [resources_order_by!]
    """
    filter the rows returned
    """
    where: resources_bool_exp
  ): resources_aggregate!
  """
  fetch data from the table in a streaming manner: "resources"
  """
  resources_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [resources_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: resources_bool_exp
  ): [resources!]!
  """
  fetch data from the table: "roles" using primary key columns
  """
  role(id: uuid!): roles
  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  rolePermission(id: uuid!): role_permissions
  """
  An array relationship
  """
  rolePermissions(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): [role_permissions!]!
  """
  fetch aggregated fields from the table: "role_permissions"
  """
  rolePermissionsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_permissions_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [role_permissions_order_by!]
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): role_permissions_aggregate!
  """
  fetch data from the table in a streaming manner: "role_permissions"
  """
  role_permissions_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [role_permissions_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: role_permissions_bool_exp
  ): [role_permissions!]!
  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinct_on: [roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [roles_order_by!]
    """
    filter the rows returned
    """
    where: roles_bool_exp
  ): [roles!]!
  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [roles_order_by!]
    """
    filter the rows returned
    """
    where: roles_bool_exp
  ): roles_aggregate!
  """
  fetch data from the table in a streaming manner: "roles"
  """
  roles_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [roles_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: roles_bool_exp
  ): [roles!]!
  """
  fetch data from the table: "users" using primary key columns
  """
  user(
    """
    Unique identifier for the user
    """
    id: uuid!
  ): users
  """
  fetch data from the table: "user_roles" using primary key columns
  """
  userRole(id: uuid!): user_roles
  """
  An array relationship
  """
  userRoles(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): [user_roles!]!
  """
  fetch aggregated fields from the table: "user_roles"
  """
  userRolesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): user_roles_aggregate!
  """
  fetch data from the table in a streaming manner: "user_roles"
  """
  user_roles_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [user_roles_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): [user_roles!]!
  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!
  """
  fetch data from the table: "users_role_backup"
  """
  users_role_backup(
    """
    distinct select on columns
    """
    distinct_on: [users_role_backup_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_role_backup_order_by!]
    """
    filter the rows returned
    """
    where: users_role_backup_bool_exp
  ): [users_role_backup!]!
  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  users_role_backup_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_role_backup_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_role_backup_order_by!]
    """
    filter the rows returned
    """
    where: users_role_backup_bool_exp
  ): users_role_backup_aggregate!
  """
  fetch data from the table in a streaming manner: "users_role_backup"
  """
  users_role_backup_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [users_role_backup_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: users_role_backup_bool_exp
  ): [users_role_backup!]!
  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [users_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!
  """
  fetch data from the table: "work_schedule" using primary key columns
  """
  workSchedule(
    """
    Unique identifier for the work schedule entry
    """
    id: uuid!
  ): work_schedule
  """
  An array relationship
  """
  workSchedules(
    """
    distinct select on columns
    """
    distinct_on: [work_schedule_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [work_schedule_order_by!]
    """
    filter the rows returned
    """
    where: work_schedule_bool_exp
  ): [work_schedule!]!
  """
  fetch aggregated fields from the table: "work_schedule"
  """
  workSchedulesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [work_schedule_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [work_schedule_order_by!]
    """
    filter the rows returned
    """
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!
  """
  fetch data from the table in a streaming manner: "work_schedule"
  """
  work_schedule_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!
    """
    cursor to stream the results returned by the query
    """
    cursor: [work_schedule_stream_cursor_input]!
    """
    filter the rows returned
    """
    where: work_schedule_bool_exp
  ): [work_schedule!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar user_role

"""
Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'.
"""
input user_role_comparison_exp {
  _eq: user_role
  _gt: user_role
  _gte: user_role
  _in: [user_role!]
  _is_null: Boolean
  _lt: user_role
  _lte: user_role
  _neq: user_role
  _nin: [user_role!]
}

"""
columns and relationships of "user_roles"
"""
type user_roles {
  createdAt: timestamptz!
  id: uuid!
  """
  An object relationship
  """
  role: roles!
  roleId: uuid!
  updatedAt: timestamptz!
  """
  An object relationship
  """
  user: users!
  userId: uuid!
}

"""
aggregated selection of "user_roles"
"""
type user_roles_aggregate {
  aggregate: user_roles_aggregate_fields
  nodes: [user_roles!]!
}

input user_roles_aggregate_bool_exp {
  count: user_roles_aggregate_bool_exp_count
}

input user_roles_aggregate_bool_exp_count {
  arguments: [user_roles_select_column!]
  distinct: Boolean
  filter: user_roles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_roles"
"""
type user_roles_aggregate_fields {
  count(columns: [user_roles_select_column!], distinct: Boolean): Int!
  max: user_roles_max_fields
  min: user_roles_min_fields
}

"""
order by aggregate values of table "user_roles"
"""
input user_roles_aggregate_order_by {
  count: order_by
  max: user_roles_max_order_by
  min: user_roles_min_order_by
}

"""
input type for inserting array relation for remote table "user_roles"
"""
input user_roles_arr_rel_insert_input {
  data: [user_roles_insert_input!]!
  """
  upsert condition
  """
  on_conflict: user_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "user_roles". All fields are combined with a logical 'AND'.
"""
input user_roles_bool_exp {
  _and: [user_roles_bool_exp!]
  _not: user_roles_bool_exp
  _or: [user_roles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: roles_bool_exp
  roleId: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_roles"
"""
enum user_roles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey
  """
  unique or primary key constraint on columns "user_id", "role_id"
  """
  user_roles_user_id_role_id_key
}

"""
input type for inserting data into table "user_roles"
"""
input user_roles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: roles_obj_rel_insert_input
  roleId: uuid
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""
aggregate max on columns
"""
type user_roles_max_fields {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "user_roles"
"""
input user_roles_max_order_by {
  createdAt: order_by
  id: order_by
  roleId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type user_roles_min_fields {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "user_roles"
"""
input user_roles_min_order_by {
  createdAt: order_by
  id: order_by
  roleId: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_roles"
"""
type user_roles_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [user_roles!]!
}

"""
on_conflict condition type for table "user_roles"
"""
input user_roles_on_conflict {
  constraint: user_roles_constraint!
  update_columns: [user_roles_update_column!]! = []
  where: user_roles_bool_exp
}

"""
Ordering options when selecting data from "user_roles".
"""
input user_roles_order_by {
  createdAt: order_by
  id: order_by
  role: roles_order_by
  roleId: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: user_roles
"""
input user_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_roles"
"""
enum user_roles_select_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  roleId
  """
  column name
  """
  updatedAt
  """
  column name
  """
  userId
}

"""
input type for updating data in table "user_roles"
"""
input user_roles_set_input {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "user_roles"
"""
input user_roles_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: user_roles_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input user_roles_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "user_roles"
"""
enum user_roles_update_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  roleId
  """
  column name
  """
  updatedAt
  """
  column name
  """
  userId
}

input user_roles_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: user_roles_set_input
  """
  filter the rows which have to be updated
  """
  where: user_roles_bool_exp!
}

"""
columns and relationships of "users"
"""
type users {
  """
  An array relationship
  """
  billingEventLogs(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): [billing_event_log!]!
  """
  An aggregate relationship
  """
  billingEventLogs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [billing_event_log_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [billing_event_log_order_by!]
    """
    filter the rows returned
    """
    where: billing_event_log_bool_exp
  ): billing_event_log_aggregate!
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: String
  """
  Timestamp when the user was created
  """
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """
  An array relationship
  """
  directReports(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!
  """
  An aggregate relationship
  """
  directReports_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!
  """
  User's email address (unique)
  """
  email: String!
  """
  Unique identifier for the user
  """
  id: uuid!
  """
  URL to the user's profile image
  """
  image: String
  isActive: Boolean
  """
  Whether the user is a staff member (vs. external user)
  """
  isStaff: Boolean
  """
  An array relationship
  """
  leaves(
    """
    distinct select on columns
    """
    distinct_on: [leave_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [leave_order_by!]
    """
    filter the rows returned
    """
    where: leave_bool_exp
  ): [leave!]!
  """
  An aggregate relationship
  """
  leaves_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [leave_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [leave_order_by!]
    """
    filter the rows returned
    """
    where: leave_bool_exp
  ): leave_aggregate!
  """
  An object relationship
  """
  manager: users
  """
  Reference to the user's manager
  """
  managerId: uuid
  """
  User's full name
  """
  name: String!
  """
  An array relationship
  """
  notesWritten(
    """
    distinct select on columns
    """
    distinct_on: [notes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [notes_order_by!]
    """
    filter the rows returned
    """
    where: notes_bool_exp
  ): [notes!]!
  """
  An aggregate relationship
  """
  notesWritten_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [notes_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [notes_order_by!]
    """
    filter the rows returned
    """
    where: notes_bool_exp
  ): notes_aggregate!
  """
  An array relationship
  """
  payrollAssignmentAuditsAsFromConsultant(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  An aggregate relationship
  """
  payrollAssignmentAuditsAsFromConsultant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): payroll_assignment_audit_aggregate!
  """
  An array relationship
  """
  payrollAssignmentAuditsAsToConsultant(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  An aggregate relationship
  """
  payrollAssignmentAuditsAsToConsultant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): payroll_assignment_audit_aggregate!
  """
  An array relationship
  """
  payrollAssignmentAuditsCreated(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): [payroll_assignment_audit!]!
  """
  An aggregate relationship
  """
  payrollAssignmentAuditsCreated_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignment_audit_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignment_audit_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignment_audit_bool_exp
  ): payroll_assignment_audit_aggregate!
  """
  An array relationship
  """
  payrollAssignmentsAsConsultant(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): [payroll_assignments!]!
  """
  An aggregate relationship
  """
  payrollAssignmentsAsConsultant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): payroll_assignments_aggregate!
  """
  An array relationship
  """
  payrollAssignmentsAsOriginalConsultant(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): [payroll_assignments!]!
  """
  An aggregate relationship
  """
  payrollAssignmentsAsOriginalConsultant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): payroll_assignments_aggregate!
  """
  An array relationship
  """
  payrollAssignmentsCreated(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): [payroll_assignments!]!
  """
  An aggregate relationship
  """
  payrollAssignmentsCreated_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payroll_assignments_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payroll_assignments_order_by!]
    """
    filter the rows returned
    """
    where: payroll_assignments_bool_exp
  ): payroll_assignments_aggregate!
  """
  An array relationship
  """
  payrollsAsBackupConsultant(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  payrollsAsBackupConsultant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  An array relationship
  """
  payrollsAsManager(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  payrollsAsManager_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  An array relationship
  """
  payrollsAsPrimaryConsultant(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): [payrolls!]!
  """
  An aggregate relationship
  """
  payrollsAsPrimaryConsultant_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [payrolls_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [payrolls_order_by!]
    """
    filter the rows returned
    """
    where: payrolls_bool_exp
  ): payrolls_aggregate!
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: user_role!
  """
  An array relationship
  """
  teamMembers(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!
  """
  An aggregate relationship
  """
  teamMembers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]
    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!
  """
  Timestamp when the user was last updated
  """
  updatedAt: timestamptz
  """
  An array relationship
  """
  userRoles(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): [user_roles!]!
  """
  An aggregate relationship
  """
  userRoles_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_roles_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [user_roles_order_by!]
    """
    filter the rows returned
    """
    where: user_roles_bool_exp
  ): user_roles_aggregate!
  """
  User's unique username for login
  """
  username: String
  """
  An array relationship
  """
  workSchedules(
    """
    distinct select on columns
    """
    distinct_on: [work_schedule_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [work_schedule_order_by!]
    """
    filter the rows returned
    """
    where: work_schedule_bool_exp
  ): [work_schedule!]!
  """
  An aggregate relationship
  """
  workSchedules_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [work_schedule_select_column!]
    """
    limit the number of rows returned
    """
    limit: Int
    """
    skip the first n rows. Use only with order_by
    """
    offset: Int
    """
    sort the rows by one or more columns
    """
    order_by: [work_schedule_order_by!]
    """
    filter the rows returned
    """
    where: work_schedule_bool_exp
  ): work_schedule_aggregate!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  """
  upsert condition
  """
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  billingEventLogs: billing_event_log_bool_exp
  billingEventLogs_aggregate: billing_event_log_aggregate_bool_exp
  clerkUserId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  deactivatedAt: timestamptz_comparison_exp
  deactivatedBy: String_comparison_exp
  directReports: users_bool_exp
  directReports_aggregate: users_aggregate_bool_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  isActive: Boolean_comparison_exp
  isStaff: Boolean_comparison_exp
  leaves: leave_bool_exp
  leaves_aggregate: leave_aggregate_bool_exp
  manager: users_bool_exp
  managerId: uuid_comparison_exp
  name: String_comparison_exp
  notesWritten: notes_bool_exp
  notesWritten_aggregate: notes_aggregate_bool_exp
  payrollAssignmentAuditsAsFromConsultant: payroll_assignment_audit_bool_exp
  payrollAssignmentAuditsAsFromConsultant_aggregate: payroll_assignment_audit_aggregate_bool_exp
  payrollAssignmentAuditsAsToConsultant: payroll_assignment_audit_bool_exp
  payrollAssignmentAuditsAsToConsultant_aggregate: payroll_assignment_audit_aggregate_bool_exp
  payrollAssignmentAuditsCreated: payroll_assignment_audit_bool_exp
  payrollAssignmentAuditsCreated_aggregate: payroll_assignment_audit_aggregate_bool_exp
  payrollAssignmentsAsConsultant: payroll_assignments_bool_exp
  payrollAssignmentsAsConsultant_aggregate: payroll_assignments_aggregate_bool_exp
  payrollAssignmentsAsOriginalConsultant: payroll_assignments_bool_exp
  payrollAssignmentsAsOriginalConsultant_aggregate: payroll_assignments_aggregate_bool_exp
  payrollAssignmentsCreated: payroll_assignments_bool_exp
  payrollAssignmentsCreated_aggregate: payroll_assignments_aggregate_bool_exp
  payrollsAsBackupConsultant: payrolls_bool_exp
  payrollsAsBackupConsultant_aggregate: payrolls_aggregate_bool_exp
  payrollsAsManager: payrolls_bool_exp
  payrollsAsManager_aggregate: payrolls_aggregate_bool_exp
  payrollsAsPrimaryConsultant: payrolls_bool_exp
  payrollsAsPrimaryConsultant_aggregate: payrolls_aggregate_bool_exp
  role: user_role_comparison_exp
  teamMembers: users_bool_exp
  teamMembers_aggregate: users_aggregate_bool_exp
  updatedAt: timestamptz_comparison_exp
  userRoles: user_roles_bool_exp
  userRoles_aggregate: user_roles_aggregate_bool_exp
  username: String_comparison_exp
  workSchedules: work_schedule_bool_exp
  workSchedules_aggregate: work_schedule_aggregate_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "clerk_user_id"
  """
  users_clerk_user_id_key
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
  """
  unique or primary key constraint on columns "username"
  """
  users_username_key
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  billingEventLogs: billing_event_log_arr_rel_insert_input
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: String
  """
  Timestamp when the user was created
  """
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  directReports: users_arr_rel_insert_input
  """
  User's email address (unique)
  """
  email: String
  """
  Unique identifier for the user
  """
  id: uuid
  """
  URL to the user's profile image
  """
  image: String
  isActive: Boolean
  """
  Whether the user is a staff member (vs. external user)
  """
  isStaff: Boolean
  leaves: leave_arr_rel_insert_input
  manager: users_obj_rel_insert_input
  """
  Reference to the user's manager
  """
  managerId: uuid
  """
  User's full name
  """
  name: String
  notesWritten: notes_arr_rel_insert_input
  payrollAssignmentAuditsAsFromConsultant: payroll_assignment_audit_arr_rel_insert_input
  payrollAssignmentAuditsAsToConsultant: payroll_assignment_audit_arr_rel_insert_input
  payrollAssignmentAuditsCreated: payroll_assignment_audit_arr_rel_insert_input
  payrollAssignmentsAsConsultant: payroll_assignments_arr_rel_insert_input
  payrollAssignmentsAsOriginalConsultant: payroll_assignments_arr_rel_insert_input
  payrollAssignmentsCreated: payroll_assignments_arr_rel_insert_input
  payrollsAsBackupConsultant: payrolls_arr_rel_insert_input
  payrollsAsManager: payrolls_arr_rel_insert_input
  payrollsAsPrimaryConsultant: payrolls_arr_rel_insert_input
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: user_role
  teamMembers: users_arr_rel_insert_input
  """
  Timestamp when the user was last updated
  """
  updatedAt: timestamptz
  userRoles: user_roles_arr_rel_insert_input
  """
  User's unique username for login
  """
  username: String
  workSchedules: work_schedule_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type users_max_fields {
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: String
  """
  Timestamp when the user was created
  """
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """
  User's email address (unique)
  """
  email: String
  """
  Unique identifier for the user
  """
  id: uuid
  """
  URL to the user's profile image
  """
  image: String
  """
  Reference to the user's manager
  """
  managerId: uuid
  """
  User's full name
  """
  name: String
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: user_role
  """
  Timestamp when the user was last updated
  """
  updatedAt: timestamptz
  """
  User's unique username for login
  """
  username: String
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: order_by
  """
  Timestamp when the user was created
  """
  createdAt: order_by
  deactivatedAt: order_by
  deactivatedBy: order_by
  """
  User's email address (unique)
  """
  email: order_by
  """
  Unique identifier for the user
  """
  id: order_by
  """
  URL to the user's profile image
  """
  image: order_by
  """
  Reference to the user's manager
  """
  managerId: order_by
  """
  User's full name
  """
  name: order_by
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: order_by
  """
  Timestamp when the user was last updated
  """
  updatedAt: order_by
  """
  User's unique username for login
  """
  username: order_by
}

"""
aggregate min on columns
"""
type users_min_fields {
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: String
  """
  Timestamp when the user was created
  """
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """
  User's email address (unique)
  """
  email: String
  """
  Unique identifier for the user
  """
  id: uuid
  """
  URL to the user's profile image
  """
  image: String
  """
  Reference to the user's manager
  """
  managerId: uuid
  """
  User's full name
  """
  name: String
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: user_role
  """
  Timestamp when the user was last updated
  """
  updatedAt: timestamptz
  """
  User's unique username for login
  """
  username: String
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: order_by
  """
  Timestamp when the user was created
  """
  createdAt: order_by
  deactivatedAt: order_by
  deactivatedBy: order_by
  """
  User's email address (unique)
  """
  email: order_by
  """
  Unique identifier for the user
  """
  id: order_by
  """
  URL to the user's profile image
  """
  image: order_by
  """
  Reference to the user's manager
  """
  managerId: order_by
  """
  User's full name
  """
  name: order_by
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: order_by
  """
  Timestamp when the user was last updated
  """
  updatedAt: order_by
  """
  User's unique username for login
  """
  username: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  """
  upsert condition
  """
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""
Ordering options when selecting data from "users".
"""
input users_order_by {
  billingEventLogs_aggregate: billing_event_log_aggregate_order_by
  clerkUserId: order_by
  createdAt: order_by
  deactivatedAt: order_by
  deactivatedBy: order_by
  directReports_aggregate: users_aggregate_order_by
  email: order_by
  id: order_by
  image: order_by
  isActive: order_by
  isStaff: order_by
  leaves_aggregate: leave_aggregate_order_by
  manager: users_order_by
  managerId: order_by
  name: order_by
  notesWritten_aggregate: notes_aggregate_order_by
  payrollAssignmentAuditsAsFromConsultant_aggregate: payroll_assignment_audit_aggregate_order_by
  payrollAssignmentAuditsAsToConsultant_aggregate: payroll_assignment_audit_aggregate_order_by
  payrollAssignmentAuditsCreated_aggregate: payroll_assignment_audit_aggregate_order_by
  payrollAssignmentsAsConsultant_aggregate: payroll_assignments_aggregate_order_by
  payrollAssignmentsAsOriginalConsultant_aggregate: payroll_assignments_aggregate_order_by
  payrollAssignmentsCreated_aggregate: payroll_assignments_aggregate_order_by
  payrollsAsBackupConsultant_aggregate: payrolls_aggregate_order_by
  payrollsAsManager_aggregate: payrolls_aggregate_order_by
  payrollsAsPrimaryConsultant_aggregate: payrolls_aggregate_order_by
  role: order_by
  teamMembers_aggregate: users_aggregate_order_by
  updatedAt: order_by
  userRoles_aggregate: user_roles_aggregate_order_by
  username: order_by
  workSchedules_aggregate: work_schedule_aggregate_order_by
}

"""
primary key columns input for table: users
"""
input users_pk_columns_input {
  """
  Unique identifier for the user
  """
  id: uuid!
}

"""
columns and relationships of "users_role_backup"
"""
type users_role_backup {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
aggregated selection of "users_role_backup"
"""
type users_role_backup_aggregate {
  aggregate: users_role_backup_aggregate_fields
  nodes: [users_role_backup!]!
}

"""
aggregate fields of "users_role_backup"
"""
type users_role_backup_aggregate_fields {
  count(columns: [users_role_backup_select_column!], distinct: Boolean): Int!
  max: users_role_backup_max_fields
  min: users_role_backup_min_fields
}

"""
Boolean expression to filter rows from the table "users_role_backup". All fields are combined with a logical 'AND'.
"""
input users_role_backup_bool_exp {
  _and: [users_role_backup_bool_exp!]
  _not: users_role_backup_bool_exp
  _or: [users_role_backup_bool_exp!]
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  role: user_role_comparison_exp
}

"""
input type for inserting data into table "users_role_backup"
"""
input users_role_backup_insert_input {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
aggregate max on columns
"""
type users_role_backup_max_fields {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
aggregate min on columns
"""
type users_role_backup_min_fields {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
response of any mutation on the table "users_role_backup"
"""
type users_role_backup_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [users_role_backup!]!
}

"""
Ordering options when selecting data from "users_role_backup".
"""
input users_role_backup_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  role: order_by
}

"""
select columns of table "users_role_backup"
"""
enum users_role_backup_select_column {
  """
  column name
  """
  created_at
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  role
}

"""
input type for updating data in table "users_role_backup"
"""
input users_role_backup_set_input {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
Streaming cursor of the table "users_role_backup"
"""
input users_role_backup_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: users_role_backup_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input users_role_backup_stream_cursor_value_input {
  created_at: timestamptz
  email: String
  id: uuid
  role: user_role
}

input users_role_backup_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: users_role_backup_set_input
  """
  filter the rows which have to be updated
  """
  where: users_role_backup_bool_exp!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """
  column name
  """
  clerkUserId
  """
  column name
  """
  createdAt
  """
  column name
  """
  deactivatedAt
  """
  column name
  """
  deactivatedBy
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  image
  """
  column name
  """
  isActive
  """
  column name
  """
  isStaff
  """
  column name
  """
  managerId
  """
  column name
  """
  name
  """
  column name
  """
  role
  """
  column name
  """
  updatedAt
  """
  column name
  """
  username
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  isActive
  """
  column name
  """
  isStaff
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  isActive
  """
  column name
  """
  isStaff
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: String
  """
  Timestamp when the user was created
  """
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """
  User's email address (unique)
  """
  email: String
  """
  Unique identifier for the user
  """
  id: uuid
  """
  URL to the user's profile image
  """
  image: String
  isActive: Boolean
  """
  Whether the user is a staff member (vs. external user)
  """
  isStaff: Boolean
  """
  Reference to the user's manager
  """
  managerId: uuid
  """
  User's full name
  """
  name: String
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: user_role
  """
  Timestamp when the user was last updated
  """
  updatedAt: timestamptz
  """
  User's unique username for login
  """
  username: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: users_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input users_stream_cursor_value_input {
  """
  External identifier from Clerk authentication service
  """
  clerkUserId: String
  """
  Timestamp when the user was created
  """
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """
  User's email address (unique)
  """
  email: String
  """
  Unique identifier for the user
  """
  id: uuid
  """
  URL to the user's profile image
  """
  image: String
  isActive: Boolean
  """
  Whether the user is a staff member (vs. external user)
  """
  isStaff: Boolean
  """
  Reference to the user's manager
  """
  managerId: uuid
  """
  User's full name
  """
  name: String
  """
  User's system role (viewer, consultant, manager, org_admin)
  """
  role: user_role
  """
  Timestamp when the user was last updated
  """
  updatedAt: timestamptz
  """
  User's unique username for login
  """
  username: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """
  column name
  """
  clerkUserId
  """
  column name
  """
  createdAt
  """
  column name
  """
  deactivatedAt
  """
  column name
  """
  deactivatedBy
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  image
  """
  column name
  """
  isActive
  """
  column name
  """
  isStaff
  """
  column name
  """
  managerId
  """
  column name
  """
  name
  """
  column name
  """
  role
  """
  column name
  """
  updatedAt
  """
  column name
  """
  username
}

input users_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: users_set_input
  """
  filter the rows which have to be updated
  """
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "work_schedule"
"""
type work_schedule {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: timestamp
  """
  Unique identifier for the work schedule entry
  """
  id: uuid!
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: timestamp
  """
  An object relationship
  """
  user: users!
  """
  Reference to the user this schedule belongs to
  """
  userId: uuid!
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: String!
  """
  Number of hours worked on this day
  """
  workHours: numeric!
  """
  An object relationship
  """
  work_schedule_user: users!
}

"""
aggregated selection of "work_schedule"
"""
type work_schedule_aggregate {
  aggregate: work_schedule_aggregate_fields
  nodes: [work_schedule!]!
}

input work_schedule_aggregate_bool_exp {
  count: work_schedule_aggregate_bool_exp_count
}

input work_schedule_aggregate_bool_exp_count {
  arguments: [work_schedule_select_column!]
  distinct: Boolean
  filter: work_schedule_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "work_schedule"
"""
type work_schedule_aggregate_fields {
  avg: work_schedule_avg_fields
  count(columns: [work_schedule_select_column!], distinct: Boolean): Int!
  max: work_schedule_max_fields
  min: work_schedule_min_fields
  stddev: work_schedule_stddev_fields
  stddev_pop: work_schedule_stddev_pop_fields
  stddev_samp: work_schedule_stddev_samp_fields
  sum: work_schedule_sum_fields
  var_pop: work_schedule_var_pop_fields
  var_samp: work_schedule_var_samp_fields
  variance: work_schedule_variance_fields
}

"""
order by aggregate values of table "work_schedule"
"""
input work_schedule_aggregate_order_by {
  avg: work_schedule_avg_order_by
  count: order_by
  max: work_schedule_max_order_by
  min: work_schedule_min_order_by
  stddev: work_schedule_stddev_order_by
  stddev_pop: work_schedule_stddev_pop_order_by
  stddev_samp: work_schedule_stddev_samp_order_by
  sum: work_schedule_sum_order_by
  var_pop: work_schedule_var_pop_order_by
  var_samp: work_schedule_var_samp_order_by
  variance: work_schedule_variance_order_by
}

"""
input type for inserting array relation for remote table "work_schedule"
"""
input work_schedule_arr_rel_insert_input {
  data: [work_schedule_insert_input!]!
  """
  upsert condition
  """
  on_conflict: work_schedule_on_conflict
}

"""
aggregate avg on columns
"""
type work_schedule_avg_fields {
  """
  Number of hours worked on this day
  """
  workHours: Float
}

"""
order by avg() on columns of table "work_schedule"
"""
input work_schedule_avg_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
Boolean expression to filter rows from the table "work_schedule". All fields are combined with a logical 'AND'.
"""
input work_schedule_bool_exp {
  _and: [work_schedule_bool_exp!]
  _not: work_schedule_bool_exp
  _or: [work_schedule_bool_exp!]
  createdAt: timestamp_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamp_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
  workDay: String_comparison_exp
  workHours: numeric_comparison_exp
  work_schedule_user: users_bool_exp
}

"""
unique or primary key constraints on table "work_schedule"
"""
enum work_schedule_constraint {
  """
  unique or primary key constraint on columns "user_id", "work_day"
  """
  unique_user_work_day
  """
  unique or primary key constraint on columns "id"
  """
  work_schedule_pkey
}

"""
input type for incrementing numeric columns in table "work_schedule"
"""
input work_schedule_inc_input {
  """
  Number of hours worked on this day
  """
  workHours: numeric
}

"""
input type for inserting data into table "work_schedule"
"""
input work_schedule_insert_input {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: timestamp
  """
  Unique identifier for the work schedule entry
  """
  id: uuid
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: timestamp
  user: users_obj_rel_insert_input
  """
  Reference to the user this schedule belongs to
  """
  userId: uuid
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: String
  """
  Number of hours worked on this day
  """
  workHours: numeric
  work_schedule_user: users_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type work_schedule_max_fields {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: timestamp
  """
  Unique identifier for the work schedule entry
  """
  id: uuid
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: timestamp
  """
  Reference to the user this schedule belongs to
  """
  userId: uuid
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: String
  """
  Number of hours worked on this day
  """
  workHours: numeric
}

"""
order by max() on columns of table "work_schedule"
"""
input work_schedule_max_order_by {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: order_by
  """
  Unique identifier for the work schedule entry
  """
  id: order_by
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: order_by
  """
  Reference to the user this schedule belongs to
  """
  userId: order_by
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: order_by
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
aggregate min on columns
"""
type work_schedule_min_fields {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: timestamp
  """
  Unique identifier for the work schedule entry
  """
  id: uuid
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: timestamp
  """
  Reference to the user this schedule belongs to
  """
  userId: uuid
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: String
  """
  Number of hours worked on this day
  """
  workHours: numeric
}

"""
order by min() on columns of table "work_schedule"
"""
input work_schedule_min_order_by {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: order_by
  """
  Unique identifier for the work schedule entry
  """
  id: order_by
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: order_by
  """
  Reference to the user this schedule belongs to
  """
  userId: order_by
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: order_by
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
response of any mutation on the table "work_schedule"
"""
type work_schedule_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [work_schedule!]!
}

"""
on_conflict condition type for table "work_schedule"
"""
input work_schedule_on_conflict {
  constraint: work_schedule_constraint!
  update_columns: [work_schedule_update_column!]! = []
  where: work_schedule_bool_exp
}

"""
Ordering options when selecting data from "work_schedule".
"""
input work_schedule_order_by {
  createdAt: order_by
  id: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
  workDay: order_by
  workHours: order_by
  work_schedule_user: users_order_by
}

"""
primary key columns input for table: work_schedule
"""
input work_schedule_pk_columns_input {
  """
  Unique identifier for the work schedule entry
  """
  id: uuid!
}

"""
select columns of table "work_schedule"
"""
enum work_schedule_select_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  updatedAt
  """
  column name
  """
  userId
  """
  column name
  """
  workDay
  """
  column name
  """
  workHours
}

"""
input type for updating data in table "work_schedule"
"""
input work_schedule_set_input {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: timestamp
  """
  Unique identifier for the work schedule entry
  """
  id: uuid
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: timestamp
  """
  Reference to the user this schedule belongs to
  """
  userId: uuid
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: String
  """
  Number of hours worked on this day
  """
  workHours: numeric
}

"""
aggregate stddev on columns
"""
type work_schedule_stddev_fields {
  """
  Number of hours worked on this day
  """
  workHours: Float
}

"""
order by stddev() on columns of table "work_schedule"
"""
input work_schedule_stddev_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
aggregate stddev_pop on columns
"""
type work_schedule_stddev_pop_fields {
  """
  Number of hours worked on this day
  """
  workHours: Float
}

"""
order by stddev_pop() on columns of table "work_schedule"
"""
input work_schedule_stddev_pop_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
aggregate stddev_samp on columns
"""
type work_schedule_stddev_samp_fields {
  """
  Number of hours worked on this day
  """
  workHours: Float
}

"""
order by stddev_samp() on columns of table "work_schedule"
"""
input work_schedule_stddev_samp_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
Streaming cursor of the table "work_schedule"
"""
input work_schedule_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: work_schedule_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input work_schedule_stream_cursor_value_input {
  """
  Timestamp when the schedule entry was created
  """
  createdAt: timestamp
  """
  Unique identifier for the work schedule entry
  """
  id: uuid
  """
  Timestamp when the schedule entry was last updated
  """
  updatedAt: timestamp
  """
  Reference to the user this schedule belongs to
  """
  userId: uuid
  """
  Day of the week (Monday, Tuesday, etc.)
  """
  workDay: String
  """
  Number of hours worked on this day
  """
  workHours: numeric
}

"""
aggregate sum on columns
"""
type work_schedule_sum_fields {
  """
  Number of hours worked on this day
  """
  workHours: numeric
}

"""
order by sum() on columns of table "work_schedule"
"""
input work_schedule_sum_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
update columns of table "work_schedule"
"""
enum work_schedule_update_column {
  """
  column name
  """
  createdAt
  """
  column name
  """
  id
  """
  column name
  """
  updatedAt
  """
  column name
  """
  userId
  """
  column name
  """
  workDay
  """
  column name
  """
  workHours
}

input work_schedule_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: work_schedule_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: work_schedule_set_input
  """
  filter the rows which have to be updated
  """
  where: work_schedule_bool_exp!
}

"""
aggregate var_pop on columns
"""
type work_schedule_var_pop_fields {
  """
  Number of hours worked on this day
  """
  workHours: Float
}

"""
order by var_pop() on columns of table "work_schedule"
"""
input work_schedule_var_pop_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
aggregate var_samp on columns
"""
type work_schedule_var_samp_fields {
  """
  Number of hours worked on this day
  """
  workHours: Float
}

"""
order by var_samp() on columns of table "work_schedule"
"""
input work_schedule_var_samp_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}

"""
aggregate variance on columns
"""
type work_schedule_variance_fields {
  """
  Number of hours worked on this day
  """
  workHours: Float
}

"""
order by variance() on columns of table "work_schedule"
"""
input work_schedule_variance_order_by {
  """
  Number of hours worked on this day
  """
  workHours: order_by
}
