schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false
  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
columns and relationships of "adjustment_rules"
"""
type AdjustmentRules {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid!
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid!
  """Unique identifier for the adjustment rule"""
  id: uuid!
  """An object relationship"""
  payrollCycle: PayrollCycles!
  """An object relationship"""
  payrollDateType: PayrollDateTypes!
  """Code/formula used to calculate date adjustments"""
  ruleCode: String!
  """Human-readable description of the adjustment rule"""
  ruleDescription: String!
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "adjustment_rules"
"""
type AdjustmentRulesAggregate {
  aggregate: AdjustmentRulesAggregateFields
  nodes: [AdjustmentRules!]!
}

input AdjustmentRulesAggregateBoolExp {
  count: adjustmentRulesAggregateBoolExpCount
}

"""
aggregate fields of "adjustment_rules"
"""
type AdjustmentRulesAggregateFields {
  count(columns: [AdjustmentRulesSelectColumn!], distinct: Boolean): Int!
  max: AdjustmentRulesMaxFields
  min: AdjustmentRulesMinFields
}

"""
order by aggregate values of table "adjustment_rules"
"""
input AdjustmentRulesAggregateOrderBy {
  count: OrderBy
  max: AdjustmentRulesMaxOrderBy
  min: AdjustmentRulesMinOrderBy
}

"""
input type for inserting array relation for remote table "adjustment_rules"
"""
input AdjustmentRulesArrRelInsertInput {
  data: [AdjustmentRulesInsertInput!]!
  """upsert condition"""
  onConflict: AdjustmentRulesOnConflict
}

"""
Boolean expression to filter rows from the table "adjustment_rules". All fields are combined with a logical 'AND'.
"""
input AdjustmentRulesBoolExp {
  _and: [AdjustmentRulesBoolExp!]
  _not: AdjustmentRulesBoolExp
  _or: [AdjustmentRulesBoolExp!]
  createdAt: TimestamptzComparisonExp
  cycleId: UuidComparisonExp
  dateTypeId: UuidComparisonExp
  id: UuidComparisonExp
  payrollCycle: PayrollCyclesBoolExp
  payrollDateType: PayrollDateTypesBoolExp
  ruleCode: StringComparisonExp
  ruleDescription: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "adjustment_rules"
"""
enum AdjustmentRulesConstraint {
  """
  unique or primary key constraint on columns "date_type_id", "cycle_id"
  """
  adjustment_rules_cycle_id_date_type_id_key
  """
  unique or primary key constraint on columns "id"
  """
  adjustment_rules_pkey
}

"""
input type for inserting data into table "adjustment_rules"
"""
input AdjustmentRulesInsertInput {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  payrollCycle: PayrollCyclesObjRelInsertInput
  payrollDateType: PayrollDateTypesObjRelInsertInput
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type AdjustmentRulesMaxFields {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "adjustment_rules"
"""
input AdjustmentRulesMaxOrderBy {
  """Timestamp when the rule was created"""
  createdAt: OrderBy
  """Reference to the payroll cycle this rule applies to"""
  cycleId: OrderBy
  """Reference to the payroll date type this rule affects"""
  dateTypeId: OrderBy
  """Unique identifier for the adjustment rule"""
  id: OrderBy
  """Code/formula used to calculate date adjustments"""
  ruleCode: OrderBy
  """Human-readable description of the adjustment rule"""
  ruleDescription: OrderBy
  """Timestamp when the rule was last updated"""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type AdjustmentRulesMinFields {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "adjustment_rules"
"""
input AdjustmentRulesMinOrderBy {
  """Timestamp when the rule was created"""
  createdAt: OrderBy
  """Reference to the payroll cycle this rule applies to"""
  cycleId: OrderBy
  """Reference to the payroll date type this rule affects"""
  dateTypeId: OrderBy
  """Unique identifier for the adjustment rule"""
  id: OrderBy
  """Code/formula used to calculate date adjustments"""
  ruleCode: OrderBy
  """Human-readable description of the adjustment rule"""
  ruleDescription: OrderBy
  """Timestamp when the rule was last updated"""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "adjustment_rules"
"""
type AdjustmentRulesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AdjustmentRules!]!
}

"""
on_conflict condition type for table "adjustment_rules"
"""
input AdjustmentRulesOnConflict {
  constraint: AdjustmentRulesConstraint!
  updateColumns: [AdjustmentRulesUpdateColumn!]! = []
  where: AdjustmentRulesBoolExp
}

"""Ordering options when selecting data from "adjustment_rules"."""
input AdjustmentRulesOrderBy {
  createdAt: OrderBy
  cycleId: OrderBy
  dateTypeId: OrderBy
  id: OrderBy
  payrollCycle: PayrollCyclesOrderBy
  payrollDateType: PayrollDateTypesOrderBy
  ruleCode: OrderBy
  ruleDescription: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: adjustment_rules"""
input AdjustmentRulesPkColumnsInput {
  """Unique identifier for the adjustment rule"""
  id: uuid!
}

"""
select columns of table "adjustment_rules"
"""
enum AdjustmentRulesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  id
  """column name"""
  ruleCode
  """column name"""
  ruleDescription
  """column name"""
  updatedAt
}

"""
input type for updating data in table "adjustment_rules"
"""
input AdjustmentRulesSetInput {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "adjustment_rules"
"""
input AdjustmentRulesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AdjustmentRulesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AdjustmentRulesStreamCursorValueInput {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "adjustment_rules"
"""
enum AdjustmentRulesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  id
  """column name"""
  ruleCode
  """column name"""
  ruleDescription
  """column name"""
  updatedAt
}

input AdjustmentRulesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AdjustmentRulesSetInput
  """filter the rows which have to be updated"""
  where: AdjustmentRulesBoolExp!
}

"""
columns and relationships of "app_settings"
"""
type AppSettings {
  """Unique identifier for application setting"""
  id: String!
  """JSON structure containing application permission configurations"""
  permissions(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "app_settings"
"""
type AppSettingsAggregate {
  aggregate: AppSettingsAggregateFields
  nodes: [AppSettings!]!
}

"""
aggregate fields of "app_settings"
"""
type AppSettingsAggregateFields {
  count(columns: [AppSettingsSelectColumn!], distinct: Boolean): Int!
  max: AppSettingsMaxFields
  min: AppSettingsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input AppSettingsAppendInput {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Boolean expression to filter rows from the table "app_settings". All fields are combined with a logical 'AND'.
"""
input AppSettingsBoolExp {
  _and: [AppSettingsBoolExp!]
  _not: AppSettingsBoolExp
  _or: [AppSettingsBoolExp!]
  id: StringComparisonExp
  permissions: JsonbComparisonExp
}

"""
unique or primary key constraints on table "app_settings"
"""
enum AppSettingsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AppSettingsDeleteAtPathInput {
  """JSON structure containing application permission configurations"""
  permissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AppSettingsDeleteElemInput {
  """JSON structure containing application permission configurations"""
  permissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AppSettingsDeleteKeyInput {
  """JSON structure containing application permission configurations"""
  permissions: String
}

"""
input type for inserting data into table "app_settings"
"""
input AppSettingsInsertInput {
  """Unique identifier for application setting"""
  id: String
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""aggregate max on columns"""
type AppSettingsMaxFields {
  """Unique identifier for application setting"""
  id: String
}

"""aggregate min on columns"""
type AppSettingsMinFields {
  """Unique identifier for application setting"""
  id: String
}

"""
response of any mutation on the table "app_settings"
"""
type AppSettingsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AppSettings!]!
}

"""
on_conflict condition type for table "app_settings"
"""
input AppSettingsOnConflict {
  constraint: AppSettingsConstraint!
  updateColumns: [AppSettingsUpdateColumn!]! = []
  where: AppSettingsBoolExp
}

"""Ordering options when selecting data from "app_settings"."""
input AppSettingsOrderBy {
  id: OrderBy
  permissions: OrderBy
}

"""primary key columns input for table: app_settings"""
input AppSettingsPkColumnsInput {
  """Unique identifier for application setting"""
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input AppSettingsPrependInput {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
select columns of table "app_settings"
"""
enum AppSettingsSelectColumn {
  """column name"""
  id
  """column name"""
  permissions
}

"""
input type for updating data in table "app_settings"
"""
input AppSettingsSetInput {
  """Unique identifier for application setting"""
  id: String
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Streaming cursor of the table "app_settings"
"""
input AppSettingsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AppSettingsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AppSettingsStreamCursorValueInput {
  """Unique identifier for application setting"""
  id: String
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
update columns of table "app_settings"
"""
enum AppSettingsUpdateColumn {
  """column name"""
  id
  """column name"""
  permissions
}

input AppSettingsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: AppSettingsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: AppSettingsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: AppSettingsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: AppSettingsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: AppSettingsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: AppSettingsSetInput
  """filter the rows which have to be updated"""
  where: AppSettingsBoolExp!
}

"""
columns and relationships of "audit.audit_log"
"""
type AuditAuditLog {
  action: String!
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz!
  id: uuid!
  ipAddress: inet
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newValues(
    """JSON select path"""
    path: String
  ): jsonb
  oldValues(
    """JSON select path"""
    path: String
  ): jsonb
  requestId: String
  resourceId: String
  resourceType: String!
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
aggregated selection of "audit.audit_log"
"""
type AuditAuditLogAggregate {
  aggregate: AuditAuditLogAggregateFields
  nodes: [AuditAuditLog!]!
}

"""
aggregate fields of "audit.audit_log"
"""
type AuditAuditLogAggregateFields {
  count(columns: [AuditAuditLogSelectColumn!], distinct: Boolean): Int!
  max: AuditAuditLogMaxFields
  min: AuditAuditLogMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input AuditAuditLogAppendInput {
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
}

"""
Boolean expression to filter rows from the table "audit.audit_log". All fields are combined with a logical 'AND'.
"""
input AuditAuditLogBoolExp {
  _and: [AuditAuditLogBoolExp!]
  _not: AuditAuditLogBoolExp
  _or: [AuditAuditLogBoolExp!]
  action: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  errorMessage: StringComparisonExp
  eventTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  metadata: JsonbComparisonExp
  newValues: JsonbComparisonExp
  oldValues: JsonbComparisonExp
  requestId: StringComparisonExp
  resourceId: StringComparisonExp
  resourceType: StringComparisonExp
  sessionId: StringComparisonExp
  success: BooleanComparisonExp
  userAgent: StringComparisonExp
  userEmail: StringComparisonExp
  userId: UuidComparisonExp
  userRole: StringComparisonExp
}

"""
unique or primary key constraints on table "audit.audit_log"
"""
enum AuditAuditLogConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AuditAuditLogDeleteAtPathInput {
  metadata: [String!]
  newValues: [String!]
  oldValues: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AuditAuditLogDeleteElemInput {
  metadata: Int
  newValues: Int
  oldValues: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AuditAuditLogDeleteKeyInput {
  metadata: String
  newValues: String
  oldValues: String
}

"""
input type for inserting data into table "audit.audit_log"
"""
input AuditAuditLogInsertInput {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""aggregate max on columns"""
type AuditAuditLogMaxFields {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""aggregate min on columns"""
type AuditAuditLogMinFields {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
response of any mutation on the table "audit.audit_log"
"""
type AuditAuditLogMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AuditAuditLog!]!
}

"""
on_conflict condition type for table "audit.audit_log"
"""
input AuditAuditLogOnConflict {
  constraint: AuditAuditLogConstraint!
  updateColumns: [AuditAuditLogUpdateColumn!]! = []
  where: AuditAuditLogBoolExp
}

"""Ordering options when selecting data from "audit.audit_log"."""
input AuditAuditLogOrderBy {
  action: OrderBy
  createdAt: OrderBy
  errorMessage: OrderBy
  eventTime: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  metadata: OrderBy
  newValues: OrderBy
  oldValues: OrderBy
  requestId: OrderBy
  resourceId: OrderBy
  resourceType: OrderBy
  sessionId: OrderBy
  success: OrderBy
  userAgent: OrderBy
  userEmail: OrderBy
  userId: OrderBy
  userRole: OrderBy
}

"""primary key columns input for table: audit.audit_log"""
input AuditAuditLogPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input AuditAuditLogPrependInput {
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
}

"""
select columns of table "audit.audit_log"
"""
enum AuditAuditLogSelectColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  errorMessage
  """column name"""
  eventTime
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  newValues
  """column name"""
  oldValues
  """column name"""
  requestId
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  sessionId
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
  """column name"""
  userRole
}

"""
input type for updating data in table "audit.audit_log"
"""
input AuditAuditLogSetInput {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
Streaming cursor of the table "audit_audit_log"
"""
input AuditAuditLogStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuditAuditLogStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuditAuditLogStreamCursorValueInput {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
update columns of table "audit.audit_log"
"""
enum AuditAuditLogUpdateColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  errorMessage
  """column name"""
  eventTime
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  newValues
  """column name"""
  oldValues
  """column name"""
  requestId
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  sessionId
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
  """column name"""
  userRole
}

input AuditAuditLogUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: AuditAuditLogAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: AuditAuditLogDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: AuditAuditLogDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: AuditAuditLogDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: AuditAuditLogPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: AuditAuditLogSetInput
  """filter the rows which have to be updated"""
  where: AuditAuditLogBoolExp!
}

"""
columns and relationships of "audit.auth_events"
"""
type AuditAuthEvents {
  createdAt: timestamptz
  eventTime: timestamptz!
  eventType: String!
  failureReason: String
  id: uuid!
  ipAddress: inet
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
aggregated selection of "audit.auth_events"
"""
type AuditAuthEventsAggregate {
  aggregate: AuditAuthEventsAggregateFields
  nodes: [AuditAuthEvents!]!
}

"""
aggregate fields of "audit.auth_events"
"""
type AuditAuthEventsAggregateFields {
  count(columns: [AuditAuthEventsSelectColumn!], distinct: Boolean): Int!
  max: AuditAuthEventsMaxFields
  min: AuditAuthEventsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input AuditAuthEventsAppendInput {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "audit.auth_events". All fields are combined with a logical 'AND'.
"""
input AuditAuthEventsBoolExp {
  _and: [AuditAuthEventsBoolExp!]
  _not: AuditAuthEventsBoolExp
  _or: [AuditAuthEventsBoolExp!]
  createdAt: TimestamptzComparisonExp
  eventTime: TimestamptzComparisonExp
  eventType: StringComparisonExp
  failureReason: StringComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  metadata: JsonbComparisonExp
  success: BooleanComparisonExp
  userAgent: StringComparisonExp
  userEmail: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.auth_events"
"""
enum AuditAuthEventsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  auth_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AuditAuthEventsDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AuditAuthEventsDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AuditAuthEventsDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "audit.auth_events"
"""
input AuditAuthEventsInsertInput {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""aggregate max on columns"""
type AuditAuthEventsMaxFields {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  userAgent: String
  userEmail: String
  userId: uuid
}

"""aggregate min on columns"""
type AuditAuthEventsMinFields {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
response of any mutation on the table "audit.auth_events"
"""
type AuditAuthEventsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AuditAuthEvents!]!
}

"""
on_conflict condition type for table "audit.auth_events"
"""
input AuditAuthEventsOnConflict {
  constraint: AuditAuthEventsConstraint!
  updateColumns: [AuditAuthEventsUpdateColumn!]! = []
  where: AuditAuthEventsBoolExp
}

"""Ordering options when selecting data from "audit.auth_events"."""
input AuditAuthEventsOrderBy {
  createdAt: OrderBy
  eventTime: OrderBy
  eventType: OrderBy
  failureReason: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  metadata: OrderBy
  success: OrderBy
  userAgent: OrderBy
  userEmail: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: audit.auth_events"""
input AuditAuthEventsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input AuditAuthEventsPrependInput {
  metadata: jsonb
}

"""
select columns of table "audit.auth_events"
"""
enum AuditAuthEventsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  eventTime
  """column name"""
  eventType
  """column name"""
  failureReason
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
}

"""
input type for updating data in table "audit.auth_events"
"""
input AuditAuthEventsSetInput {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
Streaming cursor of the table "audit_auth_events"
"""
input AuditAuthEventsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuditAuthEventsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuditAuthEventsStreamCursorValueInput {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
update columns of table "audit.auth_events"
"""
enum AuditAuthEventsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  eventTime
  """column name"""
  eventType
  """column name"""
  failureReason
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
}

input AuditAuthEventsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: AuditAuthEventsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: AuditAuthEventsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: AuditAuthEventsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: AuditAuthEventsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: AuditAuthEventsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: AuditAuthEventsSetInput
  """filter the rows which have to be updated"""
  where: AuditAuthEventsBoolExp!
}

"""
columns and relationships of "audit.data_access_log"
"""
type AuditDataAccessLog {
  accessType: String!
  accessedAt: timestamptz!
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid!
  ipAddress: inet
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String!
  rowCount: Int
  sessionId: String
  userId: uuid!
}

"""
aggregated selection of "audit.data_access_log"
"""
type AuditDataAccessLogAggregate {
  aggregate: AuditDataAccessLogAggregateFields
  nodes: [AuditDataAccessLog!]!
}

"""
aggregate fields of "audit.data_access_log"
"""
type AuditDataAccessLogAggregateFields {
  avg: AuditDataAccessLogAvgFields
  count(columns: [AuditDataAccessLogSelectColumn!], distinct: Boolean): Int!
  max: AuditDataAccessLogMaxFields
  min: AuditDataAccessLogMinFields
  stddev: AuditDataAccessLogStddevFields
  stddevPop: AuditDataAccessLogStddevPopFields
  stddevSamp: AuditDataAccessLogStddevSampFields
  sum: AuditDataAccessLogSumFields
  varPop: AuditDataAccessLogVarPopFields
  varSamp: AuditDataAccessLogVarSampFields
  variance: AuditDataAccessLogVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input AuditDataAccessLogAppendInput {
  metadata: jsonb
}

"""aggregate avg on columns"""
type AuditDataAccessLogAvgFields {
  rowCount: Float
}

"""
Boolean expression to filter rows from the table "audit.data_access_log". All fields are combined with a logical 'AND'.
"""
input AuditDataAccessLogBoolExp {
  _and: [AuditDataAccessLogBoolExp!]
  _not: AuditDataAccessLogBoolExp
  _or: [AuditDataAccessLogBoolExp!]
  accessType: StringComparisonExp
  accessedAt: TimestamptzComparisonExp
  dataClassification: StringComparisonExp
  fieldsAccessed: StringArrayComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  metadata: JsonbComparisonExp
  queryExecuted: StringComparisonExp
  resourceId: StringComparisonExp
  resourceType: StringComparisonExp
  rowCount: IntComparisonExp
  sessionId: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.data_access_log"
"""
enum AuditDataAccessLogConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  data_access_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AuditDataAccessLogDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AuditDataAccessLogDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AuditDataAccessLogDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "audit.data_access_log"
"""
input AuditDataAccessLogIncInput {
  rowCount: Int
}

"""
input type for inserting data into table "audit.data_access_log"
"""
input AuditDataAccessLogInsertInput {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate max on columns"""
type AuditDataAccessLogMaxFields {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate min on columns"""
type AuditDataAccessLogMinFields {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""
response of any mutation on the table "audit.data_access_log"
"""
type AuditDataAccessLogMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AuditDataAccessLog!]!
}

"""
on_conflict condition type for table "audit.data_access_log"
"""
input AuditDataAccessLogOnConflict {
  constraint: AuditDataAccessLogConstraint!
  updateColumns: [AuditDataAccessLogUpdateColumn!]! = []
  where: AuditDataAccessLogBoolExp
}

"""Ordering options when selecting data from "audit.data_access_log"."""
input AuditDataAccessLogOrderBy {
  accessType: OrderBy
  accessedAt: OrderBy
  dataClassification: OrderBy
  fieldsAccessed: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  metadata: OrderBy
  queryExecuted: OrderBy
  resourceId: OrderBy
  resourceType: OrderBy
  rowCount: OrderBy
  sessionId: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: audit.data_access_log"""
input AuditDataAccessLogPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input AuditDataAccessLogPrependInput {
  metadata: jsonb
}

"""
select columns of table "audit.data_access_log"
"""
enum AuditDataAccessLogSelectColumn {
  """column name"""
  accessType
  """column name"""
  accessedAt
  """column name"""
  dataClassification
  """column name"""
  fieldsAccessed
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  queryExecuted
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  rowCount
  """column name"""
  sessionId
  """column name"""
  userId
}

"""
input type for updating data in table "audit.data_access_log"
"""
input AuditDataAccessLogSetInput {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate stddev on columns"""
type AuditDataAccessLogStddevFields {
  rowCount: Float
}

"""aggregate stddevPop on columns"""
type AuditDataAccessLogStddevPopFields {
  rowCount: Float
}

"""aggregate stddevSamp on columns"""
type AuditDataAccessLogStddevSampFields {
  rowCount: Float
}

"""
Streaming cursor of the table "audit_data_access_log"
"""
input AuditDataAccessLogStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuditDataAccessLogStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuditDataAccessLogStreamCursorValueInput {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate sum on columns"""
type AuditDataAccessLogSumFields {
  rowCount: Int
}

"""
update columns of table "audit.data_access_log"
"""
enum AuditDataAccessLogUpdateColumn {
  """column name"""
  accessType
  """column name"""
  accessedAt
  """column name"""
  dataClassification
  """column name"""
  fieldsAccessed
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  queryExecuted
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  rowCount
  """column name"""
  sessionId
  """column name"""
  userId
}

input AuditDataAccessLogUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: AuditDataAccessLogAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: AuditDataAccessLogDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: AuditDataAccessLogDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: AuditDataAccessLogDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: AuditDataAccessLogIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: AuditDataAccessLogPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: AuditDataAccessLogSetInput
  """filter the rows which have to be updated"""
  where: AuditDataAccessLogBoolExp!
}

"""aggregate varPop on columns"""
type AuditDataAccessLogVarPopFields {
  rowCount: Float
}

"""aggregate varSamp on columns"""
type AuditDataAccessLogVarSampFields {
  rowCount: Float
}

"""aggregate variance on columns"""
type AuditDataAccessLogVarianceFields {
  rowCount: Float
}

"""
columns and relationships of "audit.permission_changes"
"""
type AuditPermissionChanges {
  approvedByUserId: uuid
  changeType: String!
  changedAt: timestamptz!
  changedByUserId: uuid!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newPermissions(
    """JSON select path"""
    path: String
  ): jsonb
  oldPermissions(
    """JSON select path"""
    path: String
  ): jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
aggregated selection of "audit.permission_changes"
"""
type AuditPermissionChangesAggregate {
  aggregate: AuditPermissionChangesAggregateFields
  nodes: [AuditPermissionChanges!]!
}

"""
aggregate fields of "audit.permission_changes"
"""
type AuditPermissionChangesAggregateFields {
  count(columns: [AuditPermissionChangesSelectColumn!], distinct: Boolean): Int!
  max: AuditPermissionChangesMaxFields
  min: AuditPermissionChangesMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input AuditPermissionChangesAppendInput {
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
}

"""
Boolean expression to filter rows from the table "audit.permission_changes". All fields are combined with a logical 'AND'.
"""
input AuditPermissionChangesBoolExp {
  _and: [AuditPermissionChangesBoolExp!]
  _not: AuditPermissionChangesBoolExp
  _or: [AuditPermissionChangesBoolExp!]
  approvedByUserId: UuidComparisonExp
  changeType: StringComparisonExp
  changedAt: TimestamptzComparisonExp
  changedByUserId: UuidComparisonExp
  id: UuidComparisonExp
  metadata: JsonbComparisonExp
  newPermissions: JsonbComparisonExp
  oldPermissions: JsonbComparisonExp
  permissionType: StringComparisonExp
  reason: StringComparisonExp
  targetRoleId: UuidComparisonExp
  targetUserId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.permission_changes"
"""
enum AuditPermissionChangesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_changes_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AuditPermissionChangesDeleteAtPathInput {
  metadata: [String!]
  newPermissions: [String!]
  oldPermissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AuditPermissionChangesDeleteElemInput {
  metadata: Int
  newPermissions: Int
  oldPermissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AuditPermissionChangesDeleteKeyInput {
  metadata: String
  newPermissions: String
  oldPermissions: String
}

"""
input type for inserting data into table "audit.permission_changes"
"""
input AuditPermissionChangesInsertInput {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""aggregate max on columns"""
type AuditPermissionChangesMaxFields {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""aggregate min on columns"""
type AuditPermissionChangesMinFields {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
response of any mutation on the table "audit.permission_changes"
"""
type AuditPermissionChangesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AuditPermissionChanges!]!
}

"""
on_conflict condition type for table "audit.permission_changes"
"""
input AuditPermissionChangesOnConflict {
  constraint: AuditPermissionChangesConstraint!
  updateColumns: [AuditPermissionChangesUpdateColumn!]! = []
  where: AuditPermissionChangesBoolExp
}

"""Ordering options when selecting data from "audit.permission_changes"."""
input AuditPermissionChangesOrderBy {
  approvedByUserId: OrderBy
  changeType: OrderBy
  changedAt: OrderBy
  changedByUserId: OrderBy
  id: OrderBy
  metadata: OrderBy
  newPermissions: OrderBy
  oldPermissions: OrderBy
  permissionType: OrderBy
  reason: OrderBy
  targetRoleId: OrderBy
  targetUserId: OrderBy
}

"""primary key columns input for table: audit.permission_changes"""
input AuditPermissionChangesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input AuditPermissionChangesPrependInput {
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
}

"""
select columns of table "audit.permission_changes"
"""
enum AuditPermissionChangesSelectColumn {
  """column name"""
  approvedByUserId
  """column name"""
  changeType
  """column name"""
  changedAt
  """column name"""
  changedByUserId
  """column name"""
  id
  """column name"""
  metadata
  """column name"""
  newPermissions
  """column name"""
  oldPermissions
  """column name"""
  permissionType
  """column name"""
  reason
  """column name"""
  targetRoleId
  """column name"""
  targetUserId
}

"""
input type for updating data in table "audit.permission_changes"
"""
input AuditPermissionChangesSetInput {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
Streaming cursor of the table "audit_permission_changes"
"""
input AuditPermissionChangesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuditPermissionChangesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuditPermissionChangesStreamCursorValueInput {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
update columns of table "audit.permission_changes"
"""
enum AuditPermissionChangesUpdateColumn {
  """column name"""
  approvedByUserId
  """column name"""
  changeType
  """column name"""
  changedAt
  """column name"""
  changedByUserId
  """column name"""
  id
  """column name"""
  metadata
  """column name"""
  newPermissions
  """column name"""
  oldPermissions
  """column name"""
  permissionType
  """column name"""
  reason
  """column name"""
  targetRoleId
  """column name"""
  targetUserId
}

input AuditPermissionChangesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: AuditPermissionChangesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: AuditPermissionChangesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: AuditPermissionChangesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: AuditPermissionChangesDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: AuditPermissionChangesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: AuditPermissionChangesSetInput
  """filter the rows which have to be updated"""
  where: AuditPermissionChangesBoolExp!
}

"""
columns and relationships of "audit.permission_usage_report"
"""
type AuditPermissionUsageReport {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""
aggregated selection of "audit.permission_usage_report"
"""
type AuditPermissionUsageReportAggregate {
  aggregate: AuditPermissionUsageReportAggregateFields
  nodes: [AuditPermissionUsageReport!]!
}

"""
aggregate fields of "audit.permission_usage_report"
"""
type AuditPermissionUsageReportAggregateFields {
  avg: AuditPermissionUsageReportAvgFields
  count(columns: [AuditPermissionUsageReportSelectColumn!], distinct: Boolean): Int!
  max: AuditPermissionUsageReportMaxFields
  min: AuditPermissionUsageReportMinFields
  stddev: AuditPermissionUsageReportStddevFields
  stddevPop: AuditPermissionUsageReportStddevPopFields
  stddevSamp: AuditPermissionUsageReportStddevSampFields
  sum: AuditPermissionUsageReportSumFields
  varPop: AuditPermissionUsageReportVarPopFields
  varSamp: AuditPermissionUsageReportVarSampFields
  variance: AuditPermissionUsageReportVarianceFields
}

"""aggregate avg on columns"""
type AuditPermissionUsageReportAvgFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""
Boolean expression to filter rows from the table "audit.permission_usage_report". All fields are combined with a logical 'AND'.
"""
input AuditPermissionUsageReportBoolExp {
  _and: [AuditPermissionUsageReportBoolExp!]
  _not: AuditPermissionUsageReportBoolExp
  _or: [AuditPermissionUsageReportBoolExp!]
  action: PermissionActionComparisonExp
  lastUsed: TimestamptzComparisonExp
  resourceName: StringComparisonExp
  roleName: StringComparisonExp
  totalUsageCount: BigintComparisonExp
  usersWhoUsedPermission: BigintComparisonExp
  usersWithPermission: BigintComparisonExp
}

"""aggregate max on columns"""
type AuditPermissionUsageReportMaxFields {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""aggregate min on columns"""
type AuditPermissionUsageReportMinFields {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""
Ordering options when selecting data from "audit.permission_usage_report".
"""
input AuditPermissionUsageReportOrderBy {
  action: OrderBy
  lastUsed: OrderBy
  resourceName: OrderBy
  roleName: OrderBy
  totalUsageCount: OrderBy
  usersWhoUsedPermission: OrderBy
  usersWithPermission: OrderBy
}

"""
select columns of table "audit.permission_usage_report"
"""
enum AuditPermissionUsageReportSelectColumn {
  """column name"""
  action
  """column name"""
  lastUsed
  """column name"""
  resourceName
  """column name"""
  roleName
  """column name"""
  totalUsageCount
  """column name"""
  usersWhoUsedPermission
  """column name"""
  usersWithPermission
}

"""aggregate stddev on columns"""
type AuditPermissionUsageReportStddevFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate stddevPop on columns"""
type AuditPermissionUsageReportStddevPopFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate stddevSamp on columns"""
type AuditPermissionUsageReportStddevSampFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""
Streaming cursor of the table "audit_permission_usage_report"
"""
input AuditPermissionUsageReportStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuditPermissionUsageReportStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuditPermissionUsageReportStreamCursorValueInput {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""aggregate sum on columns"""
type AuditPermissionUsageReportSumFields {
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""aggregate varPop on columns"""
type AuditPermissionUsageReportVarPopFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate varSamp on columns"""
type AuditPermissionUsageReportVarSampFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate variance on columns"""
type AuditPermissionUsageReportVarianceFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""
columns and relationships of "audit.slow_queries"
"""
type AuditSlowQueries {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid!
  query: String!
  queryDuration: interval!
  queryStart: timestamptz!
  userId: uuid
}

"""
aggregated selection of "audit.slow_queries"
"""
type AuditSlowQueriesAggregate {
  aggregate: AuditSlowQueriesAggregateFields
  nodes: [AuditSlowQueries!]!
}

"""
aggregate fields of "audit.slow_queries"
"""
type AuditSlowQueriesAggregateFields {
  count(columns: [AuditSlowQueriesSelectColumn!], distinct: Boolean): Int!
  max: AuditSlowQueriesMaxFields
  min: AuditSlowQueriesMinFields
}

"""
Boolean expression to filter rows from the table "audit.slow_queries". All fields are combined with a logical 'AND'.
"""
input AuditSlowQueriesBoolExp {
  _and: [AuditSlowQueriesBoolExp!]
  _not: AuditSlowQueriesBoolExp
  _or: [AuditSlowQueriesBoolExp!]
  applicationName: StringComparisonExp
  clientAddr: InetComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  query: StringComparisonExp
  queryDuration: IntervalComparisonExp
  queryStart: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.slow_queries"
"""
enum AuditSlowQueriesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  slow_queries_pkey
}

"""
input type for inserting data into table "audit.slow_queries"
"""
input AuditSlowQueriesInsertInput {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid
  query: String
  queryDuration: interval
  queryStart: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type AuditSlowQueriesMaxFields {
  applicationName: String
  createdAt: timestamptz
  id: uuid
  query: String
  queryStart: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type AuditSlowQueriesMinFields {
  applicationName: String
  createdAt: timestamptz
  id: uuid
  query: String
  queryStart: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "audit.slow_queries"
"""
type AuditSlowQueriesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AuditSlowQueries!]!
}

"""
on_conflict condition type for table "audit.slow_queries"
"""
input AuditSlowQueriesOnConflict {
  constraint: AuditSlowQueriesConstraint!
  updateColumns: [AuditSlowQueriesUpdateColumn!]! = []
  where: AuditSlowQueriesBoolExp
}

"""Ordering options when selecting data from "audit.slow_queries"."""
input AuditSlowQueriesOrderBy {
  applicationName: OrderBy
  clientAddr: OrderBy
  createdAt: OrderBy
  id: OrderBy
  query: OrderBy
  queryDuration: OrderBy
  queryStart: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: audit.slow_queries"""
input AuditSlowQueriesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "audit.slow_queries"
"""
enum AuditSlowQueriesSelectColumn {
  """column name"""
  applicationName
  """column name"""
  clientAddr
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  query
  """column name"""
  queryDuration
  """column name"""
  queryStart
  """column name"""
  userId
}

"""
input type for updating data in table "audit.slow_queries"
"""
input AuditSlowQueriesSetInput {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid
  query: String
  queryDuration: interval
  queryStart: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "audit_slow_queries"
"""
input AuditSlowQueriesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuditSlowQueriesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuditSlowQueriesStreamCursorValueInput {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid
  query: String
  queryDuration: interval
  queryStart: timestamptz
  userId: uuid
}

"""
update columns of table "audit.slow_queries"
"""
enum AuditSlowQueriesUpdateColumn {
  """column name"""
  applicationName
  """column name"""
  clientAddr
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  query
  """column name"""
  queryDuration
  """column name"""
  queryStart
  """column name"""
  userId
}

input AuditSlowQueriesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AuditSlowQueriesSetInput
  """filter the rows which have to be updated"""
  where: AuditSlowQueriesBoolExp!
}

"""
columns and relationships of "audit.user_access_summary"
"""
type AuditUserAccessSummary {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""
aggregated selection of "audit.user_access_summary"
"""
type AuditUserAccessSummaryAggregate {
  aggregate: AuditUserAccessSummaryAggregateFields
  nodes: [AuditUserAccessSummary!]!
}

"""
aggregate fields of "audit.user_access_summary"
"""
type AuditUserAccessSummaryAggregateFields {
  count(columns: [AuditUserAccessSummarySelectColumn!], distinct: Boolean): Int!
  max: AuditUserAccessSummaryMaxFields
  min: AuditUserAccessSummaryMinFields
}

"""
Boolean expression to filter rows from the table "audit.user_access_summary". All fields are combined with a logical 'AND'.
"""
input AuditUserAccessSummaryBoolExp {
  _and: [AuditUserAccessSummaryBoolExp!]
  _not: AuditUserAccessSummaryBoolExp
  _or: [AuditUserAccessSummaryBoolExp!]
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  isStaff: BooleanComparisonExp
  name: StringComparisonExp
  role: UserRoleComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
input type for inserting data into table "audit.user_access_summary"
"""
input AuditUserAccessSummaryInsertInput {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type AuditUserAccessSummaryMaxFields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type AuditUserAccessSummaryMinFields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""
response of any mutation on the table "audit.user_access_summary"
"""
type AuditUserAccessSummaryMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [AuditUserAccessSummary!]!
}

"""Ordering options when selecting data from "audit.user_access_summary"."""
input AuditUserAccessSummaryOrderBy {
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  isActive: OrderBy
  isStaff: OrderBy
  name: OrderBy
  role: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "audit.user_access_summary"
"""
enum AuditUserAccessSummarySelectColumn {
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isStaff
  """column name"""
  name
  """column name"""
  role
  """column name"""
  updatedAt
}

"""
input type for updating data in table "audit.user_access_summary"
"""
input AuditUserAccessSummarySetInput {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "audit_user_access_summary"
"""
input AuditUserAccessSummaryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuditUserAccessSummaryStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuditUserAccessSummaryStreamCursorValueInput {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

input AuditUserAccessSummaryUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: AuditUserAccessSummarySetInput
  """filter the rows which have to be updated"""
  where: AuditUserAccessSummaryBoolExp!
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""Metrics showing automation effectiveness and approval workflows"""
type BillingAutomationMetrics {
  approvedItems: bigint
  autoGeneratedItems: bigint
  autoGeneratedRevenue: numeric
  avgApprovalDays: numeric
  manualItems: bigint
  manualRevenue: numeric
  pendingApproval: bigint
}

"""
aggregated selection of "billing_automation_metrics"
"""
type BillingAutomationMetricsAggregate {
  aggregate: BillingAutomationMetricsAggregateFields
  nodes: [BillingAutomationMetrics!]!
}

"""
aggregate fields of "billing_automation_metrics"
"""
type BillingAutomationMetricsAggregateFields {
  avg: BillingAutomationMetricsAvgFields
  count(columns: [BillingAutomationMetricsSelectColumn!], distinct: Boolean): Int!
  max: BillingAutomationMetricsMaxFields
  min: BillingAutomationMetricsMinFields
  stddev: BillingAutomationMetricsStddevFields
  stddevPop: BillingAutomationMetricsStddevPopFields
  stddevSamp: BillingAutomationMetricsStddevSampFields
  sum: BillingAutomationMetricsSumFields
  varPop: BillingAutomationMetricsVarPopFields
  varSamp: BillingAutomationMetricsVarSampFields
  variance: BillingAutomationMetricsVarianceFields
}

"""aggregate avg on columns"""
type BillingAutomationMetricsAvgFields {
  approvedItems: Float
  autoGeneratedItems: Float
  autoGeneratedRevenue: Float
  avgApprovalDays: Float
  manualItems: Float
  manualRevenue: Float
  pendingApproval: Float
}

"""
Boolean expression to filter rows from the table "billing_automation_metrics". All fields are combined with a logical 'AND'.
"""
input BillingAutomationMetricsBoolExp {
  _and: [BillingAutomationMetricsBoolExp!]
  _not: BillingAutomationMetricsBoolExp
  _or: [BillingAutomationMetricsBoolExp!]
  approvedItems: BigintComparisonExp
  autoGeneratedItems: BigintComparisonExp
  autoGeneratedRevenue: NumericComparisonExp
  avgApprovalDays: NumericComparisonExp
  manualItems: BigintComparisonExp
  manualRevenue: NumericComparisonExp
  pendingApproval: BigintComparisonExp
}

"""aggregate max on columns"""
type BillingAutomationMetricsMaxFields {
  approvedItems: bigint
  autoGeneratedItems: bigint
  autoGeneratedRevenue: numeric
  avgApprovalDays: numeric
  manualItems: bigint
  manualRevenue: numeric
  pendingApproval: bigint
}

"""aggregate min on columns"""
type BillingAutomationMetricsMinFields {
  approvedItems: bigint
  autoGeneratedItems: bigint
  autoGeneratedRevenue: numeric
  avgApprovalDays: numeric
  manualItems: bigint
  manualRevenue: numeric
  pendingApproval: bigint
}

"""
Ordering options when selecting data from "billing_automation_metrics".
"""
input BillingAutomationMetricsOrderBy {
  approvedItems: OrderBy
  autoGeneratedItems: OrderBy
  autoGeneratedRevenue: OrderBy
  avgApprovalDays: OrderBy
  manualItems: OrderBy
  manualRevenue: OrderBy
  pendingApproval: OrderBy
}

"""
select columns of table "billing_automation_metrics"
"""
enum BillingAutomationMetricsSelectColumn {
  """column name"""
  approvedItems
  """column name"""
  autoGeneratedItems
  """column name"""
  autoGeneratedRevenue
  """column name"""
  avgApprovalDays
  """column name"""
  manualItems
  """column name"""
  manualRevenue
  """column name"""
  pendingApproval
}

"""aggregate stddev on columns"""
type BillingAutomationMetricsStddevFields {
  approvedItems: Float
  autoGeneratedItems: Float
  autoGeneratedRevenue: Float
  avgApprovalDays: Float
  manualItems: Float
  manualRevenue: Float
  pendingApproval: Float
}

"""aggregate stddevPop on columns"""
type BillingAutomationMetricsStddevPopFields {
  approvedItems: Float
  autoGeneratedItems: Float
  autoGeneratedRevenue: Float
  avgApprovalDays: Float
  manualItems: Float
  manualRevenue: Float
  pendingApproval: Float
}

"""aggregate stddevSamp on columns"""
type BillingAutomationMetricsStddevSampFields {
  approvedItems: Float
  autoGeneratedItems: Float
  autoGeneratedRevenue: Float
  avgApprovalDays: Float
  manualItems: Float
  manualRevenue: Float
  pendingApproval: Float
}

"""
Streaming cursor of the table "billing_automation_metrics"
"""
input BillingAutomationMetricsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BillingAutomationMetricsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BillingAutomationMetricsStreamCursorValueInput {
  approvedItems: bigint
  autoGeneratedItems: bigint
  autoGeneratedRevenue: numeric
  avgApprovalDays: numeric
  manualItems: bigint
  manualRevenue: numeric
  pendingApproval: bigint
}

"""aggregate sum on columns"""
type BillingAutomationMetricsSumFields {
  approvedItems: bigint
  autoGeneratedItems: bigint
  autoGeneratedRevenue: numeric
  avgApprovalDays: numeric
  manualItems: bigint
  manualRevenue: numeric
  pendingApproval: bigint
}

"""aggregate varPop on columns"""
type BillingAutomationMetricsVarPopFields {
  approvedItems: Float
  autoGeneratedItems: Float
  autoGeneratedRevenue: Float
  avgApprovalDays: Float
  manualItems: Float
  manualRevenue: Float
  pendingApproval: Float
}

"""aggregate varSamp on columns"""
type BillingAutomationMetricsVarSampFields {
  approvedItems: Float
  autoGeneratedItems: Float
  autoGeneratedRevenue: Float
  avgApprovalDays: Float
  manualItems: Float
  manualRevenue: Float
  pendingApproval: Float
}

"""aggregate variance on columns"""
type BillingAutomationMetricsVarianceFields {
  approvedItems: Float
  autoGeneratedItems: Float
  autoGeneratedRevenue: Float
  avgApprovalDays: Float
  manualItems: Float
  manualRevenue: Float
  pendingApproval: Float
}

"""
columns and relationships of "billing_event_log"
"""
type BillingEventLog {
  """An object relationship"""
  billingInvoice: BillingInvoice
  createdAt: timestamptz
  createdBy: uuid
  """An object relationship"""
  createdByUser: Users
  eventType: String!
  id: uuid!
  invoiceId: uuid
  message: String
}

"""
aggregated selection of "billing_event_log"
"""
type BillingEventLogAggregate {
  aggregate: BillingEventLogAggregateFields
  nodes: [BillingEventLog!]!
}

input BillingEventLogAggregateBoolExp {
  count: billingEventLogAggregateBoolExpCount
}

"""
aggregate fields of "billing_event_log"
"""
type BillingEventLogAggregateFields {
  count(columns: [BillingEventLogSelectColumn!], distinct: Boolean): Int!
  max: BillingEventLogMaxFields
  min: BillingEventLogMinFields
}

"""
order by aggregate values of table "billing_event_log"
"""
input BillingEventLogAggregateOrderBy {
  count: OrderBy
  max: BillingEventLogMaxOrderBy
  min: BillingEventLogMinOrderBy
}

"""
input type for inserting array relation for remote table "billing_event_log"
"""
input BillingEventLogArrRelInsertInput {
  data: [BillingEventLogInsertInput!]!
  """upsert condition"""
  onConflict: BillingEventLogOnConflict
}

"""
Boolean expression to filter rows from the table "billing_event_log". All fields are combined with a logical 'AND'.
"""
input BillingEventLogBoolExp {
  _and: [BillingEventLogBoolExp!]
  _not: BillingEventLogBoolExp
  _or: [BillingEventLogBoolExp!]
  billingInvoice: BillingInvoiceBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  eventType: StringComparisonExp
  id: UuidComparisonExp
  invoiceId: UuidComparisonExp
  message: StringComparisonExp
}

"""
unique or primary key constraints on table "billing_event_log"
"""
enum BillingEventLogConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_event_log_pkey
}

"""
input type for inserting data into table "billing_event_log"
"""
input BillingEventLogInsertInput {
  billingInvoice: BillingInvoiceObjRelInsertInput
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""aggregate max on columns"""
type BillingEventLogMaxFields {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
order by max() on columns of table "billing_event_log"
"""
input BillingEventLogMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  eventType: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  message: OrderBy
}

"""aggregate min on columns"""
type BillingEventLogMinFields {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
order by min() on columns of table "billing_event_log"
"""
input BillingEventLogMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  eventType: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  message: OrderBy
}

"""
response of any mutation on the table "billing_event_log"
"""
type BillingEventLogMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [BillingEventLog!]!
}

"""
on_conflict condition type for table "billing_event_log"
"""
input BillingEventLogOnConflict {
  constraint: BillingEventLogConstraint!
  updateColumns: [BillingEventLogUpdateColumn!]! = []
  where: BillingEventLogBoolExp
}

"""Ordering options when selecting data from "billing_event_log"."""
input BillingEventLogOrderBy {
  billingInvoice: BillingInvoiceOrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  eventType: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  message: OrderBy
}

"""primary key columns input for table: billing_event_log"""
input BillingEventLogPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_event_log"
"""
enum BillingEventLogSelectColumn {
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  eventType
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  message
}

"""
input type for updating data in table "billing_event_log"
"""
input BillingEventLogSetInput {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
Streaming cursor of the table "billing_event_log"
"""
input BillingEventLogStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BillingEventLogStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BillingEventLogStreamCursorValueInput {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
update columns of table "billing_event_log"
"""
enum BillingEventLogUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  eventType
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  message
}

input BillingEventLogUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: BillingEventLogSetInput
  """filter the rows which have to be updated"""
  where: BillingEventLogBoolExp!
}

"""
columns and relationships of "billing_invoice"
"""
type BillingInvoice {
  """An object relationship"""
  billingPeriod: BillingPeriods
  billingPeriodEnd: date!
  """Reference to billing period this invoice covers"""
  billingPeriodId: uuid
  billingPeriodStart: date!
  """An object relationship"""
  client: Clients!
  clientId: uuid!
  createdAt: timestamptz
  currency: String
  dueDate: date
  """An array relationship"""
  eventLogs(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): [BillingEventLog!]!
  """An aggregate relationship"""
  eventLogsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): BillingEventLogAggregate!
  id: uuid!
  """An array relationship"""
  invoiceItems(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): [BillingInvoiceItem!]!
  """An aggregate relationship"""
  invoiceItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): BillingInvoiceItemAggregate!
  """Unique invoice number for client reference"""
  invoiceNumber: String
  issuedDate: date
  notes: String
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  status: String!
  totalAmount: numeric!
  """Total hours spent on services in this invoice"""
  totalHours: numeric
  updatedAt: timestamptz
}

"""
aggregated selection of "billing_invoice"
"""
type BillingInvoiceAggregate {
  aggregate: BillingInvoiceAggregateFields
  nodes: [BillingInvoice!]!
}

input BillingInvoiceAggregateBoolExp {
  count: billingInvoiceAggregateBoolExpCount
}

"""
aggregate fields of "billing_invoice"
"""
type BillingInvoiceAggregateFields {
  avg: BillingInvoiceAvgFields
  count(columns: [BillingInvoiceSelectColumn!], distinct: Boolean): Int!
  max: BillingInvoiceMaxFields
  min: BillingInvoiceMinFields
  stddev: BillingInvoiceStddevFields
  stddevPop: BillingInvoiceStddevPopFields
  stddevSamp: BillingInvoiceStddevSampFields
  sum: BillingInvoiceSumFields
  varPop: BillingInvoiceVarPopFields
  varSamp: BillingInvoiceVarSampFields
  variance: BillingInvoiceVarianceFields
}

"""
order by aggregate values of table "billing_invoice"
"""
input BillingInvoiceAggregateOrderBy {
  avg: BillingInvoiceAvgOrderBy
  count: OrderBy
  max: BillingInvoiceMaxOrderBy
  min: BillingInvoiceMinOrderBy
  stddev: BillingInvoiceStddevOrderBy
  stddevPop: BillingInvoiceStddevPopOrderBy
  stddevSamp: BillingInvoiceStddevSampOrderBy
  sum: BillingInvoiceSumOrderBy
  varPop: BillingInvoiceVarPopOrderBy
  varSamp: BillingInvoiceVarSampOrderBy
  variance: BillingInvoiceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "billing_invoice"
"""
input BillingInvoiceArrRelInsertInput {
  data: [BillingInvoiceInsertInput!]!
  """upsert condition"""
  onConflict: BillingInvoiceOnConflict
}

"""aggregate avg on columns"""
type BillingInvoiceAvgFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Float
  totalAmount: Float
  """Total hours spent on services in this invoice"""
  totalHours: Float
}

"""
order by avg() on columns of table "billing_invoice"
"""
input BillingInvoiceAvgOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""
Boolean expression to filter rows from the table "billing_invoice". All fields are combined with a logical 'AND'.
"""
input BillingInvoiceBoolExp {
  _and: [BillingInvoiceBoolExp!]
  _not: BillingInvoiceBoolExp
  _or: [BillingInvoiceBoolExp!]
  billingPeriod: BillingPeriodsBoolExp
  billingPeriodEnd: DateComparisonExp
  billingPeriodId: UuidComparisonExp
  billingPeriodStart: DateComparisonExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: StringComparisonExp
  dueDate: DateComparisonExp
  eventLogs: BillingEventLogBoolExp
  eventLogsAggregate: BillingEventLogAggregateBoolExp
  id: UuidComparisonExp
  invoiceItems: BillingInvoiceItemBoolExp
  invoiceItemsAggregate: BillingInvoiceItemAggregateBoolExp
  invoiceNumber: StringComparisonExp
  issuedDate: DateComparisonExp
  notes: StringComparisonExp
  payrollCount: IntComparisonExp
  status: StringComparisonExp
  totalAmount: NumericComparisonExp
  totalHours: NumericComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "billing_invoice"
"""
enum BillingInvoiceConstraint {
  """
  unique or primary key constraint on columns "invoice_number"
  """
  billing_invoice_invoice_number_key
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoice_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoice"
"""
input BillingInvoiceIncInput {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  totalAmount: numeric
  """Total hours spent on services in this invoice"""
  totalHours: numeric
}

"""
input type for inserting data into table "billing_invoice"
"""
input BillingInvoiceInsertInput {
  billingPeriod: BillingPeriodsObjRelInsertInput
  billingPeriodEnd: date
  """Reference to billing period this invoice covers"""
  billingPeriodId: uuid
  billingPeriodStart: date
  client: ClientsObjRelInsertInput
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  eventLogs: BillingEventLogArrRelInsertInput
  id: uuid
  invoiceItems: BillingInvoiceItemArrRelInsertInput
  """Unique invoice number for client reference"""
  invoiceNumber: String
  issuedDate: date
  notes: String
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  status: String
  totalAmount: numeric
  """Total hours spent on services in this invoice"""
  totalHours: numeric
  updatedAt: timestamptz
}

"""
columns and relationships of "billing_invoice_item"
"""
type BillingInvoiceItem {
  """An object relationship"""
  billingInvoice: BillingInvoice!
  """An object relationship"""
  billingItem: BillingItems
  billingPeriodEnd: date!
  billingPeriodStart: date!
  createdAt: timestamptz!
  descriptionOverride: String
  hourlyRate: numeric!
  id: uuid!
  invoiceId: uuid!
  itemId: uuid
  lineItemType: String
  netAmount: numeric
  quantityHours: numeric!
  taxAmount: numeric!
  totalAmount: numeric!
  updatedAt: timestamptz!
}

"""
aggregated selection of "billing_invoice_item"
"""
type BillingInvoiceItemAggregate {
  aggregate: BillingInvoiceItemAggregateFields
  nodes: [BillingInvoiceItem!]!
}

input BillingInvoiceItemAggregateBoolExp {
  count: billingInvoiceItemAggregateBoolExpCount
}

"""
aggregate fields of "billing_invoice_item"
"""
type BillingInvoiceItemAggregateFields {
  avg: BillingInvoiceItemAvgFields
  count(columns: [BillingInvoiceItemSelectColumn!], distinct: Boolean): Int!
  max: BillingInvoiceItemMaxFields
  min: BillingInvoiceItemMinFields
  stddev: BillingInvoiceItemStddevFields
  stddevPop: BillingInvoiceItemStddevPopFields
  stddevSamp: BillingInvoiceItemStddevSampFields
  sum: BillingInvoiceItemSumFields
  varPop: BillingInvoiceItemVarPopFields
  varSamp: BillingInvoiceItemVarSampFields
  variance: BillingInvoiceItemVarianceFields
}

"""
order by aggregate values of table "billing_invoice_item"
"""
input BillingInvoiceItemAggregateOrderBy {
  avg: BillingInvoiceItemAvgOrderBy
  count: OrderBy
  max: BillingInvoiceItemMaxOrderBy
  min: BillingInvoiceItemMinOrderBy
  stddev: BillingInvoiceItemStddevOrderBy
  stddevPop: BillingInvoiceItemStddevPopOrderBy
  stddevSamp: BillingInvoiceItemStddevSampOrderBy
  sum: BillingInvoiceItemSumOrderBy
  varPop: BillingInvoiceItemVarPopOrderBy
  varSamp: BillingInvoiceItemVarSampOrderBy
  variance: BillingInvoiceItemVarianceOrderBy
}

"""
input type for inserting array relation for remote table "billing_invoice_item"
"""
input BillingInvoiceItemArrRelInsertInput {
  data: [BillingInvoiceItemInsertInput!]!
  """upsert condition"""
  onConflict: BillingInvoiceItemOnConflict
}

"""aggregate avg on columns"""
type BillingInvoiceItemAvgFields {
  hourlyRate: Float
  netAmount: Float
  quantityHours: Float
  taxAmount: Float
  totalAmount: Float
}

"""
order by avg() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemAvgOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "billing_invoice_item". All fields are combined with a logical 'AND'.
"""
input BillingInvoiceItemBoolExp {
  _and: [BillingInvoiceItemBoolExp!]
  _not: BillingInvoiceItemBoolExp
  _or: [BillingInvoiceItemBoolExp!]
  billingInvoice: BillingInvoiceBoolExp
  billingItem: BillingItemsBoolExp
  billingPeriodEnd: DateComparisonExp
  billingPeriodStart: DateComparisonExp
  createdAt: TimestamptzComparisonExp
  descriptionOverride: StringComparisonExp
  hourlyRate: NumericComparisonExp
  id: UuidComparisonExp
  invoiceId: UuidComparisonExp
  itemId: UuidComparisonExp
  lineItemType: StringComparisonExp
  netAmount: NumericComparisonExp
  quantityHours: NumericComparisonExp
  taxAmount: NumericComparisonExp
  totalAmount: NumericComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "billing_invoice_item"
"""
enum BillingInvoiceItemConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoice_item_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoice_item"
"""
input BillingInvoiceItemIncInput {
  hourlyRate: numeric
  quantityHours: numeric
  taxAmount: numeric
  totalAmount: numeric
}

"""
input type for inserting data into table "billing_invoice_item"
"""
input BillingInvoiceItemInsertInput {
  billingInvoice: BillingInvoiceObjRelInsertInput
  billingItem: BillingItemsObjRelInsertInput
  billingPeriodEnd: date
  billingPeriodStart: date
  createdAt: timestamptz
  descriptionOverride: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  itemId: uuid
  lineItemType: String
  quantityHours: numeric
  taxAmount: numeric
  totalAmount: numeric
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type BillingInvoiceItemMaxFields {
  billingPeriodEnd: date
  billingPeriodStart: date
  createdAt: timestamptz
  descriptionOverride: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  itemId: uuid
  lineItemType: String
  netAmount: numeric
  quantityHours: numeric
  taxAmount: numeric
  totalAmount: numeric
  updatedAt: timestamptz
}

"""
order by max() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemMaxOrderBy {
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  createdAt: OrderBy
  descriptionOverride: OrderBy
  hourlyRate: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  itemId: OrderBy
  lineItemType: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type BillingInvoiceItemMinFields {
  billingPeriodEnd: date
  billingPeriodStart: date
  createdAt: timestamptz
  descriptionOverride: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  itemId: uuid
  lineItemType: String
  netAmount: numeric
  quantityHours: numeric
  taxAmount: numeric
  totalAmount: numeric
  updatedAt: timestamptz
}

"""
order by min() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemMinOrderBy {
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  createdAt: OrderBy
  descriptionOverride: OrderBy
  hourlyRate: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  itemId: OrderBy
  lineItemType: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "billing_invoice_item"
"""
type BillingInvoiceItemMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [BillingInvoiceItem!]!
}

"""
on_conflict condition type for table "billing_invoice_item"
"""
input BillingInvoiceItemOnConflict {
  constraint: BillingInvoiceItemConstraint!
  updateColumns: [BillingInvoiceItemUpdateColumn!]! = []
  where: BillingInvoiceItemBoolExp
}

"""Ordering options when selecting data from "billing_invoice_item"."""
input BillingInvoiceItemOrderBy {
  billingInvoice: BillingInvoiceOrderBy
  billingItem: BillingItemsOrderBy
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  createdAt: OrderBy
  descriptionOverride: OrderBy
  hourlyRate: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  itemId: OrderBy
  lineItemType: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: billing_invoice_item"""
input BillingInvoiceItemPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_invoice_item"
"""
enum BillingInvoiceItemSelectColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodStart
  """column name"""
  createdAt
  """column name"""
  descriptionOverride
  """column name"""
  hourlyRate
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  itemId
  """column name"""
  lineItemType
  """column name"""
  netAmount
  """column name"""
  quantityHours
  """column name"""
  taxAmount
  """column name"""
  totalAmount
  """column name"""
  updatedAt
}

"""
input type for updating data in table "billing_invoice_item"
"""
input BillingInvoiceItemSetInput {
  billingPeriodEnd: date
  billingPeriodStart: date
  createdAt: timestamptz
  descriptionOverride: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  itemId: uuid
  lineItemType: String
  quantityHours: numeric
  taxAmount: numeric
  totalAmount: numeric
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type BillingInvoiceItemStddevFields {
  hourlyRate: Float
  netAmount: Float
  quantityHours: Float
  taxAmount: Float
  totalAmount: Float
}

"""
order by stddev() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemStddevOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type BillingInvoiceItemStddevPopFields {
  hourlyRate: Float
  netAmount: Float
  quantityHours: Float
  taxAmount: Float
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemStddevPopOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type BillingInvoiceItemStddevSampFields {
  hourlyRate: Float
  netAmount: Float
  quantityHours: Float
  taxAmount: Float
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemStddevSampOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""
Streaming cursor of the table "billing_invoice_item"
"""
input BillingInvoiceItemStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BillingInvoiceItemStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BillingInvoiceItemStreamCursorValueInput {
  billingPeriodEnd: date
  billingPeriodStart: date
  createdAt: timestamptz
  descriptionOverride: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  itemId: uuid
  lineItemType: String
  netAmount: numeric
  quantityHours: numeric
  taxAmount: numeric
  totalAmount: numeric
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type BillingInvoiceItemSumFields {
  hourlyRate: numeric
  netAmount: numeric
  quantityHours: numeric
  taxAmount: numeric
  totalAmount: numeric
}

"""
order by sum() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemSumOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""
update columns of table "billing_invoice_item"
"""
enum BillingInvoiceItemUpdateColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodStart
  """column name"""
  createdAt
  """column name"""
  descriptionOverride
  """column name"""
  hourlyRate
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  itemId
  """column name"""
  lineItemType
  """column name"""
  quantityHours
  """column name"""
  taxAmount
  """column name"""
  totalAmount
  """column name"""
  updatedAt
}

input BillingInvoiceItemUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: BillingInvoiceItemIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: BillingInvoiceItemSetInput
  """filter the rows which have to be updated"""
  where: BillingInvoiceItemBoolExp!
}

"""aggregate varPop on columns"""
type BillingInvoiceItemVarPopFields {
  hourlyRate: Float
  netAmount: Float
  quantityHours: Float
  taxAmount: Float
  totalAmount: Float
}

"""
order by varPop() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemVarPopOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type BillingInvoiceItemVarSampFields {
  hourlyRate: Float
  netAmount: Float
  quantityHours: Float
  taxAmount: Float
  totalAmount: Float
}

"""
order by varSamp() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemVarSampOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type BillingInvoiceItemVarianceFields {
  hourlyRate: Float
  netAmount: Float
  quantityHours: Float
  taxAmount: Float
  totalAmount: Float
}

"""
order by variance() on columns of table "billing_invoice_item"
"""
input BillingInvoiceItemVarianceOrderBy {
  hourlyRate: OrderBy
  netAmount: OrderBy
  quantityHours: OrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""aggregate max on columns"""
type BillingInvoiceMaxFields {
  billingPeriodEnd: date
  """Reference to billing period this invoice covers"""
  billingPeriodId: uuid
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  """Unique invoice number for client reference"""
  invoiceNumber: String
  issuedDate: date
  notes: String
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  status: String
  totalAmount: numeric
  """Total hours spent on services in this invoice"""
  totalHours: numeric
  updatedAt: timestamptz
}

"""
order by max() on columns of table "billing_invoice"
"""
input BillingInvoiceMaxOrderBy {
  billingPeriodEnd: OrderBy
  """Reference to billing period this invoice covers"""
  billingPeriodId: OrderBy
  billingPeriodStart: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  dueDate: OrderBy
  id: OrderBy
  """Unique invoice number for client reference"""
  invoiceNumber: OrderBy
  issuedDate: OrderBy
  notes: OrderBy
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type BillingInvoiceMinFields {
  billingPeriodEnd: date
  """Reference to billing period this invoice covers"""
  billingPeriodId: uuid
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  """Unique invoice number for client reference"""
  invoiceNumber: String
  issuedDate: date
  notes: String
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  status: String
  totalAmount: numeric
  """Total hours spent on services in this invoice"""
  totalHours: numeric
  updatedAt: timestamptz
}

"""
order by min() on columns of table "billing_invoice"
"""
input BillingInvoiceMinOrderBy {
  billingPeriodEnd: OrderBy
  """Reference to billing period this invoice covers"""
  billingPeriodId: OrderBy
  billingPeriodStart: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  dueDate: OrderBy
  id: OrderBy
  """Unique invoice number for client reference"""
  invoiceNumber: OrderBy
  issuedDate: OrderBy
  notes: OrderBy
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "billing_invoice"
"""
type BillingInvoiceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [BillingInvoice!]!
}

"""
input type for inserting object relation for remote table "billing_invoice"
"""
input BillingInvoiceObjRelInsertInput {
  data: BillingInvoiceInsertInput!
  """upsert condition"""
  onConflict: BillingInvoiceOnConflict
}

"""
on_conflict condition type for table "billing_invoice"
"""
input BillingInvoiceOnConflict {
  constraint: BillingInvoiceConstraint!
  updateColumns: [BillingInvoiceUpdateColumn!]! = []
  where: BillingInvoiceBoolExp
}

"""Ordering options when selecting data from "billing_invoice"."""
input BillingInvoiceOrderBy {
  billingPeriod: BillingPeriodsOrderBy
  billingPeriodEnd: OrderBy
  billingPeriodId: OrderBy
  billingPeriodStart: OrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  dueDate: OrderBy
  eventLogsAggregate: BillingEventLogAggregateOrderBy
  id: OrderBy
  invoiceItemsAggregate: BillingInvoiceItemAggregateOrderBy
  invoiceNumber: OrderBy
  issuedDate: OrderBy
  notes: OrderBy
  payrollCount: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  totalHours: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: billing_invoice"""
input BillingInvoicePkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_invoice"
"""
enum BillingInvoiceSelectColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodId
  """column name"""
  billingPeriodStart
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  currency
  """column name"""
  dueDate
  """column name"""
  id
  """column name"""
  invoiceNumber
  """column name"""
  issuedDate
  """column name"""
  notes
  """column name"""
  payrollCount
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  totalHours
  """column name"""
  updatedAt
}

"""
input type for updating data in table "billing_invoice"
"""
input BillingInvoiceSetInput {
  billingPeriodEnd: date
  """Reference to billing period this invoice covers"""
  billingPeriodId: uuid
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  """Unique invoice number for client reference"""
  invoiceNumber: String
  issuedDate: date
  notes: String
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  status: String
  totalAmount: numeric
  """Total hours spent on services in this invoice"""
  totalHours: numeric
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type BillingInvoiceStddevFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Float
  totalAmount: Float
  """Total hours spent on services in this invoice"""
  totalHours: Float
}

"""
order by stddev() on columns of table "billing_invoice"
"""
input BillingInvoiceStddevOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""aggregate stddevPop on columns"""
type BillingInvoiceStddevPopFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Float
  totalAmount: Float
  """Total hours spent on services in this invoice"""
  totalHours: Float
}

"""
order by stddevPop() on columns of table "billing_invoice"
"""
input BillingInvoiceStddevPopOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""aggregate stddevSamp on columns"""
type BillingInvoiceStddevSampFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Float
  totalAmount: Float
  """Total hours spent on services in this invoice"""
  totalHours: Float
}

"""
order by stddevSamp() on columns of table "billing_invoice"
"""
input BillingInvoiceStddevSampOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""
Streaming cursor of the table "billing_invoice"
"""
input BillingInvoiceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BillingInvoiceStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BillingInvoiceStreamCursorValueInput {
  billingPeriodEnd: date
  """Reference to billing period this invoice covers"""
  billingPeriodId: uuid
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  """Unique invoice number for client reference"""
  invoiceNumber: String
  issuedDate: date
  notes: String
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  status: String
  totalAmount: numeric
  """Total hours spent on services in this invoice"""
  totalHours: numeric
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type BillingInvoiceSumFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Int
  totalAmount: numeric
  """Total hours spent on services in this invoice"""
  totalHours: numeric
}

"""
order by sum() on columns of table "billing_invoice"
"""
input BillingInvoiceSumOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""
update columns of table "billing_invoice"
"""
enum BillingInvoiceUpdateColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodId
  """column name"""
  billingPeriodStart
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  currency
  """column name"""
  dueDate
  """column name"""
  id
  """column name"""
  invoiceNumber
  """column name"""
  issuedDate
  """column name"""
  notes
  """column name"""
  payrollCount
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  totalHours
  """column name"""
  updatedAt
}

input BillingInvoiceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: BillingInvoiceIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: BillingInvoiceSetInput
  """filter the rows which have to be updated"""
  where: BillingInvoiceBoolExp!
}

"""aggregate varPop on columns"""
type BillingInvoiceVarPopFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Float
  totalAmount: Float
  """Total hours spent on services in this invoice"""
  totalHours: Float
}

"""
order by varPop() on columns of table "billing_invoice"
"""
input BillingInvoiceVarPopOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""aggregate varSamp on columns"""
type BillingInvoiceVarSampFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Float
  totalAmount: Float
  """Total hours spent on services in this invoice"""
  totalHours: Float
}

"""
order by varSamp() on columns of table "billing_invoice"
"""
input BillingInvoiceVarSampOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""aggregate variance on columns"""
type BillingInvoiceVarianceFields {
  """Number of payroll jobs included in this invoice"""
  payrollCount: Float
  totalAmount: Float
  """Total hours spent on services in this invoice"""
  totalHours: Float
}

"""
order by variance() on columns of table "billing_invoice"
"""
input BillingInvoiceVarianceOrderBy {
  """Number of payroll jobs included in this invoice"""
  payrollCount: OrderBy
  totalAmount: OrderBy
  """Total hours spent on services in this invoice"""
  totalHours: OrderBy
}

"""
columns and relationships of "billing_items"
"""
type BillingItems {
  amount: numeric
  approvalDate: timestamptz
  approvedBy: uuid
  """An object relationship"""
  approvedByUser: Users
  billingPlanId: uuid
  """An object relationship"""
  client: Clients
  clientId: uuid
  """When this item was confirmed by manager"""
  confirmedAt: timestamptz
  """Manager who confirmed this item"""
  confirmedBy: uuid
  """An object relationship"""
  confirmedByUser: Users
  createdAt: timestamp
  description: String
  hourlyRate: numeric
  id: uuid!
  invoiceId: uuid
  """An array relationship"""
  invoiceItems(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): [BillingInvoiceItem!]!
  """An aggregate relationship"""
  invoiceItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): BillingInvoiceItemAggregate!
  isApproved: Boolean
  isAutoGenerated: Boolean
  """Additional notes about this billing item"""
  notes: String
  """An object relationship"""
  payroll: Payrolls
  """An object relationship"""
  payrollDate: PayrollDates
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: uuid
  payrollId: uuid
  quantity: Int!
  """An object relationship"""
  quote: Quotes
  quoteId: uuid
  """An object relationship"""
  service: Services
  """Reference to the service from service catalog"""
  serviceId: uuid
  serviceName: String
  """An object relationship"""
  staffUser: Users
  """Staff member who performed the service"""
  staffUserId: uuid
  """Status: draft, confirmed, billed"""
  status: String
  """An array relationship"""
  timeEntries(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """An aggregate relationship"""
  timeEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): TimeEntriesAggregate!
  totalAmount: numeric
  unitPrice: numeric!
  updatedAt: timestamptz
}

"""
aggregated selection of "billing_items"
"""
type BillingItemsAggregate {
  aggregate: BillingItemsAggregateFields
  nodes: [BillingItems!]!
}

input BillingItemsAggregateBoolExp {
  bool_and: billingItemsAggregateBoolExpBool_and
  bool_or: billingItemsAggregateBoolExpBool_or
  count: billingItemsAggregateBoolExpCount
}

"""
aggregate fields of "billing_items"
"""
type BillingItemsAggregateFields {
  avg: BillingItemsAvgFields
  count(columns: [BillingItemsSelectColumn!], distinct: Boolean): Int!
  max: BillingItemsMaxFields
  min: BillingItemsMinFields
  stddev: BillingItemsStddevFields
  stddevPop: BillingItemsStddevPopFields
  stddevSamp: BillingItemsStddevSampFields
  sum: BillingItemsSumFields
  varPop: BillingItemsVarPopFields
  varSamp: BillingItemsVarSampFields
  variance: BillingItemsVarianceFields
}

"""
order by aggregate values of table "billing_items"
"""
input BillingItemsAggregateOrderBy {
  avg: BillingItemsAvgOrderBy
  count: OrderBy
  max: BillingItemsMaxOrderBy
  min: BillingItemsMinOrderBy
  stddev: BillingItemsStddevOrderBy
  stddevPop: BillingItemsStddevPopOrderBy
  stddevSamp: BillingItemsStddevSampOrderBy
  sum: BillingItemsSumOrderBy
  varPop: BillingItemsVarPopOrderBy
  varSamp: BillingItemsVarSampOrderBy
  variance: BillingItemsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "billing_items"
"""
input BillingItemsArrRelInsertInput {
  data: [BillingItemsInsertInput!]!
  """upsert condition"""
  onConflict: BillingItemsOnConflict
}

"""aggregate avg on columns"""
type BillingItemsAvgFields {
  amount: Float
  hourlyRate: Float
  quantity: Float
  totalAmount: Float
  unitPrice: Float
}

"""
order by avg() on columns of table "billing_items"
"""
input BillingItemsAvgOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""
Boolean expression to filter rows from the table "billing_items". All fields are combined with a logical 'AND'.
"""
input BillingItemsBoolExp {
  _and: [BillingItemsBoolExp!]
  _not: BillingItemsBoolExp
  _or: [BillingItemsBoolExp!]
  amount: NumericComparisonExp
  approvalDate: TimestamptzComparisonExp
  approvedBy: UuidComparisonExp
  approvedByUser: UsersBoolExp
  billingPlanId: UuidComparisonExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  confirmedAt: TimestamptzComparisonExp
  confirmedBy: UuidComparisonExp
  confirmedByUser: UsersBoolExp
  createdAt: TimestampComparisonExp
  description: StringComparisonExp
  hourlyRate: NumericComparisonExp
  id: UuidComparisonExp
  invoiceId: UuidComparisonExp
  invoiceItems: BillingInvoiceItemBoolExp
  invoiceItemsAggregate: BillingInvoiceItemAggregateBoolExp
  isApproved: BooleanComparisonExp
  isAutoGenerated: BooleanComparisonExp
  notes: StringComparisonExp
  payroll: PayrollsBoolExp
  payrollDate: PayrollDatesBoolExp
  payrollDateId: UuidComparisonExp
  payrollId: UuidComparisonExp
  quantity: IntComparisonExp
  quote: QuotesBoolExp
  quoteId: UuidComparisonExp
  service: ServicesBoolExp
  serviceId: UuidComparisonExp
  serviceName: StringComparisonExp
  staffUser: UsersBoolExp
  staffUserId: UuidComparisonExp
  status: StringComparisonExp
  timeEntries: TimeEntriesBoolExp
  timeEntriesAggregate: TimeEntriesAggregateBoolExp
  totalAmount: NumericComparisonExp
  unitPrice: NumericComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "billing_items"
"""
enum BillingItemsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_items_pkey
}

"""
input type for incrementing numeric columns in table "billing_items"
"""
input BillingItemsIncInput {
  hourlyRate: numeric
  quantity: Int
  totalAmount: numeric
  unitPrice: numeric
}

"""
input type for inserting data into table "billing_items"
"""
input BillingItemsInsertInput {
  approvalDate: timestamptz
  approvedBy: uuid
  approvedByUser: UsersObjRelInsertInput
  billingPlanId: uuid
  client: ClientsObjRelInsertInput
  clientId: uuid
  """When this item was confirmed by manager"""
  confirmedAt: timestamptz
  """Manager who confirmed this item"""
  confirmedBy: uuid
  confirmedByUser: UsersObjRelInsertInput
  createdAt: timestamp
  description: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  invoiceItems: BillingInvoiceItemArrRelInsertInput
  isApproved: Boolean
  isAutoGenerated: Boolean
  """Additional notes about this billing item"""
  notes: String
  payroll: PayrollsObjRelInsertInput
  payrollDate: PayrollDatesObjRelInsertInput
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: uuid
  payrollId: uuid
  quantity: Int
  quote: QuotesObjRelInsertInput
  quoteId: uuid
  service: ServicesObjRelInsertInput
  """Reference to the service from service catalog"""
  serviceId: uuid
  serviceName: String
  staffUser: UsersObjRelInsertInput
  """Staff member who performed the service"""
  staffUserId: uuid
  """Status: draft, confirmed, billed"""
  status: String
  timeEntries: TimeEntriesArrRelInsertInput
  totalAmount: numeric
  unitPrice: numeric
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type BillingItemsMaxFields {
  amount: numeric
  approvalDate: timestamptz
  approvedBy: uuid
  billingPlanId: uuid
  clientId: uuid
  """When this item was confirmed by manager"""
  confirmedAt: timestamptz
  """Manager who confirmed this item"""
  confirmedBy: uuid
  createdAt: timestamp
  description: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  """Additional notes about this billing item"""
  notes: String
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: uuid
  payrollId: uuid
  quantity: Int
  quoteId: uuid
  """Reference to the service from service catalog"""
  serviceId: uuid
  serviceName: String
  """Staff member who performed the service"""
  staffUserId: uuid
  """Status: draft, confirmed, billed"""
  status: String
  totalAmount: numeric
  unitPrice: numeric
  updatedAt: timestamptz
}

"""
order by max() on columns of table "billing_items"
"""
input BillingItemsMaxOrderBy {
  amount: OrderBy
  approvalDate: OrderBy
  approvedBy: OrderBy
  billingPlanId: OrderBy
  clientId: OrderBy
  """When this item was confirmed by manager"""
  confirmedAt: OrderBy
  """Manager who confirmed this item"""
  confirmedBy: OrderBy
  createdAt: OrderBy
  description: OrderBy
  hourlyRate: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  """Additional notes about this billing item"""
  notes: OrderBy
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: OrderBy
  payrollId: OrderBy
  quantity: OrderBy
  quoteId: OrderBy
  """Reference to the service from service catalog"""
  serviceId: OrderBy
  serviceName: OrderBy
  """Staff member who performed the service"""
  staffUserId: OrderBy
  """Status: draft, confirmed, billed"""
  status: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type BillingItemsMinFields {
  amount: numeric
  approvalDate: timestamptz
  approvedBy: uuid
  billingPlanId: uuid
  clientId: uuid
  """When this item was confirmed by manager"""
  confirmedAt: timestamptz
  """Manager who confirmed this item"""
  confirmedBy: uuid
  createdAt: timestamp
  description: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  """Additional notes about this billing item"""
  notes: String
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: uuid
  payrollId: uuid
  quantity: Int
  quoteId: uuid
  """Reference to the service from service catalog"""
  serviceId: uuid
  serviceName: String
  """Staff member who performed the service"""
  staffUserId: uuid
  """Status: draft, confirmed, billed"""
  status: String
  totalAmount: numeric
  unitPrice: numeric
  updatedAt: timestamptz
}

"""
order by min() on columns of table "billing_items"
"""
input BillingItemsMinOrderBy {
  amount: OrderBy
  approvalDate: OrderBy
  approvedBy: OrderBy
  billingPlanId: OrderBy
  clientId: OrderBy
  """When this item was confirmed by manager"""
  confirmedAt: OrderBy
  """Manager who confirmed this item"""
  confirmedBy: OrderBy
  createdAt: OrderBy
  description: OrderBy
  hourlyRate: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  """Additional notes about this billing item"""
  notes: OrderBy
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: OrderBy
  payrollId: OrderBy
  quantity: OrderBy
  quoteId: OrderBy
  """Reference to the service from service catalog"""
  serviceId: OrderBy
  serviceName: OrderBy
  """Staff member who performed the service"""
  staffUserId: OrderBy
  """Status: draft, confirmed, billed"""
  status: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "billing_items"
"""
type BillingItemsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [BillingItems!]!
}

"""
input type for inserting object relation for remote table "billing_items"
"""
input BillingItemsObjRelInsertInput {
  data: BillingItemsInsertInput!
  """upsert condition"""
  onConflict: BillingItemsOnConflict
}

"""
on_conflict condition type for table "billing_items"
"""
input BillingItemsOnConflict {
  constraint: BillingItemsConstraint!
  updateColumns: [BillingItemsUpdateColumn!]! = []
  where: BillingItemsBoolExp
}

"""Ordering options when selecting data from "billing_items"."""
input BillingItemsOrderBy {
  amount: OrderBy
  approvalDate: OrderBy
  approvedBy: OrderBy
  approvedByUser: UsersOrderBy
  billingPlanId: OrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  confirmedAt: OrderBy
  confirmedBy: OrderBy
  confirmedByUser: UsersOrderBy
  createdAt: OrderBy
  description: OrderBy
  hourlyRate: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  invoiceItemsAggregate: BillingInvoiceItemAggregateOrderBy
  isApproved: OrderBy
  isAutoGenerated: OrderBy
  notes: OrderBy
  payroll: PayrollsOrderBy
  payrollDate: PayrollDatesOrderBy
  payrollDateId: OrderBy
  payrollId: OrderBy
  quantity: OrderBy
  quote: QuotesOrderBy
  quoteId: OrderBy
  service: ServicesOrderBy
  serviceId: OrderBy
  serviceName: OrderBy
  staffUser: UsersOrderBy
  staffUserId: OrderBy
  status: OrderBy
  timeEntriesAggregate: TimeEntriesAggregateOrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: billing_items"""
input BillingItemsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_items"
"""
enum BillingItemsSelectColumn {
  """column name"""
  amount
  """column name"""
  approvalDate
  """column name"""
  approvedBy
  """column name"""
  billingPlanId
  """column name"""
  clientId
  """column name"""
  confirmedAt
  """column name"""
  confirmedBy
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  hourlyRate
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  isApproved
  """column name"""
  isAutoGenerated
  """column name"""
  notes
  """column name"""
  payrollDateId
  """column name"""
  payrollId
  """column name"""
  quantity
  """column name"""
  quoteId
  """column name"""
  serviceId
  """column name"""
  serviceName
  """column name"""
  staffUserId
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  unitPrice
  """column name"""
  updatedAt
}

"""
select "billingItemsAggregateBoolExpBool_andArgumentsColumns" columns of table "billing_items"
"""
enum BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isApproved
  """column name"""
  isAutoGenerated
}

"""
select "billingItemsAggregateBoolExpBool_orArgumentsColumns" columns of table "billing_items"
"""
enum BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isApproved
  """column name"""
  isAutoGenerated
}

"""
input type for updating data in table "billing_items"
"""
input BillingItemsSetInput {
  approvalDate: timestamptz
  approvedBy: uuid
  billingPlanId: uuid
  clientId: uuid
  """When this item was confirmed by manager"""
  confirmedAt: timestamptz
  """Manager who confirmed this item"""
  confirmedBy: uuid
  createdAt: timestamp
  description: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  isApproved: Boolean
  isAutoGenerated: Boolean
  """Additional notes about this billing item"""
  notes: String
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: uuid
  payrollId: uuid
  quantity: Int
  quoteId: uuid
  """Reference to the service from service catalog"""
  serviceId: uuid
  serviceName: String
  """Staff member who performed the service"""
  staffUserId: uuid
  """Status: draft, confirmed, billed"""
  status: String
  totalAmount: numeric
  unitPrice: numeric
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type BillingItemsStddevFields {
  amount: Float
  hourlyRate: Float
  quantity: Float
  totalAmount: Float
  unitPrice: Float
}

"""
order by stddev() on columns of table "billing_items"
"""
input BillingItemsStddevOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""aggregate stddevPop on columns"""
type BillingItemsStddevPopFields {
  amount: Float
  hourlyRate: Float
  quantity: Float
  totalAmount: Float
  unitPrice: Float
}

"""
order by stddevPop() on columns of table "billing_items"
"""
input BillingItemsStddevPopOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""aggregate stddevSamp on columns"""
type BillingItemsStddevSampFields {
  amount: Float
  hourlyRate: Float
  quantity: Float
  totalAmount: Float
  unitPrice: Float
}

"""
order by stddevSamp() on columns of table "billing_items"
"""
input BillingItemsStddevSampOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""
Streaming cursor of the table "billing_items"
"""
input BillingItemsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BillingItemsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BillingItemsStreamCursorValueInput {
  amount: numeric
  approvalDate: timestamptz
  approvedBy: uuid
  billingPlanId: uuid
  clientId: uuid
  """When this item was confirmed by manager"""
  confirmedAt: timestamptz
  """Manager who confirmed this item"""
  confirmedBy: uuid
  createdAt: timestamp
  description: String
  hourlyRate: numeric
  id: uuid
  invoiceId: uuid
  isApproved: Boolean
  isAutoGenerated: Boolean
  """Additional notes about this billing item"""
  notes: String
  """
  Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking.
  """
  payrollDateId: uuid
  payrollId: uuid
  quantity: Int
  quoteId: uuid
  """Reference to the service from service catalog"""
  serviceId: uuid
  serviceName: String
  """Staff member who performed the service"""
  staffUserId: uuid
  """Status: draft, confirmed, billed"""
  status: String
  totalAmount: numeric
  unitPrice: numeric
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type BillingItemsSumFields {
  amount: numeric
  hourlyRate: numeric
  quantity: Int
  totalAmount: numeric
  unitPrice: numeric
}

"""
order by sum() on columns of table "billing_items"
"""
input BillingItemsSumOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""
update columns of table "billing_items"
"""
enum BillingItemsUpdateColumn {
  """column name"""
  approvalDate
  """column name"""
  approvedBy
  """column name"""
  billingPlanId
  """column name"""
  clientId
  """column name"""
  confirmedAt
  """column name"""
  confirmedBy
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  hourlyRate
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  isApproved
  """column name"""
  isAutoGenerated
  """column name"""
  notes
  """column name"""
  payrollDateId
  """column name"""
  payrollId
  """column name"""
  quantity
  """column name"""
  quoteId
  """column name"""
  serviceId
  """column name"""
  serviceName
  """column name"""
  staffUserId
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  unitPrice
  """column name"""
  updatedAt
}

input BillingItemsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: BillingItemsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: BillingItemsSetInput
  """filter the rows which have to be updated"""
  where: BillingItemsBoolExp!
}

"""aggregate varPop on columns"""
type BillingItemsVarPopFields {
  amount: Float
  hourlyRate: Float
  quantity: Float
  totalAmount: Float
  unitPrice: Float
}

"""
order by varPop() on columns of table "billing_items"
"""
input BillingItemsVarPopOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""aggregate varSamp on columns"""
type BillingItemsVarSampFields {
  amount: Float
  hourlyRate: Float
  quantity: Float
  totalAmount: Float
  unitPrice: Float
}

"""
order by varSamp() on columns of table "billing_items"
"""
input BillingItemsVarSampOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""aggregate variance on columns"""
type BillingItemsVarianceFields {
  amount: Float
  hourlyRate: Float
  quantity: Float
  totalAmount: Float
  unitPrice: Float
}

"""
order by variance() on columns of table "billing_items"
"""
input BillingItemsVarianceOrderBy {
  amount: OrderBy
  hourlyRate: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  unitPrice: OrderBy
}

"""
Billing periods for consolidating multiple payroll jobs into client invoices
"""
type BillingPeriods {
  """An array relationship"""
  billingInvoices(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): [BillingInvoice!]!
  """An aggregate relationship"""
  billingInvoicesAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): BillingInvoiceAggregate!
  """An object relationship"""
  client: Clients!
  """Client this billing period is for"""
  clientId: uuid!
  createdAt: timestamptz
  id: uuid!
  """End date of billing period"""
  periodEnd: date!
  """Start date of billing period"""
  periodStart: date!
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: String
  updatedAt: timestamptz
}

"""
aggregated selection of "billing_periods"
"""
type BillingPeriodsAggregate {
  aggregate: BillingPeriodsAggregateFields
  nodes: [BillingPeriods!]!
}

input BillingPeriodsAggregateBoolExp {
  count: billingPeriodsAggregateBoolExpCount
}

"""
aggregate fields of "billing_periods"
"""
type BillingPeriodsAggregateFields {
  count(columns: [BillingPeriodsSelectColumn!], distinct: Boolean): Int!
  max: BillingPeriodsMaxFields
  min: BillingPeriodsMinFields
}

"""
order by aggregate values of table "billing_periods"
"""
input BillingPeriodsAggregateOrderBy {
  count: OrderBy
  max: BillingPeriodsMaxOrderBy
  min: BillingPeriodsMinOrderBy
}

"""
input type for inserting array relation for remote table "billing_periods"
"""
input BillingPeriodsArrRelInsertInput {
  data: [BillingPeriodsInsertInput!]!
  """upsert condition"""
  onConflict: BillingPeriodsOnConflict
}

"""
Boolean expression to filter rows from the table "billing_periods". All fields are combined with a logical 'AND'.
"""
input BillingPeriodsBoolExp {
  _and: [BillingPeriodsBoolExp!]
  _not: BillingPeriodsBoolExp
  _or: [BillingPeriodsBoolExp!]
  billingInvoices: BillingInvoiceBoolExp
  billingInvoicesAggregate: BillingInvoiceAggregateBoolExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  periodEnd: DateComparisonExp
  periodStart: DateComparisonExp
  status: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "billing_periods"
"""
enum BillingPeriodsConstraint {
  """
  unique or primary key constraint on columns "client_id", "period_start", "period_end"
  """
  billing_periods_client_id_period_start_period_end_key
  """
  unique or primary key constraint on columns "id"
  """
  billing_periods_pkey
}

"""
input type for inserting data into table "billing_periods"
"""
input BillingPeriodsInsertInput {
  billingInvoices: BillingInvoiceArrRelInsertInput
  client: ClientsObjRelInsertInput
  """Client this billing period is for"""
  clientId: uuid
  createdAt: timestamptz
  id: uuid
  """End date of billing period"""
  periodEnd: date
  """Start date of billing period"""
  periodStart: date
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type BillingPeriodsMaxFields {
  """Client this billing period is for"""
  clientId: uuid
  createdAt: timestamptz
  id: uuid
  """End date of billing period"""
  periodEnd: date
  """Start date of billing period"""
  periodStart: date
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "billing_periods"
"""
input BillingPeriodsMaxOrderBy {
  """Client this billing period is for"""
  clientId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  """End date of billing period"""
  periodEnd: OrderBy
  """Start date of billing period"""
  periodStart: OrderBy
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type BillingPeriodsMinFields {
  """Client this billing period is for"""
  clientId: uuid
  createdAt: timestamptz
  id: uuid
  """End date of billing period"""
  periodEnd: date
  """Start date of billing period"""
  periodStart: date
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "billing_periods"
"""
input BillingPeriodsMinOrderBy {
  """Client this billing period is for"""
  clientId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  """End date of billing period"""
  periodEnd: OrderBy
  """Start date of billing period"""
  periodStart: OrderBy
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "billing_periods"
"""
type BillingPeriodsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [BillingPeriods!]!
}

"""
input type for inserting object relation for remote table "billing_periods"
"""
input BillingPeriodsObjRelInsertInput {
  data: BillingPeriodsInsertInput!
  """upsert condition"""
  onConflict: BillingPeriodsOnConflict
}

"""
on_conflict condition type for table "billing_periods"
"""
input BillingPeriodsOnConflict {
  constraint: BillingPeriodsConstraint!
  updateColumns: [BillingPeriodsUpdateColumn!]! = []
  where: BillingPeriodsBoolExp
}

"""Ordering options when selecting data from "billing_periods"."""
input BillingPeriodsOrderBy {
  billingInvoicesAggregate: BillingInvoiceAggregateOrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  periodEnd: OrderBy
  periodStart: OrderBy
  status: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: billing_periods"""
input BillingPeriodsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_periods"
"""
enum BillingPeriodsSelectColumn {
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  periodEnd
  """column name"""
  periodStart
  """column name"""
  status
  """column name"""
  updatedAt
}

"""
input type for updating data in table "billing_periods"
"""
input BillingPeriodsSetInput {
  """Client this billing period is for"""
  clientId: uuid
  createdAt: timestamptz
  id: uuid
  """End date of billing period"""
  periodEnd: date
  """Start date of billing period"""
  periodStart: date
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "billing_periods"
"""
input BillingPeriodsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BillingPeriodsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BillingPeriodsStreamCursorValueInput {
  """Client this billing period is for"""
  clientId: uuid
  createdAt: timestamptz
  id: uuid
  """End date of billing period"""
  periodEnd: date
  """Start date of billing period"""
  periodStart: date
  """Status: open, ready_to_invoice, invoiced, paid"""
  status: String
  updatedAt: timestamptz
}

"""
update columns of table "billing_periods"
"""
enum BillingPeriodsUpdateColumn {
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  periodEnd
  """column name"""
  periodStart
  """column name"""
  status
  """column name"""
  updatedAt
}

input BillingPeriodsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: BillingPeriodsSetInput
  """filter the rows which have to be updated"""
  where: BillingPeriodsBoolExp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input BpcharComparisonExp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar
  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _isNull: Boolean
  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar
  """does the column NOT match the given pattern"""
  _nlike: bpchar
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar
  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "client_external_systems"
"""
type ClientExternalSystems {
  """An object relationship"""
  client: Clients!
  """Reference to the client"""
  clientId: uuid!
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """An object relationship"""
  externalSystem: ExternalSystems!
  """Unique identifier for the client-system mapping"""
  id: uuid!
  """Client identifier in the external system"""
  systemClientId: String
  """Reference to the external system"""
  systemId: uuid!
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "client_external_systems"
"""
type ClientExternalSystemsAggregate {
  aggregate: ClientExternalSystemsAggregateFields
  nodes: [ClientExternalSystems!]!
}

input ClientExternalSystemsAggregateBoolExp {
  count: clientExternalSystemsAggregateBoolExpCount
}

"""
aggregate fields of "client_external_systems"
"""
type ClientExternalSystemsAggregateFields {
  count(columns: [ClientExternalSystemsSelectColumn!], distinct: Boolean): Int!
  max: ClientExternalSystemsMaxFields
  min: ClientExternalSystemsMinFields
}

"""
order by aggregate values of table "client_external_systems"
"""
input ClientExternalSystemsAggregateOrderBy {
  count: OrderBy
  max: ClientExternalSystemsMaxOrderBy
  min: ClientExternalSystemsMinOrderBy
}

"""
input type for inserting array relation for remote table "client_external_systems"
"""
input ClientExternalSystemsArrRelInsertInput {
  data: [ClientExternalSystemsInsertInput!]!
  """upsert condition"""
  onConflict: ClientExternalSystemsOnConflict
}

"""
Boolean expression to filter rows from the table "client_external_systems". All fields are combined with a logical 'AND'.
"""
input ClientExternalSystemsBoolExp {
  _and: [ClientExternalSystemsBoolExp!]
  _not: ClientExternalSystemsBoolExp
  _or: [ClientExternalSystemsBoolExp!]
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  externalSystem: ExternalSystemsBoolExp
  id: UuidComparisonExp
  systemClientId: StringComparisonExp
  systemId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "client_external_systems"
"""
enum ClientExternalSystemsConstraint {
  """
  unique or primary key constraint on columns "client_id", "system_id"
  """
  client_external_systems_client_id_system_id_key
  """
  unique or primary key constraint on columns "id"
  """
  client_external_systems_pkey
}

"""
input type for inserting data into table "client_external_systems"
"""
input ClientExternalSystemsInsertInput {
  client: ClientsObjRelInsertInput
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  externalSystem: ExternalSystemsObjRelInsertInput
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Reference to the external system"""
  systemId: uuid
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ClientExternalSystemsMaxFields {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Reference to the external system"""
  systemId: uuid
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "client_external_systems"
"""
input ClientExternalSystemsMaxOrderBy {
  """Reference to the client"""
  clientId: OrderBy
  """Timestamp when the mapping was created"""
  createdAt: OrderBy
  """Unique identifier for the client-system mapping"""
  id: OrderBy
  """Client identifier in the external system"""
  systemClientId: OrderBy
  """Reference to the external system"""
  systemId: OrderBy
  """Timestamp when the mapping was last updated"""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ClientExternalSystemsMinFields {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Reference to the external system"""
  systemId: uuid
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "client_external_systems"
"""
input ClientExternalSystemsMinOrderBy {
  """Reference to the client"""
  clientId: OrderBy
  """Timestamp when the mapping was created"""
  createdAt: OrderBy
  """Unique identifier for the client-system mapping"""
  id: OrderBy
  """Client identifier in the external system"""
  systemClientId: OrderBy
  """Reference to the external system"""
  systemId: OrderBy
  """Timestamp when the mapping was last updated"""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "client_external_systems"
"""
type ClientExternalSystemsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ClientExternalSystems!]!
}

"""
on_conflict condition type for table "client_external_systems"
"""
input ClientExternalSystemsOnConflict {
  constraint: ClientExternalSystemsConstraint!
  updateColumns: [ClientExternalSystemsUpdateColumn!]! = []
  where: ClientExternalSystemsBoolExp
}

"""Ordering options when selecting data from "client_external_systems"."""
input ClientExternalSystemsOrderBy {
  client: ClientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  externalSystem: ExternalSystemsOrderBy
  id: OrderBy
  systemClientId: OrderBy
  systemId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: client_external_systems"""
input ClientExternalSystemsPkColumnsInput {
  """Unique identifier for the client-system mapping"""
  id: uuid!
}

"""
select columns of table "client_external_systems"
"""
enum ClientExternalSystemsSelectColumn {
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  systemClientId
  """column name"""
  systemId
  """column name"""
  updatedAt
}

"""
input type for updating data in table "client_external_systems"
"""
input ClientExternalSystemsSetInput {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Reference to the external system"""
  systemId: uuid
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "client_external_systems"
"""
input ClientExternalSystemsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ClientExternalSystemsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ClientExternalSystemsStreamCursorValueInput {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Reference to the external system"""
  systemId: uuid
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "client_external_systems"
"""
enum ClientExternalSystemsUpdateColumn {
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  systemClientId
  """column name"""
  systemId
  """column name"""
  updatedAt
}

input ClientExternalSystemsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ClientExternalSystemsSetInput
  """filter the rows which have to be updated"""
  where: ClientExternalSystemsBoolExp!
}

"""Client-specific service agreements and configurations"""
type ClientServiceAgreements {
  autoBillingEnabled: Boolean
  autoBillingTriggers(
    """JSON select path"""
    path: String
  ): jsonb
  billingFrequency: String
  """An object relationship"""
  client: Clients!
  clientId: uuid!
  contractEndDate: date
  contractStartDate: date
  createdAt: timestamptz
  createdBy: uuid
  """An object relationship"""
  createdByUser: Users
  customRate: numeric
  id: uuid!
  isActive: Boolean
  isEnabled: Boolean
  """An object relationship"""
  service: Services!
  serviceConfiguration(
    """JSON select path"""
    path: String
  ): jsonb
  serviceId: uuid!
  updatedAt: timestamptz
}

"""
aggregated selection of "client_service_agreements"
"""
type ClientServiceAgreementsAggregate {
  aggregate: ClientServiceAgreementsAggregateFields
  nodes: [ClientServiceAgreements!]!
}

input ClientServiceAgreementsAggregateBoolExp {
  bool_and: clientServiceAgreementsAggregateBoolExpBool_and
  bool_or: clientServiceAgreementsAggregateBoolExpBool_or
  count: clientServiceAgreementsAggregateBoolExpCount
}

"""
aggregate fields of "client_service_agreements"
"""
type ClientServiceAgreementsAggregateFields {
  avg: ClientServiceAgreementsAvgFields
  count(columns: [ClientServiceAgreementsSelectColumn!], distinct: Boolean): Int!
  max: ClientServiceAgreementsMaxFields
  min: ClientServiceAgreementsMinFields
  stddev: ClientServiceAgreementsStddevFields
  stddevPop: ClientServiceAgreementsStddevPopFields
  stddevSamp: ClientServiceAgreementsStddevSampFields
  sum: ClientServiceAgreementsSumFields
  varPop: ClientServiceAgreementsVarPopFields
  varSamp: ClientServiceAgreementsVarSampFields
  variance: ClientServiceAgreementsVarianceFields
}

"""
order by aggregate values of table "client_service_agreements"
"""
input ClientServiceAgreementsAggregateOrderBy {
  avg: ClientServiceAgreementsAvgOrderBy
  count: OrderBy
  max: ClientServiceAgreementsMaxOrderBy
  min: ClientServiceAgreementsMinOrderBy
  stddev: ClientServiceAgreementsStddevOrderBy
  stddevPop: ClientServiceAgreementsStddevPopOrderBy
  stddevSamp: ClientServiceAgreementsStddevSampOrderBy
  sum: ClientServiceAgreementsSumOrderBy
  varPop: ClientServiceAgreementsVarPopOrderBy
  varSamp: ClientServiceAgreementsVarSampOrderBy
  variance: ClientServiceAgreementsVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ClientServiceAgreementsAppendInput {
  autoBillingTriggers: jsonb
  serviceConfiguration: jsonb
}

"""
input type for inserting array relation for remote table "client_service_agreements"
"""
input ClientServiceAgreementsArrRelInsertInput {
  data: [ClientServiceAgreementsInsertInput!]!
  """upsert condition"""
  onConflict: ClientServiceAgreementsOnConflict
}

"""aggregate avg on columns"""
type ClientServiceAgreementsAvgFields {
  customRate: Float
}

"""
order by avg() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsAvgOrderBy {
  customRate: OrderBy
}

"""
Boolean expression to filter rows from the table "client_service_agreements". All fields are combined with a logical 'AND'.
"""
input ClientServiceAgreementsBoolExp {
  _and: [ClientServiceAgreementsBoolExp!]
  _not: ClientServiceAgreementsBoolExp
  _or: [ClientServiceAgreementsBoolExp!]
  autoBillingEnabled: BooleanComparisonExp
  autoBillingTriggers: JsonbComparisonExp
  billingFrequency: StringComparisonExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  contractEndDate: DateComparisonExp
  contractStartDate: DateComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  customRate: NumericComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  isEnabled: BooleanComparisonExp
  service: ServicesBoolExp
  serviceConfiguration: JsonbComparisonExp
  serviceId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "client_service_agreements"
"""
enum ClientServiceAgreementsConstraint {
  """
  unique or primary key constraint on columns "client_id", "service_id"
  """
  client_service_agreements_client_id_service_id_key
  """
  unique or primary key constraint on columns "id"
  """
  client_service_agreements_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ClientServiceAgreementsDeleteAtPathInput {
  autoBillingTriggers: [String!]
  serviceConfiguration: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ClientServiceAgreementsDeleteElemInput {
  autoBillingTriggers: Int
  serviceConfiguration: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ClientServiceAgreementsDeleteKeyInput {
  autoBillingTriggers: String
  serviceConfiguration: String
}

"""
input type for incrementing numeric columns in table "client_service_agreements"
"""
input ClientServiceAgreementsIncInput {
  customRate: numeric
}

"""
input type for inserting data into table "client_service_agreements"
"""
input ClientServiceAgreementsInsertInput {
  autoBillingEnabled: Boolean
  autoBillingTriggers: jsonb
  billingFrequency: String
  client: ClientsObjRelInsertInput
  clientId: uuid
  contractEndDate: date
  contractStartDate: date
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  customRate: numeric
  id: uuid
  isActive: Boolean
  isEnabled: Boolean
  service: ServicesObjRelInsertInput
  serviceConfiguration: jsonb
  serviceId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ClientServiceAgreementsMaxFields {
  billingFrequency: String
  clientId: uuid
  contractEndDate: date
  contractStartDate: date
  createdAt: timestamptz
  createdBy: uuid
  customRate: numeric
  id: uuid
  serviceId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsMaxOrderBy {
  billingFrequency: OrderBy
  clientId: OrderBy
  contractEndDate: OrderBy
  contractStartDate: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  customRate: OrderBy
  id: OrderBy
  serviceId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ClientServiceAgreementsMinFields {
  billingFrequency: String
  clientId: uuid
  contractEndDate: date
  contractStartDate: date
  createdAt: timestamptz
  createdBy: uuid
  customRate: numeric
  id: uuid
  serviceId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsMinOrderBy {
  billingFrequency: OrderBy
  clientId: OrderBy
  contractEndDate: OrderBy
  contractStartDate: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  customRate: OrderBy
  id: OrderBy
  serviceId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "client_service_agreements"
"""
type ClientServiceAgreementsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ClientServiceAgreements!]!
}

"""
on_conflict condition type for table "client_service_agreements"
"""
input ClientServiceAgreementsOnConflict {
  constraint: ClientServiceAgreementsConstraint!
  updateColumns: [ClientServiceAgreementsUpdateColumn!]! = []
  where: ClientServiceAgreementsBoolExp
}

"""Ordering options when selecting data from "client_service_agreements"."""
input ClientServiceAgreementsOrderBy {
  autoBillingEnabled: OrderBy
  autoBillingTriggers: OrderBy
  billingFrequency: OrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  contractEndDate: OrderBy
  contractStartDate: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  customRate: OrderBy
  id: OrderBy
  isActive: OrderBy
  isEnabled: OrderBy
  service: ServicesOrderBy
  serviceConfiguration: OrderBy
  serviceId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: client_service_agreements"""
input ClientServiceAgreementsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ClientServiceAgreementsPrependInput {
  autoBillingTriggers: jsonb
  serviceConfiguration: jsonb
}

"""
select columns of table "client_service_agreements"
"""
enum ClientServiceAgreementsSelectColumn {
  """column name"""
  autoBillingEnabled
  """column name"""
  autoBillingTriggers
  """column name"""
  billingFrequency
  """column name"""
  clientId
  """column name"""
  contractEndDate
  """column name"""
  contractStartDate
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  customRate
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isEnabled
  """column name"""
  serviceConfiguration
  """column name"""
  serviceId
  """column name"""
  updatedAt
}

"""
select "clientServiceAgreementsAggregateBoolExpBool_andArgumentsColumns" columns of table "client_service_agreements"
"""
enum ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  autoBillingEnabled
  """column name"""
  isActive
  """column name"""
  isEnabled
}

"""
select "clientServiceAgreementsAggregateBoolExpBool_orArgumentsColumns" columns of table "client_service_agreements"
"""
enum ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  autoBillingEnabled
  """column name"""
  isActive
  """column name"""
  isEnabled
}

"""
input type for updating data in table "client_service_agreements"
"""
input ClientServiceAgreementsSetInput {
  autoBillingEnabled: Boolean
  autoBillingTriggers: jsonb
  billingFrequency: String
  clientId: uuid
  contractEndDate: date
  contractStartDate: date
  createdAt: timestamptz
  createdBy: uuid
  customRate: numeric
  id: uuid
  isActive: Boolean
  isEnabled: Boolean
  serviceConfiguration: jsonb
  serviceId: uuid
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type ClientServiceAgreementsStddevFields {
  customRate: Float
}

"""
order by stddev() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsStddevOrderBy {
  customRate: OrderBy
}

"""aggregate stddevPop on columns"""
type ClientServiceAgreementsStddevPopFields {
  customRate: Float
}

"""
order by stddevPop() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsStddevPopOrderBy {
  customRate: OrderBy
}

"""aggregate stddevSamp on columns"""
type ClientServiceAgreementsStddevSampFields {
  customRate: Float
}

"""
order by stddevSamp() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsStddevSampOrderBy {
  customRate: OrderBy
}

"""
Streaming cursor of the table "client_service_agreements"
"""
input ClientServiceAgreementsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ClientServiceAgreementsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ClientServiceAgreementsStreamCursorValueInput {
  autoBillingEnabled: Boolean
  autoBillingTriggers: jsonb
  billingFrequency: String
  clientId: uuid
  contractEndDate: date
  contractStartDate: date
  createdAt: timestamptz
  createdBy: uuid
  customRate: numeric
  id: uuid
  isActive: Boolean
  isEnabled: Boolean
  serviceConfiguration: jsonb
  serviceId: uuid
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type ClientServiceAgreementsSumFields {
  customRate: numeric
}

"""
order by sum() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsSumOrderBy {
  customRate: OrderBy
}

"""
update columns of table "client_service_agreements"
"""
enum ClientServiceAgreementsUpdateColumn {
  """column name"""
  autoBillingEnabled
  """column name"""
  autoBillingTriggers
  """column name"""
  billingFrequency
  """column name"""
  clientId
  """column name"""
  contractEndDate
  """column name"""
  contractStartDate
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  customRate
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isEnabled
  """column name"""
  serviceConfiguration
  """column name"""
  serviceId
  """column name"""
  updatedAt
}

input ClientServiceAgreementsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ClientServiceAgreementsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ClientServiceAgreementsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ClientServiceAgreementsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ClientServiceAgreementsDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: ClientServiceAgreementsIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ClientServiceAgreementsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: ClientServiceAgreementsSetInput
  """filter the rows which have to be updated"""
  where: ClientServiceAgreementsBoolExp!
}

"""aggregate varPop on columns"""
type ClientServiceAgreementsVarPopFields {
  customRate: Float
}

"""
order by varPop() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsVarPopOrderBy {
  customRate: OrderBy
}

"""aggregate varSamp on columns"""
type ClientServiceAgreementsVarSampFields {
  customRate: Float
}

"""
order by varSamp() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsVarSampOrderBy {
  customRate: OrderBy
}

"""aggregate variance on columns"""
type ClientServiceAgreementsVarianceFields {
  customRate: Float
}

"""
order by variance() on columns of table "client_service_agreements"
"""
input ClientServiceAgreementsVarianceOrderBy {
  customRate: OrderBy
}

"""
columns and relationships of "client_services_with_rates"
"""
type ClientServicesWithRates {
  agreementId: uuid
  billingFrequency: String
  billingUnit: String
  category: String
  clientId: uuid
  clientName: String
  customRate: numeric
  effectiveDate: date
  effectiveRate: numeric
  isActive: Boolean
  isEnabled: Boolean
  serviceDescription: String
  serviceId: uuid
  serviceName: String
  standardRate: numeric
}

"""
aggregated selection of "client_services_with_rates"
"""
type ClientServicesWithRatesAggregate {
  aggregate: ClientServicesWithRatesAggregateFields
  nodes: [ClientServicesWithRates!]!
}

"""
aggregate fields of "client_services_with_rates"
"""
type ClientServicesWithRatesAggregateFields {
  avg: ClientServicesWithRatesAvgFields
  count(columns: [ClientServicesWithRatesSelectColumn!], distinct: Boolean): Int!
  max: ClientServicesWithRatesMaxFields
  min: ClientServicesWithRatesMinFields
  stddev: ClientServicesWithRatesStddevFields
  stddevPop: ClientServicesWithRatesStddevPopFields
  stddevSamp: ClientServicesWithRatesStddevSampFields
  sum: ClientServicesWithRatesSumFields
  varPop: ClientServicesWithRatesVarPopFields
  varSamp: ClientServicesWithRatesVarSampFields
  variance: ClientServicesWithRatesVarianceFields
}

"""aggregate avg on columns"""
type ClientServicesWithRatesAvgFields {
  customRate: Float
  effectiveRate: Float
  standardRate: Float
}

"""
Boolean expression to filter rows from the table "client_services_with_rates". All fields are combined with a logical 'AND'.
"""
input ClientServicesWithRatesBoolExp {
  _and: [ClientServicesWithRatesBoolExp!]
  _not: ClientServicesWithRatesBoolExp
  _or: [ClientServicesWithRatesBoolExp!]
  agreementId: UuidComparisonExp
  billingFrequency: StringComparisonExp
  billingUnit: StringComparisonExp
  category: StringComparisonExp
  clientId: UuidComparisonExp
  clientName: StringComparisonExp
  customRate: NumericComparisonExp
  effectiveDate: DateComparisonExp
  effectiveRate: NumericComparisonExp
  isActive: BooleanComparisonExp
  isEnabled: BooleanComparisonExp
  serviceDescription: StringComparisonExp
  serviceId: UuidComparisonExp
  serviceName: StringComparisonExp
  standardRate: NumericComparisonExp
}

"""aggregate max on columns"""
type ClientServicesWithRatesMaxFields {
  agreementId: uuid
  billingFrequency: String
  billingUnit: String
  category: String
  clientId: uuid
  clientName: String
  customRate: numeric
  effectiveDate: date
  effectiveRate: numeric
  serviceDescription: String
  serviceId: uuid
  serviceName: String
  standardRate: numeric
}

"""aggregate min on columns"""
type ClientServicesWithRatesMinFields {
  agreementId: uuid
  billingFrequency: String
  billingUnit: String
  category: String
  clientId: uuid
  clientName: String
  customRate: numeric
  effectiveDate: date
  effectiveRate: numeric
  serviceDescription: String
  serviceId: uuid
  serviceName: String
  standardRate: numeric
}

"""
Ordering options when selecting data from "client_services_with_rates".
"""
input ClientServicesWithRatesOrderBy {
  agreementId: OrderBy
  billingFrequency: OrderBy
  billingUnit: OrderBy
  category: OrderBy
  clientId: OrderBy
  clientName: OrderBy
  customRate: OrderBy
  effectiveDate: OrderBy
  effectiveRate: OrderBy
  isActive: OrderBy
  isEnabled: OrderBy
  serviceDescription: OrderBy
  serviceId: OrderBy
  serviceName: OrderBy
  standardRate: OrderBy
}

"""
select columns of table "client_services_with_rates"
"""
enum ClientServicesWithRatesSelectColumn {
  """column name"""
  agreementId
  """column name"""
  billingFrequency
  """column name"""
  billingUnit
  """column name"""
  category
  """column name"""
  clientId
  """column name"""
  clientName
  """column name"""
  customRate
  """column name"""
  effectiveDate
  """column name"""
  effectiveRate
  """column name"""
  isActive
  """column name"""
  isEnabled
  """column name"""
  serviceDescription
  """column name"""
  serviceId
  """column name"""
  serviceName
  """column name"""
  standardRate
}

"""aggregate stddev on columns"""
type ClientServicesWithRatesStddevFields {
  customRate: Float
  effectiveRate: Float
  standardRate: Float
}

"""aggregate stddevPop on columns"""
type ClientServicesWithRatesStddevPopFields {
  customRate: Float
  effectiveRate: Float
  standardRate: Float
}

"""aggregate stddevSamp on columns"""
type ClientServicesWithRatesStddevSampFields {
  customRate: Float
  effectiveRate: Float
  standardRate: Float
}

"""
Streaming cursor of the table "client_services_with_rates"
"""
input ClientServicesWithRatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ClientServicesWithRatesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ClientServicesWithRatesStreamCursorValueInput {
  agreementId: uuid
  billingFrequency: String
  billingUnit: String
  category: String
  clientId: uuid
  clientName: String
  customRate: numeric
  effectiveDate: date
  effectiveRate: numeric
  isActive: Boolean
  isEnabled: Boolean
  serviceDescription: String
  serviceId: uuid
  serviceName: String
  standardRate: numeric
}

"""aggregate sum on columns"""
type ClientServicesWithRatesSumFields {
  customRate: numeric
  effectiveRate: numeric
  standardRate: numeric
}

"""aggregate varPop on columns"""
type ClientServicesWithRatesVarPopFields {
  customRate: Float
  effectiveRate: Float
  standardRate: Float
}

"""aggregate varSamp on columns"""
type ClientServicesWithRatesVarSampFields {
  customRate: Float
  effectiveRate: Float
  standardRate: Float
}

"""aggregate variance on columns"""
type ClientServicesWithRatesVarianceFields {
  customRate: Float
  effectiveRate: Float
  standardRate: Float
}

"""
columns and relationships of "clients"
"""
type Clients {
  """Whether the client is currently active"""
  active: Boolean
  """An array relationship"""
  billingInvoices(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): [BillingInvoice!]!
  """An aggregate relationship"""
  billingInvoicesAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): BillingInvoiceAggregate!
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """An array relationship"""
  billingPeriods(
    """distinct select on columns"""
    distinctOn: [BillingPeriodsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingPeriodsOrderBy!]
    """filter the rows returned"""
    where: BillingPeriodsBoolExp
  ): [BillingPeriods!]!
  """An aggregate relationship"""
  billingPeriodsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingPeriodsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingPeriodsOrderBy!]
    """filter the rows returned"""
    where: BillingPeriodsBoolExp
  ): BillingPeriodsAggregate!
  """An array relationship"""
  clientQuotes(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): [Quotes!]!
  """An aggregate relationship"""
  clientQuotesAggregate(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): QuotesAggregate!
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """An array relationship"""
  externalSystemConnections(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): [ClientExternalSystems!]!
  """An aggregate relationship"""
  externalSystemConnectionsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): ClientExternalSystemsAggregate!
  """An array relationship"""
  files(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): [Files!]!
  """An aggregate relationship"""
  filesAggregate(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): FilesAggregate!
  """Unique identifier for the client"""
  id: uuid!
  """Client company name"""
  name: String!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """An array relationship"""
  quoteConversions(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): [QuoteConversions!]!
  """An aggregate relationship"""
  quoteConversionsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): QuoteConversionsAggregate!
  """An array relationship"""
  quotes(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): [Quotes!]!
  """An aggregate relationship"""
  quotesAggregate(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): QuotesAggregate!
  """An array relationship"""
  serviceAgreements(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): [ClientServiceAgreements!]!
  """An aggregate relationship"""
  serviceAgreementsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): ClientServiceAgreementsAggregate!
  """An array relationship"""
  timeEntries(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """An aggregate relationship"""
  timeEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): TimeEntriesAggregate!
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "clients"
"""
type ClientsAggregate {
  aggregate: ClientsAggregateFields
  nodes: [Clients!]!
}

"""
aggregate fields of "clients"
"""
type ClientsAggregateFields {
  count(columns: [ClientsSelectColumn!], distinct: Boolean): Int!
  max: ClientsMaxFields
  min: ClientsMinFields
}

"""
Boolean expression to filter rows from the table "clients". All fields are combined with a logical 'AND'.
"""
input ClientsBoolExp {
  _and: [ClientsBoolExp!]
  _not: ClientsBoolExp
  _or: [ClientsBoolExp!]
  active: BooleanComparisonExp
  billingInvoices: BillingInvoiceBoolExp
  billingInvoicesAggregate: BillingInvoiceAggregateBoolExp
  billingItems: BillingItemsBoolExp
  billingItemsAggregate: BillingItemsAggregateBoolExp
  billingPeriods: BillingPeriodsBoolExp
  billingPeriodsAggregate: BillingPeriodsAggregateBoolExp
  clientQuotes: QuotesBoolExp
  clientQuotesAggregate: QuotesAggregateBoolExp
  contactEmail: StringComparisonExp
  contactPerson: StringComparisonExp
  contactPhone: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  externalSystemConnections: ClientExternalSystemsBoolExp
  externalSystemConnectionsAggregate: ClientExternalSystemsAggregateBoolExp
  files: FilesBoolExp
  filesAggregate: FilesAggregateBoolExp
  id: UuidComparisonExp
  name: StringComparisonExp
  payrolls: PayrollsBoolExp
  payrollsAggregate: PayrollsAggregateBoolExp
  quoteConversions: QuoteConversionsBoolExp
  quoteConversionsAggregate: QuoteConversionsAggregateBoolExp
  quotes: QuotesBoolExp
  quotesAggregate: QuotesAggregateBoolExp
  serviceAgreements: ClientServiceAgreementsBoolExp
  serviceAgreementsAggregate: ClientServiceAgreementsAggregateBoolExp
  timeEntries: TimeEntriesBoolExp
  timeEntriesAggregate: TimeEntriesAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "clients"
"""
enum ClientsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  clients_pkey
}

"""
input type for inserting data into table "clients"
"""
input ClientsInsertInput {
  """Whether the client is currently active"""
  active: Boolean
  billingInvoices: BillingInvoiceArrRelInsertInput
  billingItems: BillingItemsArrRelInsertInput
  billingPeriods: BillingPeriodsArrRelInsertInput
  clientQuotes: QuotesArrRelInsertInput
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  externalSystemConnections: ClientExternalSystemsArrRelInsertInput
  files: FilesArrRelInsertInput
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  payrolls: PayrollsArrRelInsertInput
  quoteConversions: QuoteConversionsArrRelInsertInput
  quotes: QuotesArrRelInsertInput
  serviceAgreements: ClientServiceAgreementsArrRelInsertInput
  timeEntries: TimeEntriesArrRelInsertInput
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ClientsMaxFields {
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ClientsMinFields {
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "clients"
"""
type ClientsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Clients!]!
}

"""
input type for inserting object relation for remote table "clients"
"""
input ClientsObjRelInsertInput {
  data: ClientsInsertInput!
  """upsert condition"""
  onConflict: ClientsOnConflict
}

"""
on_conflict condition type for table "clients"
"""
input ClientsOnConflict {
  constraint: ClientsConstraint!
  updateColumns: [ClientsUpdateColumn!]! = []
  where: ClientsBoolExp
}

"""Ordering options when selecting data from "clients"."""
input ClientsOrderBy {
  active: OrderBy
  billingInvoicesAggregate: BillingInvoiceAggregateOrderBy
  billingItemsAggregate: BillingItemsAggregateOrderBy
  billingPeriodsAggregate: BillingPeriodsAggregateOrderBy
  clientQuotesAggregate: QuotesAggregateOrderBy
  contactEmail: OrderBy
  contactPerson: OrderBy
  contactPhone: OrderBy
  createdAt: OrderBy
  externalSystemConnectionsAggregate: ClientExternalSystemsAggregateOrderBy
  filesAggregate: FilesAggregateOrderBy
  id: OrderBy
  name: OrderBy
  payrollsAggregate: PayrollsAggregateOrderBy
  quoteConversionsAggregate: QuoteConversionsAggregateOrderBy
  quotesAggregate: QuotesAggregateOrderBy
  serviceAgreementsAggregate: ClientServiceAgreementsAggregateOrderBy
  timeEntriesAggregate: TimeEntriesAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: clients"""
input ClientsPkColumnsInput {
  """Unique identifier for the client"""
  id: uuid!
}

"""
select columns of table "clients"
"""
enum ClientsSelectColumn {
  """column name"""
  active
  """column name"""
  contactEmail
  """column name"""
  contactPerson
  """column name"""
  contactPhone
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
input type for updating data in table "clients"
"""
input ClientsSetInput {
  """Whether the client is currently active"""
  active: Boolean
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "clients"
"""
input ClientsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ClientsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ClientsStreamCursorValueInput {
  """Whether the client is currently active"""
  active: Boolean
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "clients"
"""
enum ClientsUpdateColumn {
  """column name"""
  active
  """column name"""
  contactEmail
  """column name"""
  contactPerson
  """column name"""
  contactPhone
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input ClientsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ClientsSetInput
  """filter the rows which have to be updated"""
  where: ClientsBoolExp!
}

"""
columns and relationships of "consultant_capacity_overview"
"""
type ConsultantCapacityOverview {
  adminTimeHours: numeric
  adminTimePercentageActual: numeric
  defaultAdminTimePercentage: numeric
  email: String
  id: uuid
  name: String
  payrollCapacityHours: numeric
  position: user_position
  usesDefaultAdminTime: Boolean
  workDay: String
  workHours: numeric
}

"""
aggregated selection of "consultant_capacity_overview"
"""
type ConsultantCapacityOverviewAggregate {
  aggregate: ConsultantCapacityOverviewAggregateFields
  nodes: [ConsultantCapacityOverview!]!
}

"""
aggregate fields of "consultant_capacity_overview"
"""
type ConsultantCapacityOverviewAggregateFields {
  avg: ConsultantCapacityOverviewAvgFields
  count(columns: [ConsultantCapacityOverviewSelectColumn!], distinct: Boolean): Int!
  max: ConsultantCapacityOverviewMaxFields
  min: ConsultantCapacityOverviewMinFields
  stddev: ConsultantCapacityOverviewStddevFields
  stddevPop: ConsultantCapacityOverviewStddevPopFields
  stddevSamp: ConsultantCapacityOverviewStddevSampFields
  sum: ConsultantCapacityOverviewSumFields
  varPop: ConsultantCapacityOverviewVarPopFields
  varSamp: ConsultantCapacityOverviewVarSampFields
  variance: ConsultantCapacityOverviewVarianceFields
}

"""aggregate avg on columns"""
type ConsultantCapacityOverviewAvgFields {
  adminTimeHours: Float
  adminTimePercentageActual: Float
  defaultAdminTimePercentage: Float
  payrollCapacityHours: Float
  workHours: Float
}

"""
Boolean expression to filter rows from the table "consultant_capacity_overview". All fields are combined with a logical 'AND'.
"""
input ConsultantCapacityOverviewBoolExp {
  _and: [ConsultantCapacityOverviewBoolExp!]
  _not: ConsultantCapacityOverviewBoolExp
  _or: [ConsultantCapacityOverviewBoolExp!]
  adminTimeHours: NumericComparisonExp
  adminTimePercentageActual: NumericComparisonExp
  defaultAdminTimePercentage: NumericComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  payrollCapacityHours: NumericComparisonExp
  position: UserPositionComparisonExp
  usesDefaultAdminTime: BooleanComparisonExp
  workDay: StringComparisonExp
  workHours: NumericComparisonExp
}

"""aggregate max on columns"""
type ConsultantCapacityOverviewMaxFields {
  adminTimeHours: numeric
  adminTimePercentageActual: numeric
  defaultAdminTimePercentage: numeric
  email: String
  id: uuid
  name: String
  payrollCapacityHours: numeric
  position: user_position
  workDay: String
  workHours: numeric
}

"""aggregate min on columns"""
type ConsultantCapacityOverviewMinFields {
  adminTimeHours: numeric
  adminTimePercentageActual: numeric
  defaultAdminTimePercentage: numeric
  email: String
  id: uuid
  name: String
  payrollCapacityHours: numeric
  position: user_position
  workDay: String
  workHours: numeric
}

"""
Ordering options when selecting data from "consultant_capacity_overview".
"""
input ConsultantCapacityOverviewOrderBy {
  adminTimeHours: OrderBy
  adminTimePercentageActual: OrderBy
  defaultAdminTimePercentage: OrderBy
  email: OrderBy
  id: OrderBy
  name: OrderBy
  payrollCapacityHours: OrderBy
  position: OrderBy
  usesDefaultAdminTime: OrderBy
  workDay: OrderBy
  workHours: OrderBy
}

"""
select columns of table "consultant_capacity_overview"
"""
enum ConsultantCapacityOverviewSelectColumn {
  """column name"""
  adminTimeHours
  """column name"""
  adminTimePercentageActual
  """column name"""
  defaultAdminTimePercentage
  """column name"""
  email
  """column name"""
  id
  """column name"""
  name
  """column name"""
  payrollCapacityHours
  """column name"""
  position
  """column name"""
  usesDefaultAdminTime
  """column name"""
  workDay
  """column name"""
  workHours
}

"""aggregate stddev on columns"""
type ConsultantCapacityOverviewStddevFields {
  adminTimeHours: Float
  adminTimePercentageActual: Float
  defaultAdminTimePercentage: Float
  payrollCapacityHours: Float
  workHours: Float
}

"""aggregate stddevPop on columns"""
type ConsultantCapacityOverviewStddevPopFields {
  adminTimeHours: Float
  adminTimePercentageActual: Float
  defaultAdminTimePercentage: Float
  payrollCapacityHours: Float
  workHours: Float
}

"""aggregate stddevSamp on columns"""
type ConsultantCapacityOverviewStddevSampFields {
  adminTimeHours: Float
  adminTimePercentageActual: Float
  defaultAdminTimePercentage: Float
  payrollCapacityHours: Float
  workHours: Float
}

"""
Streaming cursor of the table "consultant_capacity_overview"
"""
input ConsultantCapacityOverviewStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ConsultantCapacityOverviewStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ConsultantCapacityOverviewStreamCursorValueInput {
  adminTimeHours: numeric
  adminTimePercentageActual: numeric
  defaultAdminTimePercentage: numeric
  email: String
  id: uuid
  name: String
  payrollCapacityHours: numeric
  position: user_position
  usesDefaultAdminTime: Boolean
  workDay: String
  workHours: numeric
}

"""aggregate sum on columns"""
type ConsultantCapacityOverviewSumFields {
  adminTimeHours: numeric
  adminTimePercentageActual: numeric
  defaultAdminTimePercentage: numeric
  payrollCapacityHours: numeric
  workHours: numeric
}

"""aggregate varPop on columns"""
type ConsultantCapacityOverviewVarPopFields {
  adminTimeHours: Float
  adminTimePercentageActual: Float
  defaultAdminTimePercentage: Float
  payrollCapacityHours: Float
  workHours: Float
}

"""aggregate varSamp on columns"""
type ConsultantCapacityOverviewVarSampFields {
  adminTimeHours: Float
  adminTimePercentageActual: Float
  defaultAdminTimePercentage: Float
  payrollCapacityHours: Float
  workHours: Float
}

"""aggregate variance on columns"""
type ConsultantCapacityOverviewVarianceFields {
  adminTimeHours: Float
  adminTimePercentageActual: Float
  defaultAdminTimePercentage: Float
  payrollCapacityHours: Float
  workHours: Float
}

"""
columns and relationships of "current_payrolls"
"""
type CurrentPayrolls {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregated selection of "current_payrolls"
"""
type CurrentPayrollsAggregate {
  aggregate: CurrentPayrollsAggregateFields
  nodes: [CurrentPayrolls!]!
}

"""
aggregate fields of "current_payrolls"
"""
type CurrentPayrollsAggregateFields {
  avg: CurrentPayrollsAvgFields
  count(columns: [CurrentPayrollsSelectColumn!], distinct: Boolean): Int!
  max: CurrentPayrollsMaxFields
  min: CurrentPayrollsMinFields
  stddev: CurrentPayrollsStddevFields
  stddevPop: CurrentPayrollsStddevPopFields
  stddevSamp: CurrentPayrollsStddevSampFields
  sum: CurrentPayrollsSumFields
  varPop: CurrentPayrollsVarPopFields
  varSamp: CurrentPayrollsVarSampFields
  variance: CurrentPayrollsVarianceFields
}

"""aggregate avg on columns"""
type CurrentPayrollsAvgFields {
  dateValue: Float
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "current_payrolls". All fields are combined with a logical 'AND'.
"""
input CurrentPayrollsBoolExp {
  _and: [CurrentPayrollsBoolExp!]
  _not: CurrentPayrollsBoolExp
  _or: [CurrentPayrollsBoolExp!]
  backupConsultantUserId: UuidComparisonExp
  clientId: UuidComparisonExp
  clientName: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  cycleId: UuidComparisonExp
  dateTypeId: UuidComparisonExp
  dateValue: IntComparisonExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  managerUserId: UuidComparisonExp
  name: StringComparisonExp
  parentPayrollId: UuidComparisonExp
  payrollCycleName: PayrollCycleTypeComparisonExp
  payrollDateTypeName: PayrollDateTypeComparisonExp
  primaryConsultantUserId: UuidComparisonExp
  supersededDate: DateComparisonExp
  updatedAt: TimestamptzComparisonExp
  versionNumber: IntComparisonExp
  versionReason: StringComparisonExp
}

"""aggregate max on columns"""
type CurrentPayrollsMaxFields {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate min on columns"""
type CurrentPayrollsMinFields {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""Ordering options when selecting data from "current_payrolls"."""
input CurrentPayrollsOrderBy {
  backupConsultantUserId: OrderBy
  clientId: OrderBy
  clientName: OrderBy
  createdAt: OrderBy
  cycleId: OrderBy
  dateTypeId: OrderBy
  dateValue: OrderBy
  goLiveDate: OrderBy
  id: OrderBy
  managerUserId: OrderBy
  name: OrderBy
  parentPayrollId: OrderBy
  payrollCycleName: OrderBy
  payrollDateTypeName: OrderBy
  primaryConsultantUserId: OrderBy
  supersededDate: OrderBy
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""
select columns of table "current_payrolls"
"""
enum CurrentPayrollsSelectColumn {
  """column name"""
  backupConsultantUserId
  """column name"""
  clientId
  """column name"""
  clientName
  """column name"""
  createdAt
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  dateValue
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  parentPayrollId
  """column name"""
  payrollCycleName
  """column name"""
  payrollDateTypeName
  """column name"""
  primaryConsultantUserId
  """column name"""
  supersededDate
  """column name"""
  updatedAt
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

"""aggregate stddev on columns"""
type CurrentPayrollsStddevFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type CurrentPayrollsStddevPopFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type CurrentPayrollsStddevSampFields {
  dateValue: Float
  versionNumber: Float
}

"""
Streaming cursor of the table "current_payrolls"
"""
input CurrentPayrollsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CurrentPayrollsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CurrentPayrollsStreamCursorValueInput {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate sum on columns"""
type CurrentPayrollsSumFields {
  dateValue: Int
  versionNumber: Int
}

"""aggregate varPop on columns"""
type CurrentPayrollsVarPopFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type CurrentPayrollsVarSampFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate variance on columns"""
type CurrentPayrollsVarianceFields {
  dateValue: Float
  versionNumber: Float
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC
  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "data_backups"
"""
type DataBackups {
  backupType: String
  checksum: String
  completedAt: timestamptz
  compressionType: String
  createdAt: timestamptz
  encryptionKeyHash: String
  errorMessage: String
  expiresAt: timestamptz
  fileSize: bigint
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  retentionDays: Int
  startedAt: timestamptz
  status: String
  storagePath: String
  tablesIncluded: [String!]
  """An object relationship"""
  user: Users
  userId: uuid
}

"""
aggregated selection of "data_backups"
"""
type DataBackupsAggregate {
  aggregate: DataBackupsAggregateFields
  nodes: [DataBackups!]!
}

input DataBackupsAggregateBoolExp {
  count: dataBackupsAggregateBoolExpCount
}

"""
aggregate fields of "data_backups"
"""
type DataBackupsAggregateFields {
  avg: DataBackupsAvgFields
  count(columns: [DataBackupsSelectColumn!], distinct: Boolean): Int!
  max: DataBackupsMaxFields
  min: DataBackupsMinFields
  stddev: DataBackupsStddevFields
  stddevPop: DataBackupsStddevPopFields
  stddevSamp: DataBackupsStddevSampFields
  sum: DataBackupsSumFields
  varPop: DataBackupsVarPopFields
  varSamp: DataBackupsVarSampFields
  variance: DataBackupsVarianceFields
}

"""
order by aggregate values of table "data_backups"
"""
input DataBackupsAggregateOrderBy {
  avg: DataBackupsAvgOrderBy
  count: OrderBy
  max: DataBackupsMaxOrderBy
  min: DataBackupsMinOrderBy
  stddev: DataBackupsStddevOrderBy
  stddevPop: DataBackupsStddevPopOrderBy
  stddevSamp: DataBackupsStddevSampOrderBy
  sum: DataBackupsSumOrderBy
  varPop: DataBackupsVarPopOrderBy
  varSamp: DataBackupsVarSampOrderBy
  variance: DataBackupsVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input DataBackupsAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "data_backups"
"""
input DataBackupsArrRelInsertInput {
  data: [DataBackupsInsertInput!]!
  """upsert condition"""
  onConflict: DataBackupsOnConflict
}

"""aggregate avg on columns"""
type DataBackupsAvgFields {
  fileSize: Float
  retentionDays: Float
}

"""
order by avg() on columns of table "data_backups"
"""
input DataBackupsAvgOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""
Boolean expression to filter rows from the table "data_backups". All fields are combined with a logical 'AND'.
"""
input DataBackupsBoolExp {
  _and: [DataBackupsBoolExp!]
  _not: DataBackupsBoolExp
  _or: [DataBackupsBoolExp!]
  backupType: StringComparisonExp
  checksum: StringComparisonExp
  completedAt: TimestamptzComparisonExp
  compressionType: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  encryptionKeyHash: StringComparisonExp
  errorMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  fileSize: BigintComparisonExp
  id: UuidComparisonExp
  metadata: JsonbComparisonExp
  retentionDays: IntComparisonExp
  startedAt: TimestamptzComparisonExp
  status: StringComparisonExp
  storagePath: StringComparisonExp
  tablesIncluded: StringArrayComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "data_backups"
"""
enum DataBackupsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  data_backups_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input DataBackupsDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input DataBackupsDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input DataBackupsDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "data_backups"
"""
input DataBackupsIncInput {
  fileSize: bigint
  retentionDays: Int
}

"""
input type for inserting data into table "data_backups"
"""
input DataBackupsInsertInput {
  backupType: String
  checksum: String
  completedAt: timestamptz
  compressionType: String
  createdAt: timestamptz
  encryptionKeyHash: String
  errorMessage: String
  expiresAt: timestamptz
  fileSize: bigint
  id: uuid
  metadata: jsonb
  retentionDays: Int
  startedAt: timestamptz
  status: String
  storagePath: String
  tablesIncluded: [String!]
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type DataBackupsMaxFields {
  backupType: String
  checksum: String
  completedAt: timestamptz
  compressionType: String
  createdAt: timestamptz
  encryptionKeyHash: String
  errorMessage: String
  expiresAt: timestamptz
  fileSize: bigint
  id: uuid
  retentionDays: Int
  startedAt: timestamptz
  status: String
  storagePath: String
  tablesIncluded: [String!]
  userId: uuid
}

"""
order by max() on columns of table "data_backups"
"""
input DataBackupsMaxOrderBy {
  backupType: OrderBy
  checksum: OrderBy
  completedAt: OrderBy
  compressionType: OrderBy
  createdAt: OrderBy
  encryptionKeyHash: OrderBy
  errorMessage: OrderBy
  expiresAt: OrderBy
  fileSize: OrderBy
  id: OrderBy
  retentionDays: OrderBy
  startedAt: OrderBy
  status: OrderBy
  storagePath: OrderBy
  tablesIncluded: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type DataBackupsMinFields {
  backupType: String
  checksum: String
  completedAt: timestamptz
  compressionType: String
  createdAt: timestamptz
  encryptionKeyHash: String
  errorMessage: String
  expiresAt: timestamptz
  fileSize: bigint
  id: uuid
  retentionDays: Int
  startedAt: timestamptz
  status: String
  storagePath: String
  tablesIncluded: [String!]
  userId: uuid
}

"""
order by min() on columns of table "data_backups"
"""
input DataBackupsMinOrderBy {
  backupType: OrderBy
  checksum: OrderBy
  completedAt: OrderBy
  compressionType: OrderBy
  createdAt: OrderBy
  encryptionKeyHash: OrderBy
  errorMessage: OrderBy
  expiresAt: OrderBy
  fileSize: OrderBy
  id: OrderBy
  retentionDays: OrderBy
  startedAt: OrderBy
  status: OrderBy
  storagePath: OrderBy
  tablesIncluded: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "data_backups"
"""
type DataBackupsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [DataBackups!]!
}

"""
on_conflict condition type for table "data_backups"
"""
input DataBackupsOnConflict {
  constraint: DataBackupsConstraint!
  updateColumns: [DataBackupsUpdateColumn!]! = []
  where: DataBackupsBoolExp
}

"""Ordering options when selecting data from "data_backups"."""
input DataBackupsOrderBy {
  backupType: OrderBy
  checksum: OrderBy
  completedAt: OrderBy
  compressionType: OrderBy
  createdAt: OrderBy
  encryptionKeyHash: OrderBy
  errorMessage: OrderBy
  expiresAt: OrderBy
  fileSize: OrderBy
  id: OrderBy
  metadata: OrderBy
  retentionDays: OrderBy
  startedAt: OrderBy
  status: OrderBy
  storagePath: OrderBy
  tablesIncluded: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""primary key columns input for table: data_backups"""
input DataBackupsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input DataBackupsPrependInput {
  metadata: jsonb
}

"""
select columns of table "data_backups"
"""
enum DataBackupsSelectColumn {
  """column name"""
  backupType
  """column name"""
  checksum
  """column name"""
  completedAt
  """column name"""
  compressionType
  """column name"""
  createdAt
  """column name"""
  encryptionKeyHash
  """column name"""
  errorMessage
  """column name"""
  expiresAt
  """column name"""
  fileSize
  """column name"""
  id
  """column name"""
  metadata
  """column name"""
  retentionDays
  """column name"""
  startedAt
  """column name"""
  status
  """column name"""
  storagePath
  """column name"""
  tablesIncluded
  """column name"""
  userId
}

"""
input type for updating data in table "data_backups"
"""
input DataBackupsSetInput {
  backupType: String
  checksum: String
  completedAt: timestamptz
  compressionType: String
  createdAt: timestamptz
  encryptionKeyHash: String
  errorMessage: String
  expiresAt: timestamptz
  fileSize: bigint
  id: uuid
  metadata: jsonb
  retentionDays: Int
  startedAt: timestamptz
  status: String
  storagePath: String
  tablesIncluded: [String!]
  userId: uuid
}

"""aggregate stddev on columns"""
type DataBackupsStddevFields {
  fileSize: Float
  retentionDays: Float
}

"""
order by stddev() on columns of table "data_backups"
"""
input DataBackupsStddevOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""aggregate stddevPop on columns"""
type DataBackupsStddevPopFields {
  fileSize: Float
  retentionDays: Float
}

"""
order by stddevPop() on columns of table "data_backups"
"""
input DataBackupsStddevPopOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""aggregate stddevSamp on columns"""
type DataBackupsStddevSampFields {
  fileSize: Float
  retentionDays: Float
}

"""
order by stddevSamp() on columns of table "data_backups"
"""
input DataBackupsStddevSampOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""
Streaming cursor of the table "data_backups"
"""
input DataBackupsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DataBackupsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DataBackupsStreamCursorValueInput {
  backupType: String
  checksum: String
  completedAt: timestamptz
  compressionType: String
  createdAt: timestamptz
  encryptionKeyHash: String
  errorMessage: String
  expiresAt: timestamptz
  fileSize: bigint
  id: uuid
  metadata: jsonb
  retentionDays: Int
  startedAt: timestamptz
  status: String
  storagePath: String
  tablesIncluded: [String!]
  userId: uuid
}

"""aggregate sum on columns"""
type DataBackupsSumFields {
  fileSize: bigint
  retentionDays: Int
}

"""
order by sum() on columns of table "data_backups"
"""
input DataBackupsSumOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""
update columns of table "data_backups"
"""
enum DataBackupsUpdateColumn {
  """column name"""
  backupType
  """column name"""
  checksum
  """column name"""
  completedAt
  """column name"""
  compressionType
  """column name"""
  createdAt
  """column name"""
  encryptionKeyHash
  """column name"""
  errorMessage
  """column name"""
  expiresAt
  """column name"""
  fileSize
  """column name"""
  id
  """column name"""
  metadata
  """column name"""
  retentionDays
  """column name"""
  startedAt
  """column name"""
  status
  """column name"""
  storagePath
  """column name"""
  tablesIncluded
  """column name"""
  userId
}

input DataBackupsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: DataBackupsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: DataBackupsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: DataBackupsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: DataBackupsDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: DataBackupsIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: DataBackupsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: DataBackupsSetInput
  """filter the rows which have to be updated"""
  where: DataBackupsBoolExp!
}

"""aggregate varPop on columns"""
type DataBackupsVarPopFields {
  fileSize: Float
  retentionDays: Float
}

"""
order by varPop() on columns of table "data_backups"
"""
input DataBackupsVarPopOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""aggregate varSamp on columns"""
type DataBackupsVarSampFields {
  fileSize: Float
  retentionDays: Float
}

"""
order by varSamp() on columns of table "data_backups"
"""
input DataBackupsVarSampOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""aggregate variance on columns"""
type DataBackupsVarianceFields {
  fileSize: Float
  retentionDays: Float
}

"""
order by variance() on columns of table "data_backups"
"""
input DataBackupsVarianceOrderBy {
  fileSize: OrderBy
  retentionDays: OrderBy
}

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""Draft emails saved for later sending"""
type EmailDrafts {
  businessContext(
    """JSON select path"""
    path: String
  ): jsonb
  createdAt: timestamptz
  """An object relationship"""
  emailTemplate: EmailTemplates
  htmlContent: String
  id: uuid!
  recipientEmails: [String!]!
  scheduledFor: timestamptz
  subject: String
  templateId: uuid
  textContent: String
  updatedAt: timestamptz
  """An object relationship"""
  user: Users!
  userId: uuid!
  variableValues(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "email_drafts"
"""
type EmailDraftsAggregate {
  aggregate: EmailDraftsAggregateFields
  nodes: [EmailDrafts!]!
}

input EmailDraftsAggregateBoolExp {
  count: emailDraftsAggregateBoolExpCount
}

"""
aggregate fields of "email_drafts"
"""
type EmailDraftsAggregateFields {
  count(columns: [EmailDraftsSelectColumn!], distinct: Boolean): Int!
  max: EmailDraftsMaxFields
  min: EmailDraftsMinFields
}

"""
order by aggregate values of table "email_drafts"
"""
input EmailDraftsAggregateOrderBy {
  count: OrderBy
  max: EmailDraftsMaxOrderBy
  min: EmailDraftsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input EmailDraftsAppendInput {
  businessContext: jsonb
  variableValues: jsonb
}

"""
input type for inserting array relation for remote table "email_drafts"
"""
input EmailDraftsArrRelInsertInput {
  data: [EmailDraftsInsertInput!]!
  """upsert condition"""
  onConflict: EmailDraftsOnConflict
}

"""
Boolean expression to filter rows from the table "email_drafts". All fields are combined with a logical 'AND'.
"""
input EmailDraftsBoolExp {
  _and: [EmailDraftsBoolExp!]
  _not: EmailDraftsBoolExp
  _or: [EmailDraftsBoolExp!]
  businessContext: JsonbComparisonExp
  createdAt: TimestamptzComparisonExp
  emailTemplate: EmailTemplatesBoolExp
  htmlContent: StringComparisonExp
  id: UuidComparisonExp
  recipientEmails: StringArrayComparisonExp
  scheduledFor: TimestamptzComparisonExp
  subject: StringComparisonExp
  templateId: UuidComparisonExp
  textContent: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
  variableValues: JsonbComparisonExp
}

"""
unique or primary key constraints on table "email_drafts"
"""
enum EmailDraftsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  email_drafts_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input EmailDraftsDeleteAtPathInput {
  businessContext: [String!]
  variableValues: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input EmailDraftsDeleteElemInput {
  businessContext: Int
  variableValues: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input EmailDraftsDeleteKeyInput {
  businessContext: String
  variableValues: String
}

"""
input type for inserting data into table "email_drafts"
"""
input EmailDraftsInsertInput {
  businessContext: jsonb
  createdAt: timestamptz
  emailTemplate: EmailTemplatesObjRelInsertInput
  htmlContent: String
  id: uuid
  recipientEmails: [String!]
  scheduledFor: timestamptz
  subject: String
  templateId: uuid
  textContent: String
  updatedAt: timestamptz
  user: UsersObjRelInsertInput
  userId: uuid
  variableValues: jsonb
}

"""aggregate max on columns"""
type EmailDraftsMaxFields {
  createdAt: timestamptz
  htmlContent: String
  id: uuid
  recipientEmails: [String!]
  scheduledFor: timestamptz
  subject: String
  templateId: uuid
  textContent: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "email_drafts"
"""
input EmailDraftsMaxOrderBy {
  createdAt: OrderBy
  htmlContent: OrderBy
  id: OrderBy
  recipientEmails: OrderBy
  scheduledFor: OrderBy
  subject: OrderBy
  templateId: OrderBy
  textContent: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type EmailDraftsMinFields {
  createdAt: timestamptz
  htmlContent: String
  id: uuid
  recipientEmails: [String!]
  scheduledFor: timestamptz
  subject: String
  templateId: uuid
  textContent: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "email_drafts"
"""
input EmailDraftsMinOrderBy {
  createdAt: OrderBy
  htmlContent: OrderBy
  id: OrderBy
  recipientEmails: OrderBy
  scheduledFor: OrderBy
  subject: OrderBy
  templateId: OrderBy
  textContent: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "email_drafts"
"""
type EmailDraftsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [EmailDrafts!]!
}

"""
on_conflict condition type for table "email_drafts"
"""
input EmailDraftsOnConflict {
  constraint: EmailDraftsConstraint!
  updateColumns: [EmailDraftsUpdateColumn!]! = []
  where: EmailDraftsBoolExp
}

"""Ordering options when selecting data from "email_drafts"."""
input EmailDraftsOrderBy {
  businessContext: OrderBy
  createdAt: OrderBy
  emailTemplate: EmailTemplatesOrderBy
  htmlContent: OrderBy
  id: OrderBy
  recipientEmails: OrderBy
  scheduledFor: OrderBy
  subject: OrderBy
  templateId: OrderBy
  textContent: OrderBy
  updatedAt: OrderBy
  user: UsersOrderBy
  userId: OrderBy
  variableValues: OrderBy
}

"""primary key columns input for table: email_drafts"""
input EmailDraftsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input EmailDraftsPrependInput {
  businessContext: jsonb
  variableValues: jsonb
}

"""
select columns of table "email_drafts"
"""
enum EmailDraftsSelectColumn {
  """column name"""
  businessContext
  """column name"""
  createdAt
  """column name"""
  htmlContent
  """column name"""
  id
  """column name"""
  recipientEmails
  """column name"""
  scheduledFor
  """column name"""
  subject
  """column name"""
  templateId
  """column name"""
  textContent
  """column name"""
  updatedAt
  """column name"""
  userId
  """column name"""
  variableValues
}

"""
input type for updating data in table "email_drafts"
"""
input EmailDraftsSetInput {
  businessContext: jsonb
  createdAt: timestamptz
  htmlContent: String
  id: uuid
  recipientEmails: [String!]
  scheduledFor: timestamptz
  subject: String
  templateId: uuid
  textContent: String
  updatedAt: timestamptz
  userId: uuid
  variableValues: jsonb
}

"""
Streaming cursor of the table "email_drafts"
"""
input EmailDraftsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EmailDraftsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EmailDraftsStreamCursorValueInput {
  businessContext: jsonb
  createdAt: timestamptz
  htmlContent: String
  id: uuid
  recipientEmails: [String!]
  scheduledFor: timestamptz
  subject: String
  templateId: uuid
  textContent: String
  updatedAt: timestamptz
  userId: uuid
  variableValues: jsonb
}

"""
update columns of table "email_drafts"
"""
enum EmailDraftsUpdateColumn {
  """column name"""
  businessContext
  """column name"""
  createdAt
  """column name"""
  htmlContent
  """column name"""
  id
  """column name"""
  recipientEmails
  """column name"""
  scheduledFor
  """column name"""
  subject
  """column name"""
  templateId
  """column name"""
  textContent
  """column name"""
  updatedAt
  """column name"""
  userId
  """column name"""
  variableValues
}

input EmailDraftsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: EmailDraftsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: EmailDraftsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: EmailDraftsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: EmailDraftsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: EmailDraftsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: EmailDraftsSetInput
  """filter the rows which have to be updated"""
  where: EmailDraftsBoolExp!
}

"""Audit log of all emails sent through the system"""
type EmailSendLogs {
  businessContext(
    """JSON select path"""
    path: String
  ): jsonb
  clickedAt: timestamptz
  createdAt: timestamptz
  deliveredAt: timestamptz
  """An object relationship"""
  emailTemplate: EmailTemplates
  errorMessage: String
  htmlContent: String
  id: uuid!
  openedAt: timestamptz
  recipientEmails: [String!]!
  resendEmailId: String
  resendResponse(
    """JSON select path"""
    path: String
  ): jsonb
  scheduledFor: timestamptz
  sendStatus: String
  """An object relationship"""
  senderUser: Users!
  senderUserId: uuid!
  sentAt: timestamptz
  subject: String!
  templateId: uuid
  textContent: String
}

"""
aggregated selection of "email_send_logs"
"""
type EmailSendLogsAggregate {
  aggregate: EmailSendLogsAggregateFields
  nodes: [EmailSendLogs!]!
}

input EmailSendLogsAggregateBoolExp {
  count: emailSendLogsAggregateBoolExpCount
}

"""
aggregate fields of "email_send_logs"
"""
type EmailSendLogsAggregateFields {
  count(columns: [EmailSendLogsSelectColumn!], distinct: Boolean): Int!
  max: EmailSendLogsMaxFields
  min: EmailSendLogsMinFields
}

"""
order by aggregate values of table "email_send_logs"
"""
input EmailSendLogsAggregateOrderBy {
  count: OrderBy
  max: EmailSendLogsMaxOrderBy
  min: EmailSendLogsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input EmailSendLogsAppendInput {
  businessContext: jsonb
  resendResponse: jsonb
}

"""
input type for inserting array relation for remote table "email_send_logs"
"""
input EmailSendLogsArrRelInsertInput {
  data: [EmailSendLogsInsertInput!]!
  """upsert condition"""
  onConflict: EmailSendLogsOnConflict
}

"""
Boolean expression to filter rows from the table "email_send_logs". All fields are combined with a logical 'AND'.
"""
input EmailSendLogsBoolExp {
  _and: [EmailSendLogsBoolExp!]
  _not: EmailSendLogsBoolExp
  _or: [EmailSendLogsBoolExp!]
  businessContext: JsonbComparisonExp
  clickedAt: TimestamptzComparisonExp
  createdAt: TimestamptzComparisonExp
  deliveredAt: TimestamptzComparisonExp
  emailTemplate: EmailTemplatesBoolExp
  errorMessage: StringComparisonExp
  htmlContent: StringComparisonExp
  id: UuidComparisonExp
  openedAt: TimestamptzComparisonExp
  recipientEmails: StringArrayComparisonExp
  resendEmailId: StringComparisonExp
  resendResponse: JsonbComparisonExp
  scheduledFor: TimestamptzComparisonExp
  sendStatus: StringComparisonExp
  senderUser: UsersBoolExp
  senderUserId: UuidComparisonExp
  sentAt: TimestamptzComparisonExp
  subject: StringComparisonExp
  templateId: UuidComparisonExp
  textContent: StringComparisonExp
}

"""
unique or primary key constraints on table "email_send_logs"
"""
enum EmailSendLogsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  email_send_logs_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input EmailSendLogsDeleteAtPathInput {
  businessContext: [String!]
  resendResponse: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input EmailSendLogsDeleteElemInput {
  businessContext: Int
  resendResponse: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input EmailSendLogsDeleteKeyInput {
  businessContext: String
  resendResponse: String
}

"""
input type for inserting data into table "email_send_logs"
"""
input EmailSendLogsInsertInput {
  businessContext: jsonb
  clickedAt: timestamptz
  createdAt: timestamptz
  deliveredAt: timestamptz
  emailTemplate: EmailTemplatesObjRelInsertInput
  errorMessage: String
  htmlContent: String
  id: uuid
  openedAt: timestamptz
  recipientEmails: [String!]
  resendEmailId: String
  resendResponse: jsonb
  scheduledFor: timestamptz
  sendStatus: String
  senderUser: UsersObjRelInsertInput
  senderUserId: uuid
  sentAt: timestamptz
  subject: String
  templateId: uuid
  textContent: String
}

"""aggregate max on columns"""
type EmailSendLogsMaxFields {
  clickedAt: timestamptz
  createdAt: timestamptz
  deliveredAt: timestamptz
  errorMessage: String
  htmlContent: String
  id: uuid
  openedAt: timestamptz
  recipientEmails: [String!]
  resendEmailId: String
  scheduledFor: timestamptz
  sendStatus: String
  senderUserId: uuid
  sentAt: timestamptz
  subject: String
  templateId: uuid
  textContent: String
}

"""
order by max() on columns of table "email_send_logs"
"""
input EmailSendLogsMaxOrderBy {
  clickedAt: OrderBy
  createdAt: OrderBy
  deliveredAt: OrderBy
  errorMessage: OrderBy
  htmlContent: OrderBy
  id: OrderBy
  openedAt: OrderBy
  recipientEmails: OrderBy
  resendEmailId: OrderBy
  scheduledFor: OrderBy
  sendStatus: OrderBy
  senderUserId: OrderBy
  sentAt: OrderBy
  subject: OrderBy
  templateId: OrderBy
  textContent: OrderBy
}

"""aggregate min on columns"""
type EmailSendLogsMinFields {
  clickedAt: timestamptz
  createdAt: timestamptz
  deliveredAt: timestamptz
  errorMessage: String
  htmlContent: String
  id: uuid
  openedAt: timestamptz
  recipientEmails: [String!]
  resendEmailId: String
  scheduledFor: timestamptz
  sendStatus: String
  senderUserId: uuid
  sentAt: timestamptz
  subject: String
  templateId: uuid
  textContent: String
}

"""
order by min() on columns of table "email_send_logs"
"""
input EmailSendLogsMinOrderBy {
  clickedAt: OrderBy
  createdAt: OrderBy
  deliveredAt: OrderBy
  errorMessage: OrderBy
  htmlContent: OrderBy
  id: OrderBy
  openedAt: OrderBy
  recipientEmails: OrderBy
  resendEmailId: OrderBy
  scheduledFor: OrderBy
  sendStatus: OrderBy
  senderUserId: OrderBy
  sentAt: OrderBy
  subject: OrderBy
  templateId: OrderBy
  textContent: OrderBy
}

"""
response of any mutation on the table "email_send_logs"
"""
type EmailSendLogsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [EmailSendLogs!]!
}

"""
on_conflict condition type for table "email_send_logs"
"""
input EmailSendLogsOnConflict {
  constraint: EmailSendLogsConstraint!
  updateColumns: [EmailSendLogsUpdateColumn!]! = []
  where: EmailSendLogsBoolExp
}

"""Ordering options when selecting data from "email_send_logs"."""
input EmailSendLogsOrderBy {
  businessContext: OrderBy
  clickedAt: OrderBy
  createdAt: OrderBy
  deliveredAt: OrderBy
  emailTemplate: EmailTemplatesOrderBy
  errorMessage: OrderBy
  htmlContent: OrderBy
  id: OrderBy
  openedAt: OrderBy
  recipientEmails: OrderBy
  resendEmailId: OrderBy
  resendResponse: OrderBy
  scheduledFor: OrderBy
  sendStatus: OrderBy
  senderUser: UsersOrderBy
  senderUserId: OrderBy
  sentAt: OrderBy
  subject: OrderBy
  templateId: OrderBy
  textContent: OrderBy
}

"""primary key columns input for table: email_send_logs"""
input EmailSendLogsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input EmailSendLogsPrependInput {
  businessContext: jsonb
  resendResponse: jsonb
}

"""
select columns of table "email_send_logs"
"""
enum EmailSendLogsSelectColumn {
  """column name"""
  businessContext
  """column name"""
  clickedAt
  """column name"""
  createdAt
  """column name"""
  deliveredAt
  """column name"""
  errorMessage
  """column name"""
  htmlContent
  """column name"""
  id
  """column name"""
  openedAt
  """column name"""
  recipientEmails
  """column name"""
  resendEmailId
  """column name"""
  resendResponse
  """column name"""
  scheduledFor
  """column name"""
  sendStatus
  """column name"""
  senderUserId
  """column name"""
  sentAt
  """column name"""
  subject
  """column name"""
  templateId
  """column name"""
  textContent
}

"""
input type for updating data in table "email_send_logs"
"""
input EmailSendLogsSetInput {
  businessContext: jsonb
  clickedAt: timestamptz
  createdAt: timestamptz
  deliveredAt: timestamptz
  errorMessage: String
  htmlContent: String
  id: uuid
  openedAt: timestamptz
  recipientEmails: [String!]
  resendEmailId: String
  resendResponse: jsonb
  scheduledFor: timestamptz
  sendStatus: String
  senderUserId: uuid
  sentAt: timestamptz
  subject: String
  templateId: uuid
  textContent: String
}

"""
Streaming cursor of the table "email_send_logs"
"""
input EmailSendLogsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EmailSendLogsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EmailSendLogsStreamCursorValueInput {
  businessContext: jsonb
  clickedAt: timestamptz
  createdAt: timestamptz
  deliveredAt: timestamptz
  errorMessage: String
  htmlContent: String
  id: uuid
  openedAt: timestamptz
  recipientEmails: [String!]
  resendEmailId: String
  resendResponse: jsonb
  scheduledFor: timestamptz
  sendStatus: String
  senderUserId: uuid
  sentAt: timestamptz
  subject: String
  templateId: uuid
  textContent: String
}

"""
update columns of table "email_send_logs"
"""
enum EmailSendLogsUpdateColumn {
  """column name"""
  businessContext
  """column name"""
  clickedAt
  """column name"""
  createdAt
  """column name"""
  deliveredAt
  """column name"""
  errorMessage
  """column name"""
  htmlContent
  """column name"""
  id
  """column name"""
  openedAt
  """column name"""
  recipientEmails
  """column name"""
  resendEmailId
  """column name"""
  resendResponse
  """column name"""
  scheduledFor
  """column name"""
  sendStatus
  """column name"""
  senderUserId
  """column name"""
  sentAt
  """column name"""
  subject
  """column name"""
  templateId
  """column name"""
  textContent
}

input EmailSendLogsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: EmailSendLogsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: EmailSendLogsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: EmailSendLogsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: EmailSendLogsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: EmailSendLogsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: EmailSendLogsSetInput
  """filter the rows which have to be updated"""
  where: EmailSendLogsBoolExp!
}

"""Email templates for various business communications"""
type EmailTemplates {
  approvedAt: timestamptz
  """An object relationship"""
  approvedByUser: Users
  approvedByUserId: uuid
  availableVariables(
    """JSON select path"""
    path: String
  ): jsonb!
  category: String!
  createdAt: timestamptz
  """An object relationship"""
  createdByUser: Users!
  createdByUserId: uuid!
  description: String
  """An array relationship"""
  emailDrafts(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): [EmailDrafts!]!
  """An aggregate relationship"""
  emailDraftsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): EmailDraftsAggregate!
  """An array relationship"""
  emailSendLogs(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): [EmailSendLogs!]!
  """An aggregate relationship"""
  emailSendLogsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): EmailSendLogsAggregate!
  htmlContent: String!
  id: uuid!
  isActive: Boolean
  isSystemTemplate: Boolean
  name: String!
  requiresApproval: Boolean
  subjectTemplate: String!
  textContent: String
  updatedAt: timestamptz
  """An array relationship"""
  userFavorites(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): [UserEmailTemplateFavorites!]!
  """An aggregate relationship"""
  userFavoritesAggregate(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): UserEmailTemplateFavoritesAggregate!
}

"""
aggregated selection of "email_templates"
"""
type EmailTemplatesAggregate {
  aggregate: EmailTemplatesAggregateFields
  nodes: [EmailTemplates!]!
}

input EmailTemplatesAggregateBoolExp {
  bool_and: emailTemplatesAggregateBoolExpBool_and
  bool_or: emailTemplatesAggregateBoolExpBool_or
  count: emailTemplatesAggregateBoolExpCount
}

"""
aggregate fields of "email_templates"
"""
type EmailTemplatesAggregateFields {
  count(columns: [EmailTemplatesSelectColumn!], distinct: Boolean): Int!
  max: EmailTemplatesMaxFields
  min: EmailTemplatesMinFields
}

"""
order by aggregate values of table "email_templates"
"""
input EmailTemplatesAggregateOrderBy {
  count: OrderBy
  max: EmailTemplatesMaxOrderBy
  min: EmailTemplatesMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input EmailTemplatesAppendInput {
  availableVariables: jsonb
}

"""
input type for inserting array relation for remote table "email_templates"
"""
input EmailTemplatesArrRelInsertInput {
  data: [EmailTemplatesInsertInput!]!
  """upsert condition"""
  onConflict: EmailTemplatesOnConflict
}

"""
Boolean expression to filter rows from the table "email_templates". All fields are combined with a logical 'AND'.
"""
input EmailTemplatesBoolExp {
  _and: [EmailTemplatesBoolExp!]
  _not: EmailTemplatesBoolExp
  _or: [EmailTemplatesBoolExp!]
  approvedAt: TimestamptzComparisonExp
  approvedByUser: UsersBoolExp
  approvedByUserId: UuidComparisonExp
  availableVariables: JsonbComparisonExp
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdByUser: UsersBoolExp
  createdByUserId: UuidComparisonExp
  description: StringComparisonExp
  emailDrafts: EmailDraftsBoolExp
  emailDraftsAggregate: EmailDraftsAggregateBoolExp
  emailSendLogs: EmailSendLogsBoolExp
  emailSendLogsAggregate: EmailSendLogsAggregateBoolExp
  htmlContent: StringComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  isSystemTemplate: BooleanComparisonExp
  name: StringComparisonExp
  requiresApproval: BooleanComparisonExp
  subjectTemplate: StringComparisonExp
  textContent: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  userFavorites: UserEmailTemplateFavoritesBoolExp
  userFavoritesAggregate: UserEmailTemplateFavoritesAggregateBoolExp
}

"""
unique or primary key constraints on table "email_templates"
"""
enum EmailTemplatesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  email_templates_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input EmailTemplatesDeleteAtPathInput {
  availableVariables: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input EmailTemplatesDeleteElemInput {
  availableVariables: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input EmailTemplatesDeleteKeyInput {
  availableVariables: String
}

"""
input type for inserting data into table "email_templates"
"""
input EmailTemplatesInsertInput {
  approvedAt: timestamptz
  approvedByUser: UsersObjRelInsertInput
  approvedByUserId: uuid
  availableVariables: jsonb
  category: String
  createdAt: timestamptz
  createdByUser: UsersObjRelInsertInput
  createdByUserId: uuid
  description: String
  emailDrafts: EmailDraftsArrRelInsertInput
  emailSendLogs: EmailSendLogsArrRelInsertInput
  htmlContent: String
  id: uuid
  isActive: Boolean
  isSystemTemplate: Boolean
  name: String
  requiresApproval: Boolean
  subjectTemplate: String
  textContent: String
  updatedAt: timestamptz
  userFavorites: UserEmailTemplateFavoritesArrRelInsertInput
}

"""aggregate max on columns"""
type EmailTemplatesMaxFields {
  approvedAt: timestamptz
  approvedByUserId: uuid
  category: String
  createdAt: timestamptz
  createdByUserId: uuid
  description: String
  htmlContent: String
  id: uuid
  name: String
  subjectTemplate: String
  textContent: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "email_templates"
"""
input EmailTemplatesMaxOrderBy {
  approvedAt: OrderBy
  approvedByUserId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdByUserId: OrderBy
  description: OrderBy
  htmlContent: OrderBy
  id: OrderBy
  name: OrderBy
  subjectTemplate: OrderBy
  textContent: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type EmailTemplatesMinFields {
  approvedAt: timestamptz
  approvedByUserId: uuid
  category: String
  createdAt: timestamptz
  createdByUserId: uuid
  description: String
  htmlContent: String
  id: uuid
  name: String
  subjectTemplate: String
  textContent: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "email_templates"
"""
input EmailTemplatesMinOrderBy {
  approvedAt: OrderBy
  approvedByUserId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdByUserId: OrderBy
  description: OrderBy
  htmlContent: OrderBy
  id: OrderBy
  name: OrderBy
  subjectTemplate: OrderBy
  textContent: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "email_templates"
"""
type EmailTemplatesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [EmailTemplates!]!
}

"""
input type for inserting object relation for remote table "email_templates"
"""
input EmailTemplatesObjRelInsertInput {
  data: EmailTemplatesInsertInput!
  """upsert condition"""
  onConflict: EmailTemplatesOnConflict
}

"""
on_conflict condition type for table "email_templates"
"""
input EmailTemplatesOnConflict {
  constraint: EmailTemplatesConstraint!
  updateColumns: [EmailTemplatesUpdateColumn!]! = []
  where: EmailTemplatesBoolExp
}

"""Ordering options when selecting data from "email_templates"."""
input EmailTemplatesOrderBy {
  approvedAt: OrderBy
  approvedByUser: UsersOrderBy
  approvedByUserId: OrderBy
  availableVariables: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdByUser: UsersOrderBy
  createdByUserId: OrderBy
  description: OrderBy
  emailDraftsAggregate: EmailDraftsAggregateOrderBy
  emailSendLogsAggregate: EmailSendLogsAggregateOrderBy
  htmlContent: OrderBy
  id: OrderBy
  isActive: OrderBy
  isSystemTemplate: OrderBy
  name: OrderBy
  requiresApproval: OrderBy
  subjectTemplate: OrderBy
  textContent: OrderBy
  updatedAt: OrderBy
  userFavoritesAggregate: UserEmailTemplateFavoritesAggregateOrderBy
}

"""primary key columns input for table: email_templates"""
input EmailTemplatesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input EmailTemplatesPrependInput {
  availableVariables: jsonb
}

"""
select columns of table "email_templates"
"""
enum EmailTemplatesSelectColumn {
  """column name"""
  approvedAt
  """column name"""
  approvedByUserId
  """column name"""
  availableVariables
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  description
  """column name"""
  htmlContent
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isSystemTemplate
  """column name"""
  name
  """column name"""
  requiresApproval
  """column name"""
  subjectTemplate
  """column name"""
  textContent
  """column name"""
  updatedAt
}

"""
select "emailTemplatesAggregateBoolExpBool_andArgumentsColumns" columns of table "email_templates"
"""
enum EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isSystemTemplate
  """column name"""
  requiresApproval
}

"""
select "emailTemplatesAggregateBoolExpBool_orArgumentsColumns" columns of table "email_templates"
"""
enum EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isSystemTemplate
  """column name"""
  requiresApproval
}

"""
input type for updating data in table "email_templates"
"""
input EmailTemplatesSetInput {
  approvedAt: timestamptz
  approvedByUserId: uuid
  availableVariables: jsonb
  category: String
  createdAt: timestamptz
  createdByUserId: uuid
  description: String
  htmlContent: String
  id: uuid
  isActive: Boolean
  isSystemTemplate: Boolean
  name: String
  requiresApproval: Boolean
  subjectTemplate: String
  textContent: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "email_templates"
"""
input EmailTemplatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EmailTemplatesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EmailTemplatesStreamCursorValueInput {
  approvedAt: timestamptz
  approvedByUserId: uuid
  availableVariables: jsonb
  category: String
  createdAt: timestamptz
  createdByUserId: uuid
  description: String
  htmlContent: String
  id: uuid
  isActive: Boolean
  isSystemTemplate: Boolean
  name: String
  requiresApproval: Boolean
  subjectTemplate: String
  textContent: String
  updatedAt: timestamptz
}

"""
update columns of table "email_templates"
"""
enum EmailTemplatesUpdateColumn {
  """column name"""
  approvedAt
  """column name"""
  approvedByUserId
  """column name"""
  availableVariables
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  description
  """column name"""
  htmlContent
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isSystemTemplate
  """column name"""
  name
  """column name"""
  requiresApproval
  """column name"""
  subjectTemplate
  """column name"""
  textContent
  """column name"""
  updatedAt
}

input EmailTemplatesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: EmailTemplatesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: EmailTemplatesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: EmailTemplatesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: EmailTemplatesDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: EmailTemplatesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: EmailTemplatesSetInput
  """filter the rows which have to be updated"""
  where: EmailTemplatesBoolExp!
}

"""
columns and relationships of "external_systems"
"""
type ExternalSystems {
  """An array relationship"""
  clientExternalSystems(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): [ClientExternalSystems!]!
  """An aggregate relationship"""
  clientExternalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): ClientExternalSystemsAggregate!
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid!
  """Name of the external system"""
  name: String!
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String!
}

"""
aggregated selection of "external_systems"
"""
type ExternalSystemsAggregate {
  aggregate: ExternalSystemsAggregateFields
  nodes: [ExternalSystems!]!
}

"""
aggregate fields of "external_systems"
"""
type ExternalSystemsAggregateFields {
  count(columns: [ExternalSystemsSelectColumn!], distinct: Boolean): Int!
  max: ExternalSystemsMaxFields
  min: ExternalSystemsMinFields
}

"""
Boolean expression to filter rows from the table "external_systems". All fields are combined with a logical 'AND'.
"""
input ExternalSystemsBoolExp {
  _and: [ExternalSystemsBoolExp!]
  _not: ExternalSystemsBoolExp
  _or: [ExternalSystemsBoolExp!]
  clientExternalSystems: ClientExternalSystemsBoolExp
  clientExternalSystemsAggregate: ClientExternalSystemsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  icon: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  url: StringComparisonExp
}

"""
unique or primary key constraints on table "external_systems"
"""
enum ExternalSystemsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  external_systems_pkey
}

"""
input type for inserting data into table "external_systems"
"""
input ExternalSystemsInsertInput {
  clientExternalSystems: ClientExternalSystemsArrRelInsertInput
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""aggregate max on columns"""
type ExternalSystemsMaxFields {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""aggregate min on columns"""
type ExternalSystemsMinFields {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""
response of any mutation on the table "external_systems"
"""
type ExternalSystemsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ExternalSystems!]!
}

"""
input type for inserting object relation for remote table "external_systems"
"""
input ExternalSystemsObjRelInsertInput {
  data: ExternalSystemsInsertInput!
  """upsert condition"""
  onConflict: ExternalSystemsOnConflict
}

"""
on_conflict condition type for table "external_systems"
"""
input ExternalSystemsOnConflict {
  constraint: ExternalSystemsConstraint!
  updateColumns: [ExternalSystemsUpdateColumn!]! = []
  where: ExternalSystemsBoolExp
}

"""Ordering options when selecting data from "external_systems"."""
input ExternalSystemsOrderBy {
  clientExternalSystemsAggregate: ClientExternalSystemsAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  icon: OrderBy
  id: OrderBy
  name: OrderBy
  updatedAt: OrderBy
  url: OrderBy
}

"""primary key columns input for table: external_systems"""
input ExternalSystemsPkColumnsInput {
  """Unique identifier for the external system"""
  id: uuid!
}

"""
select columns of table "external_systems"
"""
enum ExternalSystemsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  icon
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
  """column name"""
  url
}

"""
input type for updating data in table "external_systems"
"""
input ExternalSystemsSetInput {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""
Streaming cursor of the table "external_systems"
"""
input ExternalSystemsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ExternalSystemsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ExternalSystemsStreamCursorValueInput {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""
update columns of table "external_systems"
"""
enum ExternalSystemsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  icon
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
  """column name"""
  url
}

input ExternalSystemsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ExternalSystemsSetInput
  """filter the rows which have to be updated"""
  where: ExternalSystemsBoolExp!
}

"""
columns and relationships of "feature_flags"
"""
type FeatureFlags {
  """JSON array of roles that can access this feature"""
  allowedRoles(
    """JSON select path"""
    path: String
  ): jsonb!
  """Name of the feature controlled by this flag"""
  featureName: String!
  """Unique identifier for the feature flag"""
  id: uuid!
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "feature_flags"
"""
type FeatureFlagsAggregate {
  aggregate: FeatureFlagsAggregateFields
  nodes: [FeatureFlags!]!
}

"""
aggregate fields of "feature_flags"
"""
type FeatureFlagsAggregateFields {
  count(columns: [FeatureFlagsSelectColumn!], distinct: Boolean): Int!
  max: FeatureFlagsMaxFields
  min: FeatureFlagsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input FeatureFlagsAppendInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
}

"""
Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'.
"""
input FeatureFlagsBoolExp {
  _and: [FeatureFlagsBoolExp!]
  _not: FeatureFlagsBoolExp
  _or: [FeatureFlagsBoolExp!]
  allowedRoles: JsonbComparisonExp
  featureName: StringComparisonExp
  id: UuidComparisonExp
  isEnabled: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "feature_flags"
"""
enum FeatureFlagsConstraint {
  """
  unique or primary key constraint on columns "feature_name"
  """
  feature_flags_feature_name_key
  """
  unique or primary key constraint on columns "id"
  """
  feature_flags_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input FeatureFlagsDeleteAtPathInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input FeatureFlagsDeleteElemInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input FeatureFlagsDeleteKeyInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: String
}

"""
input type for inserting data into table "feature_flags"
"""
input FeatureFlagsInsertInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type FeatureFlagsMaxFields {
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type FeatureFlagsMinFields {
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "feature_flags"
"""
type FeatureFlagsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [FeatureFlags!]!
}

"""
on_conflict condition type for table "feature_flags"
"""
input FeatureFlagsOnConflict {
  constraint: FeatureFlagsConstraint!
  updateColumns: [FeatureFlagsUpdateColumn!]! = []
  where: FeatureFlagsBoolExp
}

"""Ordering options when selecting data from "feature_flags"."""
input FeatureFlagsOrderBy {
  allowedRoles: OrderBy
  featureName: OrderBy
  id: OrderBy
  isEnabled: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: feature_flags"""
input FeatureFlagsPkColumnsInput {
  """Unique identifier for the feature flag"""
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input FeatureFlagsPrependInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
}

"""
select columns of table "feature_flags"
"""
enum FeatureFlagsSelectColumn {
  """column name"""
  allowedRoles
  """column name"""
  featureName
  """column name"""
  id
  """column name"""
  isEnabled
  """column name"""
  updatedAt
}

"""
input type for updating data in table "feature_flags"
"""
input FeatureFlagsSetInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "feature_flags"
"""
input FeatureFlagsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: FeatureFlagsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input FeatureFlagsStreamCursorValueInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "feature_flags"
"""
enum FeatureFlagsUpdateColumn {
  """column name"""
  allowedRoles
  """column name"""
  featureName
  """column name"""
  id
  """column name"""
  isEnabled
  """column name"""
  updatedAt
}

input FeatureFlagsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: FeatureFlagsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: FeatureFlagsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: FeatureFlagsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: FeatureFlagsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: FeatureFlagsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: FeatureFlagsSetInput
  """filter the rows which have to be updated"""
  where: FeatureFlagsBoolExp!
}

"""
columns and relationships of "files"
"""
type Files {
  bucket: String!
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: String
  """An object relationship"""
  client: Clients
  """Links document to a specific client"""
  clientId: uuid
  createdAt: timestamptz
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: String
  filename: String!
  id: uuid!
  """Whether document is publicly accessible within permissions"""
  isPublic: Boolean
  """Additional document metadata as JSON"""
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  mimetype: String
  objectKey: String!
  """An object relationship"""
  payroll: Payrolls
  """Links document to a specific payroll"""
  payrollId: uuid
  size: Int
  """User who uploaded the document"""
  uploadedBy: uuid
  """An object relationship"""
  uploadedByUser: Users
  url: String
}

"""
aggregated selection of "files"
"""
type FilesAggregate {
  aggregate: FilesAggregateFields
  nodes: [Files!]!
}

input FilesAggregateBoolExp {
  bool_and: filesAggregateBoolExpBool_and
  bool_or: filesAggregateBoolExpBool_or
  count: filesAggregateBoolExpCount
}

"""
aggregate fields of "files"
"""
type FilesAggregateFields {
  avg: FilesAvgFields
  count(columns: [FilesSelectColumn!], distinct: Boolean): Int!
  max: FilesMaxFields
  min: FilesMinFields
  stddev: FilesStddevFields
  stddevPop: FilesStddevPopFields
  stddevSamp: FilesStddevSampFields
  sum: FilesSumFields
  varPop: FilesVarPopFields
  varSamp: FilesVarSampFields
  variance: FilesVarianceFields
}

"""
order by aggregate values of table "files"
"""
input FilesAggregateOrderBy {
  avg: FilesAvgOrderBy
  count: OrderBy
  max: FilesMaxOrderBy
  min: FilesMinOrderBy
  stddev: FilesStddevOrderBy
  stddevPop: FilesStddevPopOrderBy
  stddevSamp: FilesStddevSampOrderBy
  sum: FilesSumOrderBy
  varPop: FilesVarPopOrderBy
  varSamp: FilesVarSampOrderBy
  variance: FilesVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input FilesAppendInput {
  """Additional document metadata as JSON"""
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "files"
"""
input FilesArrRelInsertInput {
  data: [FilesInsertInput!]!
  """upsert condition"""
  onConflict: FilesOnConflict
}

"""aggregate avg on columns"""
type FilesAvgFields {
  size: Float
}

"""
order by avg() on columns of table "files"
"""
input FilesAvgOrderBy {
  size: OrderBy
}

"""
Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'.
"""
input FilesBoolExp {
  _and: [FilesBoolExp!]
  _not: FilesBoolExp
  _or: [FilesBoolExp!]
  bucket: StringComparisonExp
  category: StringComparisonExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  fileType: StringComparisonExp
  filename: StringComparisonExp
  id: UuidComparisonExp
  isPublic: BooleanComparisonExp
  metadata: JsonbComparisonExp
  mimetype: StringComparisonExp
  objectKey: StringComparisonExp
  payroll: PayrollsBoolExp
  payrollId: UuidComparisonExp
  size: IntComparisonExp
  uploadedBy: UuidComparisonExp
  uploadedByUser: UsersBoolExp
  url: StringComparisonExp
}

"""
unique or primary key constraints on table "files"
"""
enum FilesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input FilesDeleteAtPathInput {
  """Additional document metadata as JSON"""
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input FilesDeleteElemInput {
  """Additional document metadata as JSON"""
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input FilesDeleteKeyInput {
  """Additional document metadata as JSON"""
  metadata: String
}

"""
input type for incrementing numeric columns in table "files"
"""
input FilesIncInput {
  size: Int
}

"""
input type for inserting data into table "files"
"""
input FilesInsertInput {
  bucket: String
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: String
  client: ClientsObjRelInsertInput
  """Links document to a specific client"""
  clientId: uuid
  createdAt: timestamptz
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: String
  filename: String
  id: uuid
  """Whether document is publicly accessible within permissions"""
  isPublic: Boolean
  """Additional document metadata as JSON"""
  metadata: jsonb
  mimetype: String
  objectKey: String
  payroll: PayrollsObjRelInsertInput
  """Links document to a specific payroll"""
  payrollId: uuid
  size: Int
  """User who uploaded the document"""
  uploadedBy: uuid
  uploadedByUser: UsersObjRelInsertInput
  url: String
}

"""aggregate max on columns"""
type FilesMaxFields {
  bucket: String
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: String
  """Links document to a specific client"""
  clientId: uuid
  createdAt: timestamptz
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: String
  filename: String
  id: uuid
  mimetype: String
  objectKey: String
  """Links document to a specific payroll"""
  payrollId: uuid
  size: Int
  """User who uploaded the document"""
  uploadedBy: uuid
  url: String
}

"""
order by max() on columns of table "files"
"""
input FilesMaxOrderBy {
  bucket: OrderBy
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: OrderBy
  """Links document to a specific client"""
  clientId: OrderBy
  createdAt: OrderBy
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: OrderBy
  filename: OrderBy
  id: OrderBy
  mimetype: OrderBy
  objectKey: OrderBy
  """Links document to a specific payroll"""
  payrollId: OrderBy
  size: OrderBy
  """User who uploaded the document"""
  uploadedBy: OrderBy
  url: OrderBy
}

"""aggregate min on columns"""
type FilesMinFields {
  bucket: String
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: String
  """Links document to a specific client"""
  clientId: uuid
  createdAt: timestamptz
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: String
  filename: String
  id: uuid
  mimetype: String
  objectKey: String
  """Links document to a specific payroll"""
  payrollId: uuid
  size: Int
  """User who uploaded the document"""
  uploadedBy: uuid
  url: String
}

"""
order by min() on columns of table "files"
"""
input FilesMinOrderBy {
  bucket: OrderBy
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: OrderBy
  """Links document to a specific client"""
  clientId: OrderBy
  createdAt: OrderBy
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: OrderBy
  filename: OrderBy
  id: OrderBy
  mimetype: OrderBy
  objectKey: OrderBy
  """Links document to a specific payroll"""
  payrollId: OrderBy
  size: OrderBy
  """User who uploaded the document"""
  uploadedBy: OrderBy
  url: OrderBy
}

"""
response of any mutation on the table "files"
"""
type FilesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Files!]!
}

"""
on_conflict condition type for table "files"
"""
input FilesOnConflict {
  constraint: FilesConstraint!
  updateColumns: [FilesUpdateColumn!]! = []
  where: FilesBoolExp
}

"""Ordering options when selecting data from "files"."""
input FilesOrderBy {
  bucket: OrderBy
  category: OrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  fileType: OrderBy
  filename: OrderBy
  id: OrderBy
  isPublic: OrderBy
  metadata: OrderBy
  mimetype: OrderBy
  objectKey: OrderBy
  payroll: PayrollsOrderBy
  payrollId: OrderBy
  size: OrderBy
  uploadedBy: OrderBy
  uploadedByUser: UsersOrderBy
  url: OrderBy
}

"""primary key columns input for table: files"""
input FilesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input FilesPrependInput {
  """Additional document metadata as JSON"""
  metadata: jsonb
}

"""
select columns of table "files"
"""
enum FilesSelectColumn {
  """column name"""
  bucket
  """column name"""
  category
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  fileType
  """column name"""
  filename
  """column name"""
  id
  """column name"""
  isPublic
  """column name"""
  metadata
  """column name"""
  mimetype
  """column name"""
  objectKey
  """column name"""
  payrollId
  """column name"""
  size
  """column name"""
  uploadedBy
  """column name"""
  url
}

"""
select "filesAggregateBoolExpBool_andArgumentsColumns" columns of table "files"
"""
enum FilesSelectColumnFilesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isPublic
}

"""
select "filesAggregateBoolExpBool_orArgumentsColumns" columns of table "files"
"""
enum FilesSelectColumnFilesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isPublic
}

"""
input type for updating data in table "files"
"""
input FilesSetInput {
  bucket: String
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: String
  """Links document to a specific client"""
  clientId: uuid
  createdAt: timestamptz
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: String
  filename: String
  id: uuid
  """Whether document is publicly accessible within permissions"""
  isPublic: Boolean
  """Additional document metadata as JSON"""
  metadata: jsonb
  mimetype: String
  objectKey: String
  """Links document to a specific payroll"""
  payrollId: uuid
  size: Int
  """User who uploaded the document"""
  uploadedBy: uuid
  url: String
}

"""aggregate stddev on columns"""
type FilesStddevFields {
  size: Float
}

"""
order by stddev() on columns of table "files"
"""
input FilesStddevOrderBy {
  size: OrderBy
}

"""aggregate stddevPop on columns"""
type FilesStddevPopFields {
  size: Float
}

"""
order by stddevPop() on columns of table "files"
"""
input FilesStddevPopOrderBy {
  size: OrderBy
}

"""aggregate stddevSamp on columns"""
type FilesStddevSampFields {
  size: Float
}

"""
order by stddevSamp() on columns of table "files"
"""
input FilesStddevSampOrderBy {
  size: OrderBy
}

"""
Streaming cursor of the table "files"
"""
input FilesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: FilesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input FilesStreamCursorValueInput {
  bucket: String
  """
  Document category: contract, invoice, report, timesheet, correspondence, other
  """
  category: String
  """Links document to a specific client"""
  clientId: uuid
  createdAt: timestamptz
  """Type of file: document (MinIO) or avatar (Clerk)"""
  fileType: String
  filename: String
  id: uuid
  """Whether document is publicly accessible within permissions"""
  isPublic: Boolean
  """Additional document metadata as JSON"""
  metadata: jsonb
  mimetype: String
  objectKey: String
  """Links document to a specific payroll"""
  payrollId: uuid
  size: Int
  """User who uploaded the document"""
  uploadedBy: uuid
  url: String
}

"""aggregate sum on columns"""
type FilesSumFields {
  size: Int
}

"""
order by sum() on columns of table "files"
"""
input FilesSumOrderBy {
  size: OrderBy
}

"""
update columns of table "files"
"""
enum FilesUpdateColumn {
  """column name"""
  bucket
  """column name"""
  category
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  fileType
  """column name"""
  filename
  """column name"""
  id
  """column name"""
  isPublic
  """column name"""
  metadata
  """column name"""
  mimetype
  """column name"""
  objectKey
  """column name"""
  payrollId
  """column name"""
  size
  """column name"""
  uploadedBy
  """column name"""
  url
}

input FilesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: FilesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: FilesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: FilesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: FilesDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: FilesIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: FilesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: FilesSetInput
  """filter the rows which have to be updated"""
  where: FilesBoolExp!
}

"""aggregate varPop on columns"""
type FilesVarPopFields {
  size: Float
}

"""
order by varPop() on columns of table "files"
"""
input FilesVarPopOrderBy {
  size: OrderBy
}

"""aggregate varSamp on columns"""
type FilesVarSampFields {
  size: Float
}

"""
order by varSamp() on columns of table "files"
"""
input FilesVarSampOrderBy {
  size: OrderBy
}

"""aggregate variance on columns"""
type FilesVarianceFields {
  size: Float
}

"""
order by variance() on columns of table "files"
"""
input FilesVarianceOrderBy {
  size: OrderBy
}

"""
columns and relationships of "holidays"
"""
type Holidays {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar!
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date!
  """Unique identifier for the holiday"""
  id: uuid!
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String!
  """Name of the holiday in English"""
  name: String!
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]!
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "holidays"
"""
type HolidaysAggregate {
  aggregate: HolidaysAggregateFields
  nodes: [Holidays!]!
}

"""
aggregate fields of "holidays"
"""
type HolidaysAggregateFields {
  avg: HolidaysAvgFields
  count(columns: [HolidaysSelectColumn!], distinct: Boolean): Int!
  max: HolidaysMaxFields
  min: HolidaysMinFields
  stddev: HolidaysStddevFields
  stddevPop: HolidaysStddevPopFields
  stddevSamp: HolidaysStddevSampFields
  sum: HolidaysSumFields
  varPop: HolidaysVarPopFields
  varSamp: HolidaysVarSampFields
  variance: HolidaysVarianceFields
}

"""aggregate avg on columns"""
type HolidaysAvgFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""
Boolean expression to filter rows from the table "holidays". All fields are combined with a logical 'AND'.
"""
input HolidaysBoolExp {
  _and: [HolidaysBoolExp!]
  _not: HolidaysBoolExp
  _or: [HolidaysBoolExp!]
  countryCode: BpcharComparisonExp
  createdAt: TimestamptzComparisonExp
  date: DateComparisonExp
  id: UuidComparisonExp
  isFixed: BooleanComparisonExp
  isGlobal: BooleanComparisonExp
  launchYear: IntComparisonExp
  localName: StringComparisonExp
  name: StringComparisonExp
  region: StringArrayComparisonExp
  types: StringArrayComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "holidays"
"""
enum HolidaysConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  holidays_pkey
}

"""
input type for incrementing numeric columns in table "holidays"
"""
input HolidaysIncInput {
  """First year when the holiday was observed"""
  launchYear: Int
}

"""
input type for inserting data into table "holidays"
"""
input HolidaysInsertInput {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type HolidaysMaxFields {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type HolidaysMinFields {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "holidays"
"""
type HolidaysMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Holidays!]!
}

"""
on_conflict condition type for table "holidays"
"""
input HolidaysOnConflict {
  constraint: HolidaysConstraint!
  updateColumns: [HolidaysUpdateColumn!]! = []
  where: HolidaysBoolExp
}

"""Ordering options when selecting data from "holidays"."""
input HolidaysOrderBy {
  countryCode: OrderBy
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
  isFixed: OrderBy
  isGlobal: OrderBy
  launchYear: OrderBy
  localName: OrderBy
  name: OrderBy
  region: OrderBy
  types: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: holidays"""
input HolidaysPkColumnsInput {
  """Unique identifier for the holiday"""
  id: uuid!
}

"""
select columns of table "holidays"
"""
enum HolidaysSelectColumn {
  """column name"""
  countryCode
  """column name"""
  createdAt
  """column name"""
  date
  """column name"""
  id
  """column name"""
  isFixed
  """column name"""
  isGlobal
  """column name"""
  launchYear
  """column name"""
  localName
  """column name"""
  name
  """column name"""
  region
  """column name"""
  types
  """column name"""
  updatedAt
}

"""
input type for updating data in table "holidays"
"""
input HolidaysSetInput {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type HolidaysStddevFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate stddevPop on columns"""
type HolidaysStddevPopFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate stddevSamp on columns"""
type HolidaysStddevSampFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""
Streaming cursor of the table "holidays"
"""
input HolidaysStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: HolidaysStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input HolidaysStreamCursorValueInput {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type HolidaysSumFields {
  """First year when the holiday was observed"""
  launchYear: Int
}

"""
update columns of table "holidays"
"""
enum HolidaysUpdateColumn {
  """column name"""
  countryCode
  """column name"""
  createdAt
  """column name"""
  date
  """column name"""
  id
  """column name"""
  isFixed
  """column name"""
  isGlobal
  """column name"""
  launchYear
  """column name"""
  localName
  """column name"""
  name
  """column name"""
  region
  """column name"""
  types
  """column name"""
  updatedAt
}

input HolidaysUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: HolidaysIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: HolidaysSetInput
  """filter the rows which have to be updated"""
  where: HolidaysBoolExp!
}

"""aggregate varPop on columns"""
type HolidaysVarPopFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate varSamp on columns"""
type HolidaysVarSampFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate variance on columns"""
type HolidaysVarianceFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input InetComparisonExp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _isNull: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input IntervalComparisonExp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _isNull: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

"""
Boolean expression to compare columns of type "invitation_status_enum". All fields are combined with logical 'AND'.
"""
input InvitationStatusEnumComparisonExp {
  _eq: invitation_status_enum
  _gt: invitation_status_enum
  _gte: invitation_status_enum
  _in: [invitation_status_enum!]
  _isNull: Boolean
  _lt: invitation_status_enum
  _lte: invitation_status_enum
  _neq: invitation_status_enum
  _nin: [invitation_status_enum!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp
  """is the column contained in the given json value"""
  _containedIn: jsonb
  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  """does the string exist as a top-level key in the column"""
  _hasKey: String
  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]
  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "latest_payroll_version_results"
"""
type LatestPayrollVersionResults {
  active: Boolean!
  goLiveDate: date
  id: uuid!
  name: String!
  payrollId: uuid!
  queriedAt: timestamptz
  versionNumber: Int!
}

type LatestPayrollVersionResultsAggregate {
  aggregate: LatestPayrollVersionResultsAggregateFields
  nodes: [LatestPayrollVersionResults!]!
}

"""
aggregate fields of "latest_payroll_version_results"
"""
type LatestPayrollVersionResultsAggregateFields {
  avg: LatestPayrollVersionResultsAvgFields
  count(columns: [LatestPayrollVersionResultsSelectColumn!], distinct: Boolean): Int!
  max: LatestPayrollVersionResultsMaxFields
  min: LatestPayrollVersionResultsMinFields
  stddev: LatestPayrollVersionResultsStddevFields
  stddevPop: LatestPayrollVersionResultsStddevPopFields
  stddevSamp: LatestPayrollVersionResultsStddevSampFields
  sum: LatestPayrollVersionResultsSumFields
  varPop: LatestPayrollVersionResultsVarPopFields
  varSamp: LatestPayrollVersionResultsVarSampFields
  variance: LatestPayrollVersionResultsVarianceFields
}

"""aggregate avg on columns"""
type LatestPayrollVersionResultsAvgFields {
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "latest_payroll_version_results". All fields are combined with a logical 'AND'.
"""
input LatestPayrollVersionResultsBoolExp {
  _and: [LatestPayrollVersionResultsBoolExp!]
  _not: LatestPayrollVersionResultsBoolExp
  _or: [LatestPayrollVersionResultsBoolExp!]
  active: BooleanComparisonExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  payrollId: UuidComparisonExp
  queriedAt: TimestamptzComparisonExp
  versionNumber: IntComparisonExp
}

"""
unique or primary key constraints on table "latest_payroll_version_results"
"""
enum LatestPayrollVersionResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  latest_payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "latest_payroll_version_results"
"""
input LatestPayrollVersionResultsIncInput {
  versionNumber: Int
}

"""
input type for inserting data into table "latest_payroll_version_results"
"""
input LatestPayrollVersionResultsInsertInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate max on columns"""
type LatestPayrollVersionResultsMaxFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate min on columns"""
type LatestPayrollVersionResultsMinFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""
response of any mutation on the table "latest_payroll_version_results"
"""
type LatestPayrollVersionResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [LatestPayrollVersionResults!]!
}

"""
on_conflict condition type for table "latest_payroll_version_results"
"""
input LatestPayrollVersionResultsOnConflict {
  constraint: LatestPayrollVersionResultsConstraint!
  updateColumns: [LatestPayrollVersionResultsUpdateColumn!]! = []
  where: LatestPayrollVersionResultsBoolExp
}

"""
Ordering options when selecting data from "latest_payroll_version_results".
"""
input LatestPayrollVersionResultsOrderBy {
  active: OrderBy
  goLiveDate: OrderBy
  id: OrderBy
  name: OrderBy
  payrollId: OrderBy
  queriedAt: OrderBy
  versionNumber: OrderBy
}

"""primary key columns input for table: latest_payroll_version_results"""
input LatestPayrollVersionResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "latest_payroll_version_results"
"""
enum LatestPayrollVersionResultsSelectColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  versionNumber
}

"""
input type for updating data in table "latest_payroll_version_results"
"""
input LatestPayrollVersionResultsSetInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate stddev on columns"""
type LatestPayrollVersionResultsStddevFields {
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type LatestPayrollVersionResultsStddevPopFields {
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type LatestPayrollVersionResultsStddevSampFields {
  versionNumber: Float
}

"""
Streaming cursor of the table "latest_payroll_version_results"
"""
input LatestPayrollVersionResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LatestPayrollVersionResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LatestPayrollVersionResultsStreamCursorValueInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate sum on columns"""
type LatestPayrollVersionResultsSumFields {
  versionNumber: Int
}

"""
update columns of table "latest_payroll_version_results"
"""
enum LatestPayrollVersionResultsUpdateColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  versionNumber
}

input LatestPayrollVersionResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: LatestPayrollVersionResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: LatestPayrollVersionResultsSetInput
  """filter the rows which have to be updated"""
  where: LatestPayrollVersionResultsBoolExp!
}

"""aggregate varPop on columns"""
type LatestPayrollVersionResultsVarPopFields {
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type LatestPayrollVersionResultsVarSampFields {
  versionNumber: Float
}

"""aggregate variance on columns"""
type LatestPayrollVersionResultsVarianceFields {
  versionNumber: Float
}

"""
columns and relationships of "leave"
"""
type Leave {
  """Timestamp when the leave request was created"""
  createdAt: timestamptz
  """An object relationship"""
  employee: Users!
  """Last day of the leave period"""
  endDate: date!
  """Unique identifier for the leave record"""
  id: uuid!
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String!
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date!
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Timestamp when the leave request was last updated"""
  updatedAt: timestamptz
  """Reference to the user taking leave"""
  userId: uuid!
}

"""
aggregated selection of "leave"
"""
type LeaveAggregate {
  aggregate: LeaveAggregateFields
  nodes: [Leave!]!
}

input LeaveAggregateBoolExp {
  count: leaveAggregateBoolExpCount
}

"""
aggregate fields of "leave"
"""
type LeaveAggregateFields {
  count(columns: [LeaveSelectColumn!], distinct: Boolean): Int!
  max: LeaveMaxFields
  min: LeaveMinFields
}

"""
order by aggregate values of table "leave"
"""
input LeaveAggregateOrderBy {
  count: OrderBy
  max: LeaveMaxOrderBy
  min: LeaveMinOrderBy
}

"""
input type for inserting array relation for remote table "leave"
"""
input LeaveArrRelInsertInput {
  data: [LeaveInsertInput!]!
  """upsert condition"""
  onConflict: LeaveOnConflict
}

"""
Boolean expression to filter rows from the table "leave". All fields are combined with a logical 'AND'.
"""
input LeaveBoolExp {
  _and: [LeaveBoolExp!]
  _not: LeaveBoolExp
  _or: [LeaveBoolExp!]
  createdAt: TimestamptzComparisonExp
  employee: UsersBoolExp
  endDate: DateComparisonExp
  id: UuidComparisonExp
  leaveType: StringComparisonExp
  reason: StringComparisonExp
  startDate: DateComparisonExp
  status: LeaveStatusEnumComparisonExp
  updatedAt: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "leave"
"""
enum LeaveConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_pkey
}

"""
input type for inserting data into table "leave"
"""
input LeaveInsertInput {
  """Timestamp when the leave request was created"""
  createdAt: timestamptz
  employee: UsersObjRelInsertInput
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Timestamp when the leave request was last updated"""
  updatedAt: timestamptz
  """Reference to the user taking leave"""
  userId: uuid
}

"""aggregate max on columns"""
type LeaveMaxFields {
  """Timestamp when the leave request was created"""
  createdAt: timestamptz
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Timestamp when the leave request was last updated"""
  updatedAt: timestamptz
  """Reference to the user taking leave"""
  userId: uuid
}

"""
order by max() on columns of table "leave"
"""
input LeaveMaxOrderBy {
  """Timestamp when the leave request was created"""
  createdAt: OrderBy
  """Last day of the leave period"""
  endDate: OrderBy
  """Unique identifier for the leave record"""
  id: OrderBy
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: OrderBy
  """Reason provided for the leave request"""
  reason: OrderBy
  """First day of the leave period"""
  startDate: OrderBy
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: OrderBy
  """Timestamp when the leave request was last updated"""
  updatedAt: OrderBy
  """Reference to the user taking leave"""
  userId: OrderBy
}

"""aggregate min on columns"""
type LeaveMinFields {
  """Timestamp when the leave request was created"""
  createdAt: timestamptz
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Timestamp when the leave request was last updated"""
  updatedAt: timestamptz
  """Reference to the user taking leave"""
  userId: uuid
}

"""
order by min() on columns of table "leave"
"""
input LeaveMinOrderBy {
  """Timestamp when the leave request was created"""
  createdAt: OrderBy
  """Last day of the leave period"""
  endDate: OrderBy
  """Unique identifier for the leave record"""
  id: OrderBy
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: OrderBy
  """Reason provided for the leave request"""
  reason: OrderBy
  """First day of the leave period"""
  startDate: OrderBy
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: OrderBy
  """Timestamp when the leave request was last updated"""
  updatedAt: OrderBy
  """Reference to the user taking leave"""
  userId: OrderBy
}

"""
response of any mutation on the table "leave"
"""
type LeaveMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Leave!]!
}

"""
on_conflict condition type for table "leave"
"""
input LeaveOnConflict {
  constraint: LeaveConstraint!
  updateColumns: [LeaveUpdateColumn!]! = []
  where: LeaveBoolExp
}

"""Ordering options when selecting data from "leave"."""
input LeaveOrderBy {
  createdAt: OrderBy
  employee: UsersOrderBy
  endDate: OrderBy
  id: OrderBy
  leaveType: OrderBy
  reason: OrderBy
  startDate: OrderBy
  status: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: leave"""
input LeavePkColumnsInput {
  """Unique identifier for the leave record"""
  id: uuid!
}

"""
select columns of table "leave"
"""
enum LeaveSelectColumn {
  """column name"""
  createdAt
  """column name"""
  endDate
  """column name"""
  id
  """column name"""
  leaveType
  """column name"""
  reason
  """column name"""
  startDate
  """column name"""
  status
  """column name"""
  updatedAt
  """column name"""
  userId
}

"""
input type for updating data in table "leave"
"""
input LeaveSetInput {
  """Timestamp when the leave request was created"""
  createdAt: timestamptz
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Timestamp when the leave request was last updated"""
  updatedAt: timestamptz
  """Reference to the user taking leave"""
  userId: uuid
}

"""
Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'.
"""
input LeaveStatusEnumComparisonExp {
  _eq: leave_status_enum
  _gt: leave_status_enum
  _gte: leave_status_enum
  _in: [leave_status_enum!]
  _isNull: Boolean
  _lt: leave_status_enum
  _lte: leave_status_enum
  _neq: leave_status_enum
  _nin: [leave_status_enum!]
}

"""
Streaming cursor of the table "leave"
"""
input LeaveStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: LeaveStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input LeaveStreamCursorValueInput {
  """Timestamp when the leave request was created"""
  createdAt: timestamptz
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Timestamp when the leave request was last updated"""
  updatedAt: timestamptz
  """Reference to the user taking leave"""
  userId: uuid
}

"""
update columns of table "leave"
"""
enum LeaveUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  endDate
  """column name"""
  id
  """column name"""
  leaveType
  """column name"""
  reason
  """column name"""
  startDate
  """column name"""
  status
  """column name"""
  updatedAt
  """column name"""
  userId
}

input LeaveUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: LeaveSetInput
  """filter the rows which have to be updated"""
  where: LeaveBoolExp!
}

"""
Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'.
"""
input NameComparisonExp {
  _eq: name
  _gt: name
  _gte: name
  _in: [name!]
  _isNull: Boolean
  _lt: name
  _lte: name
  _neq: name
  _nin: [name!]
}

"""
columns and relationships of "notes"
"""
type Notes {
  """An object relationship"""
  author: Users
  """Content of the note"""
  content: String!
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid!
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String!
  """Unique identifier for the note"""
  id: uuid!
  """Whether the note is flagged as important"""
  isImportant: Boolean
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
aggregated selection of "notes"
"""
type NotesAggregate {
  aggregate: NotesAggregateFields
  nodes: [Notes!]!
}

input NotesAggregateBoolExp {
  bool_and: notesAggregateBoolExpBool_and
  bool_or: notesAggregateBoolExpBool_or
  count: notesAggregateBoolExpCount
}

"""
aggregate fields of "notes"
"""
type NotesAggregateFields {
  count(columns: [NotesSelectColumn!], distinct: Boolean): Int!
  max: NotesMaxFields
  min: NotesMinFields
}

"""
order by aggregate values of table "notes"
"""
input NotesAggregateOrderBy {
  count: OrderBy
  max: NotesMaxOrderBy
  min: NotesMinOrderBy
}

"""
input type for inserting array relation for remote table "notes"
"""
input NotesArrRelInsertInput {
  data: [NotesInsertInput!]!
  """upsert condition"""
  onConflict: NotesOnConflict
}

"""
Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'.
"""
input NotesBoolExp {
  _and: [NotesBoolExp!]
  _not: NotesBoolExp
  _or: [NotesBoolExp!]
  author: UsersBoolExp
  content: StringComparisonExp
  createdAt: TimestampComparisonExp
  entityId: UuidComparisonExp
  entityType: StringComparisonExp
  id: UuidComparisonExp
  isImportant: BooleanComparisonExp
  updatedAt: TimestampComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "notes"
"""
enum NotesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  notes_pkey
}

"""
input type for inserting data into table "notes"
"""
input NotesInsertInput {
  author: UsersObjRelInsertInput
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Whether the note is flagged as important"""
  isImportant: Boolean
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""aggregate max on columns"""
type NotesMaxFields {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
order by max() on columns of table "notes"
"""
input NotesMaxOrderBy {
  """Content of the note"""
  content: OrderBy
  """Timestamp when the note was created"""
  createdAt: OrderBy
  """Identifier of the entity this note is attached to"""
  entityId: OrderBy
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: OrderBy
  """Unique identifier for the note"""
  id: OrderBy
  """Timestamp when the note was last updated"""
  updatedAt: OrderBy
  """User who created the note"""
  userId: OrderBy
}

"""aggregate min on columns"""
type NotesMinFields {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
order by min() on columns of table "notes"
"""
input NotesMinOrderBy {
  """Content of the note"""
  content: OrderBy
  """Timestamp when the note was created"""
  createdAt: OrderBy
  """Identifier of the entity this note is attached to"""
  entityId: OrderBy
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: OrderBy
  """Unique identifier for the note"""
  id: OrderBy
  """Timestamp when the note was last updated"""
  updatedAt: OrderBy
  """User who created the note"""
  userId: OrderBy
}

"""
response of any mutation on the table "notes"
"""
type NotesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Notes!]!
}

"""
on_conflict condition type for table "notes"
"""
input NotesOnConflict {
  constraint: NotesConstraint!
  updateColumns: [NotesUpdateColumn!]! = []
  where: NotesBoolExp
}

"""Ordering options when selecting data from "notes"."""
input NotesOrderBy {
  author: UsersOrderBy
  content: OrderBy
  createdAt: OrderBy
  entityId: OrderBy
  entityType: OrderBy
  id: OrderBy
  isImportant: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: notes"""
input NotesPkColumnsInput {
  """Unique identifier for the note"""
  id: uuid!
}

"""
select columns of table "notes"
"""
enum NotesSelectColumn {
  """column name"""
  content
  """column name"""
  createdAt
  """column name"""
  entityId
  """column name"""
  entityType
  """column name"""
  id
  """column name"""
  isImportant
  """column name"""
  updatedAt
  """column name"""
  userId
}

"""
select "notesAggregateBoolExpBool_andArgumentsColumns" columns of table "notes"
"""
enum NotesSelectColumnNotesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isImportant
}

"""
select "notesAggregateBoolExpBool_orArgumentsColumns" columns of table "notes"
"""
enum NotesSelectColumnNotesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isImportant
}

"""
input type for updating data in table "notes"
"""
input NotesSetInput {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Whether the note is flagged as important"""
  isImportant: Boolean
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
Streaming cursor of the table "notes"
"""
input NotesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: NotesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input NotesStreamCursorValueInput {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Whether the note is flagged as important"""
  isImportant: Boolean
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
update columns of table "notes"
"""
enum NotesUpdateColumn {
  """column name"""
  content
  """column name"""
  createdAt
  """column name"""
  entityId
  """column name"""
  entityType
  """column name"""
  id
  """column name"""
  isImportant
  """column name"""
  updatedAt
  """column name"""
  userId
}

input NotesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: NotesSetInput
  """filter the rows which have to be updated"""
  where: NotesBoolExp!
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC
  """in ascending order, nulls first"""
  ASC_NULLS_FIRST
  """in ascending order, nulls last"""
  ASC_NULLS_LAST
  """in descending order, nulls first"""
  DESC
  """in descending order, nulls first"""
  DESC_NULLS_FIRST
  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
columns and relationships of "payroll_activation_results"
"""
type PayrollActivationResults {
  actionTaken: String!
  executedAt: timestamptz
  id: uuid!
  payrollId: uuid!
  versionNumber: Int!
}

"""
aggregated selection of "payroll_activation_results"
"""
type PayrollActivationResultsAggregate {
  aggregate: PayrollActivationResultsAggregateFields
  nodes: [PayrollActivationResults!]!
}

"""
aggregate fields of "payroll_activation_results"
"""
type PayrollActivationResultsAggregateFields {
  avg: PayrollActivationResultsAvgFields
  count(columns: [PayrollActivationResultsSelectColumn!], distinct: Boolean): Int!
  max: PayrollActivationResultsMaxFields
  min: PayrollActivationResultsMinFields
  stddev: PayrollActivationResultsStddevFields
  stddevPop: PayrollActivationResultsStddevPopFields
  stddevSamp: PayrollActivationResultsStddevSampFields
  sum: PayrollActivationResultsSumFields
  varPop: PayrollActivationResultsVarPopFields
  varSamp: PayrollActivationResultsVarSampFields
  variance: PayrollActivationResultsVarianceFields
}

"""aggregate avg on columns"""
type PayrollActivationResultsAvgFields {
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "payroll_activation_results". All fields are combined with a logical 'AND'.
"""
input PayrollActivationResultsBoolExp {
  _and: [PayrollActivationResultsBoolExp!]
  _not: PayrollActivationResultsBoolExp
  _or: [PayrollActivationResultsBoolExp!]
  actionTaken: StringComparisonExp
  executedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  payrollId: UuidComparisonExp
  versionNumber: IntComparisonExp
}

"""
unique or primary key constraints on table "payroll_activation_results"
"""
enum PayrollActivationResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_activation_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_activation_results"
"""
input PayrollActivationResultsIncInput {
  versionNumber: Int
}

"""
input type for inserting data into table "payroll_activation_results"
"""
input PayrollActivationResultsInsertInput {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate max on columns"""
type PayrollActivationResultsMaxFields {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate min on columns"""
type PayrollActivationResultsMinFields {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""
response of any mutation on the table "payroll_activation_results"
"""
type PayrollActivationResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollActivationResults!]!
}

"""
on_conflict condition type for table "payroll_activation_results"
"""
input PayrollActivationResultsOnConflict {
  constraint: PayrollActivationResultsConstraint!
  updateColumns: [PayrollActivationResultsUpdateColumn!]! = []
  where: PayrollActivationResultsBoolExp
}

"""
Ordering options when selecting data from "payroll_activation_results".
"""
input PayrollActivationResultsOrderBy {
  actionTaken: OrderBy
  executedAt: OrderBy
  id: OrderBy
  payrollId: OrderBy
  versionNumber: OrderBy
}

"""primary key columns input for table: payroll_activation_results"""
input PayrollActivationResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_activation_results"
"""
enum PayrollActivationResultsSelectColumn {
  """column name"""
  actionTaken
  """column name"""
  executedAt
  """column name"""
  id
  """column name"""
  payrollId
  """column name"""
  versionNumber
}

"""
input type for updating data in table "payroll_activation_results"
"""
input PayrollActivationResultsSetInput {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate stddev on columns"""
type PayrollActivationResultsStddevFields {
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type PayrollActivationResultsStddevPopFields {
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type PayrollActivationResultsStddevSampFields {
  versionNumber: Float
}

"""
Streaming cursor of the table "payroll_activation_results"
"""
input PayrollActivationResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollActivationResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollActivationResultsStreamCursorValueInput {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate sum on columns"""
type PayrollActivationResultsSumFields {
  versionNumber: Int
}

"""
update columns of table "payroll_activation_results"
"""
enum PayrollActivationResultsUpdateColumn {
  """column name"""
  actionTaken
  """column name"""
  executedAt
  """column name"""
  id
  """column name"""
  payrollId
  """column name"""
  versionNumber
}

input PayrollActivationResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PayrollActivationResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollActivationResultsSetInput
  """filter the rows which have to be updated"""
  where: PayrollActivationResultsBoolExp!
}

"""aggregate varPop on columns"""
type PayrollActivationResultsVarPopFields {
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type PayrollActivationResultsVarSampFields {
  versionNumber: Float
}

"""aggregate variance on columns"""
type PayrollActivationResultsVarianceFields {
  versionNumber: Float
}

"""
columns and relationships of "payroll_assignment_audit"
"""
type PayrollAssignmentAudit {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  """An object relationship"""
  changedByUser: Users
  createdAt: timestamptz
  """An object relationship"""
  fromConsultant: Users
  fromConsultantId: uuid
  id: uuid!
  """An object relationship"""
  payrollAssignment: PayrollAssignments
  """An object relationship"""
  payrollDate: PayrollDates!
  payrollDateId: uuid!
  """An object relationship"""
  toConsultant: Users!
  toConsultantId: uuid!
}

"""
aggregated selection of "payroll_assignment_audit"
"""
type PayrollAssignmentAuditAggregate {
  aggregate: PayrollAssignmentAuditAggregateFields
  nodes: [PayrollAssignmentAudit!]!
}

input PayrollAssignmentAuditAggregateBoolExp {
  count: payrollAssignmentAuditAggregateBoolExpCount
}

"""
aggregate fields of "payroll_assignment_audit"
"""
type PayrollAssignmentAuditAggregateFields {
  count(columns: [PayrollAssignmentAuditSelectColumn!], distinct: Boolean): Int!
  max: PayrollAssignmentAuditMaxFields
  min: PayrollAssignmentAuditMinFields
}

"""
order by aggregate values of table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditAggregateOrderBy {
  count: OrderBy
  max: PayrollAssignmentAuditMaxOrderBy
  min: PayrollAssignmentAuditMinOrderBy
}

"""
input type for inserting array relation for remote table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditArrRelInsertInput {
  data: [PayrollAssignmentAuditInsertInput!]!
  """upsert condition"""
  onConflict: PayrollAssignmentAuditOnConflict
}

"""
Boolean expression to filter rows from the table "payroll_assignment_audit". All fields are combined with a logical 'AND'.
"""
input PayrollAssignmentAuditBoolExp {
  _and: [PayrollAssignmentAuditBoolExp!]
  _not: PayrollAssignmentAuditBoolExp
  _or: [PayrollAssignmentAuditBoolExp!]
  assignmentId: UuidComparisonExp
  changeReason: StringComparisonExp
  changedBy: UuidComparisonExp
  changedByUser: UsersBoolExp
  createdAt: TimestamptzComparisonExp
  fromConsultant: UsersBoolExp
  fromConsultantId: UuidComparisonExp
  id: UuidComparisonExp
  payrollAssignment: PayrollAssignmentsBoolExp
  payrollDate: PayrollDatesBoolExp
  payrollDateId: UuidComparisonExp
  toConsultant: UsersBoolExp
  toConsultantId: UuidComparisonExp
}

"""
unique or primary key constraints on table "payroll_assignment_audit"
"""
enum PayrollAssignmentAuditConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_assignment_audit_pkey
}

"""
input type for inserting data into table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditInsertInput {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  changedByUser: UsersObjRelInsertInput
  createdAt: timestamptz
  fromConsultant: UsersObjRelInsertInput
  fromConsultantId: uuid
  id: uuid
  payrollAssignment: PayrollAssignmentsObjRelInsertInput
  payrollDate: PayrollDatesObjRelInsertInput
  payrollDateId: uuid
  toConsultant: UsersObjRelInsertInput
  toConsultantId: uuid
}

"""aggregate max on columns"""
type PayrollAssignmentAuditMaxFields {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
order by max() on columns of table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditMaxOrderBy {
  assignmentId: OrderBy
  changeReason: OrderBy
  changedBy: OrderBy
  createdAt: OrderBy
  fromConsultantId: OrderBy
  id: OrderBy
  payrollDateId: OrderBy
  toConsultantId: OrderBy
}

"""aggregate min on columns"""
type PayrollAssignmentAuditMinFields {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
order by min() on columns of table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditMinOrderBy {
  assignmentId: OrderBy
  changeReason: OrderBy
  changedBy: OrderBy
  createdAt: OrderBy
  fromConsultantId: OrderBy
  id: OrderBy
  payrollDateId: OrderBy
  toConsultantId: OrderBy
}

"""
response of any mutation on the table "payroll_assignment_audit"
"""
type PayrollAssignmentAuditMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollAssignmentAudit!]!
}

"""
on_conflict condition type for table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditOnConflict {
  constraint: PayrollAssignmentAuditConstraint!
  updateColumns: [PayrollAssignmentAuditUpdateColumn!]! = []
  where: PayrollAssignmentAuditBoolExp
}

"""Ordering options when selecting data from "payroll_assignment_audit"."""
input PayrollAssignmentAuditOrderBy {
  assignmentId: OrderBy
  changeReason: OrderBy
  changedBy: OrderBy
  changedByUser: UsersOrderBy
  createdAt: OrderBy
  fromConsultant: UsersOrderBy
  fromConsultantId: OrderBy
  id: OrderBy
  payrollAssignment: PayrollAssignmentsOrderBy
  payrollDate: PayrollDatesOrderBy
  payrollDateId: OrderBy
  toConsultant: UsersOrderBy
  toConsultantId: OrderBy
}

"""primary key columns input for table: payroll_assignment_audit"""
input PayrollAssignmentAuditPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_assignment_audit"
"""
enum PayrollAssignmentAuditSelectColumn {
  """column name"""
  assignmentId
  """column name"""
  changeReason
  """column name"""
  changedBy
  """column name"""
  createdAt
  """column name"""
  fromConsultantId
  """column name"""
  id
  """column name"""
  payrollDateId
  """column name"""
  toConsultantId
}

"""
input type for updating data in table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditSetInput {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
Streaming cursor of the table "payroll_assignment_audit"
"""
input PayrollAssignmentAuditStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollAssignmentAuditStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollAssignmentAuditStreamCursorValueInput {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
update columns of table "payroll_assignment_audit"
"""
enum PayrollAssignmentAuditUpdateColumn {
  """column name"""
  assignmentId
  """column name"""
  changeReason
  """column name"""
  changedBy
  """column name"""
  createdAt
  """column name"""
  fromConsultantId
  """column name"""
  id
  """column name"""
  payrollDateId
  """column name"""
  toConsultantId
}

input PayrollAssignmentAuditUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollAssignmentAuditSetInput
  """filter the rows which have to be updated"""
  where: PayrollAssignmentAuditBoolExp!
}

"""
columns and relationships of "payroll_assignments"
"""
type PayrollAssignments {
  assignedBy: uuid
  """An object relationship"""
  assignedByUser: Users
  assignedDate: timestamptz
  """An array relationship"""
  auditTrail(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """An aggregate relationship"""
  auditTrailAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): PayrollAssignmentAuditAggregate!
  """An object relationship"""
  consultant: Users!
  consultantId: uuid!
  createdAt: timestamptz
  id: uuid!
  isBackup: Boolean
  """An object relationship"""
  originalConsultant: Users
  originalConsultantId: uuid
  """An object relationship"""
  payrollDate: PayrollDates!
  payrollDateId: uuid!
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_assignments"
"""
type PayrollAssignmentsAggregate {
  aggregate: PayrollAssignmentsAggregateFields
  nodes: [PayrollAssignments!]!
}

input PayrollAssignmentsAggregateBoolExp {
  bool_and: payrollAssignmentsAggregateBoolExpBool_and
  bool_or: payrollAssignmentsAggregateBoolExpBool_or
  count: payrollAssignmentsAggregateBoolExpCount
}

"""
aggregate fields of "payroll_assignments"
"""
type PayrollAssignmentsAggregateFields {
  count(columns: [PayrollAssignmentsSelectColumn!], distinct: Boolean): Int!
  max: PayrollAssignmentsMaxFields
  min: PayrollAssignmentsMinFields
}

"""
order by aggregate values of table "payroll_assignments"
"""
input PayrollAssignmentsAggregateOrderBy {
  count: OrderBy
  max: PayrollAssignmentsMaxOrderBy
  min: PayrollAssignmentsMinOrderBy
}

"""
input type for inserting array relation for remote table "payroll_assignments"
"""
input PayrollAssignmentsArrRelInsertInput {
  data: [PayrollAssignmentsInsertInput!]!
  """upsert condition"""
  onConflict: PayrollAssignmentsOnConflict
}

"""
Boolean expression to filter rows from the table "payroll_assignments". All fields are combined with a logical 'AND'.
"""
input PayrollAssignmentsBoolExp {
  _and: [PayrollAssignmentsBoolExp!]
  _not: PayrollAssignmentsBoolExp
  _or: [PayrollAssignmentsBoolExp!]
  assignedBy: UuidComparisonExp
  assignedByUser: UsersBoolExp
  assignedDate: TimestamptzComparisonExp
  auditTrail: PayrollAssignmentAuditBoolExp
  auditTrailAggregate: PayrollAssignmentAuditAggregateBoolExp
  consultant: UsersBoolExp
  consultantId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isBackup: BooleanComparisonExp
  originalConsultant: UsersBoolExp
  originalConsultantId: UuidComparisonExp
  payrollDate: PayrollDatesBoolExp
  payrollDateId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_assignments"
"""
enum PayrollAssignmentsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_assignments_pkey
  """
  unique or primary key constraint on columns "payroll_date_id"
  """
  uq_payroll_assignment_payroll_date
}

"""
input type for inserting data into table "payroll_assignments"
"""
input PayrollAssignmentsInsertInput {
  assignedBy: uuid
  assignedByUser: UsersObjRelInsertInput
  assignedDate: timestamptz
  auditTrail: PayrollAssignmentAuditArrRelInsertInput
  consultant: UsersObjRelInsertInput
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultant: UsersObjRelInsertInput
  originalConsultantId: uuid
  payrollDate: PayrollDatesObjRelInsertInput
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PayrollAssignmentsMaxFields {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "payroll_assignments"
"""
input PayrollAssignmentsMaxOrderBy {
  assignedBy: OrderBy
  assignedDate: OrderBy
  consultantId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  originalConsultantId: OrderBy
  payrollDateId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PayrollAssignmentsMinFields {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "payroll_assignments"
"""
input PayrollAssignmentsMinOrderBy {
  assignedBy: OrderBy
  assignedDate: OrderBy
  consultantId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  originalConsultantId: OrderBy
  payrollDateId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "payroll_assignments"
"""
type PayrollAssignmentsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollAssignments!]!
}

"""
input type for inserting object relation for remote table "payroll_assignments"
"""
input PayrollAssignmentsObjRelInsertInput {
  data: PayrollAssignmentsInsertInput!
  """upsert condition"""
  onConflict: PayrollAssignmentsOnConflict
}

"""
on_conflict condition type for table "payroll_assignments"
"""
input PayrollAssignmentsOnConflict {
  constraint: PayrollAssignmentsConstraint!
  updateColumns: [PayrollAssignmentsUpdateColumn!]! = []
  where: PayrollAssignmentsBoolExp
}

"""Ordering options when selecting data from "payroll_assignments"."""
input PayrollAssignmentsOrderBy {
  assignedBy: OrderBy
  assignedByUser: UsersOrderBy
  assignedDate: OrderBy
  auditTrailAggregate: PayrollAssignmentAuditAggregateOrderBy
  consultant: UsersOrderBy
  consultantId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  isBackup: OrderBy
  originalConsultant: UsersOrderBy
  originalConsultantId: OrderBy
  payrollDate: PayrollDatesOrderBy
  payrollDateId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_assignments"""
input PayrollAssignmentsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_assignments"
"""
enum PayrollAssignmentsSelectColumn {
  """column name"""
  assignedBy
  """column name"""
  assignedDate
  """column name"""
  consultantId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  isBackup
  """column name"""
  originalConsultantId
  """column name"""
  payrollDateId
  """column name"""
  updatedAt
}

"""
select "payrollAssignmentsAggregateBoolExpBool_andArgumentsColumns" columns of table "payroll_assignments"
"""
enum PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isBackup
}

"""
select "payrollAssignmentsAggregateBoolExpBool_orArgumentsColumns" columns of table "payroll_assignments"
"""
enum PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isBackup
}

"""
input type for updating data in table "payroll_assignments"
"""
input PayrollAssignmentsSetInput {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payroll_assignments"
"""
input PayrollAssignmentsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollAssignmentsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollAssignmentsStreamCursorValueInput {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "payroll_assignments"
"""
enum PayrollAssignmentsUpdateColumn {
  """column name"""
  assignedBy
  """column name"""
  assignedDate
  """column name"""
  consultantId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  isBackup
  """column name"""
  originalConsultantId
  """column name"""
  payrollDateId
  """column name"""
  updatedAt
}

input PayrollAssignmentsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollAssignmentsSetInput
  """filter the rows which have to be updated"""
  where: PayrollAssignmentsBoolExp!
}

"""
Boolean expression to compare columns of type "payroll_cycle_type". All fields are combined with logical 'AND'.
"""
input PayrollCycleTypeComparisonExp {
  _eq: payroll_cycle_type
  _gt: payroll_cycle_type
  _gte: payroll_cycle_type
  _in: [payroll_cycle_type!]
  _isNull: Boolean
  _lt: payroll_cycle_type
  _lte: payroll_cycle_type
  _neq: payroll_cycle_type
  _nin: [payroll_cycle_type!]
}

"""
columns and relationships of "payroll_cycles"
"""
type PayrollCycles {
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): [AdjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): AdjustmentRulesAggregate!
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid!
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_cycles"
"""
type PayrollCyclesAggregate {
  aggregate: PayrollCyclesAggregateFields
  nodes: [PayrollCycles!]!
}

"""
aggregate fields of "payroll_cycles"
"""
type PayrollCyclesAggregateFields {
  count(columns: [PayrollCyclesSelectColumn!], distinct: Boolean): Int!
  max: PayrollCyclesMaxFields
  min: PayrollCyclesMinFields
}

"""
Boolean expression to filter rows from the table "payroll_cycles". All fields are combined with a logical 'AND'.
"""
input PayrollCyclesBoolExp {
  _and: [PayrollCyclesBoolExp!]
  _not: PayrollCyclesBoolExp
  _or: [PayrollCyclesBoolExp!]
  adjustmentRules: AdjustmentRulesBoolExp
  adjustmentRulesAggregate: AdjustmentRulesAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: PayrollCycleTypeComparisonExp
  payrolls: PayrollsBoolExp
  payrollsAggregate: PayrollsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_cycles"
"""
enum PayrollCyclesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_cycles_name_key
  """
  unique or primary key constraint on columns "id"
  """
  payroll_cycles_pkey
}

"""
input type for inserting data into table "payroll_cycles"
"""
input PayrollCyclesInsertInput {
  adjustmentRules: AdjustmentRulesArrRelInsertInput
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  payrolls: PayrollsArrRelInsertInput
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PayrollCyclesMaxFields {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type PayrollCyclesMinFields {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "payroll_cycles"
"""
type PayrollCyclesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollCycles!]!
}

"""
input type for inserting object relation for remote table "payroll_cycles"
"""
input PayrollCyclesObjRelInsertInput {
  data: PayrollCyclesInsertInput!
  """upsert condition"""
  onConflict: PayrollCyclesOnConflict
}

"""
on_conflict condition type for table "payroll_cycles"
"""
input PayrollCyclesOnConflict {
  constraint: PayrollCyclesConstraint!
  updateColumns: [PayrollCyclesUpdateColumn!]! = []
  where: PayrollCyclesBoolExp
}

"""Ordering options when selecting data from "payroll_cycles"."""
input PayrollCyclesOrderBy {
  adjustmentRulesAggregate: AdjustmentRulesAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  payrollsAggregate: PayrollsAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_cycles"""
input PayrollCyclesPkColumnsInput {
  """Unique identifier for the payroll cycle"""
  id: uuid!
}

"""
select columns of table "payroll_cycles"
"""
enum PayrollCyclesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
input type for updating data in table "payroll_cycles"
"""
input PayrollCyclesSetInput {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payroll_cycles"
"""
input PayrollCyclesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollCyclesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollCyclesStreamCursorValueInput {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "payroll_cycles"
"""
enum PayrollCyclesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input PayrollCyclesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollCyclesSetInput
  """filter the rows which have to be updated"""
  where: PayrollCyclesBoolExp!
}

"""
columns and relationships of "payroll_dashboard_stats"
"""
type PayrollDashboardStats {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""
aggregated selection of "payroll_dashboard_stats"
"""
type PayrollDashboardStatsAggregate {
  aggregate: PayrollDashboardStatsAggregateFields
  nodes: [PayrollDashboardStats!]!
}

"""
aggregate fields of "payroll_dashboard_stats"
"""
type PayrollDashboardStatsAggregateFields {
  avg: PayrollDashboardStatsAvgFields
  count(columns: [PayrollDashboardStatsSelectColumn!], distinct: Boolean): Int!
  max: PayrollDashboardStatsMaxFields
  min: PayrollDashboardStatsMinFields
  stddev: PayrollDashboardStatsStddevFields
  stddevPop: PayrollDashboardStatsStddevPopFields
  stddevSamp: PayrollDashboardStatsStddevSampFields
  sum: PayrollDashboardStatsSumFields
  varPop: PayrollDashboardStatsVarPopFields
  varSamp: PayrollDashboardStatsVarSampFields
  variance: PayrollDashboardStatsVarianceFields
}

"""aggregate avg on columns"""
type PayrollDashboardStatsAvgFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""
Boolean expression to filter rows from the table "payroll_dashboard_stats". All fields are combined with a logical 'AND'.
"""
input PayrollDashboardStatsBoolExp {
  _and: [PayrollDashboardStatsBoolExp!]
  _not: PayrollDashboardStatsBoolExp
  _or: [PayrollDashboardStatsBoolExp!]
  backupConsultantUserId: UuidComparisonExp
  clientName: StringComparisonExp
  cycleName: PayrollCycleTypeComparisonExp
  futureDates: BigintComparisonExp
  id: UuidComparisonExp
  managerUserId: UuidComparisonExp
  name: StringComparisonExp
  nextEftDate: DateComparisonExp
  pastDates: BigintComparisonExp
  primaryConsultantUserId: UuidComparisonExp
  status: PayrollStatusComparisonExp
  totalDates: BigintComparisonExp
}

"""aggregate max on columns"""
type PayrollDashboardStatsMaxFields {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""aggregate min on columns"""
type PayrollDashboardStatsMinFields {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""Ordering options when selecting data from "payroll_dashboard_stats"."""
input PayrollDashboardStatsOrderBy {
  backupConsultantUserId: OrderBy
  clientName: OrderBy
  cycleName: OrderBy
  futureDates: OrderBy
  id: OrderBy
  managerUserId: OrderBy
  name: OrderBy
  nextEftDate: OrderBy
  pastDates: OrderBy
  primaryConsultantUserId: OrderBy
  status: OrderBy
  totalDates: OrderBy
}

"""
select columns of table "payroll_dashboard_stats"
"""
enum PayrollDashboardStatsSelectColumn {
  """column name"""
  backupConsultantUserId
  """column name"""
  clientName
  """column name"""
  cycleName
  """column name"""
  futureDates
  """column name"""
  id
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  nextEftDate
  """column name"""
  pastDates
  """column name"""
  primaryConsultantUserId
  """column name"""
  status
  """column name"""
  totalDates
}

"""aggregate stddev on columns"""
type PayrollDashboardStatsStddevFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate stddevPop on columns"""
type PayrollDashboardStatsStddevPopFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate stddevSamp on columns"""
type PayrollDashboardStatsStddevSampFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""
Streaming cursor of the table "payroll_dashboard_stats"
"""
input PayrollDashboardStatsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollDashboardStatsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollDashboardStatsStreamCursorValueInput {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""aggregate sum on columns"""
type PayrollDashboardStatsSumFields {
  futureDates: bigint
  pastDates: bigint
  totalDates: bigint
}

"""aggregate varPop on columns"""
type PayrollDashboardStatsVarPopFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate varSamp on columns"""
type PayrollDashboardStatsVarSampFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate variance on columns"""
type PayrollDashboardStatsVarianceFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""
Boolean expression to compare columns of type "payroll_date_type". All fields are combined with logical 'AND'.
"""
input PayrollDateTypeComparisonExp {
  _eq: payroll_date_type
  _gt: payroll_date_type
  _gte: payroll_date_type
  _in: [payroll_date_type!]
  _isNull: Boolean
  _lt: payroll_date_type
  _lte: payroll_date_type
  _neq: payroll_date_type
  _nin: [payroll_date_type!]
}

"""
columns and relationships of "payroll_date_types"
"""
type PayrollDateTypes {
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): [AdjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): AdjustmentRulesAggregate!
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid!
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_date_types"
"""
type PayrollDateTypesAggregate {
  aggregate: PayrollDateTypesAggregateFields
  nodes: [PayrollDateTypes!]!
}

"""
aggregate fields of "payroll_date_types"
"""
type PayrollDateTypesAggregateFields {
  count(columns: [PayrollDateTypesSelectColumn!], distinct: Boolean): Int!
  max: PayrollDateTypesMaxFields
  min: PayrollDateTypesMinFields
}

"""
Boolean expression to filter rows from the table "payroll_date_types". All fields are combined with a logical 'AND'.
"""
input PayrollDateTypesBoolExp {
  _and: [PayrollDateTypesBoolExp!]
  _not: PayrollDateTypesBoolExp
  _or: [PayrollDateTypesBoolExp!]
  adjustmentRules: AdjustmentRulesBoolExp
  adjustmentRulesAggregate: AdjustmentRulesAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: PayrollDateTypeComparisonExp
  payrolls: PayrollsBoolExp
  payrollsAggregate: PayrollsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_date_types"
"""
enum PayrollDateTypesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_date_types_name_key
  """
  unique or primary key constraint on columns "id"
  """
  payroll_date_types_pkey
}

"""
input type for inserting data into table "payroll_date_types"
"""
input PayrollDateTypesInsertInput {
  adjustmentRules: AdjustmentRulesArrRelInsertInput
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  payrolls: PayrollsArrRelInsertInput
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PayrollDateTypesMaxFields {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type PayrollDateTypesMinFields {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "payroll_date_types"
"""
type PayrollDateTypesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollDateTypes!]!
}

"""
input type for inserting object relation for remote table "payroll_date_types"
"""
input PayrollDateTypesObjRelInsertInput {
  data: PayrollDateTypesInsertInput!
  """upsert condition"""
  onConflict: PayrollDateTypesOnConflict
}

"""
on_conflict condition type for table "payroll_date_types"
"""
input PayrollDateTypesOnConflict {
  constraint: PayrollDateTypesConstraint!
  updateColumns: [PayrollDateTypesUpdateColumn!]! = []
  where: PayrollDateTypesBoolExp
}

"""Ordering options when selecting data from "payroll_date_types"."""
input PayrollDateTypesOrderBy {
  adjustmentRulesAggregate: AdjustmentRulesAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  payrollsAggregate: PayrollsAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_date_types"""
input PayrollDateTypesPkColumnsInput {
  """Unique identifier for the payroll date type"""
  id: uuid!
}

"""
select columns of table "payroll_date_types"
"""
enum PayrollDateTypesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
input type for updating data in table "payroll_date_types"
"""
input PayrollDateTypesSetInput {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payroll_date_types"
"""
input PayrollDateTypesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollDateTypesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollDateTypesStreamCursorValueInput {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "payroll_date_types"
"""
enum PayrollDateTypesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input PayrollDateTypesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollDateTypesSetInput
  """filter the rows which have to be updated"""
  where: PayrollDateTypesBoolExp!
}

"""
columns and relationships of "payroll_dates"
"""
type PayrollDates {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date!
  """An object relationship"""
  assignmentDetails: PayrollAssignments
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid!
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date!
  """An object relationship"""
  payroll: Payrolls!
  """An array relationship"""
  payrollAssignments(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """An aggregate relationship"""
  payrollAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): PayrollAssignmentAuditAggregate!
  """Reference to the payroll this date belongs to"""
  payrollId: uuid!
  """Date when payroll processing must be completed"""
  processingDate: date!
  """An array relationship"""
  timeEntries(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """An aggregate relationship"""
  timeEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): TimeEntriesAggregate!
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_dates"
"""
type PayrollDatesAggregate {
  aggregate: PayrollDatesAggregateFields
  nodes: [PayrollDates!]!
}

input PayrollDatesAggregateBoolExp {
  count: payrollDatesAggregateBoolExpCount
}

"""
aggregate fields of "payroll_dates"
"""
type PayrollDatesAggregateFields {
  count(columns: [PayrollDatesSelectColumn!], distinct: Boolean): Int!
  max: PayrollDatesMaxFields
  min: PayrollDatesMinFields
}

"""
order by aggregate values of table "payroll_dates"
"""
input PayrollDatesAggregateOrderBy {
  count: OrderBy
  max: PayrollDatesMaxOrderBy
  min: PayrollDatesMinOrderBy
}

"""
input type for inserting array relation for remote table "payroll_dates"
"""
input PayrollDatesArrRelInsertInput {
  data: [PayrollDatesInsertInput!]!
  """upsert condition"""
  onConflict: PayrollDatesOnConflict
}

"""
Boolean expression to filter rows from the table "payroll_dates". All fields are combined with a logical 'AND'.
"""
input PayrollDatesBoolExp {
  _and: [PayrollDatesBoolExp!]
  _not: PayrollDatesBoolExp
  _or: [PayrollDatesBoolExp!]
  adjustedEftDate: DateComparisonExp
  assignmentDetails: PayrollAssignmentsBoolExp
  billingItems: BillingItemsBoolExp
  billingItemsAggregate: BillingItemsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  notes: StringComparisonExp
  originalEftDate: DateComparisonExp
  payroll: PayrollsBoolExp
  payrollAssignments: PayrollAssignmentAuditBoolExp
  payrollAssignmentsAggregate: PayrollAssignmentAuditAggregateBoolExp
  payrollId: UuidComparisonExp
  processingDate: DateComparisonExp
  timeEntries: TimeEntriesBoolExp
  timeEntriesAggregate: TimeEntriesAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_dates"
"""
enum PayrollDatesConstraint {
  """
  unique or primary key constraint on columns "original_eft_date", "payroll_id"
  """
  idx_unique_payroll_date
  """
  unique or primary key constraint on columns "id"
  """
  payroll_dates_pkey
}

"""
input type for inserting data into table "payroll_dates"
"""
input PayrollDatesInsertInput {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  assignmentDetails: PayrollAssignmentsObjRelInsertInput
  billingItems: BillingItemsArrRelInsertInput
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  payroll: PayrollsObjRelInsertInput
  payrollAssignments: PayrollAssignmentAuditArrRelInsertInput
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  timeEntries: TimeEntriesArrRelInsertInput
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PayrollDatesMaxFields {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "payroll_dates"
"""
input PayrollDatesMaxOrderBy {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: OrderBy
  """Timestamp when the date record was created"""
  createdAt: OrderBy
  """Unique identifier for the payroll date"""
  id: OrderBy
  """Additional notes about this payroll date"""
  notes: OrderBy
  """Originally calculated EFT date before adjustments"""
  originalEftDate: OrderBy
  """Reference to the payroll this date belongs to"""
  payrollId: OrderBy
  """Date when payroll processing must be completed"""
  processingDate: OrderBy
  """Timestamp when the date record was last updated"""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PayrollDatesMinFields {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "payroll_dates"
"""
input PayrollDatesMinOrderBy {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: OrderBy
  """Timestamp when the date record was created"""
  createdAt: OrderBy
  """Unique identifier for the payroll date"""
  id: OrderBy
  """Additional notes about this payroll date"""
  notes: OrderBy
  """Originally calculated EFT date before adjustments"""
  originalEftDate: OrderBy
  """Reference to the payroll this date belongs to"""
  payrollId: OrderBy
  """Date when payroll processing must be completed"""
  processingDate: OrderBy
  """Timestamp when the date record was last updated"""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "payroll_dates"
"""
type PayrollDatesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollDates!]!
}

"""
input type for inserting object relation for remote table "payroll_dates"
"""
input PayrollDatesObjRelInsertInput {
  data: PayrollDatesInsertInput!
  """upsert condition"""
  onConflict: PayrollDatesOnConflict
}

"""
on_conflict condition type for table "payroll_dates"
"""
input PayrollDatesOnConflict {
  constraint: PayrollDatesConstraint!
  updateColumns: [PayrollDatesUpdateColumn!]! = []
  where: PayrollDatesBoolExp
}

"""Ordering options when selecting data from "payroll_dates"."""
input PayrollDatesOrderBy {
  adjustedEftDate: OrderBy
  assignmentDetails: PayrollAssignmentsOrderBy
  billingItemsAggregate: BillingItemsAggregateOrderBy
  createdAt: OrderBy
  id: OrderBy
  notes: OrderBy
  originalEftDate: OrderBy
  payroll: PayrollsOrderBy
  payrollAssignmentsAggregate: PayrollAssignmentAuditAggregateOrderBy
  payrollId: OrderBy
  processingDate: OrderBy
  timeEntriesAggregate: TimeEntriesAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_dates"""
input PayrollDatesPkColumnsInput {
  """Unique identifier for the payroll date"""
  id: uuid!
}

"""
select columns of table "payroll_dates"
"""
enum PayrollDatesSelectColumn {
  """column name"""
  adjustedEftDate
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  originalEftDate
  """column name"""
  payrollId
  """column name"""
  processingDate
  """column name"""
  updatedAt
}

"""
input type for updating data in table "payroll_dates"
"""
input PayrollDatesSetInput {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payroll_dates"
"""
input PayrollDatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollDatesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollDatesStreamCursorValueInput {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "payroll_dates"
"""
enum PayrollDatesUpdateColumn {
  """column name"""
  adjustedEftDate
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  originalEftDate
  """column name"""
  payrollId
  """column name"""
  processingDate
  """column name"""
  updatedAt
}

input PayrollDatesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollDatesSetInput
  """filter the rows which have to be updated"""
  where: PayrollDatesBoolExp!
}

"""Profitability analysis for individual payroll jobs"""
type PayrollProfitability {
  billingItemsCount: bigint
  billingStatus: String
  clientId: uuid
  clientName: String
  employeeCount: Int
  payrollId: uuid
  payrollName: String
  payslipCount: Int
  revenuePerHour: numeric
  timeEntriesCount: bigint
  totalHours: numeric
  totalRevenue: numeric
}

"""
aggregated selection of "payroll_profitability"
"""
type PayrollProfitabilityAggregate {
  aggregate: PayrollProfitabilityAggregateFields
  nodes: [PayrollProfitability!]!
}

"""
aggregate fields of "payroll_profitability"
"""
type PayrollProfitabilityAggregateFields {
  avg: PayrollProfitabilityAvgFields
  count(columns: [PayrollProfitabilitySelectColumn!], distinct: Boolean): Int!
  max: PayrollProfitabilityMaxFields
  min: PayrollProfitabilityMinFields
  stddev: PayrollProfitabilityStddevFields
  stddevPop: PayrollProfitabilityStddevPopFields
  stddevSamp: PayrollProfitabilityStddevSampFields
  sum: PayrollProfitabilitySumFields
  varPop: PayrollProfitabilityVarPopFields
  varSamp: PayrollProfitabilityVarSampFields
  variance: PayrollProfitabilityVarianceFields
}

"""aggregate avg on columns"""
type PayrollProfitabilityAvgFields {
  billingItemsCount: Float
  employeeCount: Float
  payslipCount: Float
  revenuePerHour: Float
  timeEntriesCount: Float
  totalHours: Float
  totalRevenue: Float
}

"""
Boolean expression to filter rows from the table "payroll_profitability". All fields are combined with a logical 'AND'.
"""
input PayrollProfitabilityBoolExp {
  _and: [PayrollProfitabilityBoolExp!]
  _not: PayrollProfitabilityBoolExp
  _or: [PayrollProfitabilityBoolExp!]
  billingItemsCount: BigintComparisonExp
  billingStatus: StringComparisonExp
  clientId: UuidComparisonExp
  clientName: StringComparisonExp
  employeeCount: IntComparisonExp
  payrollId: UuidComparisonExp
  payrollName: StringComparisonExp
  payslipCount: IntComparisonExp
  revenuePerHour: NumericComparisonExp
  timeEntriesCount: BigintComparisonExp
  totalHours: NumericComparisonExp
  totalRevenue: NumericComparisonExp
}

"""aggregate max on columns"""
type PayrollProfitabilityMaxFields {
  billingItemsCount: bigint
  billingStatus: String
  clientId: uuid
  clientName: String
  employeeCount: Int
  payrollId: uuid
  payrollName: String
  payslipCount: Int
  revenuePerHour: numeric
  timeEntriesCount: bigint
  totalHours: numeric
  totalRevenue: numeric
}

"""aggregate min on columns"""
type PayrollProfitabilityMinFields {
  billingItemsCount: bigint
  billingStatus: String
  clientId: uuid
  clientName: String
  employeeCount: Int
  payrollId: uuid
  payrollName: String
  payslipCount: Int
  revenuePerHour: numeric
  timeEntriesCount: bigint
  totalHours: numeric
  totalRevenue: numeric
}

"""Ordering options when selecting data from "payroll_profitability"."""
input PayrollProfitabilityOrderBy {
  billingItemsCount: OrderBy
  billingStatus: OrderBy
  clientId: OrderBy
  clientName: OrderBy
  employeeCount: OrderBy
  payrollId: OrderBy
  payrollName: OrderBy
  payslipCount: OrderBy
  revenuePerHour: OrderBy
  timeEntriesCount: OrderBy
  totalHours: OrderBy
  totalRevenue: OrderBy
}

"""
select columns of table "payroll_profitability"
"""
enum PayrollProfitabilitySelectColumn {
  """column name"""
  billingItemsCount
  """column name"""
  billingStatus
  """column name"""
  clientId
  """column name"""
  clientName
  """column name"""
  employeeCount
  """column name"""
  payrollId
  """column name"""
  payrollName
  """column name"""
  payslipCount
  """column name"""
  revenuePerHour
  """column name"""
  timeEntriesCount
  """column name"""
  totalHours
  """column name"""
  totalRevenue
}

"""aggregate stddev on columns"""
type PayrollProfitabilityStddevFields {
  billingItemsCount: Float
  employeeCount: Float
  payslipCount: Float
  revenuePerHour: Float
  timeEntriesCount: Float
  totalHours: Float
  totalRevenue: Float
}

"""aggregate stddevPop on columns"""
type PayrollProfitabilityStddevPopFields {
  billingItemsCount: Float
  employeeCount: Float
  payslipCount: Float
  revenuePerHour: Float
  timeEntriesCount: Float
  totalHours: Float
  totalRevenue: Float
}

"""aggregate stddevSamp on columns"""
type PayrollProfitabilityStddevSampFields {
  billingItemsCount: Float
  employeeCount: Float
  payslipCount: Float
  revenuePerHour: Float
  timeEntriesCount: Float
  totalHours: Float
  totalRevenue: Float
}

"""
Streaming cursor of the table "payroll_profitability"
"""
input PayrollProfitabilityStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollProfitabilityStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollProfitabilityStreamCursorValueInput {
  billingItemsCount: bigint
  billingStatus: String
  clientId: uuid
  clientName: String
  employeeCount: Int
  payrollId: uuid
  payrollName: String
  payslipCount: Int
  revenuePerHour: numeric
  timeEntriesCount: bigint
  totalHours: numeric
  totalRevenue: numeric
}

"""aggregate sum on columns"""
type PayrollProfitabilitySumFields {
  billingItemsCount: bigint
  employeeCount: Int
  payslipCount: Int
  revenuePerHour: numeric
  timeEntriesCount: bigint
  totalHours: numeric
  totalRevenue: numeric
}

"""aggregate varPop on columns"""
type PayrollProfitabilityVarPopFields {
  billingItemsCount: Float
  employeeCount: Float
  payslipCount: Float
  revenuePerHour: Float
  timeEntriesCount: Float
  totalHours: Float
  totalRevenue: Float
}

"""aggregate varSamp on columns"""
type PayrollProfitabilityVarSampFields {
  billingItemsCount: Float
  employeeCount: Float
  payslipCount: Float
  revenuePerHour: Float
  timeEntriesCount: Float
  totalHours: Float
  totalRevenue: Float
}

"""aggregate variance on columns"""
type PayrollProfitabilityVarianceFields {
  billingItemsCount: Float
  employeeCount: Float
  payslipCount: Float
  revenuePerHour: Float
  timeEntriesCount: Float
  totalHours: Float
  totalRevenue: Float
}

"""
columns and relationships of "payroll_required_skills"
"""
type PayrollRequiredSkills {
  """An object relationship"""
  payroll: Payrolls
  payrollId: uuid
  requiredLevel: String
  skillName: String
}

"""
aggregated selection of "payroll_required_skills"
"""
type PayrollRequiredSkillsAggregate {
  aggregate: PayrollRequiredSkillsAggregateFields
  nodes: [PayrollRequiredSkills!]!
}

input PayrollRequiredSkillsAggregateBoolExp {
  count: payrollRequiredSkillsAggregateBoolExpCount
}

"""
aggregate fields of "payroll_required_skills"
"""
type PayrollRequiredSkillsAggregateFields {
  count(columns: [PayrollRequiredSkillsSelectColumn!], distinct: Boolean): Int!
  max: PayrollRequiredSkillsMaxFields
  min: PayrollRequiredSkillsMinFields
}

"""
order by aggregate values of table "payroll_required_skills"
"""
input PayrollRequiredSkillsAggregateOrderBy {
  count: OrderBy
  max: PayrollRequiredSkillsMaxOrderBy
  min: PayrollRequiredSkillsMinOrderBy
}

"""
input type for inserting array relation for remote table "payroll_required_skills"
"""
input PayrollRequiredSkillsArrRelInsertInput {
  data: [PayrollRequiredSkillsInsertInput!]!
}

"""
Boolean expression to filter rows from the table "payroll_required_skills". All fields are combined with a logical 'AND'.
"""
input PayrollRequiredSkillsBoolExp {
  _and: [PayrollRequiredSkillsBoolExp!]
  _not: PayrollRequiredSkillsBoolExp
  _or: [PayrollRequiredSkillsBoolExp!]
  payroll: PayrollsBoolExp
  payrollId: UuidComparisonExp
  requiredLevel: StringComparisonExp
  skillName: StringComparisonExp
}

"""
input type for inserting data into table "payroll_required_skills"
"""
input PayrollRequiredSkillsInsertInput {
  payroll: PayrollsObjRelInsertInput
  payrollId: uuid
  requiredLevel: String
  skillName: String
}

"""aggregate max on columns"""
type PayrollRequiredSkillsMaxFields {
  payrollId: uuid
  requiredLevel: String
  skillName: String
}

"""
order by max() on columns of table "payroll_required_skills"
"""
input PayrollRequiredSkillsMaxOrderBy {
  payrollId: OrderBy
  requiredLevel: OrderBy
  skillName: OrderBy
}

"""aggregate min on columns"""
type PayrollRequiredSkillsMinFields {
  payrollId: uuid
  requiredLevel: String
  skillName: String
}

"""
order by min() on columns of table "payroll_required_skills"
"""
input PayrollRequiredSkillsMinOrderBy {
  payrollId: OrderBy
  requiredLevel: OrderBy
  skillName: OrderBy
}

"""
response of any mutation on the table "payroll_required_skills"
"""
type PayrollRequiredSkillsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollRequiredSkills!]!
}

"""Ordering options when selecting data from "payroll_required_skills"."""
input PayrollRequiredSkillsOrderBy {
  payroll: PayrollsOrderBy
  payrollId: OrderBy
  requiredLevel: OrderBy
  skillName: OrderBy
}

"""
select columns of table "payroll_required_skills"
"""
enum PayrollRequiredSkillsSelectColumn {
  """column name"""
  payrollId
  """column name"""
  requiredLevel
  """column name"""
  skillName
}

"""
input type for updating data in table "payroll_required_skills"
"""
input PayrollRequiredSkillsSetInput {
  payrollId: uuid
  requiredLevel: String
  skillName: String
}

"""
Streaming cursor of the table "payroll_required_skills"
"""
input PayrollRequiredSkillsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollRequiredSkillsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollRequiredSkillsStreamCursorValueInput {
  payrollId: uuid
  requiredLevel: String
  skillName: String
}

input PayrollRequiredSkillsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollRequiredSkillsSetInput
  """filter the rows which have to be updated"""
  where: PayrollRequiredSkillsBoolExp!
}

"""
Boolean expression to compare columns of type "payroll_status". All fields are combined with logical 'AND'.
"""
input PayrollStatusComparisonExp {
  _eq: payroll_status
  _gt: payroll_status
  _gte: payroll_status
  _in: [payroll_status!]
  _isNull: Boolean
  _lt: payroll_status
  _lte: payroll_status
  _neq: payroll_status
  _nin: [payroll_status!]
}

"""
columns and relationships of "payroll_triggers_status"
"""
type PayrollTriggersStatus {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
  eventObjectTable: name
  triggerName: name
}

"""
aggregated selection of "payroll_triggers_status"
"""
type PayrollTriggersStatusAggregate {
  aggregate: PayrollTriggersStatusAggregateFields
  nodes: [PayrollTriggersStatus!]!
}

"""
aggregate fields of "payroll_triggers_status"
"""
type PayrollTriggersStatusAggregateFields {
  count(columns: [PayrollTriggersStatusSelectColumn!], distinct: Boolean): Int!
  max: PayrollTriggersStatusMaxFields
  min: PayrollTriggersStatusMinFields
}

"""
Boolean expression to filter rows from the table "payroll_triggers_status". All fields are combined with a logical 'AND'.
"""
input PayrollTriggersStatusBoolExp {
  _and: [PayrollTriggersStatusBoolExp!]
  _not: PayrollTriggersStatusBoolExp
  _or: [PayrollTriggersStatusBoolExp!]
  actionStatement: StringComparisonExp
  actionTiming: StringComparisonExp
  eventManipulation: StringComparisonExp
  eventObjectTable: NameComparisonExp
  triggerName: NameComparisonExp
}

"""aggregate max on columns"""
type PayrollTriggersStatusMaxFields {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
}

"""aggregate min on columns"""
type PayrollTriggersStatusMinFields {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
}

"""Ordering options when selecting data from "payroll_triggers_status"."""
input PayrollTriggersStatusOrderBy {
  actionStatement: OrderBy
  actionTiming: OrderBy
  eventManipulation: OrderBy
  eventObjectTable: OrderBy
  triggerName: OrderBy
}

"""
select columns of table "payroll_triggers_status"
"""
enum PayrollTriggersStatusSelectColumn {
  """column name"""
  actionStatement
  """column name"""
  actionTiming
  """column name"""
  eventManipulation
  """column name"""
  eventObjectTable
  """column name"""
  triggerName
}

"""
Streaming cursor of the table "payroll_triggers_status"
"""
input PayrollTriggersStatusStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollTriggersStatusStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollTriggersStatusStreamCursorValueInput {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
  eventObjectTable: name
  triggerName: name
}

"""
columns and relationships of "payroll_version_history_results"
"""
type PayrollVersionHistoryResults {
  active: Boolean!
  goLiveDate: date
  id: uuid!
  isCurrent: Boolean!
  name: String!
  payrollId: uuid!
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int!
  versionReason: String
}

type PayrollVersionHistoryResultsAggregate {
  aggregate: PayrollVersionHistoryResultsAggregateFields
  nodes: [PayrollVersionHistoryResults!]!
}

"""
aggregate fields of "payroll_version_history_results"
"""
type PayrollVersionHistoryResultsAggregateFields {
  avg: PayrollVersionHistoryResultsAvgFields
  count(columns: [PayrollVersionHistoryResultsSelectColumn!], distinct: Boolean): Int!
  max: PayrollVersionHistoryResultsMaxFields
  min: PayrollVersionHistoryResultsMinFields
  stddev: PayrollVersionHistoryResultsStddevFields
  stddevPop: PayrollVersionHistoryResultsStddevPopFields
  stddevSamp: PayrollVersionHistoryResultsStddevSampFields
  sum: PayrollVersionHistoryResultsSumFields
  varPop: PayrollVersionHistoryResultsVarPopFields
  varSamp: PayrollVersionHistoryResultsVarSampFields
  variance: PayrollVersionHistoryResultsVarianceFields
}

"""aggregate avg on columns"""
type PayrollVersionHistoryResultsAvgFields {
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_history_results". All fields are combined with a logical 'AND'.
"""
input PayrollVersionHistoryResultsBoolExp {
  _and: [PayrollVersionHistoryResultsBoolExp!]
  _not: PayrollVersionHistoryResultsBoolExp
  _or: [PayrollVersionHistoryResultsBoolExp!]
  active: BooleanComparisonExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  isCurrent: BooleanComparisonExp
  name: StringComparisonExp
  payrollId: UuidComparisonExp
  queriedAt: TimestamptzComparisonExp
  supersededDate: DateComparisonExp
  versionNumber: IntComparisonExp
  versionReason: StringComparisonExp
}

"""
unique or primary key constraints on table "payroll_version_history_results"
"""
enum PayrollVersionHistoryResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_history_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_history_results"
"""
input PayrollVersionHistoryResultsIncInput {
  versionNumber: Int
}

"""
input type for inserting data into table "payroll_version_history_results"
"""
input PayrollVersionHistoryResultsInsertInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  isCurrent: Boolean
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate max on columns"""
type PayrollVersionHistoryResultsMaxFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate min on columns"""
type PayrollVersionHistoryResultsMinFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""
response of any mutation on the table "payroll_version_history_results"
"""
type PayrollVersionHistoryResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollVersionHistoryResults!]!
}

"""
on_conflict condition type for table "payroll_version_history_results"
"""
input PayrollVersionHistoryResultsOnConflict {
  constraint: PayrollVersionHistoryResultsConstraint!
  updateColumns: [PayrollVersionHistoryResultsUpdateColumn!]! = []
  where: PayrollVersionHistoryResultsBoolExp
}

"""
Ordering options when selecting data from "payroll_version_history_results".
"""
input PayrollVersionHistoryResultsOrderBy {
  active: OrderBy
  goLiveDate: OrderBy
  id: OrderBy
  isCurrent: OrderBy
  name: OrderBy
  payrollId: OrderBy
  queriedAt: OrderBy
  supersededDate: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""primary key columns input for table: payroll_version_history_results"""
input PayrollVersionHistoryResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_version_history_results"
"""
enum PayrollVersionHistoryResultsSelectColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  isCurrent
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  supersededDate
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

"""
input type for updating data in table "payroll_version_history_results"
"""
input PayrollVersionHistoryResultsSetInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  isCurrent: Boolean
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate stddev on columns"""
type PayrollVersionHistoryResultsStddevFields {
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type PayrollVersionHistoryResultsStddevPopFields {
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type PayrollVersionHistoryResultsStddevSampFields {
  versionNumber: Float
}

"""
Streaming cursor of the table "payroll_version_history_results"
"""
input PayrollVersionHistoryResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollVersionHistoryResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollVersionHistoryResultsStreamCursorValueInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  isCurrent: Boolean
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate sum on columns"""
type PayrollVersionHistoryResultsSumFields {
  versionNumber: Int
}

"""
update columns of table "payroll_version_history_results"
"""
enum PayrollVersionHistoryResultsUpdateColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  isCurrent
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  supersededDate
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

input PayrollVersionHistoryResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PayrollVersionHistoryResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollVersionHistoryResultsSetInput
  """filter the rows which have to be updated"""
  where: PayrollVersionHistoryResultsBoolExp!
}

"""aggregate varPop on columns"""
type PayrollVersionHistoryResultsVarPopFields {
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type PayrollVersionHistoryResultsVarSampFields {
  versionNumber: Float
}

"""aggregate variance on columns"""
type PayrollVersionHistoryResultsVarianceFields {
  versionNumber: Float
}

"""
columns and relationships of "payroll_version_results"
"""
type PayrollVersionResults {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int!
  id: uuid!
  message: String!
  newPayrollId: uuid!
  newVersionNumber: Int!
  oldPayrollId: uuid!
}

"""
aggregated selection of "payroll_version_results"
"""
type PayrollVersionResultsAggregate {
  aggregate: PayrollVersionResultsAggregateFields
  nodes: [PayrollVersionResults!]!
}

"""
aggregate fields of "payroll_version_results"
"""
type PayrollVersionResultsAggregateFields {
  avg: PayrollVersionResultsAvgFields
  count(columns: [PayrollVersionResultsSelectColumn!], distinct: Boolean): Int!
  max: PayrollVersionResultsMaxFields
  min: PayrollVersionResultsMinFields
  stddev: PayrollVersionResultsStddevFields
  stddevPop: PayrollVersionResultsStddevPopFields
  stddevSamp: PayrollVersionResultsStddevSampFields
  sum: PayrollVersionResultsSumFields
  varPop: PayrollVersionResultsVarPopFields
  varSamp: PayrollVersionResultsVarSampFields
  variance: PayrollVersionResultsVarianceFields
}

"""aggregate avg on columns"""
type PayrollVersionResultsAvgFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_results". All fields are combined with a logical 'AND'.
"""
input PayrollVersionResultsBoolExp {
  _and: [PayrollVersionResultsBoolExp!]
  _not: PayrollVersionResultsBoolExp
  _or: [PayrollVersionResultsBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdByUserId: UuidComparisonExp
  datesDeleted: IntComparisonExp
  id: UuidComparisonExp
  message: StringComparisonExp
  newPayrollId: UuidComparisonExp
  newVersionNumber: IntComparisonExp
  oldPayrollId: UuidComparisonExp
}

"""
unique or primary key constraints on table "payroll_version_results"
"""
enum PayrollVersionResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_results"
"""
input PayrollVersionResultsIncInput {
  datesDeleted: Int
  newVersionNumber: Int
}

"""
input type for inserting data into table "payroll_version_results"
"""
input PayrollVersionResultsInsertInput {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate max on columns"""
type PayrollVersionResultsMaxFields {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate min on columns"""
type PayrollVersionResultsMinFields {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""
response of any mutation on the table "payroll_version_results"
"""
type PayrollVersionResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PayrollVersionResults!]!
}

"""
on_conflict condition type for table "payroll_version_results"
"""
input PayrollVersionResultsOnConflict {
  constraint: PayrollVersionResultsConstraint!
  updateColumns: [PayrollVersionResultsUpdateColumn!]! = []
  where: PayrollVersionResultsBoolExp
}

"""Ordering options when selecting data from "payroll_version_results"."""
input PayrollVersionResultsOrderBy {
  createdAt: OrderBy
  createdByUserId: OrderBy
  datesDeleted: OrderBy
  id: OrderBy
  message: OrderBy
  newPayrollId: OrderBy
  newVersionNumber: OrderBy
  oldPayrollId: OrderBy
}

"""primary key columns input for table: payroll_version_results"""
input PayrollVersionResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_version_results"
"""
enum PayrollVersionResultsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  datesDeleted
  """column name"""
  id
  """column name"""
  message
  """column name"""
  newPayrollId
  """column name"""
  newVersionNumber
  """column name"""
  oldPayrollId
}

"""
input type for updating data in table "payroll_version_results"
"""
input PayrollVersionResultsSetInput {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate stddev on columns"""
type PayrollVersionResultsStddevFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate stddevPop on columns"""
type PayrollVersionResultsStddevPopFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate stddevSamp on columns"""
type PayrollVersionResultsStddevSampFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""
Streaming cursor of the table "payroll_version_results"
"""
input PayrollVersionResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollVersionResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollVersionResultsStreamCursorValueInput {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate sum on columns"""
type PayrollVersionResultsSumFields {
  datesDeleted: Int
  newVersionNumber: Int
}

"""
update columns of table "payroll_version_results"
"""
enum PayrollVersionResultsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  datesDeleted
  """column name"""
  id
  """column name"""
  message
  """column name"""
  newPayrollId
  """column name"""
  newVersionNumber
  """column name"""
  oldPayrollId
}

input PayrollVersionResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PayrollVersionResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollVersionResultsSetInput
  """filter the rows which have to be updated"""
  where: PayrollVersionResultsBoolExp!
}

"""aggregate varPop on columns"""
type PayrollVersionResultsVarPopFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate varSamp on columns"""
type PayrollVersionResultsVarSampFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate variance on columns"""
type PayrollVersionResultsVarianceFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""
Distributes payroll processing time across working days prior to EFT dates, excluding weekends and holidays. Used for accurate workload capacity visualization.
"""
type PayrollWorkloadDistribution {
  adjustedEftDate: date
  adminTimeHours: numeric
  assignmentDate: date
  assignmentDay: String
  clientId: uuid
  clientName: String
  consultantRole: String
  dayCapacityHours: numeric
  dayUtilizationPercentage: numeric
  distributedProcessingTime: numeric
  originalEftDate: date
  payrollDateId: uuid
  payrollId: uuid
  payrollName: String
  processingDaysBeforeEft: Int
  processingEndDate: date
  processingStartDate: date
  status: payroll_status
  totalPeriodCapacity: numeric
  totalProcessingTime: Int
  userId: uuid
  workHours: numeric
}

"""
aggregated selection of "payroll_workload_distribution"
"""
type PayrollWorkloadDistributionAggregate {
  aggregate: PayrollWorkloadDistributionAggregateFields
  nodes: [PayrollWorkloadDistribution!]!
}

"""
aggregate fields of "payroll_workload_distribution"
"""
type PayrollWorkloadDistributionAggregateFields {
  avg: PayrollWorkloadDistributionAvgFields
  count(columns: [PayrollWorkloadDistributionSelectColumn!], distinct: Boolean): Int!
  max: PayrollWorkloadDistributionMaxFields
  min: PayrollWorkloadDistributionMinFields
  stddev: PayrollWorkloadDistributionStddevFields
  stddevPop: PayrollWorkloadDistributionStddevPopFields
  stddevSamp: PayrollWorkloadDistributionStddevSampFields
  sum: PayrollWorkloadDistributionSumFields
  varPop: PayrollWorkloadDistributionVarPopFields
  varSamp: PayrollWorkloadDistributionVarSampFields
  variance: PayrollWorkloadDistributionVarianceFields
}

"""aggregate avg on columns"""
type PayrollWorkloadDistributionAvgFields {
  adminTimeHours: Float
  dayCapacityHours: Float
  dayUtilizationPercentage: Float
  distributedProcessingTime: Float
  processingDaysBeforeEft: Float
  totalPeriodCapacity: Float
  totalProcessingTime: Float
  workHours: Float
}

"""
Boolean expression to filter rows from the table "payroll_workload_distribution". All fields are combined with a logical 'AND'.
"""
input PayrollWorkloadDistributionBoolExp {
  _and: [PayrollWorkloadDistributionBoolExp!]
  _not: PayrollWorkloadDistributionBoolExp
  _or: [PayrollWorkloadDistributionBoolExp!]
  adjustedEftDate: DateComparisonExp
  adminTimeHours: NumericComparisonExp
  assignmentDate: DateComparisonExp
  assignmentDay: StringComparisonExp
  clientId: UuidComparisonExp
  clientName: StringComparisonExp
  consultantRole: StringComparisonExp
  dayCapacityHours: NumericComparisonExp
  dayUtilizationPercentage: NumericComparisonExp
  distributedProcessingTime: NumericComparisonExp
  originalEftDate: DateComparisonExp
  payrollDateId: UuidComparisonExp
  payrollId: UuidComparisonExp
  payrollName: StringComparisonExp
  processingDaysBeforeEft: IntComparisonExp
  processingEndDate: DateComparisonExp
  processingStartDate: DateComparisonExp
  status: PayrollStatusComparisonExp
  totalPeriodCapacity: NumericComparisonExp
  totalProcessingTime: IntComparisonExp
  userId: UuidComparisonExp
  workHours: NumericComparisonExp
}

"""aggregate max on columns"""
type PayrollWorkloadDistributionMaxFields {
  adjustedEftDate: date
  adminTimeHours: numeric
  assignmentDate: date
  assignmentDay: String
  clientId: uuid
  clientName: String
  consultantRole: String
  dayCapacityHours: numeric
  dayUtilizationPercentage: numeric
  distributedProcessingTime: numeric
  originalEftDate: date
  payrollDateId: uuid
  payrollId: uuid
  payrollName: String
  processingDaysBeforeEft: Int
  processingEndDate: date
  processingStartDate: date
  status: payroll_status
  totalPeriodCapacity: numeric
  totalProcessingTime: Int
  userId: uuid
  workHours: numeric
}

"""aggregate min on columns"""
type PayrollWorkloadDistributionMinFields {
  adjustedEftDate: date
  adminTimeHours: numeric
  assignmentDate: date
  assignmentDay: String
  clientId: uuid
  clientName: String
  consultantRole: String
  dayCapacityHours: numeric
  dayUtilizationPercentage: numeric
  distributedProcessingTime: numeric
  originalEftDate: date
  payrollDateId: uuid
  payrollId: uuid
  payrollName: String
  processingDaysBeforeEft: Int
  processingEndDate: date
  processingStartDate: date
  status: payroll_status
  totalPeriodCapacity: numeric
  totalProcessingTime: Int
  userId: uuid
  workHours: numeric
}

"""
Ordering options when selecting data from "payroll_workload_distribution".
"""
input PayrollWorkloadDistributionOrderBy {
  adjustedEftDate: OrderBy
  adminTimeHours: OrderBy
  assignmentDate: OrderBy
  assignmentDay: OrderBy
  clientId: OrderBy
  clientName: OrderBy
  consultantRole: OrderBy
  dayCapacityHours: OrderBy
  dayUtilizationPercentage: OrderBy
  distributedProcessingTime: OrderBy
  originalEftDate: OrderBy
  payrollDateId: OrderBy
  payrollId: OrderBy
  payrollName: OrderBy
  processingDaysBeforeEft: OrderBy
  processingEndDate: OrderBy
  processingStartDate: OrderBy
  status: OrderBy
  totalPeriodCapacity: OrderBy
  totalProcessingTime: OrderBy
  userId: OrderBy
  workHours: OrderBy
}

"""
select columns of table "payroll_workload_distribution"
"""
enum PayrollWorkloadDistributionSelectColumn {
  """column name"""
  adjustedEftDate
  """column name"""
  adminTimeHours
  """column name"""
  assignmentDate
  """column name"""
  assignmentDay
  """column name"""
  clientId
  """column name"""
  clientName
  """column name"""
  consultantRole
  """column name"""
  dayCapacityHours
  """column name"""
  dayUtilizationPercentage
  """column name"""
  distributedProcessingTime
  """column name"""
  originalEftDate
  """column name"""
  payrollDateId
  """column name"""
  payrollId
  """column name"""
  payrollName
  """column name"""
  processingDaysBeforeEft
  """column name"""
  processingEndDate
  """column name"""
  processingStartDate
  """column name"""
  status
  """column name"""
  totalPeriodCapacity
  """column name"""
  totalProcessingTime
  """column name"""
  userId
  """column name"""
  workHours
}

"""aggregate stddev on columns"""
type PayrollWorkloadDistributionStddevFields {
  adminTimeHours: Float
  dayCapacityHours: Float
  dayUtilizationPercentage: Float
  distributedProcessingTime: Float
  processingDaysBeforeEft: Float
  totalPeriodCapacity: Float
  totalProcessingTime: Float
  workHours: Float
}

"""aggregate stddevPop on columns"""
type PayrollWorkloadDistributionStddevPopFields {
  adminTimeHours: Float
  dayCapacityHours: Float
  dayUtilizationPercentage: Float
  distributedProcessingTime: Float
  processingDaysBeforeEft: Float
  totalPeriodCapacity: Float
  totalProcessingTime: Float
  workHours: Float
}

"""aggregate stddevSamp on columns"""
type PayrollWorkloadDistributionStddevSampFields {
  adminTimeHours: Float
  dayCapacityHours: Float
  dayUtilizationPercentage: Float
  distributedProcessingTime: Float
  processingDaysBeforeEft: Float
  totalPeriodCapacity: Float
  totalProcessingTime: Float
  workHours: Float
}

"""
Streaming cursor of the table "payroll_workload_distribution"
"""
input PayrollWorkloadDistributionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollWorkloadDistributionStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollWorkloadDistributionStreamCursorValueInput {
  adjustedEftDate: date
  adminTimeHours: numeric
  assignmentDate: date
  assignmentDay: String
  clientId: uuid
  clientName: String
  consultantRole: String
  dayCapacityHours: numeric
  dayUtilizationPercentage: numeric
  distributedProcessingTime: numeric
  originalEftDate: date
  payrollDateId: uuid
  payrollId: uuid
  payrollName: String
  processingDaysBeforeEft: Int
  processingEndDate: date
  processingStartDate: date
  status: payroll_status
  totalPeriodCapacity: numeric
  totalProcessingTime: Int
  userId: uuid
  workHours: numeric
}

"""aggregate sum on columns"""
type PayrollWorkloadDistributionSumFields {
  adminTimeHours: numeric
  dayCapacityHours: numeric
  dayUtilizationPercentage: numeric
  distributedProcessingTime: numeric
  processingDaysBeforeEft: Int
  totalPeriodCapacity: numeric
  totalProcessingTime: Int
  workHours: numeric
}

"""aggregate varPop on columns"""
type PayrollWorkloadDistributionVarPopFields {
  adminTimeHours: Float
  dayCapacityHours: Float
  dayUtilizationPercentage: Float
  distributedProcessingTime: Float
  processingDaysBeforeEft: Float
  totalPeriodCapacity: Float
  totalProcessingTime: Float
  workHours: Float
}

"""aggregate varSamp on columns"""
type PayrollWorkloadDistributionVarSampFields {
  adminTimeHours: Float
  dayCapacityHours: Float
  dayUtilizationPercentage: Float
  distributedProcessingTime: Float
  processingDaysBeforeEft: Float
  totalPeriodCapacity: Float
  totalProcessingTime: Float
  workHours: Float
}

"""aggregate variance on columns"""
type PayrollWorkloadDistributionVarianceFields {
  adminTimeHours: Float
  dayCapacityHours: Float
  dayUtilizationPercentage: Float
  distributedProcessingTime: Float
  processingDaysBeforeEft: Float
  totalPeriodCapacity: Float
  totalProcessingTime: Float
  workHours: Float
}

"""
columns and relationships of "payrolls"
"""
type Payrolls {
  actualHours: numeric
  actualRevenue: numeric
  """An object relationship"""
  assignedManager: Users
  """An object relationship"""
  backupConsultant: Users
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: String
  """An array relationship"""
  childPayrolls(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  childPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """An object relationship"""
  client: Clients!
  """Reference to the client this payroll belongs to"""
  clientId: uuid!
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid!
  """Reference to the payroll date type"""
  dateTypeId: uuid!
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  """An array relationship"""
  files(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): [Files!]!
  """An aggregate relationship"""
  filesAggregate(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): FilesAggregate!
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid!
  lastBilledDate: timestamptz
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String!
  """Number of new employees processed"""
  newEmployees: Int
  """An object relationship"""
  parentPayroll: Payrolls
  parentPayrollId: uuid
  """An object relationship"""
  payrollCycle: PayrollCycles!
  """An object relationship"""
  payrollDateType: PayrollDateTypes!
  """An array relationship"""
  payrollDates(
    """distinct select on columns"""
    distinctOn: [PayrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDatesOrderBy!]
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): [PayrollDates!]!
  """An aggregate relationship"""
  payrollDatesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDatesOrderBy!]
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): PayrollDatesAggregate!
  """External payroll system used for this client"""
  payrollSystem: String
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  """An object relationship"""
  primaryConsultant: Users
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int!
  """Number of hours required to process this payroll"""
  processingTime: Int!
  profitMargin: numeric
  """An array relationship"""
  requiredSkills(
    """distinct select on columns"""
    distinctOn: [PayrollRequiredSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollRequiredSkillsOrderBy!]
    """filter the rows returned"""
    where: PayrollRequiredSkillsBoolExp
  ): [PayrollRequiredSkills!]!
  """An aggregate relationship"""
  requiredSkillsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollRequiredSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollRequiredSkillsOrderBy!]
    """filter the rows returned"""
    where: PayrollRequiredSkillsBoolExp
  ): PayrollRequiredSkillsAggregate!
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status!
  supersededDate: date
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  """An array relationship"""
  timeEntries(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """An aggregate relationship"""
  timeEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): TimeEntriesAggregate!
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregated selection of "payrolls"
"""
type PayrollsAggregate {
  aggregate: PayrollsAggregateFields
  nodes: [Payrolls!]!
}

input PayrollsAggregateBoolExp {
  count: payrollsAggregateBoolExpCount
}

"""
aggregate fields of "payrolls"
"""
type PayrollsAggregateFields {
  avg: PayrollsAvgFields
  count(columns: [PayrollsSelectColumn!], distinct: Boolean): Int!
  max: PayrollsMaxFields
  min: PayrollsMinFields
  stddev: PayrollsStddevFields
  stddevPop: PayrollsStddevPopFields
  stddevSamp: PayrollsStddevSampFields
  sum: PayrollsSumFields
  varPop: PayrollsVarPopFields
  varSamp: PayrollsVarSampFields
  variance: PayrollsVarianceFields
}

"""
order by aggregate values of table "payrolls"
"""
input PayrollsAggregateOrderBy {
  avg: PayrollsAvgOrderBy
  count: OrderBy
  max: PayrollsMaxOrderBy
  min: PayrollsMinOrderBy
  stddev: PayrollsStddevOrderBy
  stddevPop: PayrollsStddevPopOrderBy
  stddevSamp: PayrollsStddevSampOrderBy
  sum: PayrollsSumOrderBy
  varPop: PayrollsVarPopOrderBy
  varSamp: PayrollsVarSampOrderBy
  variance: PayrollsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "payrolls"
"""
input PayrollsArrRelInsertInput {
  data: [PayrollsInsertInput!]!
  """upsert condition"""
  onConflict: PayrollsOnConflict
}

"""aggregate avg on columns"""
type PayrollsAvgFields {
  actualHours: Float
  actualRevenue: Float
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  estimatedHours: Float
  estimatedRevenue: Float
  """Number of new employees processed"""
  newEmployees: Float
  """Number of payslips processed in this payroll run"""
  payslipCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  profitMargin: Float
  """Number of terminated employees processed"""
  terminatedEmployees: Float
  versionNumber: Float
}

"""
order by avg() on columns of table "payrolls"
"""
input PayrollsAvgOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""
Boolean expression to filter rows from the table "payrolls". All fields are combined with a logical 'AND'.
"""
input PayrollsBoolExp {
  _and: [PayrollsBoolExp!]
  _not: PayrollsBoolExp
  _or: [PayrollsBoolExp!]
  actualHours: NumericComparisonExp
  actualRevenue: NumericComparisonExp
  assignedManager: UsersBoolExp
  backupConsultant: UsersBoolExp
  backupConsultantUserId: UuidComparisonExp
  billingItems: BillingItemsBoolExp
  billingItemsAggregate: BillingItemsAggregateBoolExp
  billingStatus: StringComparisonExp
  childPayrolls: PayrollsBoolExp
  childPayrollsAggregate: PayrollsAggregateBoolExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  createdByUserId: UuidComparisonExp
  cycleId: UuidComparisonExp
  dateTypeId: UuidComparisonExp
  dateValue: IntComparisonExp
  employeeCount: IntComparisonExp
  estimatedHours: NumericComparisonExp
  estimatedRevenue: NumericComparisonExp
  files: FilesBoolExp
  filesAggregate: FilesAggregateBoolExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  lastBilledDate: TimestamptzComparisonExp
  managerUserId: UuidComparisonExp
  name: StringComparisonExp
  newEmployees: IntComparisonExp
  parentPayroll: PayrollsBoolExp
  parentPayrollId: UuidComparisonExp
  payrollCycle: PayrollCyclesBoolExp
  payrollDateType: PayrollDateTypesBoolExp
  payrollDates: PayrollDatesBoolExp
  payrollDatesAggregate: PayrollDatesAggregateBoolExp
  payrollSystem: StringComparisonExp
  payslipCount: IntComparisonExp
  primaryConsultant: UsersBoolExp
  primaryConsultantUserId: UuidComparisonExp
  processingDaysBeforeEft: IntComparisonExp
  processingTime: IntComparisonExp
  profitMargin: NumericComparisonExp
  requiredSkills: PayrollRequiredSkillsBoolExp
  requiredSkillsAggregate: PayrollRequiredSkillsAggregateBoolExp
  status: PayrollStatusComparisonExp
  supersededDate: DateComparisonExp
  terminatedEmployees: IntComparisonExp
  timeEntries: TimeEntriesBoolExp
  timeEntriesAggregate: TimeEntriesAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  versionNumber: IntComparisonExp
  versionReason: StringComparisonExp
}

"""
unique or primary key constraints on table "payrolls"
"""
enum PayrollsConstraint {
  """unique or primary key constraint on columns """
  only_one_current_version_per_family
  """
  unique or primary key constraint on columns "id"
  """
  payrolls_pkey
}

"""
input type for incrementing numeric columns in table "payrolls"
"""
input PayrollsIncInput {
  actualHours: numeric
  actualRevenue: numeric
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  """Number of new employees processed"""
  newEmployees: Int
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  profitMargin: numeric
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  versionNumber: Int
}

"""
input type for inserting data into table "payrolls"
"""
input PayrollsInsertInput {
  actualHours: numeric
  actualRevenue: numeric
  assignedManager: UsersObjRelInsertInput
  backupConsultant: UsersObjRelInsertInput
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  billingItems: BillingItemsArrRelInsertInput
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: String
  childPayrolls: PayrollsArrRelInsertInput
  client: ClientsObjRelInsertInput
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  files: FilesArrRelInsertInput
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  lastBilledDate: timestamptz
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  """Number of new employees processed"""
  newEmployees: Int
  parentPayroll: PayrollsObjRelInsertInput
  parentPayrollId: uuid
  payrollCycle: PayrollCyclesObjRelInsertInput
  payrollDateType: PayrollDateTypesObjRelInsertInput
  payrollDates: PayrollDatesArrRelInsertInput
  """External payroll system used for this client"""
  payrollSystem: String
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  primaryConsultant: UsersObjRelInsertInput
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  profitMargin: numeric
  requiredSkills: PayrollRequiredSkillsArrRelInsertInput
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  timeEntries: TimeEntriesArrRelInsertInput
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate max on columns"""
type PayrollsMaxFields {
  actualHours: numeric
  actualRevenue: numeric
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: String
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  lastBilledDate: timestamptz
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  """Number of new employees processed"""
  newEmployees: Int
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  profitMargin: numeric
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
order by max() on columns of table "payrolls"
"""
input PayrollsMaxOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Backup consultant for this payroll"""
  backupConsultantUserId: OrderBy
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: OrderBy
  """Reference to the client this payroll belongs to"""
  clientId: OrderBy
  """Timestamp when the payroll was created"""
  createdAt: OrderBy
  createdByUserId: OrderBy
  """Reference to the payroll cycle"""
  cycleId: OrderBy
  """Reference to the payroll date type"""
  dateTypeId: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """The date when the payroll went live in the system"""
  goLiveDate: OrderBy
  """Unique identifier for the payroll"""
  id: OrderBy
  lastBilledDate: OrderBy
  """Manager overseeing this payroll"""
  managerUserId: OrderBy
  """Name of the payroll"""
  name: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  parentPayrollId: OrderBy
  """External payroll system used for this client"""
  payrollSystem: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: OrderBy
  supersededDate: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  """Timestamp when the payroll was last updated"""
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""aggregate min on columns"""
type PayrollsMinFields {
  actualHours: numeric
  actualRevenue: numeric
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: String
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  lastBilledDate: timestamptz
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  """Number of new employees processed"""
  newEmployees: Int
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  profitMargin: numeric
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
order by min() on columns of table "payrolls"
"""
input PayrollsMinOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Backup consultant for this payroll"""
  backupConsultantUserId: OrderBy
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: OrderBy
  """Reference to the client this payroll belongs to"""
  clientId: OrderBy
  """Timestamp when the payroll was created"""
  createdAt: OrderBy
  createdByUserId: OrderBy
  """Reference to the payroll cycle"""
  cycleId: OrderBy
  """Reference to the payroll date type"""
  dateTypeId: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """The date when the payroll went live in the system"""
  goLiveDate: OrderBy
  """Unique identifier for the payroll"""
  id: OrderBy
  lastBilledDate: OrderBy
  """Manager overseeing this payroll"""
  managerUserId: OrderBy
  """Name of the payroll"""
  name: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  parentPayrollId: OrderBy
  """External payroll system used for this client"""
  payrollSystem: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: OrderBy
  supersededDate: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  """Timestamp when the payroll was last updated"""
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""
response of any mutation on the table "payrolls"
"""
type PayrollsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Payrolls!]!
}

"""
input type for inserting object relation for remote table "payrolls"
"""
input PayrollsObjRelInsertInput {
  data: PayrollsInsertInput!
  """upsert condition"""
  onConflict: PayrollsOnConflict
}

"""
on_conflict condition type for table "payrolls"
"""
input PayrollsOnConflict {
  constraint: PayrollsConstraint!
  updateColumns: [PayrollsUpdateColumn!]! = []
  where: PayrollsBoolExp
}

"""Ordering options when selecting data from "payrolls"."""
input PayrollsOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  assignedManager: UsersOrderBy
  backupConsultant: UsersOrderBy
  backupConsultantUserId: OrderBy
  billingItemsAggregate: BillingItemsAggregateOrderBy
  billingStatus: OrderBy
  childPayrollsAggregate: PayrollsAggregateOrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  createdByUserId: OrderBy
  cycleId: OrderBy
  dateTypeId: OrderBy
  dateValue: OrderBy
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  filesAggregate: FilesAggregateOrderBy
  goLiveDate: OrderBy
  id: OrderBy
  lastBilledDate: OrderBy
  managerUserId: OrderBy
  name: OrderBy
  newEmployees: OrderBy
  parentPayroll: PayrollsOrderBy
  parentPayrollId: OrderBy
  payrollCycle: PayrollCyclesOrderBy
  payrollDateType: PayrollDateTypesOrderBy
  payrollDatesAggregate: PayrollDatesAggregateOrderBy
  payrollSystem: OrderBy
  payslipCount: OrderBy
  primaryConsultant: UsersOrderBy
  primaryConsultantUserId: OrderBy
  processingDaysBeforeEft: OrderBy
  processingTime: OrderBy
  profitMargin: OrderBy
  requiredSkillsAggregate: PayrollRequiredSkillsAggregateOrderBy
  status: OrderBy
  supersededDate: OrderBy
  terminatedEmployees: OrderBy
  timeEntriesAggregate: TimeEntriesAggregateOrderBy
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""primary key columns input for table: payrolls"""
input PayrollsPkColumnsInput {
  """Unique identifier for the payroll"""
  id: uuid!
}

"""
select columns of table "payrolls"
"""
enum PayrollsSelectColumn {
  """column name"""
  actualHours
  """column name"""
  actualRevenue
  """column name"""
  backupConsultantUserId
  """column name"""
  billingStatus
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  dateValue
  """column name"""
  employeeCount
  """column name"""
  estimatedHours
  """column name"""
  estimatedRevenue
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  lastBilledDate
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  newEmployees
  """column name"""
  parentPayrollId
  """column name"""
  payrollSystem
  """column name"""
  payslipCount
  """column name"""
  primaryConsultantUserId
  """column name"""
  processingDaysBeforeEft
  """column name"""
  processingTime
  """column name"""
  profitMargin
  """column name"""
  status
  """column name"""
  supersededDate
  """column name"""
  terminatedEmployees
  """column name"""
  updatedAt
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

"""
input type for updating data in table "payrolls"
"""
input PayrollsSetInput {
  actualHours: numeric
  actualRevenue: numeric
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: String
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  lastBilledDate: timestamptz
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  """Number of new employees processed"""
  newEmployees: Int
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  profitMargin: numeric
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate stddev on columns"""
type PayrollsStddevFields {
  actualHours: Float
  actualRevenue: Float
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  estimatedHours: Float
  estimatedRevenue: Float
  """Number of new employees processed"""
  newEmployees: Float
  """Number of payslips processed in this payroll run"""
  payslipCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  profitMargin: Float
  """Number of terminated employees processed"""
  terminatedEmployees: Float
  versionNumber: Float
}

"""
order by stddev() on columns of table "payrolls"
"""
input PayrollsStddevOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""aggregate stddevPop on columns"""
type PayrollsStddevPopFields {
  actualHours: Float
  actualRevenue: Float
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  estimatedHours: Float
  estimatedRevenue: Float
  """Number of new employees processed"""
  newEmployees: Float
  """Number of payslips processed in this payroll run"""
  payslipCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  profitMargin: Float
  """Number of terminated employees processed"""
  terminatedEmployees: Float
  versionNumber: Float
}

"""
order by stddevPop() on columns of table "payrolls"
"""
input PayrollsStddevPopOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""aggregate stddevSamp on columns"""
type PayrollsStddevSampFields {
  actualHours: Float
  actualRevenue: Float
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  estimatedHours: Float
  estimatedRevenue: Float
  """Number of new employees processed"""
  newEmployees: Float
  """Number of payslips processed in this payroll run"""
  payslipCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  profitMargin: Float
  """Number of terminated employees processed"""
  terminatedEmployees: Float
  versionNumber: Float
}

"""
order by stddevSamp() on columns of table "payrolls"
"""
input PayrollsStddevSampOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""
Streaming cursor of the table "payrolls"
"""
input PayrollsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayrollsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayrollsStreamCursorValueInput {
  actualHours: numeric
  actualRevenue: numeric
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Billing status: pending, items_added, ready_to_bill, billed"""
  billingStatus: String
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  lastBilledDate: timestamptz
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  """Number of new employees processed"""
  newEmployees: Int
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  profitMargin: numeric
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate sum on columns"""
type PayrollsSumFields {
  actualHours: numeric
  actualRevenue: numeric
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  estimatedHours: numeric
  estimatedRevenue: numeric
  """Number of new employees processed"""
  newEmployees: Int
  """Number of payslips processed in this payroll run"""
  payslipCount: Int
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  profitMargin: numeric
  """Number of terminated employees processed"""
  terminatedEmployees: Int
  versionNumber: Int
}

"""
order by sum() on columns of table "payrolls"
"""
input PayrollsSumOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""
update columns of table "payrolls"
"""
enum PayrollsUpdateColumn {
  """column name"""
  actualHours
  """column name"""
  actualRevenue
  """column name"""
  backupConsultantUserId
  """column name"""
  billingStatus
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  dateValue
  """column name"""
  employeeCount
  """column name"""
  estimatedHours
  """column name"""
  estimatedRevenue
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  lastBilledDate
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  newEmployees
  """column name"""
  parentPayrollId
  """column name"""
  payrollSystem
  """column name"""
  payslipCount
  """column name"""
  primaryConsultantUserId
  """column name"""
  processingDaysBeforeEft
  """column name"""
  processingTime
  """column name"""
  profitMargin
  """column name"""
  status
  """column name"""
  supersededDate
  """column name"""
  terminatedEmployees
  """column name"""
  updatedAt
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

input PayrollsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PayrollsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: PayrollsSetInput
  """filter the rows which have to be updated"""
  where: PayrollsBoolExp!
}

"""aggregate varPop on columns"""
type PayrollsVarPopFields {
  actualHours: Float
  actualRevenue: Float
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  estimatedHours: Float
  estimatedRevenue: Float
  """Number of new employees processed"""
  newEmployees: Float
  """Number of payslips processed in this payroll run"""
  payslipCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  profitMargin: Float
  """Number of terminated employees processed"""
  terminatedEmployees: Float
  versionNumber: Float
}

"""
order by varPop() on columns of table "payrolls"
"""
input PayrollsVarPopOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""aggregate varSamp on columns"""
type PayrollsVarSampFields {
  actualHours: Float
  actualRevenue: Float
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  estimatedHours: Float
  estimatedRevenue: Float
  """Number of new employees processed"""
  newEmployees: Float
  """Number of payslips processed in this payroll run"""
  payslipCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  profitMargin: Float
  """Number of terminated employees processed"""
  terminatedEmployees: Float
  versionNumber: Float
}

"""
order by varSamp() on columns of table "payrolls"
"""
input PayrollsVarSampOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""aggregate variance on columns"""
type PayrollsVarianceFields {
  actualHours: Float
  actualRevenue: Float
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  estimatedHours: Float
  estimatedRevenue: Float
  """Number of new employees processed"""
  newEmployees: Float
  """Number of payslips processed in this payroll run"""
  payslipCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  profitMargin: Float
  """Number of terminated employees processed"""
  terminatedEmployees: Float
  versionNumber: Float
}

"""
order by variance() on columns of table "payrolls"
"""
input PayrollsVarianceOrderBy {
  actualHours: OrderBy
  actualRevenue: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  estimatedHours: OrderBy
  estimatedRevenue: OrderBy
  """Number of new employees processed"""
  newEmployees: OrderBy
  """Number of payslips processed in this payroll run"""
  payslipCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  profitMargin: OrderBy
  """Number of terminated employees processed"""
  terminatedEmployees: OrderBy
  versionNumber: OrderBy
}

"""All billing items awaiting manager approval"""
type PendingBillingApprovals {
  amount: numeric
  clientId: uuid
  clientName: String
  createdAt: timestamp
  daysPending: numeric
  description: String
  id: uuid
  isAutoGenerated: Boolean
  payrollId: uuid
  payrollName: String
  quantity: Int
  serviceCategory: String
  serviceId: uuid
  serviceName: String
  staffName: String
  staffUserId: uuid
  unitPrice: numeric
}

"""
aggregated selection of "pending_billing_approvals"
"""
type PendingBillingApprovalsAggregate {
  aggregate: PendingBillingApprovalsAggregateFields
  nodes: [PendingBillingApprovals!]!
}

"""
aggregate fields of "pending_billing_approvals"
"""
type PendingBillingApprovalsAggregateFields {
  avg: PendingBillingApprovalsAvgFields
  count(columns: [PendingBillingApprovalsSelectColumn!], distinct: Boolean): Int!
  max: PendingBillingApprovalsMaxFields
  min: PendingBillingApprovalsMinFields
  stddev: PendingBillingApprovalsStddevFields
  stddevPop: PendingBillingApprovalsStddevPopFields
  stddevSamp: PendingBillingApprovalsStddevSampFields
  sum: PendingBillingApprovalsSumFields
  varPop: PendingBillingApprovalsVarPopFields
  varSamp: PendingBillingApprovalsVarSampFields
  variance: PendingBillingApprovalsVarianceFields
}

"""aggregate avg on columns"""
type PendingBillingApprovalsAvgFields {
  amount: Float
  daysPending: Float
  quantity: Float
  unitPrice: Float
}

"""
Boolean expression to filter rows from the table "pending_billing_approvals". All fields are combined with a logical 'AND'.
"""
input PendingBillingApprovalsBoolExp {
  _and: [PendingBillingApprovalsBoolExp!]
  _not: PendingBillingApprovalsBoolExp
  _or: [PendingBillingApprovalsBoolExp!]
  amount: NumericComparisonExp
  clientId: UuidComparisonExp
  clientName: StringComparisonExp
  createdAt: TimestampComparisonExp
  daysPending: NumericComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  isAutoGenerated: BooleanComparisonExp
  payrollId: UuidComparisonExp
  payrollName: StringComparisonExp
  quantity: IntComparisonExp
  serviceCategory: StringComparisonExp
  serviceId: UuidComparisonExp
  serviceName: StringComparisonExp
  staffName: StringComparisonExp
  staffUserId: UuidComparisonExp
  unitPrice: NumericComparisonExp
}

"""aggregate max on columns"""
type PendingBillingApprovalsMaxFields {
  amount: numeric
  clientId: uuid
  clientName: String
  createdAt: timestamp
  daysPending: numeric
  description: String
  id: uuid
  payrollId: uuid
  payrollName: String
  quantity: Int
  serviceCategory: String
  serviceId: uuid
  serviceName: String
  staffName: String
  staffUserId: uuid
  unitPrice: numeric
}

"""aggregate min on columns"""
type PendingBillingApprovalsMinFields {
  amount: numeric
  clientId: uuid
  clientName: String
  createdAt: timestamp
  daysPending: numeric
  description: String
  id: uuid
  payrollId: uuid
  payrollName: String
  quantity: Int
  serviceCategory: String
  serviceId: uuid
  serviceName: String
  staffName: String
  staffUserId: uuid
  unitPrice: numeric
}

"""Ordering options when selecting data from "pending_billing_approvals"."""
input PendingBillingApprovalsOrderBy {
  amount: OrderBy
  clientId: OrderBy
  clientName: OrderBy
  createdAt: OrderBy
  daysPending: OrderBy
  description: OrderBy
  id: OrderBy
  isAutoGenerated: OrderBy
  payrollId: OrderBy
  payrollName: OrderBy
  quantity: OrderBy
  serviceCategory: OrderBy
  serviceId: OrderBy
  serviceName: OrderBy
  staffName: OrderBy
  staffUserId: OrderBy
  unitPrice: OrderBy
}

"""
select columns of table "pending_billing_approvals"
"""
enum PendingBillingApprovalsSelectColumn {
  """column name"""
  amount
  """column name"""
  clientId
  """column name"""
  clientName
  """column name"""
  createdAt
  """column name"""
  daysPending
  """column name"""
  description
  """column name"""
  id
  """column name"""
  isAutoGenerated
  """column name"""
  payrollId
  """column name"""
  payrollName
  """column name"""
  quantity
  """column name"""
  serviceCategory
  """column name"""
  serviceId
  """column name"""
  serviceName
  """column name"""
  staffName
  """column name"""
  staffUserId
  """column name"""
  unitPrice
}

"""aggregate stddev on columns"""
type PendingBillingApprovalsStddevFields {
  amount: Float
  daysPending: Float
  quantity: Float
  unitPrice: Float
}

"""aggregate stddevPop on columns"""
type PendingBillingApprovalsStddevPopFields {
  amount: Float
  daysPending: Float
  quantity: Float
  unitPrice: Float
}

"""aggregate stddevSamp on columns"""
type PendingBillingApprovalsStddevSampFields {
  amount: Float
  daysPending: Float
  quantity: Float
  unitPrice: Float
}

"""
Streaming cursor of the table "pending_billing_approvals"
"""
input PendingBillingApprovalsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PendingBillingApprovalsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PendingBillingApprovalsStreamCursorValueInput {
  amount: numeric
  clientId: uuid
  clientName: String
  createdAt: timestamp
  daysPending: numeric
  description: String
  id: uuid
  isAutoGenerated: Boolean
  payrollId: uuid
  payrollName: String
  quantity: Int
  serviceCategory: String
  serviceId: uuid
  serviceName: String
  staffName: String
  staffUserId: uuid
  unitPrice: numeric
}

"""aggregate sum on columns"""
type PendingBillingApprovalsSumFields {
  amount: numeric
  daysPending: numeric
  quantity: Int
  unitPrice: numeric
}

"""aggregate varPop on columns"""
type PendingBillingApprovalsVarPopFields {
  amount: Float
  daysPending: Float
  quantity: Float
  unitPrice: Float
}

"""aggregate varSamp on columns"""
type PendingBillingApprovalsVarSampFields {
  amount: Float
  daysPending: Float
  quantity: Float
  unitPrice: Float
}

"""aggregate variance on columns"""
type PendingBillingApprovalsVarianceFields {
  amount: Float
  daysPending: Float
  quantity: Float
  unitPrice: Float
}

"""
Boolean expression to compare columns of type "permission_action". All fields are combined with logical 'AND'.
"""
input PermissionActionComparisonExp {
  _eq: permission_action
  _gt: permission_action
  _gte: permission_action
  _in: [permission_action!]
  _isNull: Boolean
  _lt: permission_action
  _lte: permission_action
  _neq: permission_action
  _nin: [permission_action!]
}

"""Audit log for permission changes and access attempts"""
type PermissionAuditLog {
  action: String!
  createdAt: timestamptz!
  id: uuid!
  newValue(
    """JSON select path"""
    path: String
  ): jsonb
  operation: String!
  previousValue(
    """JSON select path"""
    path: String
  ): jsonb
  reason: String
  resource: String!
  targetRole: String
  """An object relationship"""
  targetUser: Users
  targetUserId: uuid
  timestamp: timestamptz!
  """An object relationship"""
  user: Users
  userId: uuid
}

"""
aggregated selection of "permission_audit_log"
"""
type PermissionAuditLogAggregate {
  aggregate: PermissionAuditLogAggregateFields
  nodes: [PermissionAuditLog!]!
}

input PermissionAuditLogAggregateBoolExp {
  count: permissionAuditLogAggregateBoolExpCount
}

"""
aggregate fields of "permission_audit_log"
"""
type PermissionAuditLogAggregateFields {
  count(columns: [PermissionAuditLogSelectColumn!], distinct: Boolean): Int!
  max: PermissionAuditLogMaxFields
  min: PermissionAuditLogMinFields
}

"""
order by aggregate values of table "permission_audit_log"
"""
input PermissionAuditLogAggregateOrderBy {
  count: OrderBy
  max: PermissionAuditLogMaxOrderBy
  min: PermissionAuditLogMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PermissionAuditLogAppendInput {
  newValue: jsonb
  previousValue: jsonb
}

"""
input type for inserting array relation for remote table "permission_audit_log"
"""
input PermissionAuditLogArrRelInsertInput {
  data: [PermissionAuditLogInsertInput!]!
  """upsert condition"""
  onConflict: PermissionAuditLogOnConflict
}

"""
Boolean expression to filter rows from the table "permission_audit_log". All fields are combined with a logical 'AND'.
"""
input PermissionAuditLogBoolExp {
  _and: [PermissionAuditLogBoolExp!]
  _not: PermissionAuditLogBoolExp
  _or: [PermissionAuditLogBoolExp!]
  action: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  newValue: JsonbComparisonExp
  operation: StringComparisonExp
  previousValue: JsonbComparisonExp
  reason: StringComparisonExp
  resource: StringComparisonExp
  targetRole: StringComparisonExp
  targetUser: UsersBoolExp
  targetUserId: UuidComparisonExp
  timestamp: TimestamptzComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "permission_audit_log"
"""
enum PermissionAuditLogConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PermissionAuditLogDeleteAtPathInput {
  newValue: [String!]
  previousValue: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PermissionAuditLogDeleteElemInput {
  newValue: Int
  previousValue: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PermissionAuditLogDeleteKeyInput {
  newValue: String
  previousValue: String
}

"""
input type for inserting data into table "permission_audit_log"
"""
input PermissionAuditLogInsertInput {
  action: String
  createdAt: timestamptz
  id: uuid
  newValue: jsonb
  operation: String
  previousValue: jsonb
  reason: String
  resource: String
  targetRole: String
  targetUser: UsersObjRelInsertInput
  targetUserId: uuid
  timestamp: timestamptz
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type PermissionAuditLogMaxFields {
  action: String
  createdAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "permission_audit_log"
"""
input PermissionAuditLogMaxOrderBy {
  action: OrderBy
  createdAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  targetRole: OrderBy
  targetUserId: OrderBy
  timestamp: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type PermissionAuditLogMinFields {
  action: String
  createdAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "permission_audit_log"
"""
input PermissionAuditLogMinOrderBy {
  action: OrderBy
  createdAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  targetRole: OrderBy
  targetUserId: OrderBy
  timestamp: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "permission_audit_log"
"""
type PermissionAuditLogMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PermissionAuditLog!]!
}

"""
on_conflict condition type for table "permission_audit_log"
"""
input PermissionAuditLogOnConflict {
  constraint: PermissionAuditLogConstraint!
  updateColumns: [PermissionAuditLogUpdateColumn!]! = []
  where: PermissionAuditLogBoolExp
}

"""Ordering options when selecting data from "permission_audit_log"."""
input PermissionAuditLogOrderBy {
  action: OrderBy
  createdAt: OrderBy
  id: OrderBy
  newValue: OrderBy
  operation: OrderBy
  previousValue: OrderBy
  reason: OrderBy
  resource: OrderBy
  targetRole: OrderBy
  targetUser: UsersOrderBy
  targetUserId: OrderBy
  timestamp: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""primary key columns input for table: permission_audit_log"""
input PermissionAuditLogPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PermissionAuditLogPrependInput {
  newValue: jsonb
  previousValue: jsonb
}

"""
select columns of table "permission_audit_log"
"""
enum PermissionAuditLogSelectColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  newValue
  """column name"""
  operation
  """column name"""
  previousValue
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  targetRole
  """column name"""
  targetUserId
  """column name"""
  timestamp
  """column name"""
  userId
}

"""
input type for updating data in table "permission_audit_log"
"""
input PermissionAuditLogSetInput {
  action: String
  createdAt: timestamptz
  id: uuid
  newValue: jsonb
  operation: String
  previousValue: jsonb
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "permission_audit_log"
"""
input PermissionAuditLogStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PermissionAuditLogStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PermissionAuditLogStreamCursorValueInput {
  action: String
  createdAt: timestamptz
  id: uuid
  newValue: jsonb
  operation: String
  previousValue: jsonb
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
update columns of table "permission_audit_log"
"""
enum PermissionAuditLogUpdateColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  newValue
  """column name"""
  operation
  """column name"""
  previousValue
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  targetRole
  """column name"""
  targetUserId
  """column name"""
  timestamp
  """column name"""
  userId
}

input PermissionAuditLogUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PermissionAuditLogAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PermissionAuditLogDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PermissionAuditLogDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PermissionAuditLogDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PermissionAuditLogPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: PermissionAuditLogSetInput
  """filter the rows which have to be updated"""
  where: PermissionAuditLogBoolExp!
}

"""User-specific and role-specific permission overrides"""
type PermissionOverrides {
  """JSON conditions for conditional permissions"""
  conditions(
    """JSON select path"""
    path: String
  ): jsonb
  createdAt: timestamptz!
  createdBy: uuid
  """An object relationship"""
  createdByUser: Users
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean!
  id: uuid!
  operation: String!
  reason: String
  resource: String!
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz!
  """An object relationship"""
  user: Users
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
aggregated selection of "permission_overrides"
"""
type PermissionOverridesAggregate {
  aggregate: PermissionOverridesAggregateFields
  nodes: [PermissionOverrides!]!
}

input PermissionOverridesAggregateBoolExp {
  bool_and: permissionOverridesAggregateBoolExpBool_and
  bool_or: permissionOverridesAggregateBoolExpBool_or
  count: permissionOverridesAggregateBoolExpCount
}

"""
aggregate fields of "permission_overrides"
"""
type PermissionOverridesAggregateFields {
  count(columns: [PermissionOverridesSelectColumn!], distinct: Boolean): Int!
  max: PermissionOverridesMaxFields
  min: PermissionOverridesMinFields
}

"""
order by aggregate values of table "permission_overrides"
"""
input PermissionOverridesAggregateOrderBy {
  count: OrderBy
  max: PermissionOverridesMaxOrderBy
  min: PermissionOverridesMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input PermissionOverridesAppendInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
}

"""
input type for inserting array relation for remote table "permission_overrides"
"""
input PermissionOverridesArrRelInsertInput {
  data: [PermissionOverridesInsertInput!]!
  """upsert condition"""
  onConflict: PermissionOverridesOnConflict
}

"""
Boolean expression to filter rows from the table "permission_overrides". All fields are combined with a logical 'AND'.
"""
input PermissionOverridesBoolExp {
  _and: [PermissionOverridesBoolExp!]
  _not: PermissionOverridesBoolExp
  _or: [PermissionOverridesBoolExp!]
  conditions: JsonbComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  expiresAt: TimestamptzComparisonExp
  granted: BooleanComparisonExp
  id: UuidComparisonExp
  operation: StringComparisonExp
  reason: StringComparisonExp
  resource: StringComparisonExp
  role: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "permission_overrides"
"""
enum PermissionOverridesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_overrides_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PermissionOverridesDeleteAtPathInput {
  """JSON conditions for conditional permissions"""
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PermissionOverridesDeleteElemInput {
  """JSON conditions for conditional permissions"""
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PermissionOverridesDeleteKeyInput {
  """JSON conditions for conditional permissions"""
  conditions: String
}

"""
input type for inserting data into table "permission_overrides"
"""
input PermissionOverridesInsertInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  user: UsersObjRelInsertInput
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""aggregate max on columns"""
type PermissionOverridesMaxFields {
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
order by max() on columns of table "permission_overrides"
"""
input PermissionOverridesMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  """When this override expires (NULL for permanent)"""
  expiresAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: OrderBy
  updatedAt: OrderBy
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: OrderBy
}

"""aggregate min on columns"""
type PermissionOverridesMinFields {
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
order by min() on columns of table "permission_overrides"
"""
input PermissionOverridesMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  """When this override expires (NULL for permanent)"""
  expiresAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: OrderBy
  updatedAt: OrderBy
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: OrderBy
}

"""
response of any mutation on the table "permission_overrides"
"""
type PermissionOverridesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PermissionOverrides!]!
}

"""
on_conflict condition type for table "permission_overrides"
"""
input PermissionOverridesOnConflict {
  constraint: PermissionOverridesConstraint!
  updateColumns: [PermissionOverridesUpdateColumn!]! = []
  where: PermissionOverridesBoolExp
}

"""Ordering options when selecting data from "permission_overrides"."""
input PermissionOverridesOrderBy {
  conditions: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  expiresAt: OrderBy
  granted: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  role: OrderBy
  updatedAt: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""primary key columns input for table: permission_overrides"""
input PermissionOverridesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input PermissionOverridesPrependInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
}

"""
select columns of table "permission_overrides"
"""
enum PermissionOverridesSelectColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  expiresAt
  """column name"""
  granted
  """column name"""
  id
  """column name"""
  operation
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  role
  """column name"""
  updatedAt
  """column name"""
  userId
}

"""
select "permissionOverridesAggregateBoolExpBool_andArgumentsColumns" columns of table "permission_overrides"
"""
enum PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  granted
}

"""
select "permissionOverridesAggregateBoolExpBool_orArgumentsColumns" columns of table "permission_overrides"
"""
enum PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  granted
}

"""
input type for updating data in table "permission_overrides"
"""
input PermissionOverridesSetInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
Streaming cursor of the table "permission_overrides"
"""
input PermissionOverridesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PermissionOverridesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PermissionOverridesStreamCursorValueInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
update columns of table "permission_overrides"
"""
enum PermissionOverridesUpdateColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  expiresAt
  """column name"""
  granted
  """column name"""
  id
  """column name"""
  operation
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  role
  """column name"""
  updatedAt
  """column name"""
  userId
}

input PermissionOverridesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: PermissionOverridesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PermissionOverridesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PermissionOverridesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PermissionOverridesDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: PermissionOverridesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: PermissionOverridesSetInput
  """filter the rows which have to be updated"""
  where: PermissionOverridesBoolExp!
}

"""
columns and relationships of "permissions"
"""
type Permissions {
  action: permission_action!
  createdAt: timestamptz!
  description: String
  id: uuid!
  legacyPermissionName: String
  """An object relationship"""
  resource: Resources!
  resourceId: uuid!
  """An array relationship"""
  rolePermissions(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): [RolePermissions!]!
  """An aggregate relationship"""
  rolePermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): RolePermissionsAggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "permissions"
"""
type PermissionsAggregate {
  aggregate: PermissionsAggregateFields
  nodes: [Permissions!]!
}

input PermissionsAggregateBoolExp {
  count: permissionsAggregateBoolExpCount
}

"""
aggregate fields of "permissions"
"""
type PermissionsAggregateFields {
  count(columns: [PermissionsSelectColumn!], distinct: Boolean): Int!
  max: PermissionsMaxFields
  min: PermissionsMinFields
}

"""
order by aggregate values of table "permissions"
"""
input PermissionsAggregateOrderBy {
  count: OrderBy
  max: PermissionsMaxOrderBy
  min: PermissionsMinOrderBy
}

"""
input type for inserting array relation for remote table "permissions"
"""
input PermissionsArrRelInsertInput {
  data: [PermissionsInsertInput!]!
  """upsert condition"""
  onConflict: PermissionsOnConflict
}

"""
Boolean expression to filter rows from the table "permissions". All fields are combined with a logical 'AND'.
"""
input PermissionsBoolExp {
  _and: [PermissionsBoolExp!]
  _not: PermissionsBoolExp
  _or: [PermissionsBoolExp!]
  action: PermissionActionComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  legacyPermissionName: StringComparisonExp
  resource: ResourcesBoolExp
  resourceId: UuidComparisonExp
  rolePermissions: RolePermissionsBoolExp
  rolePermissionsAggregate: RolePermissionsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "permissions"
"""
enum PermissionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permissions_pkey
  """
  unique or primary key constraint on columns "action", "resource_id"
  """
  permissions_resource_id_action_key
}

"""
input type for inserting data into table "permissions"
"""
input PermissionsInsertInput {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resource: ResourcesObjRelInsertInput
  resourceId: uuid
  rolePermissions: RolePermissionsArrRelInsertInput
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type PermissionsMaxFields {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "permissions"
"""
input PermissionsMaxOrderBy {
  action: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  legacyPermissionName: OrderBy
  resourceId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type PermissionsMinFields {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "permissions"
"""
input PermissionsMinOrderBy {
  action: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  legacyPermissionName: OrderBy
  resourceId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "permissions"
"""
type PermissionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Permissions!]!
}

"""
input type for inserting object relation for remote table "permissions"
"""
input PermissionsObjRelInsertInput {
  data: PermissionsInsertInput!
  """upsert condition"""
  onConflict: PermissionsOnConflict
}

"""
on_conflict condition type for table "permissions"
"""
input PermissionsOnConflict {
  constraint: PermissionsConstraint!
  updateColumns: [PermissionsUpdateColumn!]! = []
  where: PermissionsBoolExp
}

"""Ordering options when selecting data from "permissions"."""
input PermissionsOrderBy {
  action: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  legacyPermissionName: OrderBy
  resource: ResourcesOrderBy
  resourceId: OrderBy
  rolePermissionsAggregate: RolePermissionsAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: permissions"""
input PermissionsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "permissions"
"""
enum PermissionsSelectColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  legacyPermissionName
  """column name"""
  resourceId
  """column name"""
  updatedAt
}

"""
input type for updating data in table "permissions"
"""
input PermissionsSetInput {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "permissions"
"""
input PermissionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PermissionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PermissionsStreamCursorValueInput {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "permissions"
"""
enum PermissionsUpdateColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  legacyPermissionName
  """column name"""
  resourceId
  """column name"""
  updatedAt
}

input PermissionsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: PermissionsSetInput
  """filter the rows which have to be updated"""
  where: PermissionsBoolExp!
}

"""
columns and relationships of "position_admin_defaults"
"""
type PositionAdminDefaults {
  defaultAdminPercentage: numeric!
  description: String
  position: user_position!
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
aggregated selection of "position_admin_defaults"
"""
type PositionAdminDefaultsAggregate {
  aggregate: PositionAdminDefaultsAggregateFields
  nodes: [PositionAdminDefaults!]!
}

"""
aggregate fields of "position_admin_defaults"
"""
type PositionAdminDefaultsAggregateFields {
  avg: PositionAdminDefaultsAvgFields
  count(columns: [PositionAdminDefaultsSelectColumn!], distinct: Boolean): Int!
  max: PositionAdminDefaultsMaxFields
  min: PositionAdminDefaultsMinFields
  stddev: PositionAdminDefaultsStddevFields
  stddevPop: PositionAdminDefaultsStddevPopFields
  stddevSamp: PositionAdminDefaultsStddevSampFields
  sum: PositionAdminDefaultsSumFields
  varPop: PositionAdminDefaultsVarPopFields
  varSamp: PositionAdminDefaultsVarSampFields
  variance: PositionAdminDefaultsVarianceFields
}

"""aggregate avg on columns"""
type PositionAdminDefaultsAvgFields {
  defaultAdminPercentage: Float
}

"""
Boolean expression to filter rows from the table "position_admin_defaults". All fields are combined with a logical 'AND'.
"""
input PositionAdminDefaultsBoolExp {
  _and: [PositionAdminDefaultsBoolExp!]
  _not: PositionAdminDefaultsBoolExp
  _or: [PositionAdminDefaultsBoolExp!]
  defaultAdminPercentage: NumericComparisonExp
  description: StringComparisonExp
  position: UserPositionComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: UuidComparisonExp
}

"""
unique or primary key constraints on table "position_admin_defaults"
"""
enum PositionAdminDefaultsConstraint {
  """
  unique or primary key constraint on columns "position"
  """
  position_admin_defaults_pkey
}

"""
input type for incrementing numeric columns in table "position_admin_defaults"
"""
input PositionAdminDefaultsIncInput {
  defaultAdminPercentage: numeric
}

"""
input type for inserting data into table "position_admin_defaults"
"""
input PositionAdminDefaultsInsertInput {
  defaultAdminPercentage: numeric
  description: String
  position: user_position
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate max on columns"""
type PositionAdminDefaultsMaxFields {
  defaultAdminPercentage: numeric
  description: String
  position: user_position
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate min on columns"""
type PositionAdminDefaultsMinFields {
  defaultAdminPercentage: numeric
  description: String
  position: user_position
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
response of any mutation on the table "position_admin_defaults"
"""
type PositionAdminDefaultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [PositionAdminDefaults!]!
}

"""
on_conflict condition type for table "position_admin_defaults"
"""
input PositionAdminDefaultsOnConflict {
  constraint: PositionAdminDefaultsConstraint!
  updateColumns: [PositionAdminDefaultsUpdateColumn!]! = []
  where: PositionAdminDefaultsBoolExp
}

"""Ordering options when selecting data from "position_admin_defaults"."""
input PositionAdminDefaultsOrderBy {
  defaultAdminPercentage: OrderBy
  description: OrderBy
  position: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""primary key columns input for table: position_admin_defaults"""
input PositionAdminDefaultsPkColumnsInput {
  position: user_position!
}

"""
select columns of table "position_admin_defaults"
"""
enum PositionAdminDefaultsSelectColumn {
  """column name"""
  defaultAdminPercentage
  """column name"""
  description
  """column name"""
  position
  """column name"""
  updatedAt
  """column name"""
  updatedBy
}

"""
input type for updating data in table "position_admin_defaults"
"""
input PositionAdminDefaultsSetInput {
  defaultAdminPercentage: numeric
  description: String
  position: user_position
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate stddev on columns"""
type PositionAdminDefaultsStddevFields {
  defaultAdminPercentage: Float
}

"""aggregate stddevPop on columns"""
type PositionAdminDefaultsStddevPopFields {
  defaultAdminPercentage: Float
}

"""aggregate stddevSamp on columns"""
type PositionAdminDefaultsStddevSampFields {
  defaultAdminPercentage: Float
}

"""
Streaming cursor of the table "position_admin_defaults"
"""
input PositionAdminDefaultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PositionAdminDefaultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PositionAdminDefaultsStreamCursorValueInput {
  defaultAdminPercentage: numeric
  description: String
  position: user_position
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate sum on columns"""
type PositionAdminDefaultsSumFields {
  defaultAdminPercentage: numeric
}

"""
update columns of table "position_admin_defaults"
"""
enum PositionAdminDefaultsUpdateColumn {
  """column name"""
  defaultAdminPercentage
  """column name"""
  description
  """column name"""
  position
  """column name"""
  updatedAt
  """column name"""
  updatedBy
}

input PositionAdminDefaultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: PositionAdminDefaultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: PositionAdminDefaultsSetInput
  """filter the rows which have to be updated"""
  where: PositionAdminDefaultsBoolExp!
}

"""aggregate varPop on columns"""
type PositionAdminDefaultsVarPopFields {
  defaultAdminPercentage: Float
}

"""aggregate varSamp on columns"""
type PositionAdminDefaultsVarSampFields {
  defaultAdminPercentage: Float
}

"""aggregate variance on columns"""
type PositionAdminDefaultsVarianceFields {
  defaultAdminPercentage: Float
}

"""
columns and relationships of "quote_analytics"
"""
type QuoteAnalytics {
  clientName: String
  conversionValue: numeric
  convertedAt: timestamptz
  createdAt: timestamptz
  createdByName: String
  daysInPipeline: numeric
  id: uuid
  lineItemsCount: bigint
  pipelineStatus: String
  quoteNumber: String
  status: String
  totalAmount: numeric
  validUntil: date
}

"""
aggregated selection of "quote_analytics"
"""
type QuoteAnalyticsAggregate {
  aggregate: QuoteAnalyticsAggregateFields
  nodes: [QuoteAnalytics!]!
}

"""
aggregate fields of "quote_analytics"
"""
type QuoteAnalyticsAggregateFields {
  avg: QuoteAnalyticsAvgFields
  count(columns: [QuoteAnalyticsSelectColumn!], distinct: Boolean): Int!
  max: QuoteAnalyticsMaxFields
  min: QuoteAnalyticsMinFields
  stddev: QuoteAnalyticsStddevFields
  stddevPop: QuoteAnalyticsStddevPopFields
  stddevSamp: QuoteAnalyticsStddevSampFields
  sum: QuoteAnalyticsSumFields
  varPop: QuoteAnalyticsVarPopFields
  varSamp: QuoteAnalyticsVarSampFields
  variance: QuoteAnalyticsVarianceFields
}

"""aggregate avg on columns"""
type QuoteAnalyticsAvgFields {
  conversionValue: Float
  daysInPipeline: Float
  lineItemsCount: Float
  totalAmount: Float
}

"""
Boolean expression to filter rows from the table "quote_analytics". All fields are combined with a logical 'AND'.
"""
input QuoteAnalyticsBoolExp {
  _and: [QuoteAnalyticsBoolExp!]
  _not: QuoteAnalyticsBoolExp
  _or: [QuoteAnalyticsBoolExp!]
  clientName: StringComparisonExp
  conversionValue: NumericComparisonExp
  convertedAt: TimestamptzComparisonExp
  createdAt: TimestamptzComparisonExp
  createdByName: StringComparisonExp
  daysInPipeline: NumericComparisonExp
  id: UuidComparisonExp
  lineItemsCount: BigintComparisonExp
  pipelineStatus: StringComparisonExp
  quoteNumber: StringComparisonExp
  status: StringComparisonExp
  totalAmount: NumericComparisonExp
  validUntil: DateComparisonExp
}

"""aggregate max on columns"""
type QuoteAnalyticsMaxFields {
  clientName: String
  conversionValue: numeric
  convertedAt: timestamptz
  createdAt: timestamptz
  createdByName: String
  daysInPipeline: numeric
  id: uuid
  lineItemsCount: bigint
  pipelineStatus: String
  quoteNumber: String
  status: String
  totalAmount: numeric
  validUntil: date
}

"""aggregate min on columns"""
type QuoteAnalyticsMinFields {
  clientName: String
  conversionValue: numeric
  convertedAt: timestamptz
  createdAt: timestamptz
  createdByName: String
  daysInPipeline: numeric
  id: uuid
  lineItemsCount: bigint
  pipelineStatus: String
  quoteNumber: String
  status: String
  totalAmount: numeric
  validUntil: date
}

"""Ordering options when selecting data from "quote_analytics"."""
input QuoteAnalyticsOrderBy {
  clientName: OrderBy
  conversionValue: OrderBy
  convertedAt: OrderBy
  createdAt: OrderBy
  createdByName: OrderBy
  daysInPipeline: OrderBy
  id: OrderBy
  lineItemsCount: OrderBy
  pipelineStatus: OrderBy
  quoteNumber: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  validUntil: OrderBy
}

"""
select columns of table "quote_analytics"
"""
enum QuoteAnalyticsSelectColumn {
  """column name"""
  clientName
  """column name"""
  conversionValue
  """column name"""
  convertedAt
  """column name"""
  createdAt
  """column name"""
  createdByName
  """column name"""
  daysInPipeline
  """column name"""
  id
  """column name"""
  lineItemsCount
  """column name"""
  pipelineStatus
  """column name"""
  quoteNumber
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  validUntil
}

"""aggregate stddev on columns"""
type QuoteAnalyticsStddevFields {
  conversionValue: Float
  daysInPipeline: Float
  lineItemsCount: Float
  totalAmount: Float
}

"""aggregate stddevPop on columns"""
type QuoteAnalyticsStddevPopFields {
  conversionValue: Float
  daysInPipeline: Float
  lineItemsCount: Float
  totalAmount: Float
}

"""aggregate stddevSamp on columns"""
type QuoteAnalyticsStddevSampFields {
  conversionValue: Float
  daysInPipeline: Float
  lineItemsCount: Float
  totalAmount: Float
}

"""
Streaming cursor of the table "quote_analytics"
"""
input QuoteAnalyticsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuoteAnalyticsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuoteAnalyticsStreamCursorValueInput {
  clientName: String
  conversionValue: numeric
  convertedAt: timestamptz
  createdAt: timestamptz
  createdByName: String
  daysInPipeline: numeric
  id: uuid
  lineItemsCount: bigint
  pipelineStatus: String
  quoteNumber: String
  status: String
  totalAmount: numeric
  validUntil: date
}

"""aggregate sum on columns"""
type QuoteAnalyticsSumFields {
  conversionValue: numeric
  daysInPipeline: numeric
  lineItemsCount: bigint
  totalAmount: numeric
}

"""aggregate varPop on columns"""
type QuoteAnalyticsVarPopFields {
  conversionValue: Float
  daysInPipeline: Float
  lineItemsCount: Float
  totalAmount: Float
}

"""aggregate varSamp on columns"""
type QuoteAnalyticsVarSampFields {
  conversionValue: Float
  daysInPipeline: Float
  lineItemsCount: Float
  totalAmount: Float
}

"""aggregate variance on columns"""
type QuoteAnalyticsVarianceFields {
  conversionValue: Float
  daysInPipeline: Float
  lineItemsCount: Float
  totalAmount: Float
}

"""
columns and relationships of "quote_conversions"
"""
type QuoteConversions {
  """An object relationship"""
  client: Clients!
  clientId: uuid!
  conversionDate: timestamptz!
  conversionNotes: String
  createdBy: uuid!
  """An object relationship"""
  createdByUser: Users!
  id: uuid!
  """An object relationship"""
  quote: Quotes!
  quoteId: uuid!
  serviceAgreementsCreated(
    """JSON select path"""
    path: String
  ): jsonb
  totalValue: numeric!
}

"""
aggregated selection of "quote_conversions"
"""
type QuoteConversionsAggregate {
  aggregate: QuoteConversionsAggregateFields
  nodes: [QuoteConversions!]!
}

input QuoteConversionsAggregateBoolExp {
  count: quoteConversionsAggregateBoolExpCount
}

"""
aggregate fields of "quote_conversions"
"""
type QuoteConversionsAggregateFields {
  avg: QuoteConversionsAvgFields
  count(columns: [QuoteConversionsSelectColumn!], distinct: Boolean): Int!
  max: QuoteConversionsMaxFields
  min: QuoteConversionsMinFields
  stddev: QuoteConversionsStddevFields
  stddevPop: QuoteConversionsStddevPopFields
  stddevSamp: QuoteConversionsStddevSampFields
  sum: QuoteConversionsSumFields
  varPop: QuoteConversionsVarPopFields
  varSamp: QuoteConversionsVarSampFields
  variance: QuoteConversionsVarianceFields
}

"""
order by aggregate values of table "quote_conversions"
"""
input QuoteConversionsAggregateOrderBy {
  avg: QuoteConversionsAvgOrderBy
  count: OrderBy
  max: QuoteConversionsMaxOrderBy
  min: QuoteConversionsMinOrderBy
  stddev: QuoteConversionsStddevOrderBy
  stddevPop: QuoteConversionsStddevPopOrderBy
  stddevSamp: QuoteConversionsStddevSampOrderBy
  sum: QuoteConversionsSumOrderBy
  varPop: QuoteConversionsVarPopOrderBy
  varSamp: QuoteConversionsVarSampOrderBy
  variance: QuoteConversionsVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input QuoteConversionsAppendInput {
  serviceAgreementsCreated: jsonb
}

"""
input type for inserting array relation for remote table "quote_conversions"
"""
input QuoteConversionsArrRelInsertInput {
  data: [QuoteConversionsInsertInput!]!
  """upsert condition"""
  onConflict: QuoteConversionsOnConflict
}

"""aggregate avg on columns"""
type QuoteConversionsAvgFields {
  totalValue: Float
}

"""
order by avg() on columns of table "quote_conversions"
"""
input QuoteConversionsAvgOrderBy {
  totalValue: OrderBy
}

"""
Boolean expression to filter rows from the table "quote_conversions". All fields are combined with a logical 'AND'.
"""
input QuoteConversionsBoolExp {
  _and: [QuoteConversionsBoolExp!]
  _not: QuoteConversionsBoolExp
  _or: [QuoteConversionsBoolExp!]
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  conversionDate: TimestamptzComparisonExp
  conversionNotes: StringComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  id: UuidComparisonExp
  quote: QuotesBoolExp
  quoteId: UuidComparisonExp
  serviceAgreementsCreated: JsonbComparisonExp
  totalValue: NumericComparisonExp
}

"""
unique or primary key constraints on table "quote_conversions"
"""
enum QuoteConversionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  quote_conversions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input QuoteConversionsDeleteAtPathInput {
  serviceAgreementsCreated: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input QuoteConversionsDeleteElemInput {
  serviceAgreementsCreated: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input QuoteConversionsDeleteKeyInput {
  serviceAgreementsCreated: String
}

"""
input type for incrementing numeric columns in table "quote_conversions"
"""
input QuoteConversionsIncInput {
  totalValue: numeric
}

"""
input type for inserting data into table "quote_conversions"
"""
input QuoteConversionsInsertInput {
  client: ClientsObjRelInsertInput
  clientId: uuid
  conversionDate: timestamptz
  conversionNotes: String
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  id: uuid
  quote: QuotesObjRelInsertInput
  quoteId: uuid
  serviceAgreementsCreated: jsonb
  totalValue: numeric
}

"""aggregate max on columns"""
type QuoteConversionsMaxFields {
  clientId: uuid
  conversionDate: timestamptz
  conversionNotes: String
  createdBy: uuid
  id: uuid
  quoteId: uuid
  totalValue: numeric
}

"""
order by max() on columns of table "quote_conversions"
"""
input QuoteConversionsMaxOrderBy {
  clientId: OrderBy
  conversionDate: OrderBy
  conversionNotes: OrderBy
  createdBy: OrderBy
  id: OrderBy
  quoteId: OrderBy
  totalValue: OrderBy
}

"""aggregate min on columns"""
type QuoteConversionsMinFields {
  clientId: uuid
  conversionDate: timestamptz
  conversionNotes: String
  createdBy: uuid
  id: uuid
  quoteId: uuid
  totalValue: numeric
}

"""
order by min() on columns of table "quote_conversions"
"""
input QuoteConversionsMinOrderBy {
  clientId: OrderBy
  conversionDate: OrderBy
  conversionNotes: OrderBy
  createdBy: OrderBy
  id: OrderBy
  quoteId: OrderBy
  totalValue: OrderBy
}

"""
response of any mutation on the table "quote_conversions"
"""
type QuoteConversionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [QuoteConversions!]!
}

"""
on_conflict condition type for table "quote_conversions"
"""
input QuoteConversionsOnConflict {
  constraint: QuoteConversionsConstraint!
  updateColumns: [QuoteConversionsUpdateColumn!]! = []
  where: QuoteConversionsBoolExp
}

"""Ordering options when selecting data from "quote_conversions"."""
input QuoteConversionsOrderBy {
  client: ClientsOrderBy
  clientId: OrderBy
  conversionDate: OrderBy
  conversionNotes: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  id: OrderBy
  quote: QuotesOrderBy
  quoteId: OrderBy
  serviceAgreementsCreated: OrderBy
  totalValue: OrderBy
}

"""primary key columns input for table: quote_conversions"""
input QuoteConversionsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input QuoteConversionsPrependInput {
  serviceAgreementsCreated: jsonb
}

"""
select columns of table "quote_conversions"
"""
enum QuoteConversionsSelectColumn {
  """column name"""
  clientId
  """column name"""
  conversionDate
  """column name"""
  conversionNotes
  """column name"""
  createdBy
  """column name"""
  id
  """column name"""
  quoteId
  """column name"""
  serviceAgreementsCreated
  """column name"""
  totalValue
}

"""
input type for updating data in table "quote_conversions"
"""
input QuoteConversionsSetInput {
  clientId: uuid
  conversionDate: timestamptz
  conversionNotes: String
  createdBy: uuid
  id: uuid
  quoteId: uuid
  serviceAgreementsCreated: jsonb
  totalValue: numeric
}

"""aggregate stddev on columns"""
type QuoteConversionsStddevFields {
  totalValue: Float
}

"""
order by stddev() on columns of table "quote_conversions"
"""
input QuoteConversionsStddevOrderBy {
  totalValue: OrderBy
}

"""aggregate stddevPop on columns"""
type QuoteConversionsStddevPopFields {
  totalValue: Float
}

"""
order by stddevPop() on columns of table "quote_conversions"
"""
input QuoteConversionsStddevPopOrderBy {
  totalValue: OrderBy
}

"""aggregate stddevSamp on columns"""
type QuoteConversionsStddevSampFields {
  totalValue: Float
}

"""
order by stddevSamp() on columns of table "quote_conversions"
"""
input QuoteConversionsStddevSampOrderBy {
  totalValue: OrderBy
}

"""
Streaming cursor of the table "quote_conversions"
"""
input QuoteConversionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuoteConversionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuoteConversionsStreamCursorValueInput {
  clientId: uuid
  conversionDate: timestamptz
  conversionNotes: String
  createdBy: uuid
  id: uuid
  quoteId: uuid
  serviceAgreementsCreated: jsonb
  totalValue: numeric
}

"""aggregate sum on columns"""
type QuoteConversionsSumFields {
  totalValue: numeric
}

"""
order by sum() on columns of table "quote_conversions"
"""
input QuoteConversionsSumOrderBy {
  totalValue: OrderBy
}

"""
update columns of table "quote_conversions"
"""
enum QuoteConversionsUpdateColumn {
  """column name"""
  clientId
  """column name"""
  conversionDate
  """column name"""
  conversionNotes
  """column name"""
  createdBy
  """column name"""
  id
  """column name"""
  quoteId
  """column name"""
  serviceAgreementsCreated
  """column name"""
  totalValue
}

input QuoteConversionsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: QuoteConversionsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: QuoteConversionsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: QuoteConversionsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: QuoteConversionsDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: QuoteConversionsIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: QuoteConversionsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: QuoteConversionsSetInput
  """filter the rows which have to be updated"""
  where: QuoteConversionsBoolExp!
}

"""aggregate varPop on columns"""
type QuoteConversionsVarPopFields {
  totalValue: Float
}

"""
order by varPop() on columns of table "quote_conversions"
"""
input QuoteConversionsVarPopOrderBy {
  totalValue: OrderBy
}

"""aggregate varSamp on columns"""
type QuoteConversionsVarSampFields {
  totalValue: Float
}

"""
order by varSamp() on columns of table "quote_conversions"
"""
input QuoteConversionsVarSampOrderBy {
  totalValue: OrderBy
}

"""aggregate variance on columns"""
type QuoteConversionsVarianceFields {
  totalValue: Float
}

"""
order by variance() on columns of table "quote_conversions"
"""
input QuoteConversionsVarianceOrderBy {
  totalValue: OrderBy
}

"""
columns and relationships of "quote_line_items"
"""
type QuoteLineItems {
  createdAt: timestamptz!
  description: String!
  id: uuid!
  notes: String
  quantity: Int!
  """An object relationship"""
  quote: Quotes!
  quoteId: uuid!
  """An object relationship"""
  service: Services!
  serviceId: uuid!
  totalAmount: numeric
  unitRate: numeric!
}

"""
aggregated selection of "quote_line_items"
"""
type QuoteLineItemsAggregate {
  aggregate: QuoteLineItemsAggregateFields
  nodes: [QuoteLineItems!]!
}

input QuoteLineItemsAggregateBoolExp {
  count: quoteLineItemsAggregateBoolExpCount
}

"""
aggregate fields of "quote_line_items"
"""
type QuoteLineItemsAggregateFields {
  avg: QuoteLineItemsAvgFields
  count(columns: [QuoteLineItemsSelectColumn!], distinct: Boolean): Int!
  max: QuoteLineItemsMaxFields
  min: QuoteLineItemsMinFields
  stddev: QuoteLineItemsStddevFields
  stddevPop: QuoteLineItemsStddevPopFields
  stddevSamp: QuoteLineItemsStddevSampFields
  sum: QuoteLineItemsSumFields
  varPop: QuoteLineItemsVarPopFields
  varSamp: QuoteLineItemsVarSampFields
  variance: QuoteLineItemsVarianceFields
}

"""
order by aggregate values of table "quote_line_items"
"""
input QuoteLineItemsAggregateOrderBy {
  avg: QuoteLineItemsAvgOrderBy
  count: OrderBy
  max: QuoteLineItemsMaxOrderBy
  min: QuoteLineItemsMinOrderBy
  stddev: QuoteLineItemsStddevOrderBy
  stddevPop: QuoteLineItemsStddevPopOrderBy
  stddevSamp: QuoteLineItemsStddevSampOrderBy
  sum: QuoteLineItemsSumOrderBy
  varPop: QuoteLineItemsVarPopOrderBy
  varSamp: QuoteLineItemsVarSampOrderBy
  variance: QuoteLineItemsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "quote_line_items"
"""
input QuoteLineItemsArrRelInsertInput {
  data: [QuoteLineItemsInsertInput!]!
  """upsert condition"""
  onConflict: QuoteLineItemsOnConflict
}

"""aggregate avg on columns"""
type QuoteLineItemsAvgFields {
  quantity: Float
  totalAmount: Float
  unitRate: Float
}

"""
order by avg() on columns of table "quote_line_items"
"""
input QuoteLineItemsAvgOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""
Boolean expression to filter rows from the table "quote_line_items". All fields are combined with a logical 'AND'.
"""
input QuoteLineItemsBoolExp {
  _and: [QuoteLineItemsBoolExp!]
  _not: QuoteLineItemsBoolExp
  _or: [QuoteLineItemsBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  notes: StringComparisonExp
  quantity: IntComparisonExp
  quote: QuotesBoolExp
  quoteId: UuidComparisonExp
  service: ServicesBoolExp
  serviceId: UuidComparisonExp
  totalAmount: NumericComparisonExp
  unitRate: NumericComparisonExp
}

"""
unique or primary key constraints on table "quote_line_items"
"""
enum QuoteLineItemsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  quote_line_items_pkey
}

"""
input type for incrementing numeric columns in table "quote_line_items"
"""
input QuoteLineItemsIncInput {
  quantity: Int
  totalAmount: numeric
  unitRate: numeric
}

"""
input type for inserting data into table "quote_line_items"
"""
input QuoteLineItemsInsertInput {
  createdAt: timestamptz
  description: String
  id: uuid
  notes: String
  quantity: Int
  quote: QuotesObjRelInsertInput
  quoteId: uuid
  service: ServicesObjRelInsertInput
  serviceId: uuid
  totalAmount: numeric
  unitRate: numeric
}

"""aggregate max on columns"""
type QuoteLineItemsMaxFields {
  createdAt: timestamptz
  description: String
  id: uuid
  notes: String
  quantity: Int
  quoteId: uuid
  serviceId: uuid
  totalAmount: numeric
  unitRate: numeric
}

"""
order by max() on columns of table "quote_line_items"
"""
input QuoteLineItemsMaxOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  notes: OrderBy
  quantity: OrderBy
  quoteId: OrderBy
  serviceId: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""aggregate min on columns"""
type QuoteLineItemsMinFields {
  createdAt: timestamptz
  description: String
  id: uuid
  notes: String
  quantity: Int
  quoteId: uuid
  serviceId: uuid
  totalAmount: numeric
  unitRate: numeric
}

"""
order by min() on columns of table "quote_line_items"
"""
input QuoteLineItemsMinOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  notes: OrderBy
  quantity: OrderBy
  quoteId: OrderBy
  serviceId: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""
response of any mutation on the table "quote_line_items"
"""
type QuoteLineItemsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [QuoteLineItems!]!
}

"""
on_conflict condition type for table "quote_line_items"
"""
input QuoteLineItemsOnConflict {
  constraint: QuoteLineItemsConstraint!
  updateColumns: [QuoteLineItemsUpdateColumn!]! = []
  where: QuoteLineItemsBoolExp
}

"""Ordering options when selecting data from "quote_line_items"."""
input QuoteLineItemsOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  notes: OrderBy
  quantity: OrderBy
  quote: QuotesOrderBy
  quoteId: OrderBy
  service: ServicesOrderBy
  serviceId: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""primary key columns input for table: quote_line_items"""
input QuoteLineItemsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "quote_line_items"
"""
enum QuoteLineItemsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  quantity
  """column name"""
  quoteId
  """column name"""
  serviceId
  """column name"""
  totalAmount
  """column name"""
  unitRate
}

"""
input type for updating data in table "quote_line_items"
"""
input QuoteLineItemsSetInput {
  createdAt: timestamptz
  description: String
  id: uuid
  notes: String
  quantity: Int
  quoteId: uuid
  serviceId: uuid
  totalAmount: numeric
  unitRate: numeric
}

"""aggregate stddev on columns"""
type QuoteLineItemsStddevFields {
  quantity: Float
  totalAmount: Float
  unitRate: Float
}

"""
order by stddev() on columns of table "quote_line_items"
"""
input QuoteLineItemsStddevOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""aggregate stddevPop on columns"""
type QuoteLineItemsStddevPopFields {
  quantity: Float
  totalAmount: Float
  unitRate: Float
}

"""
order by stddevPop() on columns of table "quote_line_items"
"""
input QuoteLineItemsStddevPopOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""aggregate stddevSamp on columns"""
type QuoteLineItemsStddevSampFields {
  quantity: Float
  totalAmount: Float
  unitRate: Float
}

"""
order by stddevSamp() on columns of table "quote_line_items"
"""
input QuoteLineItemsStddevSampOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""
Streaming cursor of the table "quote_line_items"
"""
input QuoteLineItemsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuoteLineItemsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuoteLineItemsStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  notes: String
  quantity: Int
  quoteId: uuid
  serviceId: uuid
  totalAmount: numeric
  unitRate: numeric
}

"""aggregate sum on columns"""
type QuoteLineItemsSumFields {
  quantity: Int
  totalAmount: numeric
  unitRate: numeric
}

"""
order by sum() on columns of table "quote_line_items"
"""
input QuoteLineItemsSumOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""
update columns of table "quote_line_items"
"""
enum QuoteLineItemsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  quantity
  """column name"""
  quoteId
  """column name"""
  serviceId
  """column name"""
  totalAmount
  """column name"""
  unitRate
}

input QuoteLineItemsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: QuoteLineItemsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: QuoteLineItemsSetInput
  """filter the rows which have to be updated"""
  where: QuoteLineItemsBoolExp!
}

"""aggregate varPop on columns"""
type QuoteLineItemsVarPopFields {
  quantity: Float
  totalAmount: Float
  unitRate: Float
}

"""
order by varPop() on columns of table "quote_line_items"
"""
input QuoteLineItemsVarPopOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""aggregate varSamp on columns"""
type QuoteLineItemsVarSampFields {
  quantity: Float
  totalAmount: Float
  unitRate: Float
}

"""
order by varSamp() on columns of table "quote_line_items"
"""
input QuoteLineItemsVarSampOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""aggregate variance on columns"""
type QuoteLineItemsVarianceFields {
  quantity: Float
  totalAmount: Float
  unitRate: Float
}

"""
order by variance() on columns of table "quote_line_items"
"""
input QuoteLineItemsVarianceOrderBy {
  quantity: OrderBy
  totalAmount: OrderBy
  unitRate: OrderBy
}

"""
columns and relationships of "quote_templates"
"""
type QuoteTemplates {
  category: String
  createdAt: timestamptz!
  createdBy: uuid!
  """An object relationship"""
  createdByUser: Users!
  description: String
  estimatedTotal: numeric
  id: uuid!
  isActive: Boolean
  isPublic: Boolean
  name: String!
  serviceBundle(
    """JSON select path"""
    path: String
  ): jsonb!
  targetClientSize: String
  targetIndustry: String
  updatedAt: timestamptz!
}

"""
aggregated selection of "quote_templates"
"""
type QuoteTemplatesAggregate {
  aggregate: QuoteTemplatesAggregateFields
  nodes: [QuoteTemplates!]!
}

input QuoteTemplatesAggregateBoolExp {
  bool_and: quoteTemplatesAggregateBoolExpBool_and
  bool_or: quoteTemplatesAggregateBoolExpBool_or
  count: quoteTemplatesAggregateBoolExpCount
}

"""
aggregate fields of "quote_templates"
"""
type QuoteTemplatesAggregateFields {
  avg: QuoteTemplatesAvgFields
  count(columns: [QuoteTemplatesSelectColumn!], distinct: Boolean): Int!
  max: QuoteTemplatesMaxFields
  min: QuoteTemplatesMinFields
  stddev: QuoteTemplatesStddevFields
  stddevPop: QuoteTemplatesStddevPopFields
  stddevSamp: QuoteTemplatesStddevSampFields
  sum: QuoteTemplatesSumFields
  varPop: QuoteTemplatesVarPopFields
  varSamp: QuoteTemplatesVarSampFields
  variance: QuoteTemplatesVarianceFields
}

"""
order by aggregate values of table "quote_templates"
"""
input QuoteTemplatesAggregateOrderBy {
  avg: QuoteTemplatesAvgOrderBy
  count: OrderBy
  max: QuoteTemplatesMaxOrderBy
  min: QuoteTemplatesMinOrderBy
  stddev: QuoteTemplatesStddevOrderBy
  stddevPop: QuoteTemplatesStddevPopOrderBy
  stddevSamp: QuoteTemplatesStddevSampOrderBy
  sum: QuoteTemplatesSumOrderBy
  varPop: QuoteTemplatesVarPopOrderBy
  varSamp: QuoteTemplatesVarSampOrderBy
  variance: QuoteTemplatesVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input QuoteTemplatesAppendInput {
  serviceBundle: jsonb
}

"""
input type for inserting array relation for remote table "quote_templates"
"""
input QuoteTemplatesArrRelInsertInput {
  data: [QuoteTemplatesInsertInput!]!
  """upsert condition"""
  onConflict: QuoteTemplatesOnConflict
}

"""aggregate avg on columns"""
type QuoteTemplatesAvgFields {
  estimatedTotal: Float
}

"""
order by avg() on columns of table "quote_templates"
"""
input QuoteTemplatesAvgOrderBy {
  estimatedTotal: OrderBy
}

"""
Boolean expression to filter rows from the table "quote_templates". All fields are combined with a logical 'AND'.
"""
input QuoteTemplatesBoolExp {
  _and: [QuoteTemplatesBoolExp!]
  _not: QuoteTemplatesBoolExp
  _or: [QuoteTemplatesBoolExp!]
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  description: StringComparisonExp
  estimatedTotal: NumericComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  isPublic: BooleanComparisonExp
  name: StringComparisonExp
  serviceBundle: JsonbComparisonExp
  targetClientSize: StringComparisonExp
  targetIndustry: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "quote_templates"
"""
enum QuoteTemplatesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  quote_templates_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input QuoteTemplatesDeleteAtPathInput {
  serviceBundle: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input QuoteTemplatesDeleteElemInput {
  serviceBundle: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input QuoteTemplatesDeleteKeyInput {
  serviceBundle: String
}

"""
input type for incrementing numeric columns in table "quote_templates"
"""
input QuoteTemplatesIncInput {
  estimatedTotal: numeric
}

"""
input type for inserting data into table "quote_templates"
"""
input QuoteTemplatesInsertInput {
  category: String
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  description: String
  estimatedTotal: numeric
  id: uuid
  isActive: Boolean
  isPublic: Boolean
  name: String
  serviceBundle: jsonb
  targetClientSize: String
  targetIndustry: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type QuoteTemplatesMaxFields {
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  estimatedTotal: numeric
  id: uuid
  name: String
  targetClientSize: String
  targetIndustry: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "quote_templates"
"""
input QuoteTemplatesMaxOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  description: OrderBy
  estimatedTotal: OrderBy
  id: OrderBy
  name: OrderBy
  targetClientSize: OrderBy
  targetIndustry: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type QuoteTemplatesMinFields {
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  estimatedTotal: numeric
  id: uuid
  name: String
  targetClientSize: String
  targetIndustry: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "quote_templates"
"""
input QuoteTemplatesMinOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  description: OrderBy
  estimatedTotal: OrderBy
  id: OrderBy
  name: OrderBy
  targetClientSize: OrderBy
  targetIndustry: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "quote_templates"
"""
type QuoteTemplatesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [QuoteTemplates!]!
}

"""
on_conflict condition type for table "quote_templates"
"""
input QuoteTemplatesOnConflict {
  constraint: QuoteTemplatesConstraint!
  updateColumns: [QuoteTemplatesUpdateColumn!]! = []
  where: QuoteTemplatesBoolExp
}

"""Ordering options when selecting data from "quote_templates"."""
input QuoteTemplatesOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  description: OrderBy
  estimatedTotal: OrderBy
  id: OrderBy
  isActive: OrderBy
  isPublic: OrderBy
  name: OrderBy
  serviceBundle: OrderBy
  targetClientSize: OrderBy
  targetIndustry: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: quote_templates"""
input QuoteTemplatesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input QuoteTemplatesPrependInput {
  serviceBundle: jsonb
}

"""
select columns of table "quote_templates"
"""
enum QuoteTemplatesSelectColumn {
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  description
  """column name"""
  estimatedTotal
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isPublic
  """column name"""
  name
  """column name"""
  serviceBundle
  """column name"""
  targetClientSize
  """column name"""
  targetIndustry
  """column name"""
  updatedAt
}

"""
select "quoteTemplatesAggregateBoolExpBool_andArgumentsColumns" columns of table "quote_templates"
"""
enum QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isPublic
}

"""
select "quoteTemplatesAggregateBoolExpBool_orArgumentsColumns" columns of table "quote_templates"
"""
enum QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isPublic
}

"""
input type for updating data in table "quote_templates"
"""
input QuoteTemplatesSetInput {
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  estimatedTotal: numeric
  id: uuid
  isActive: Boolean
  isPublic: Boolean
  name: String
  serviceBundle: jsonb
  targetClientSize: String
  targetIndustry: String
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type QuoteTemplatesStddevFields {
  estimatedTotal: Float
}

"""
order by stddev() on columns of table "quote_templates"
"""
input QuoteTemplatesStddevOrderBy {
  estimatedTotal: OrderBy
}

"""aggregate stddevPop on columns"""
type QuoteTemplatesStddevPopFields {
  estimatedTotal: Float
}

"""
order by stddevPop() on columns of table "quote_templates"
"""
input QuoteTemplatesStddevPopOrderBy {
  estimatedTotal: OrderBy
}

"""aggregate stddevSamp on columns"""
type QuoteTemplatesStddevSampFields {
  estimatedTotal: Float
}

"""
order by stddevSamp() on columns of table "quote_templates"
"""
input QuoteTemplatesStddevSampOrderBy {
  estimatedTotal: OrderBy
}

"""
Streaming cursor of the table "quote_templates"
"""
input QuoteTemplatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuoteTemplatesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuoteTemplatesStreamCursorValueInput {
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  estimatedTotal: numeric
  id: uuid
  isActive: Boolean
  isPublic: Boolean
  name: String
  serviceBundle: jsonb
  targetClientSize: String
  targetIndustry: String
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type QuoteTemplatesSumFields {
  estimatedTotal: numeric
}

"""
order by sum() on columns of table "quote_templates"
"""
input QuoteTemplatesSumOrderBy {
  estimatedTotal: OrderBy
}

"""
update columns of table "quote_templates"
"""
enum QuoteTemplatesUpdateColumn {
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  description
  """column name"""
  estimatedTotal
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isPublic
  """column name"""
  name
  """column name"""
  serviceBundle
  """column name"""
  targetClientSize
  """column name"""
  targetIndustry
  """column name"""
  updatedAt
}

input QuoteTemplatesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: QuoteTemplatesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: QuoteTemplatesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: QuoteTemplatesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: QuoteTemplatesDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: QuoteTemplatesIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: QuoteTemplatesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: QuoteTemplatesSetInput
  """filter the rows which have to be updated"""
  where: QuoteTemplatesBoolExp!
}

"""aggregate varPop on columns"""
type QuoteTemplatesVarPopFields {
  estimatedTotal: Float
}

"""
order by varPop() on columns of table "quote_templates"
"""
input QuoteTemplatesVarPopOrderBy {
  estimatedTotal: OrderBy
}

"""aggregate varSamp on columns"""
type QuoteTemplatesVarSampFields {
  estimatedTotal: Float
}

"""
order by varSamp() on columns of table "quote_templates"
"""
input QuoteTemplatesVarSampOrderBy {
  estimatedTotal: OrderBy
}

"""aggregate variance on columns"""
type QuoteTemplatesVarianceFields {
  estimatedTotal: Float
}

"""
order by variance() on columns of table "quote_templates"
"""
input QuoteTemplatesVarianceOrderBy {
  estimatedTotal: OrderBy
}

"""
columns and relationships of "quotes"
"""
type Quotes {
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """An object relationship"""
  client: Clients
  clientId: uuid
  conversionValue: numeric
  """An array relationship"""
  conversions(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): [QuoteConversions!]!
  """An aggregate relationship"""
  conversionsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): QuoteConversionsAggregate!
  convertedAt: timestamptz
  """An object relationship"""
  convertedToClient: Clients
  convertedToClientId: uuid
  createdAt: timestamptz!
  createdBy: uuid!
  """An object relationship"""
  createdByUser: Users!
  id: uuid!
  """An array relationship"""
  lineItems(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): [QuoteLineItems!]!
  """An aggregate relationship"""
  lineItemsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): QuoteLineItemsAggregate!
  notes: String
  prospectCompany: String
  prospectEmail: String
  prospectName: String
  prospectPhone: String
  quoteNumber: String!
  status: String!
  termsConditions: String
  totalAmount: numeric!
  updatedAt: timestamptz!
  validUntil: date
}

"""
aggregated selection of "quotes"
"""
type QuotesAggregate {
  aggregate: QuotesAggregateFields
  nodes: [Quotes!]!
}

input QuotesAggregateBoolExp {
  count: quotesAggregateBoolExpCount
}

"""
aggregate fields of "quotes"
"""
type QuotesAggregateFields {
  avg: QuotesAvgFields
  count(columns: [QuotesSelectColumn!], distinct: Boolean): Int!
  max: QuotesMaxFields
  min: QuotesMinFields
  stddev: QuotesStddevFields
  stddevPop: QuotesStddevPopFields
  stddevSamp: QuotesStddevSampFields
  sum: QuotesSumFields
  varPop: QuotesVarPopFields
  varSamp: QuotesVarSampFields
  variance: QuotesVarianceFields
}

"""
order by aggregate values of table "quotes"
"""
input QuotesAggregateOrderBy {
  avg: QuotesAvgOrderBy
  count: OrderBy
  max: QuotesMaxOrderBy
  min: QuotesMinOrderBy
  stddev: QuotesStddevOrderBy
  stddevPop: QuotesStddevPopOrderBy
  stddevSamp: QuotesStddevSampOrderBy
  sum: QuotesSumOrderBy
  varPop: QuotesVarPopOrderBy
  varSamp: QuotesVarSampOrderBy
  variance: QuotesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "quotes"
"""
input QuotesArrRelInsertInput {
  data: [QuotesInsertInput!]!
  """upsert condition"""
  onConflict: QuotesOnConflict
}

"""aggregate avg on columns"""
type QuotesAvgFields {
  conversionValue: Float
  totalAmount: Float
}

"""
order by avg() on columns of table "quotes"
"""
input QuotesAvgOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "quotes". All fields are combined with a logical 'AND'.
"""
input QuotesBoolExp {
  _and: [QuotesBoolExp!]
  _not: QuotesBoolExp
  _or: [QuotesBoolExp!]
  billingItems: BillingItemsBoolExp
  billingItemsAggregate: BillingItemsAggregateBoolExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  conversionValue: NumericComparisonExp
  conversions: QuoteConversionsBoolExp
  conversionsAggregate: QuoteConversionsAggregateBoolExp
  convertedAt: TimestamptzComparisonExp
  convertedToClient: ClientsBoolExp
  convertedToClientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  id: UuidComparisonExp
  lineItems: QuoteLineItemsBoolExp
  lineItemsAggregate: QuoteLineItemsAggregateBoolExp
  notes: StringComparisonExp
  prospectCompany: StringComparisonExp
  prospectEmail: StringComparisonExp
  prospectName: StringComparisonExp
  prospectPhone: StringComparisonExp
  quoteNumber: StringComparisonExp
  status: StringComparisonExp
  termsConditions: StringComparisonExp
  totalAmount: NumericComparisonExp
  updatedAt: TimestamptzComparisonExp
  validUntil: DateComparisonExp
}

"""
unique or primary key constraints on table "quotes"
"""
enum QuotesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  quotes_pkey
  """
  unique or primary key constraint on columns "quote_number"
  """
  quotes_quote_number_key
}

"""
input type for incrementing numeric columns in table "quotes"
"""
input QuotesIncInput {
  conversionValue: numeric
  totalAmount: numeric
}

"""
input type for inserting data into table "quotes"
"""
input QuotesInsertInput {
  billingItems: BillingItemsArrRelInsertInput
  client: ClientsObjRelInsertInput
  clientId: uuid
  conversionValue: numeric
  conversions: QuoteConversionsArrRelInsertInput
  convertedAt: timestamptz
  convertedToClient: ClientsObjRelInsertInput
  convertedToClientId: uuid
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  id: uuid
  lineItems: QuoteLineItemsArrRelInsertInput
  notes: String
  prospectCompany: String
  prospectEmail: String
  prospectName: String
  prospectPhone: String
  quoteNumber: String
  status: String
  termsConditions: String
  totalAmount: numeric
  updatedAt: timestamptz
  validUntil: date
}

"""aggregate max on columns"""
type QuotesMaxFields {
  clientId: uuid
  conversionValue: numeric
  convertedAt: timestamptz
  convertedToClientId: uuid
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  notes: String
  prospectCompany: String
  prospectEmail: String
  prospectName: String
  prospectPhone: String
  quoteNumber: String
  status: String
  termsConditions: String
  totalAmount: numeric
  updatedAt: timestamptz
  validUntil: date
}

"""
order by max() on columns of table "quotes"
"""
input QuotesMaxOrderBy {
  clientId: OrderBy
  conversionValue: OrderBy
  convertedAt: OrderBy
  convertedToClientId: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  notes: OrderBy
  prospectCompany: OrderBy
  prospectEmail: OrderBy
  prospectName: OrderBy
  prospectPhone: OrderBy
  quoteNumber: OrderBy
  status: OrderBy
  termsConditions: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
  validUntil: OrderBy
}

"""aggregate min on columns"""
type QuotesMinFields {
  clientId: uuid
  conversionValue: numeric
  convertedAt: timestamptz
  convertedToClientId: uuid
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  notes: String
  prospectCompany: String
  prospectEmail: String
  prospectName: String
  prospectPhone: String
  quoteNumber: String
  status: String
  termsConditions: String
  totalAmount: numeric
  updatedAt: timestamptz
  validUntil: date
}

"""
order by min() on columns of table "quotes"
"""
input QuotesMinOrderBy {
  clientId: OrderBy
  conversionValue: OrderBy
  convertedAt: OrderBy
  convertedToClientId: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  notes: OrderBy
  prospectCompany: OrderBy
  prospectEmail: OrderBy
  prospectName: OrderBy
  prospectPhone: OrderBy
  quoteNumber: OrderBy
  status: OrderBy
  termsConditions: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
  validUntil: OrderBy
}

"""
response of any mutation on the table "quotes"
"""
type QuotesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Quotes!]!
}

"""
input type for inserting object relation for remote table "quotes"
"""
input QuotesObjRelInsertInput {
  data: QuotesInsertInput!
  """upsert condition"""
  onConflict: QuotesOnConflict
}

"""
on_conflict condition type for table "quotes"
"""
input QuotesOnConflict {
  constraint: QuotesConstraint!
  updateColumns: [QuotesUpdateColumn!]! = []
  where: QuotesBoolExp
}

"""Ordering options when selecting data from "quotes"."""
input QuotesOrderBy {
  billingItemsAggregate: BillingItemsAggregateOrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  conversionValue: OrderBy
  conversionsAggregate: QuoteConversionsAggregateOrderBy
  convertedAt: OrderBy
  convertedToClient: ClientsOrderBy
  convertedToClientId: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  id: OrderBy
  lineItemsAggregate: QuoteLineItemsAggregateOrderBy
  notes: OrderBy
  prospectCompany: OrderBy
  prospectEmail: OrderBy
  prospectName: OrderBy
  prospectPhone: OrderBy
  quoteNumber: OrderBy
  status: OrderBy
  termsConditions: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
  validUntil: OrderBy
}

"""primary key columns input for table: quotes"""
input QuotesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "quotes"
"""
enum QuotesSelectColumn {
  """column name"""
  clientId
  """column name"""
  conversionValue
  """column name"""
  convertedAt
  """column name"""
  convertedToClientId
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  prospectCompany
  """column name"""
  prospectEmail
  """column name"""
  prospectName
  """column name"""
  prospectPhone
  """column name"""
  quoteNumber
  """column name"""
  status
  """column name"""
  termsConditions
  """column name"""
  totalAmount
  """column name"""
  updatedAt
  """column name"""
  validUntil
}

"""
input type for updating data in table "quotes"
"""
input QuotesSetInput {
  clientId: uuid
  conversionValue: numeric
  convertedAt: timestamptz
  convertedToClientId: uuid
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  notes: String
  prospectCompany: String
  prospectEmail: String
  prospectName: String
  prospectPhone: String
  quoteNumber: String
  status: String
  termsConditions: String
  totalAmount: numeric
  updatedAt: timestamptz
  validUntil: date
}

"""aggregate stddev on columns"""
type QuotesStddevFields {
  conversionValue: Float
  totalAmount: Float
}

"""
order by stddev() on columns of table "quotes"
"""
input QuotesStddevOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type QuotesStddevPopFields {
  conversionValue: Float
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "quotes"
"""
input QuotesStddevPopOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type QuotesStddevSampFields {
  conversionValue: Float
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "quotes"
"""
input QuotesStddevSampOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""
Streaming cursor of the table "quotes"
"""
input QuotesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuotesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuotesStreamCursorValueInput {
  clientId: uuid
  conversionValue: numeric
  convertedAt: timestamptz
  convertedToClientId: uuid
  createdAt: timestamptz
  createdBy: uuid
  id: uuid
  notes: String
  prospectCompany: String
  prospectEmail: String
  prospectName: String
  prospectPhone: String
  quoteNumber: String
  status: String
  termsConditions: String
  totalAmount: numeric
  updatedAt: timestamptz
  validUntil: date
}

"""aggregate sum on columns"""
type QuotesSumFields {
  conversionValue: numeric
  totalAmount: numeric
}

"""
order by sum() on columns of table "quotes"
"""
input QuotesSumOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""
update columns of table "quotes"
"""
enum QuotesUpdateColumn {
  """column name"""
  clientId
  """column name"""
  conversionValue
  """column name"""
  convertedAt
  """column name"""
  convertedToClientId
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  prospectCompany
  """column name"""
  prospectEmail
  """column name"""
  prospectName
  """column name"""
  prospectPhone
  """column name"""
  quoteNumber
  """column name"""
  status
  """column name"""
  termsConditions
  """column name"""
  totalAmount
  """column name"""
  updatedAt
  """column name"""
  validUntil
}

input QuotesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: QuotesIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: QuotesSetInput
  """filter the rows which have to be updated"""
  where: QuotesBoolExp!
}

"""aggregate varPop on columns"""
type QuotesVarPopFields {
  conversionValue: Float
  totalAmount: Float
}

"""
order by varPop() on columns of table "quotes"
"""
input QuotesVarPopOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type QuotesVarSampFields {
  conversionValue: Float
  totalAmount: Float
}

"""
order by varSamp() on columns of table "quotes"
"""
input QuotesVarSampOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type QuotesVarianceFields {
  conversionValue: Float
  totalAmount: Float
}

"""
order by variance() on columns of table "quotes"
"""
input QuotesVarianceOrderBy {
  conversionValue: OrderBy
  totalAmount: OrderBy
}

"""
columns and relationships of "rate_limits"
"""
type RateLimits {
  createdAt: timestamptz
  id: uuid!
  limitExceededCount: Int!
  requestCount: Int!
  serviceId: String!
  windowDurationMinutes: Int!
  windowStart: timestamptz!
}

"""
aggregated selection of "rate_limits"
"""
type RateLimitsAggregate {
  aggregate: RateLimitsAggregateFields
  nodes: [RateLimits!]!
}

"""
aggregate fields of "rate_limits"
"""
type RateLimitsAggregateFields {
  avg: RateLimitsAvgFields
  count(columns: [RateLimitsSelectColumn!], distinct: Boolean): Int!
  max: RateLimitsMaxFields
  min: RateLimitsMinFields
  stddev: RateLimitsStddevFields
  stddevPop: RateLimitsStddevPopFields
  stddevSamp: RateLimitsStddevSampFields
  sum: RateLimitsSumFields
  varPop: RateLimitsVarPopFields
  varSamp: RateLimitsVarSampFields
  variance: RateLimitsVarianceFields
}

"""aggregate avg on columns"""
type RateLimitsAvgFields {
  limitExceededCount: Float
  requestCount: Float
  windowDurationMinutes: Float
}

"""
Boolean expression to filter rows from the table "rate_limits". All fields are combined with a logical 'AND'.
"""
input RateLimitsBoolExp {
  _and: [RateLimitsBoolExp!]
  _not: RateLimitsBoolExp
  _or: [RateLimitsBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  limitExceededCount: IntComparisonExp
  requestCount: IntComparisonExp
  serviceId: StringComparisonExp
  windowDurationMinutes: IntComparisonExp
  windowStart: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "rate_limits"
"""
enum RateLimitsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  rate_limits_pkey
  """
  unique or primary key constraint on columns "service_id", "window_start"
  """
  rate_limits_service_id_window_start_key
}

"""
input type for incrementing numeric columns in table "rate_limits"
"""
input RateLimitsIncInput {
  limitExceededCount: Int
  requestCount: Int
  windowDurationMinutes: Int
}

"""
input type for inserting data into table "rate_limits"
"""
input RateLimitsInsertInput {
  createdAt: timestamptz
  id: uuid
  limitExceededCount: Int
  requestCount: Int
  serviceId: String
  windowDurationMinutes: Int
  windowStart: timestamptz
}

"""aggregate max on columns"""
type RateLimitsMaxFields {
  createdAt: timestamptz
  id: uuid
  limitExceededCount: Int
  requestCount: Int
  serviceId: String
  windowDurationMinutes: Int
  windowStart: timestamptz
}

"""aggregate min on columns"""
type RateLimitsMinFields {
  createdAt: timestamptz
  id: uuid
  limitExceededCount: Int
  requestCount: Int
  serviceId: String
  windowDurationMinutes: Int
  windowStart: timestamptz
}

"""
response of any mutation on the table "rate_limits"
"""
type RateLimitsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [RateLimits!]!
}

"""
on_conflict condition type for table "rate_limits"
"""
input RateLimitsOnConflict {
  constraint: RateLimitsConstraint!
  updateColumns: [RateLimitsUpdateColumn!]! = []
  where: RateLimitsBoolExp
}

"""Ordering options when selecting data from "rate_limits"."""
input RateLimitsOrderBy {
  createdAt: OrderBy
  id: OrderBy
  limitExceededCount: OrderBy
  requestCount: OrderBy
  serviceId: OrderBy
  windowDurationMinutes: OrderBy
  windowStart: OrderBy
}

"""primary key columns input for table: rate_limits"""
input RateLimitsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "rate_limits"
"""
enum RateLimitsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  limitExceededCount
  """column name"""
  requestCount
  """column name"""
  serviceId
  """column name"""
  windowDurationMinutes
  """column name"""
  windowStart
}

"""
input type for updating data in table "rate_limits"
"""
input RateLimitsSetInput {
  createdAt: timestamptz
  id: uuid
  limitExceededCount: Int
  requestCount: Int
  serviceId: String
  windowDurationMinutes: Int
  windowStart: timestamptz
}

"""aggregate stddev on columns"""
type RateLimitsStddevFields {
  limitExceededCount: Float
  requestCount: Float
  windowDurationMinutes: Float
}

"""aggregate stddevPop on columns"""
type RateLimitsStddevPopFields {
  limitExceededCount: Float
  requestCount: Float
  windowDurationMinutes: Float
}

"""aggregate stddevSamp on columns"""
type RateLimitsStddevSampFields {
  limitExceededCount: Float
  requestCount: Float
  windowDurationMinutes: Float
}

"""
Streaming cursor of the table "rate_limits"
"""
input RateLimitsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RateLimitsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RateLimitsStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  limitExceededCount: Int
  requestCount: Int
  serviceId: String
  windowDurationMinutes: Int
  windowStart: timestamptz
}

"""aggregate sum on columns"""
type RateLimitsSumFields {
  limitExceededCount: Int
  requestCount: Int
  windowDurationMinutes: Int
}

"""
update columns of table "rate_limits"
"""
enum RateLimitsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  limitExceededCount
  """column name"""
  requestCount
  """column name"""
  serviceId
  """column name"""
  windowDurationMinutes
  """column name"""
  windowStart
}

input RateLimitsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: RateLimitsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: RateLimitsSetInput
  """filter the rows which have to be updated"""
  where: RateLimitsBoolExp!
}

"""aggregate varPop on columns"""
type RateLimitsVarPopFields {
  limitExceededCount: Float
  requestCount: Float
  windowDurationMinutes: Float
}

"""aggregate varSamp on columns"""
type RateLimitsVarSampFields {
  limitExceededCount: Float
  requestCount: Float
  windowDurationMinutes: Float
}

"""aggregate variance on columns"""
type RateLimitsVarianceFields {
  limitExceededCount: Float
  requestCount: Float
  windowDurationMinutes: Float
}

"""
columns and relationships of "resources"
"""
type Resources {
  createdAt: timestamptz!
  description: String
  displayName: String!
  id: uuid!
  name: String!
  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinctOn: [PermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionsOrderBy!]
    """filter the rows returned"""
    where: PermissionsBoolExp
  ): [Permissions!]!
  """An aggregate relationship"""
  permissionsAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionsOrderBy!]
    """filter the rows returned"""
    where: PermissionsBoolExp
  ): PermissionsAggregate!
  updatedAt: timestamptz!
}

"""
aggregated selection of "resources"
"""
type ResourcesAggregate {
  aggregate: ResourcesAggregateFields
  nodes: [Resources!]!
}

"""
aggregate fields of "resources"
"""
type ResourcesAggregateFields {
  count(columns: [ResourcesSelectColumn!], distinct: Boolean): Int!
  max: ResourcesMaxFields
  min: ResourcesMinFields
}

"""
Boolean expression to filter rows from the table "resources". All fields are combined with a logical 'AND'.
"""
input ResourcesBoolExp {
  _and: [ResourcesBoolExp!]
  _not: ResourcesBoolExp
  _or: [ResourcesBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  displayName: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  permissions: PermissionsBoolExp
  permissionsAggregate: PermissionsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "resources"
"""
enum ResourcesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  resources_name_key
  """
  unique or primary key constraint on columns "id"
  """
  resources_pkey
}

"""
input type for inserting data into table "resources"
"""
input ResourcesInsertInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  permissions: PermissionsArrRelInsertInput
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ResourcesMaxFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type ResourcesMinFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "resources"
"""
type ResourcesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Resources!]!
}

"""
input type for inserting object relation for remote table "resources"
"""
input ResourcesObjRelInsertInput {
  data: ResourcesInsertInput!
  """upsert condition"""
  onConflict: ResourcesOnConflict
}

"""
on_conflict condition type for table "resources"
"""
input ResourcesOnConflict {
  constraint: ResourcesConstraint!
  updateColumns: [ResourcesUpdateColumn!]! = []
  where: ResourcesBoolExp
}

"""Ordering options when selecting data from "resources"."""
input ResourcesOrderBy {
  createdAt: OrderBy
  description: OrderBy
  displayName: OrderBy
  id: OrderBy
  name: OrderBy
  permissionsAggregate: PermissionsAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: resources"""
input ResourcesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "resources"
"""
enum ResourcesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
input type for updating data in table "resources"
"""
input ResourcesSetInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "resources"
"""
input ResourcesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ResourcesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ResourcesStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
update columns of table "resources"
"""
enum ResourcesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input ResourcesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ResourcesSetInput
  """filter the rows which have to be updated"""
  where: ResourcesBoolExp!
}

"""
columns and relationships of "role_permissions"
"""
type RolePermissions {
  conditions(
    """JSON select path"""
    path: String
  ): jsonb
  createdAt: timestamptz!
  id: uuid!
  """An object relationship"""
  permission: Permissions!
  permissionId: uuid!
  """An object relationship"""
  role: Roles!
  roleId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "role_permissions"
"""
type RolePermissionsAggregate {
  aggregate: RolePermissionsAggregateFields
  nodes: [RolePermissions!]!
}

input RolePermissionsAggregateBoolExp {
  count: rolePermissionsAggregateBoolExpCount
}

"""
aggregate fields of "role_permissions"
"""
type RolePermissionsAggregateFields {
  count(columns: [RolePermissionsSelectColumn!], distinct: Boolean): Int!
  max: RolePermissionsMaxFields
  min: RolePermissionsMinFields
}

"""
order by aggregate values of table "role_permissions"
"""
input RolePermissionsAggregateOrderBy {
  count: OrderBy
  max: RolePermissionsMaxOrderBy
  min: RolePermissionsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input RolePermissionsAppendInput {
  conditions: jsonb
}

"""
input type for inserting array relation for remote table "role_permissions"
"""
input RolePermissionsArrRelInsertInput {
  data: [RolePermissionsInsertInput!]!
  """upsert condition"""
  onConflict: RolePermissionsOnConflict
}

"""
Boolean expression to filter rows from the table "role_permissions". All fields are combined with a logical 'AND'.
"""
input RolePermissionsBoolExp {
  _and: [RolePermissionsBoolExp!]
  _not: RolePermissionsBoolExp
  _or: [RolePermissionsBoolExp!]
  conditions: JsonbComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  permission: PermissionsBoolExp
  permissionId: UuidComparisonExp
  role: RolesBoolExp
  roleId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "role_permissions"
"""
enum RolePermissionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  role_permissions_pkey
  """
  unique or primary key constraint on columns "permission_id", "role_id"
  """
  role_permissions_role_id_permission_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input RolePermissionsDeleteAtPathInput {
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input RolePermissionsDeleteElemInput {
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input RolePermissionsDeleteKeyInput {
  conditions: String
}

"""
input type for inserting data into table "role_permissions"
"""
input RolePermissionsInsertInput {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permission: PermissionsObjRelInsertInput
  permissionId: uuid
  role: RolesObjRelInsertInput
  roleId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type RolePermissionsMaxFields {
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "role_permissions"
"""
input RolePermissionsMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  permissionId: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type RolePermissionsMinFields {
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "role_permissions"
"""
input RolePermissionsMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  permissionId: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "role_permissions"
"""
type RolePermissionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [RolePermissions!]!
}

"""
on_conflict condition type for table "role_permissions"
"""
input RolePermissionsOnConflict {
  constraint: RolePermissionsConstraint!
  updateColumns: [RolePermissionsUpdateColumn!]! = []
  where: RolePermissionsBoolExp
}

"""Ordering options when selecting data from "role_permissions"."""
input RolePermissionsOrderBy {
  conditions: OrderBy
  createdAt: OrderBy
  id: OrderBy
  permission: PermissionsOrderBy
  permissionId: OrderBy
  role: RolesOrderBy
  roleId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: role_permissions"""
input RolePermissionsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input RolePermissionsPrependInput {
  conditions: jsonb
}

"""
select columns of table "role_permissions"
"""
enum RolePermissionsSelectColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  permissionId
  """column name"""
  roleId
  """column name"""
  updatedAt
}

"""
input type for updating data in table "role_permissions"
"""
input RolePermissionsSetInput {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "role_permissions"
"""
input RolePermissionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RolePermissionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RolePermissionsStreamCursorValueInput {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "role_permissions"
"""
enum RolePermissionsUpdateColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  permissionId
  """column name"""
  roleId
  """column name"""
  updatedAt
}

input RolePermissionsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: RolePermissionsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: RolePermissionsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: RolePermissionsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: RolePermissionsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: RolePermissionsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: RolePermissionsSetInput
  """filter the rows which have to be updated"""
  where: RolePermissionsBoolExp!
}

"""
columns and relationships of "roles"
"""
type Roles {
  createdAt: timestamptz!
  description: String
  displayName: String!
  id: uuid!
  isSystemRole: Boolean!
  name: String!
  priority: Int!
  """An array relationship"""
  rolePermissions(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): [RolePermissions!]!
  """An aggregate relationship"""
  rolePermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): RolePermissionsAggregate!
  updatedAt: timestamptz!
  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): [UserRoles!]!
  """An aggregate relationship"""
  userRolesAggregate(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): UserRolesAggregate!
}

"""
aggregated selection of "roles"
"""
type RolesAggregate {
  aggregate: RolesAggregateFields
  nodes: [Roles!]!
}

"""
aggregate fields of "roles"
"""
type RolesAggregateFields {
  avg: RolesAvgFields
  count(columns: [RolesSelectColumn!], distinct: Boolean): Int!
  max: RolesMaxFields
  min: RolesMinFields
  stddev: RolesStddevFields
  stddevPop: RolesStddevPopFields
  stddevSamp: RolesStddevSampFields
  sum: RolesSumFields
  varPop: RolesVarPopFields
  varSamp: RolesVarSampFields
  variance: RolesVarianceFields
}

"""aggregate avg on columns"""
type RolesAvgFields {
  priority: Float
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input RolesBoolExp {
  _and: [RolesBoolExp!]
  _not: RolesBoolExp
  _or: [RolesBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  displayName: StringComparisonExp
  id: UuidComparisonExp
  isSystemRole: BooleanComparisonExp
  name: StringComparisonExp
  priority: IntComparisonExp
  rolePermissions: RolePermissionsBoolExp
  rolePermissionsAggregate: RolePermissionsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  userRoles: UserRolesBoolExp
  userRolesAggregate: UserRolesAggregateBoolExp
}

"""
unique or primary key constraints on table "roles"
"""
enum RolesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  roles_name_key
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey
}

"""
input type for incrementing numeric columns in table "roles"
"""
input RolesIncInput {
  priority: Int
}

"""
input type for inserting data into table "roles"
"""
input RolesInsertInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  rolePermissions: RolePermissionsArrRelInsertInput
  updatedAt: timestamptz
  userRoles: UserRolesArrRelInsertInput
}

"""aggregate max on columns"""
type RolesMaxFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type RolesMinFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "roles"
"""
type RolesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input RolesObjRelInsertInput {
  data: RolesInsertInput!
  """upsert condition"""
  onConflict: RolesOnConflict
}

"""
on_conflict condition type for table "roles"
"""
input RolesOnConflict {
  constraint: RolesConstraint!
  updateColumns: [RolesUpdateColumn!]! = []
  where: RolesBoolExp
}

"""Ordering options when selecting data from "roles"."""
input RolesOrderBy {
  createdAt: OrderBy
  description: OrderBy
  displayName: OrderBy
  id: OrderBy
  isSystemRole: OrderBy
  name: OrderBy
  priority: OrderBy
  rolePermissionsAggregate: RolePermissionsAggregateOrderBy
  updatedAt: OrderBy
  userRolesAggregate: UserRolesAggregateOrderBy
}

"""primary key columns input for table: roles"""
input RolesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum RolesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  isSystemRole
  """column name"""
  name
  """column name"""
  priority
  """column name"""
  updatedAt
}

"""
input type for updating data in table "roles"
"""
input RolesSetInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type RolesStddevFields {
  priority: Float
}

"""aggregate stddevPop on columns"""
type RolesStddevPopFields {
  priority: Float
}

"""aggregate stddevSamp on columns"""
type RolesStddevSampFields {
  priority: Float
}

"""
Streaming cursor of the table "roles"
"""
input RolesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RolesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RolesStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type RolesSumFields {
  priority: Int
}

"""
update columns of table "roles"
"""
enum RolesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  isSystemRole
  """column name"""
  name
  """column name"""
  priority
  """column name"""
  updatedAt
}

input RolesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: RolesIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: RolesSetInput
  """filter the rows which have to be updated"""
  where: RolesBoolExp!
}

"""aggregate varPop on columns"""
type RolesVarPopFields {
  priority: Float
}

"""aggregate varSamp on columns"""
type RolesVarSampFields {
  priority: Float
}

"""aggregate variance on columns"""
type RolesVarianceFields {
  priority: Float
}

"""
columns and relationships of "security_alerts"
"""
type SecurityAlerts {
  alertType: String!
  createdAt: timestamptz
  description: String!
  id: uuid!
  ipAddress: inet
  isResolved: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  resolutionNotes: String
  resolvedAt: timestamptz
  resolvedBy: uuid
  """An object relationship"""
  resolvedByUser: Users
  severity: String
  title: String!
  """An object relationship"""
  user: Users
  userAgent: String
  userId: uuid
}

"""
aggregated selection of "security_alerts"
"""
type SecurityAlertsAggregate {
  aggregate: SecurityAlertsAggregateFields
  nodes: [SecurityAlerts!]!
}

input SecurityAlertsAggregateBoolExp {
  bool_and: securityAlertsAggregateBoolExpBool_and
  bool_or: securityAlertsAggregateBoolExpBool_or
  count: securityAlertsAggregateBoolExpCount
}

"""
aggregate fields of "security_alerts"
"""
type SecurityAlertsAggregateFields {
  count(columns: [SecurityAlertsSelectColumn!], distinct: Boolean): Int!
  max: SecurityAlertsMaxFields
  min: SecurityAlertsMinFields
}

"""
order by aggregate values of table "security_alerts"
"""
input SecurityAlertsAggregateOrderBy {
  count: OrderBy
  max: SecurityAlertsMaxOrderBy
  min: SecurityAlertsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input SecurityAlertsAppendInput {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "security_alerts"
"""
input SecurityAlertsArrRelInsertInput {
  data: [SecurityAlertsInsertInput!]!
  """upsert condition"""
  onConflict: SecurityAlertsOnConflict
}

"""
Boolean expression to filter rows from the table "security_alerts". All fields are combined with a logical 'AND'.
"""
input SecurityAlertsBoolExp {
  _and: [SecurityAlertsBoolExp!]
  _not: SecurityAlertsBoolExp
  _or: [SecurityAlertsBoolExp!]
  alertType: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  isResolved: BooleanComparisonExp
  metadata: JsonbComparisonExp
  resolutionNotes: StringComparisonExp
  resolvedAt: TimestamptzComparisonExp
  resolvedBy: UuidComparisonExp
  resolvedByUser: UsersBoolExp
  severity: StringComparisonExp
  title: StringComparisonExp
  user: UsersBoolExp
  userAgent: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "security_alerts"
"""
enum SecurityAlertsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  security_alerts_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input SecurityAlertsDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input SecurityAlertsDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input SecurityAlertsDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "security_alerts"
"""
input SecurityAlertsInsertInput {
  alertType: String
  createdAt: timestamptz
  description: String
  id: uuid
  ipAddress: inet
  isResolved: Boolean
  metadata: jsonb
  resolutionNotes: String
  resolvedAt: timestamptz
  resolvedBy: uuid
  resolvedByUser: UsersObjRelInsertInput
  severity: String
  title: String
  user: UsersObjRelInsertInput
  userAgent: String
  userId: uuid
}

"""aggregate max on columns"""
type SecurityAlertsMaxFields {
  alertType: String
  createdAt: timestamptz
  description: String
  id: uuid
  resolutionNotes: String
  resolvedAt: timestamptz
  resolvedBy: uuid
  severity: String
  title: String
  userAgent: String
  userId: uuid
}

"""
order by max() on columns of table "security_alerts"
"""
input SecurityAlertsMaxOrderBy {
  alertType: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  resolutionNotes: OrderBy
  resolvedAt: OrderBy
  resolvedBy: OrderBy
  severity: OrderBy
  title: OrderBy
  userAgent: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type SecurityAlertsMinFields {
  alertType: String
  createdAt: timestamptz
  description: String
  id: uuid
  resolutionNotes: String
  resolvedAt: timestamptz
  resolvedBy: uuid
  severity: String
  title: String
  userAgent: String
  userId: uuid
}

"""
order by min() on columns of table "security_alerts"
"""
input SecurityAlertsMinOrderBy {
  alertType: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  resolutionNotes: OrderBy
  resolvedAt: OrderBy
  resolvedBy: OrderBy
  severity: OrderBy
  title: OrderBy
  userAgent: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "security_alerts"
"""
type SecurityAlertsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [SecurityAlerts!]!
}

"""
on_conflict condition type for table "security_alerts"
"""
input SecurityAlertsOnConflict {
  constraint: SecurityAlertsConstraint!
  updateColumns: [SecurityAlertsUpdateColumn!]! = []
  where: SecurityAlertsBoolExp
}

"""Ordering options when selecting data from "security_alerts"."""
input SecurityAlertsOrderBy {
  alertType: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  isResolved: OrderBy
  metadata: OrderBy
  resolutionNotes: OrderBy
  resolvedAt: OrderBy
  resolvedBy: OrderBy
  resolvedByUser: UsersOrderBy
  severity: OrderBy
  title: OrderBy
  user: UsersOrderBy
  userAgent: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: security_alerts"""
input SecurityAlertsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input SecurityAlertsPrependInput {
  metadata: jsonb
}

"""
select columns of table "security_alerts"
"""
enum SecurityAlertsSelectColumn {
  """column name"""
  alertType
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  isResolved
  """column name"""
  metadata
  """column name"""
  resolutionNotes
  """column name"""
  resolvedAt
  """column name"""
  resolvedBy
  """column name"""
  severity
  """column name"""
  title
  """column name"""
  userAgent
  """column name"""
  userId
}

"""
select "securityAlertsAggregateBoolExpBool_andArgumentsColumns" columns of table "security_alerts"
"""
enum SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isResolved
}

"""
select "securityAlertsAggregateBoolExpBool_orArgumentsColumns" columns of table "security_alerts"
"""
enum SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isResolved
}

"""
input type for updating data in table "security_alerts"
"""
input SecurityAlertsSetInput {
  alertType: String
  createdAt: timestamptz
  description: String
  id: uuid
  ipAddress: inet
  isResolved: Boolean
  metadata: jsonb
  resolutionNotes: String
  resolvedAt: timestamptz
  resolvedBy: uuid
  severity: String
  title: String
  userAgent: String
  userId: uuid
}

"""
Streaming cursor of the table "security_alerts"
"""
input SecurityAlertsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SecurityAlertsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SecurityAlertsStreamCursorValueInput {
  alertType: String
  createdAt: timestamptz
  description: String
  id: uuid
  ipAddress: inet
  isResolved: Boolean
  metadata: jsonb
  resolutionNotes: String
  resolvedAt: timestamptz
  resolvedBy: uuid
  severity: String
  title: String
  userAgent: String
  userId: uuid
}

"""
update columns of table "security_alerts"
"""
enum SecurityAlertsUpdateColumn {
  """column name"""
  alertType
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  isResolved
  """column name"""
  metadata
  """column name"""
  resolutionNotes
  """column name"""
  resolvedAt
  """column name"""
  resolvedBy
  """column name"""
  severity
  """column name"""
  title
  """column name"""
  userAgent
  """column name"""
  userId
}

input SecurityAlertsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: SecurityAlertsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: SecurityAlertsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: SecurityAlertsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: SecurityAlertsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: SecurityAlertsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: SecurityAlertsSetInput
  """filter the rows which have to be updated"""
  where: SecurityAlertsBoolExp!
}

"""
columns and relationships of "security_settings"
"""
type SecuritySettings {
  createdAt: timestamptz
  id: uuid!
  isSystemWide: Boolean
  settingKey: String!
  settingValue(
    """JSON select path"""
    path: String
  ): jsonb!
  updatedAt: timestamptz
  updatedBy: uuid
  """An object relationship"""
  updatedByUser: Users
  """An object relationship"""
  user: Users
  userId: uuid
}

"""
aggregated selection of "security_settings"
"""
type SecuritySettingsAggregate {
  aggregate: SecuritySettingsAggregateFields
  nodes: [SecuritySettings!]!
}

input SecuritySettingsAggregateBoolExp {
  bool_and: securitySettingsAggregateBoolExpBool_and
  bool_or: securitySettingsAggregateBoolExpBool_or
  count: securitySettingsAggregateBoolExpCount
}

"""
aggregate fields of "security_settings"
"""
type SecuritySettingsAggregateFields {
  count(columns: [SecuritySettingsSelectColumn!], distinct: Boolean): Int!
  max: SecuritySettingsMaxFields
  min: SecuritySettingsMinFields
}

"""
order by aggregate values of table "security_settings"
"""
input SecuritySettingsAggregateOrderBy {
  count: OrderBy
  max: SecuritySettingsMaxOrderBy
  min: SecuritySettingsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input SecuritySettingsAppendInput {
  settingValue: jsonb
}

"""
input type for inserting array relation for remote table "security_settings"
"""
input SecuritySettingsArrRelInsertInput {
  data: [SecuritySettingsInsertInput!]!
  """upsert condition"""
  onConflict: SecuritySettingsOnConflict
}

"""
Boolean expression to filter rows from the table "security_settings". All fields are combined with a logical 'AND'.
"""
input SecuritySettingsBoolExp {
  _and: [SecuritySettingsBoolExp!]
  _not: SecuritySettingsBoolExp
  _or: [SecuritySettingsBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isSystemWide: BooleanComparisonExp
  settingKey: StringComparisonExp
  settingValue: JsonbComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: UuidComparisonExp
  updatedByUser: UsersBoolExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "security_settings"
"""
enum SecuritySettingsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  security_settings_pkey
  """
  unique or primary key constraint on columns "user_id", "setting_key"
  """
  security_settings_user_id_setting_key_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input SecuritySettingsDeleteAtPathInput {
  settingValue: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input SecuritySettingsDeleteElemInput {
  settingValue: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input SecuritySettingsDeleteKeyInput {
  settingValue: String
}

"""
input type for inserting data into table "security_settings"
"""
input SecuritySettingsInsertInput {
  createdAt: timestamptz
  id: uuid
  isSystemWide: Boolean
  settingKey: String
  settingValue: jsonb
  updatedAt: timestamptz
  updatedBy: uuid
  updatedByUser: UsersObjRelInsertInput
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type SecuritySettingsMaxFields {
  createdAt: timestamptz
  id: uuid
  settingKey: String
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
order by max() on columns of table "security_settings"
"""
input SecuritySettingsMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  settingKey: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type SecuritySettingsMinFields {
  createdAt: timestamptz
  id: uuid
  settingKey: String
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
order by min() on columns of table "security_settings"
"""
input SecuritySettingsMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  settingKey: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "security_settings"
"""
type SecuritySettingsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [SecuritySettings!]!
}

"""
on_conflict condition type for table "security_settings"
"""
input SecuritySettingsOnConflict {
  constraint: SecuritySettingsConstraint!
  updateColumns: [SecuritySettingsUpdateColumn!]! = []
  where: SecuritySettingsBoolExp
}

"""Ordering options when selecting data from "security_settings"."""
input SecuritySettingsOrderBy {
  createdAt: OrderBy
  id: OrderBy
  isSystemWide: OrderBy
  settingKey: OrderBy
  settingValue: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  updatedByUser: UsersOrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""primary key columns input for table: security_settings"""
input SecuritySettingsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input SecuritySettingsPrependInput {
  settingValue: jsonb
}

"""
select columns of table "security_settings"
"""
enum SecuritySettingsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  isSystemWide
  """column name"""
  settingKey
  """column name"""
  settingValue
  """column name"""
  updatedAt
  """column name"""
  updatedBy
  """column name"""
  userId
}

"""
select "securitySettingsAggregateBoolExpBool_andArgumentsColumns" columns of table "security_settings"
"""
enum SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isSystemWide
}

"""
select "securitySettingsAggregateBoolExpBool_orArgumentsColumns" columns of table "security_settings"
"""
enum SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isSystemWide
}

"""
input type for updating data in table "security_settings"
"""
input SecuritySettingsSetInput {
  createdAt: timestamptz
  id: uuid
  isSystemWide: Boolean
  settingKey: String
  settingValue: jsonb
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
Streaming cursor of the table "security_settings"
"""
input SecuritySettingsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SecuritySettingsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SecuritySettingsStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  isSystemWide: Boolean
  settingKey: String
  settingValue: jsonb
  updatedAt: timestamptz
  updatedBy: uuid
  userId: uuid
}

"""
update columns of table "security_settings"
"""
enum SecuritySettingsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  isSystemWide
  """column name"""
  settingKey
  """column name"""
  settingValue
  """column name"""
  updatedAt
  """column name"""
  updatedBy
  """column name"""
  userId
}

input SecuritySettingsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: SecuritySettingsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: SecuritySettingsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: SecuritySettingsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: SecuritySettingsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: SecuritySettingsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: SecuritySettingsSetInput
  """filter the rows which have to be updated"""
  where: SecuritySettingsBoolExp!
}

"""Dynamic pricing rules for services"""
type ServicePricingRules {
  conditions(
    """JSON select path"""
    path: String
  ): jsonb!
  createdAt: timestamptz
  createdBy: uuid
  """An object relationship"""
  createdByUser: Users
  effectiveFrom: timestamptz
  effectiveUntil: timestamptz
  id: uuid!
  isActive: Boolean
  pricingAdjustment(
    """JSON select path"""
    path: String
  ): jsonb!
  priority: Int
  ruleName: String!
  ruleType: String!
  """An object relationship"""
  service: Services!
  serviceId: uuid!
  updatedAt: timestamptz
}

"""
aggregated selection of "service_pricing_rules"
"""
type ServicePricingRulesAggregate {
  aggregate: ServicePricingRulesAggregateFields
  nodes: [ServicePricingRules!]!
}

input ServicePricingRulesAggregateBoolExp {
  bool_and: servicePricingRulesAggregateBoolExpBool_and
  bool_or: servicePricingRulesAggregateBoolExpBool_or
  count: servicePricingRulesAggregateBoolExpCount
}

"""
aggregate fields of "service_pricing_rules"
"""
type ServicePricingRulesAggregateFields {
  avg: ServicePricingRulesAvgFields
  count(columns: [ServicePricingRulesSelectColumn!], distinct: Boolean): Int!
  max: ServicePricingRulesMaxFields
  min: ServicePricingRulesMinFields
  stddev: ServicePricingRulesStddevFields
  stddevPop: ServicePricingRulesStddevPopFields
  stddevSamp: ServicePricingRulesStddevSampFields
  sum: ServicePricingRulesSumFields
  varPop: ServicePricingRulesVarPopFields
  varSamp: ServicePricingRulesVarSampFields
  variance: ServicePricingRulesVarianceFields
}

"""
order by aggregate values of table "service_pricing_rules"
"""
input ServicePricingRulesAggregateOrderBy {
  avg: ServicePricingRulesAvgOrderBy
  count: OrderBy
  max: ServicePricingRulesMaxOrderBy
  min: ServicePricingRulesMinOrderBy
  stddev: ServicePricingRulesStddevOrderBy
  stddevPop: ServicePricingRulesStddevPopOrderBy
  stddevSamp: ServicePricingRulesStddevSampOrderBy
  sum: ServicePricingRulesSumOrderBy
  varPop: ServicePricingRulesVarPopOrderBy
  varSamp: ServicePricingRulesVarSampOrderBy
  variance: ServicePricingRulesVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ServicePricingRulesAppendInput {
  conditions: jsonb
  pricingAdjustment: jsonb
}

"""
input type for inserting array relation for remote table "service_pricing_rules"
"""
input ServicePricingRulesArrRelInsertInput {
  data: [ServicePricingRulesInsertInput!]!
  """upsert condition"""
  onConflict: ServicePricingRulesOnConflict
}

"""aggregate avg on columns"""
type ServicePricingRulesAvgFields {
  priority: Float
}

"""
order by avg() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesAvgOrderBy {
  priority: OrderBy
}

"""
Boolean expression to filter rows from the table "service_pricing_rules". All fields are combined with a logical 'AND'.
"""
input ServicePricingRulesBoolExp {
  _and: [ServicePricingRulesBoolExp!]
  _not: ServicePricingRulesBoolExp
  _or: [ServicePricingRulesBoolExp!]
  conditions: JsonbComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  effectiveFrom: TimestamptzComparisonExp
  effectiveUntil: TimestamptzComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  pricingAdjustment: JsonbComparisonExp
  priority: IntComparisonExp
  ruleName: StringComparisonExp
  ruleType: StringComparisonExp
  service: ServicesBoolExp
  serviceId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "service_pricing_rules"
"""
enum ServicePricingRulesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_pricing_rules_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ServicePricingRulesDeleteAtPathInput {
  conditions: [String!]
  pricingAdjustment: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ServicePricingRulesDeleteElemInput {
  conditions: Int
  pricingAdjustment: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ServicePricingRulesDeleteKeyInput {
  conditions: String
  pricingAdjustment: String
}

"""
input type for incrementing numeric columns in table "service_pricing_rules"
"""
input ServicePricingRulesIncInput {
  priority: Int
}

"""
input type for inserting data into table "service_pricing_rules"
"""
input ServicePricingRulesInsertInput {
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  effectiveFrom: timestamptz
  effectiveUntil: timestamptz
  id: uuid
  isActive: Boolean
  pricingAdjustment: jsonb
  priority: Int
  ruleName: String
  ruleType: String
  service: ServicesObjRelInsertInput
  serviceId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type ServicePricingRulesMaxFields {
  createdAt: timestamptz
  createdBy: uuid
  effectiveFrom: timestamptz
  effectiveUntil: timestamptz
  id: uuid
  priority: Int
  ruleName: String
  ruleType: String
  serviceId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  effectiveFrom: OrderBy
  effectiveUntil: OrderBy
  id: OrderBy
  priority: OrderBy
  ruleName: OrderBy
  ruleType: OrderBy
  serviceId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ServicePricingRulesMinFields {
  createdAt: timestamptz
  createdBy: uuid
  effectiveFrom: timestamptz
  effectiveUntil: timestamptz
  id: uuid
  priority: Int
  ruleName: String
  ruleType: String
  serviceId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  effectiveFrom: OrderBy
  effectiveUntil: OrderBy
  id: OrderBy
  priority: OrderBy
  ruleName: OrderBy
  ruleType: OrderBy
  serviceId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "service_pricing_rules"
"""
type ServicePricingRulesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ServicePricingRules!]!
}

"""
on_conflict condition type for table "service_pricing_rules"
"""
input ServicePricingRulesOnConflict {
  constraint: ServicePricingRulesConstraint!
  updateColumns: [ServicePricingRulesUpdateColumn!]! = []
  where: ServicePricingRulesBoolExp
}

"""Ordering options when selecting data from "service_pricing_rules"."""
input ServicePricingRulesOrderBy {
  conditions: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  effectiveFrom: OrderBy
  effectiveUntil: OrderBy
  id: OrderBy
  isActive: OrderBy
  pricingAdjustment: OrderBy
  priority: OrderBy
  ruleName: OrderBy
  ruleType: OrderBy
  service: ServicesOrderBy
  serviceId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: service_pricing_rules"""
input ServicePricingRulesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ServicePricingRulesPrependInput {
  conditions: jsonb
  pricingAdjustment: jsonb
}

"""
select columns of table "service_pricing_rules"
"""
enum ServicePricingRulesSelectColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  effectiveFrom
  """column name"""
  effectiveUntil
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  pricingAdjustment
  """column name"""
  priority
  """column name"""
  ruleName
  """column name"""
  ruleType
  """column name"""
  serviceId
  """column name"""
  updatedAt
}

"""
select "servicePricingRulesAggregateBoolExpBool_andArgumentsColumns" columns of table "service_pricing_rules"
"""
enum ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
}

"""
select "servicePricingRulesAggregateBoolExpBool_orArgumentsColumns" columns of table "service_pricing_rules"
"""
enum ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
}

"""
input type for updating data in table "service_pricing_rules"
"""
input ServicePricingRulesSetInput {
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  effectiveFrom: timestamptz
  effectiveUntil: timestamptz
  id: uuid
  isActive: Boolean
  pricingAdjustment: jsonb
  priority: Int
  ruleName: String
  ruleType: String
  serviceId: uuid
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type ServicePricingRulesStddevFields {
  priority: Float
}

"""
order by stddev() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesStddevOrderBy {
  priority: OrderBy
}

"""aggregate stddevPop on columns"""
type ServicePricingRulesStddevPopFields {
  priority: Float
}

"""
order by stddevPop() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesStddevPopOrderBy {
  priority: OrderBy
}

"""aggregate stddevSamp on columns"""
type ServicePricingRulesStddevSampFields {
  priority: Float
}

"""
order by stddevSamp() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesStddevSampOrderBy {
  priority: OrderBy
}

"""
Streaming cursor of the table "service_pricing_rules"
"""
input ServicePricingRulesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServicePricingRulesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServicePricingRulesStreamCursorValueInput {
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  effectiveFrom: timestamptz
  effectiveUntil: timestamptz
  id: uuid
  isActive: Boolean
  pricingAdjustment: jsonb
  priority: Int
  ruleName: String
  ruleType: String
  serviceId: uuid
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type ServicePricingRulesSumFields {
  priority: Int
}

"""
order by sum() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesSumOrderBy {
  priority: OrderBy
}

"""
update columns of table "service_pricing_rules"
"""
enum ServicePricingRulesUpdateColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  effectiveFrom
  """column name"""
  effectiveUntil
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  pricingAdjustment
  """column name"""
  priority
  """column name"""
  ruleName
  """column name"""
  ruleType
  """column name"""
  serviceId
  """column name"""
  updatedAt
}

input ServicePricingRulesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ServicePricingRulesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ServicePricingRulesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ServicePricingRulesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ServicePricingRulesDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: ServicePricingRulesIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ServicePricingRulesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: ServicePricingRulesSetInput
  """filter the rows which have to be updated"""
  where: ServicePricingRulesBoolExp!
}

"""aggregate varPop on columns"""
type ServicePricingRulesVarPopFields {
  priority: Float
}

"""
order by varPop() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesVarPopOrderBy {
  priority: OrderBy
}

"""aggregate varSamp on columns"""
type ServicePricingRulesVarSampFields {
  priority: Float
}

"""
order by varSamp() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesVarSampOrderBy {
  priority: OrderBy
}

"""aggregate variance on columns"""
type ServicePricingRulesVarianceFields {
  priority: Float
}

"""
order by variance() on columns of table "service_pricing_rules"
"""
input ServicePricingRulesVarianceOrderBy {
  priority: OrderBy
}

"""Reusable service bundles and templates"""
type ServiceTemplates {
  bundleDiscountPercentage: numeric
  category: String
  createdAt: timestamptz
  createdBy: uuid
  """An object relationship"""
  createdByUser: Users
  description: String
  id: uuid!
  isPublic: Boolean
  name: String!
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: String
  services(
    """JSON select path"""
    path: String
  ): jsonb!
  targetClientTypes: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  """An object relationship"""
  updatedByUser: Users
}

"""
aggregated selection of "service_templates"
"""
type ServiceTemplatesAggregate {
  aggregate: ServiceTemplatesAggregateFields
  nodes: [ServiceTemplates!]!
}

input ServiceTemplatesAggregateBoolExp {
  bool_and: serviceTemplatesAggregateBoolExpBool_and
  bool_or: serviceTemplatesAggregateBoolExpBool_or
  count: serviceTemplatesAggregateBoolExpCount
}

"""
aggregate fields of "service_templates"
"""
type ServiceTemplatesAggregateFields {
  avg: ServiceTemplatesAvgFields
  count(columns: [ServiceTemplatesSelectColumn!], distinct: Boolean): Int!
  max: ServiceTemplatesMaxFields
  min: ServiceTemplatesMinFields
  stddev: ServiceTemplatesStddevFields
  stddevPop: ServiceTemplatesStddevPopFields
  stddevSamp: ServiceTemplatesStddevSampFields
  sum: ServiceTemplatesSumFields
  varPop: ServiceTemplatesVarPopFields
  varSamp: ServiceTemplatesVarSampFields
  variance: ServiceTemplatesVarianceFields
}

"""
order by aggregate values of table "service_templates"
"""
input ServiceTemplatesAggregateOrderBy {
  avg: ServiceTemplatesAvgOrderBy
  count: OrderBy
  max: ServiceTemplatesMaxOrderBy
  min: ServiceTemplatesMinOrderBy
  stddev: ServiceTemplatesStddevOrderBy
  stddevPop: ServiceTemplatesStddevPopOrderBy
  stddevSamp: ServiceTemplatesStddevSampOrderBy
  sum: ServiceTemplatesSumOrderBy
  varPop: ServiceTemplatesVarPopOrderBy
  varSamp: ServiceTemplatesVarSampOrderBy
  variance: ServiceTemplatesVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ServiceTemplatesAppendInput {
  services: jsonb
}

"""
input type for inserting array relation for remote table "service_templates"
"""
input ServiceTemplatesArrRelInsertInput {
  data: [ServiceTemplatesInsertInput!]!
  """upsert condition"""
  onConflict: ServiceTemplatesOnConflict
}

"""aggregate avg on columns"""
type ServiceTemplatesAvgFields {
  bundleDiscountPercentage: Float
}

"""
order by avg() on columns of table "service_templates"
"""
input ServiceTemplatesAvgOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""
Boolean expression to filter rows from the table "service_templates". All fields are combined with a logical 'AND'.
"""
input ServiceTemplatesBoolExp {
  _and: [ServiceTemplatesBoolExp!]
  _not: ServiceTemplatesBoolExp
  _or: [ServiceTemplatesBoolExp!]
  bundleDiscountPercentage: NumericComparisonExp
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  description: StringComparisonExp
  id: UuidComparisonExp
  isPublic: BooleanComparisonExp
  name: StringComparisonExp
  pricingStrategy: StringComparisonExp
  services: JsonbComparisonExp
  targetClientTypes: StringArrayComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: UuidComparisonExp
  updatedByUser: UsersBoolExp
}

"""
unique or primary key constraints on table "service_templates"
"""
enum ServiceTemplatesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_templates_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ServiceTemplatesDeleteAtPathInput {
  services: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ServiceTemplatesDeleteElemInput {
  services: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ServiceTemplatesDeleteKeyInput {
  services: String
}

"""
input type for incrementing numeric columns in table "service_templates"
"""
input ServiceTemplatesIncInput {
  bundleDiscountPercentage: numeric
}

"""
input type for inserting data into table "service_templates"
"""
input ServiceTemplatesInsertInput {
  bundleDiscountPercentage: numeric
  category: String
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  description: String
  id: uuid
  isPublic: Boolean
  name: String
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: String
  services: jsonb
  targetClientTypes: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
  updatedByUser: UsersObjRelInsertInput
}

"""aggregate max on columns"""
type ServiceTemplatesMaxFields {
  bundleDiscountPercentage: numeric
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  id: uuid
  name: String
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: String
  targetClientTypes: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "service_templates"
"""
input ServiceTemplatesMaxOrderBy {
  bundleDiscountPercentage: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: OrderBy
  targetClientTypes: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""aggregate min on columns"""
type ServiceTemplatesMinFields {
  bundleDiscountPercentage: numeric
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  id: uuid
  name: String
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: String
  targetClientTypes: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "service_templates"
"""
input ServiceTemplatesMinOrderBy {
  bundleDiscountPercentage: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: OrderBy
  targetClientTypes: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""
response of any mutation on the table "service_templates"
"""
type ServiceTemplatesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ServiceTemplates!]!
}

"""
on_conflict condition type for table "service_templates"
"""
input ServiceTemplatesOnConflict {
  constraint: ServiceTemplatesConstraint!
  updateColumns: [ServiceTemplatesUpdateColumn!]! = []
  where: ServiceTemplatesBoolExp
}

"""Ordering options when selecting data from "service_templates"."""
input ServiceTemplatesOrderBy {
  bundleDiscountPercentage: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  description: OrderBy
  id: OrderBy
  isPublic: OrderBy
  name: OrderBy
  pricingStrategy: OrderBy
  services: OrderBy
  targetClientTypes: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  updatedByUser: UsersOrderBy
}

"""primary key columns input for table: service_templates"""
input ServiceTemplatesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ServiceTemplatesPrependInput {
  services: jsonb
}

"""
select columns of table "service_templates"
"""
enum ServiceTemplatesSelectColumn {
  """column name"""
  bundleDiscountPercentage
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  description
  """column name"""
  id
  """column name"""
  isPublic
  """column name"""
  name
  """column name"""
  pricingStrategy
  """column name"""
  services
  """column name"""
  targetClientTypes
  """column name"""
  updatedAt
  """column name"""
  updatedBy
}

"""
select "serviceTemplatesAggregateBoolExpBool_andArgumentsColumns" columns of table "service_templates"
"""
enum ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isPublic
}

"""
select "serviceTemplatesAggregateBoolExpBool_orArgumentsColumns" columns of table "service_templates"
"""
enum ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isPublic
}

"""
input type for updating data in table "service_templates"
"""
input ServiceTemplatesSetInput {
  bundleDiscountPercentage: numeric
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  id: uuid
  isPublic: Boolean
  name: String
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: String
  services: jsonb
  targetClientTypes: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate stddev on columns"""
type ServiceTemplatesStddevFields {
  bundleDiscountPercentage: Float
}

"""
order by stddev() on columns of table "service_templates"
"""
input ServiceTemplatesStddevOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""aggregate stddevPop on columns"""
type ServiceTemplatesStddevPopFields {
  bundleDiscountPercentage: Float
}

"""
order by stddevPop() on columns of table "service_templates"
"""
input ServiceTemplatesStddevPopOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""aggregate stddevSamp on columns"""
type ServiceTemplatesStddevSampFields {
  bundleDiscountPercentage: Float
}

"""
order by stddevSamp() on columns of table "service_templates"
"""
input ServiceTemplatesStddevSampOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""
Streaming cursor of the table "service_templates"
"""
input ServiceTemplatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServiceTemplatesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServiceTemplatesStreamCursorValueInput {
  bundleDiscountPercentage: numeric
  category: String
  createdAt: timestamptz
  createdBy: uuid
  description: String
  id: uuid
  isPublic: Boolean
  name: String
  """
  How to calculate template price: sum (add all), fixed (set price), tiered (based on rules)
  """
  pricingStrategy: String
  services: jsonb
  targetClientTypes: [String!]
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate sum on columns"""
type ServiceTemplatesSumFields {
  bundleDiscountPercentage: numeric
}

"""
order by sum() on columns of table "service_templates"
"""
input ServiceTemplatesSumOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""
update columns of table "service_templates"
"""
enum ServiceTemplatesUpdateColumn {
  """column name"""
  bundleDiscountPercentage
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  description
  """column name"""
  id
  """column name"""
  isPublic
  """column name"""
  name
  """column name"""
  pricingStrategy
  """column name"""
  services
  """column name"""
  targetClientTypes
  """column name"""
  updatedAt
  """column name"""
  updatedBy
}

input ServiceTemplatesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ServiceTemplatesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ServiceTemplatesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ServiceTemplatesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ServiceTemplatesDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: ServiceTemplatesIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ServiceTemplatesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: ServiceTemplatesSetInput
  """filter the rows which have to be updated"""
  where: ServiceTemplatesBoolExp!
}

"""aggregate varPop on columns"""
type ServiceTemplatesVarPopFields {
  bundleDiscountPercentage: Float
}

"""
order by varPop() on columns of table "service_templates"
"""
input ServiceTemplatesVarPopOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""aggregate varSamp on columns"""
type ServiceTemplatesVarSampFields {
  bundleDiscountPercentage: Float
}

"""
order by varSamp() on columns of table "service_templates"
"""
input ServiceTemplatesVarSampOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""aggregate variance on columns"""
type ServiceTemplatesVarianceFields {
  bundleDiscountPercentage: Float
}

"""
order by variance() on columns of table "service_templates"
"""
input ServiceTemplatesVarianceOrderBy {
  bundleDiscountPercentage: OrderBy
}

"""Core services catalog with proper referential integrity"""
type Services {
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: String!
  category: String!
  """An array relationship"""
  clientAgreements(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): [ClientServiceAgreements!]!
  """An aggregate relationship"""
  clientAgreementsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): ClientServiceAgreementsAggregate!
  createdAt: timestamptz
  createdBy: uuid
  """An object relationship"""
  createdByUser: Users
  currency: String!
  defaultRate: numeric!
  dependencies(
    """JSON select path"""
    path: String
  ): jsonb
  description: String
  id: uuid!
  isActive: Boolean
  isTemplate: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String!
  """JSONB field for complex pricing logic"""
  pricingRules(
    """JSON select path"""
    path: String
  ): jsonb
  """An array relationship"""
  quoteLineItems(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): [QuoteLineItems!]!
  """An aggregate relationship"""
  quoteLineItemsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): QuoteLineItemsAggregate!
  """An array relationship"""
  servicePricingRules(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): [ServicePricingRules!]!
  """An aggregate relationship"""
  servicePricingRulesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): ServicePricingRulesAggregate!
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: String!
  updatedAt: timestamptz
  updatedBy: uuid
  """An object relationship"""
  updatedByUser: Users
}

"""
aggregated selection of "services"
"""
type ServicesAggregate {
  aggregate: ServicesAggregateFields
  nodes: [Services!]!
}

input ServicesAggregateBoolExp {
  bool_and: servicesAggregateBoolExpBool_and
  bool_or: servicesAggregateBoolExpBool_or
  count: servicesAggregateBoolExpCount
}

"""
aggregate fields of "services"
"""
type ServicesAggregateFields {
  avg: ServicesAvgFields
  count(columns: [ServicesSelectColumn!], distinct: Boolean): Int!
  max: ServicesMaxFields
  min: ServicesMinFields
  stddev: ServicesStddevFields
  stddevPop: ServicesStddevPopFields
  stddevSamp: ServicesStddevSampFields
  sum: ServicesSumFields
  varPop: ServicesVarPopFields
  varSamp: ServicesVarSampFields
  variance: ServicesVarianceFields
}

"""
order by aggregate values of table "services"
"""
input ServicesAggregateOrderBy {
  avg: ServicesAvgOrderBy
  count: OrderBy
  max: ServicesMaxOrderBy
  min: ServicesMinOrderBy
  stddev: ServicesStddevOrderBy
  stddevPop: ServicesStddevPopOrderBy
  stddevSamp: ServicesStddevSampOrderBy
  sum: ServicesSumOrderBy
  varPop: ServicesVarPopOrderBy
  varSamp: ServicesVarSampOrderBy
  variance: ServicesVarianceOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input ServicesAppendInput {
  dependencies: jsonb
  metadata: jsonb
  """JSONB field for complex pricing logic"""
  pricingRules: jsonb
}

"""
input type for inserting array relation for remote table "services"
"""
input ServicesArrRelInsertInput {
  data: [ServicesInsertInput!]!
  """upsert condition"""
  onConflict: ServicesOnConflict
}

"""aggregate avg on columns"""
type ServicesAvgFields {
  defaultRate: Float
}

"""
order by avg() on columns of table "services"
"""
input ServicesAvgOrderBy {
  defaultRate: OrderBy
}

"""
Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'.
"""
input ServicesBoolExp {
  _and: [ServicesBoolExp!]
  _not: ServicesBoolExp
  _or: [ServicesBoolExp!]
  billingItems: BillingItemsBoolExp
  billingItemsAggregate: BillingItemsAggregateBoolExp
  billingUnit: StringComparisonExp
  category: StringComparisonExp
  clientAgreements: ClientServiceAgreementsBoolExp
  clientAgreementsAggregate: ClientServiceAgreementsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: UsersBoolExp
  currency: StringComparisonExp
  defaultRate: NumericComparisonExp
  dependencies: JsonbComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  isTemplate: BooleanComparisonExp
  metadata: JsonbComparisonExp
  name: StringComparisonExp
  pricingRules: JsonbComparisonExp
  quoteLineItems: QuoteLineItemsBoolExp
  quoteLineItemsAggregate: QuoteLineItemsAggregateBoolExp
  servicePricingRules: ServicePricingRulesBoolExp
  servicePricingRulesAggregate: ServicePricingRulesAggregateBoolExp
  serviceType: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  updatedBy: UuidComparisonExp
  updatedByUser: UsersBoolExp
}

"""
unique or primary key constraints on table "services"
"""
enum ServicesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  services_name_key
  """
  unique or primary key constraint on columns "id"
  """
  services_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input ServicesDeleteAtPathInput {
  dependencies: [String!]
  metadata: [String!]
  """JSONB field for complex pricing logic"""
  pricingRules: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input ServicesDeleteElemInput {
  dependencies: Int
  metadata: Int
  """JSONB field for complex pricing logic"""
  pricingRules: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input ServicesDeleteKeyInput {
  dependencies: String
  metadata: String
  """JSONB field for complex pricing logic"""
  pricingRules: String
}

"""
input type for incrementing numeric columns in table "services"
"""
input ServicesIncInput {
  defaultRate: numeric
}

"""
input type for inserting data into table "services"
"""
input ServicesInsertInput {
  billingItems: BillingItemsArrRelInsertInput
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: String
  category: String
  clientAgreements: ClientServiceAgreementsArrRelInsertInput
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: UsersObjRelInsertInput
  currency: String
  defaultRate: numeric
  dependencies: jsonb
  description: String
  id: uuid
  isActive: Boolean
  isTemplate: Boolean
  metadata: jsonb
  name: String
  """JSONB field for complex pricing logic"""
  pricingRules: jsonb
  quoteLineItems: QuoteLineItemsArrRelInsertInput
  servicePricingRules: ServicePricingRulesArrRelInsertInput
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: String
  updatedAt: timestamptz
  updatedBy: uuid
  updatedByUser: UsersObjRelInsertInput
}

"""aggregate max on columns"""
type ServicesMaxFields {
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: String
  category: String
  createdAt: timestamptz
  createdBy: uuid
  currency: String
  defaultRate: numeric
  description: String
  id: uuid
  name: String
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by max() on columns of table "services"
"""
input ServicesMaxOrderBy {
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  currency: OrderBy
  defaultRate: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""aggregate min on columns"""
type ServicesMinFields {
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: String
  category: String
  createdAt: timestamptz
  createdBy: uuid
  currency: String
  defaultRate: numeric
  description: String
  id: uuid
  name: String
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""
order by min() on columns of table "services"
"""
input ServicesMinOrderBy {
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  currency: OrderBy
  defaultRate: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
}

"""
response of any mutation on the table "services"
"""
type ServicesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Services!]!
}

"""
input type for inserting object relation for remote table "services"
"""
input ServicesObjRelInsertInput {
  data: ServicesInsertInput!
  """upsert condition"""
  onConflict: ServicesOnConflict
}

"""
on_conflict condition type for table "services"
"""
input ServicesOnConflict {
  constraint: ServicesConstraint!
  updateColumns: [ServicesUpdateColumn!]! = []
  where: ServicesBoolExp
}

"""Ordering options when selecting data from "services"."""
input ServicesOrderBy {
  billingItemsAggregate: BillingItemsAggregateOrderBy
  billingUnit: OrderBy
  category: OrderBy
  clientAgreementsAggregate: ClientServiceAgreementsAggregateOrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: UsersOrderBy
  currency: OrderBy
  defaultRate: OrderBy
  dependencies: OrderBy
  description: OrderBy
  id: OrderBy
  isActive: OrderBy
  isTemplate: OrderBy
  metadata: OrderBy
  name: OrderBy
  pricingRules: OrderBy
  quoteLineItemsAggregate: QuoteLineItemsAggregateOrderBy
  servicePricingRulesAggregate: ServicePricingRulesAggregateOrderBy
  serviceType: OrderBy
  updatedAt: OrderBy
  updatedBy: OrderBy
  updatedByUser: UsersOrderBy
}

"""primary key columns input for table: services"""
input ServicesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input ServicesPrependInput {
  dependencies: jsonb
  metadata: jsonb
  """JSONB field for complex pricing logic"""
  pricingRules: jsonb
}

"""
select columns of table "services"
"""
enum ServicesSelectColumn {
  """column name"""
  billingUnit
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  currency
  """column name"""
  defaultRate
  """column name"""
  dependencies
  """column name"""
  description
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isTemplate
  """column name"""
  metadata
  """column name"""
  name
  """column name"""
  pricingRules
  """column name"""
  serviceType
  """column name"""
  updatedAt
  """column name"""
  updatedBy
}

"""
select "servicesAggregateBoolExpBool_andArgumentsColumns" columns of table "services"
"""
enum ServicesSelectColumnServicesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isTemplate
}

"""
select "servicesAggregateBoolExpBool_orArgumentsColumns" columns of table "services"
"""
enum ServicesSelectColumnServicesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isTemplate
}

"""
input type for updating data in table "services"
"""
input ServicesSetInput {
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: String
  category: String
  createdAt: timestamptz
  createdBy: uuid
  currency: String
  defaultRate: numeric
  dependencies: jsonb
  description: String
  id: uuid
  isActive: Boolean
  isTemplate: Boolean
  metadata: jsonb
  name: String
  """JSONB field for complex pricing logic"""
  pricingRules: jsonb
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate stddev on columns"""
type ServicesStddevFields {
  defaultRate: Float
}

"""
order by stddev() on columns of table "services"
"""
input ServicesStddevOrderBy {
  defaultRate: OrderBy
}

"""aggregate stddevPop on columns"""
type ServicesStddevPopFields {
  defaultRate: Float
}

"""
order by stddevPop() on columns of table "services"
"""
input ServicesStddevPopOrderBy {
  defaultRate: OrderBy
}

"""aggregate stddevSamp on columns"""
type ServicesStddevSampFields {
  defaultRate: Float
}

"""
order by stddevSamp() on columns of table "services"
"""
input ServicesStddevSampOrderBy {
  defaultRate: OrderBy
}

"""
Streaming cursor of the table "services"
"""
input ServicesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ServicesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ServicesStreamCursorValueInput {
  """How this service is billed: Per Payroll, Per Employee, Per Hour, etc."""
  billingUnit: String
  category: String
  createdAt: timestamptz
  createdBy: uuid
  currency: String
  defaultRate: numeric
  dependencies: jsonb
  description: String
  id: uuid
  isActive: Boolean
  isTemplate: Boolean
  metadata: jsonb
  name: String
  """JSONB field for complex pricing logic"""
  pricingRules: jsonb
  """
  standard: regular service, template: reusable template, custom: client-specific
  """
  serviceType: String
  updatedAt: timestamptz
  updatedBy: uuid
}

"""aggregate sum on columns"""
type ServicesSumFields {
  defaultRate: numeric
}

"""
order by sum() on columns of table "services"
"""
input ServicesSumOrderBy {
  defaultRate: OrderBy
}

"""
update columns of table "services"
"""
enum ServicesUpdateColumn {
  """column name"""
  billingUnit
  """column name"""
  category
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  currency
  """column name"""
  defaultRate
  """column name"""
  dependencies
  """column name"""
  description
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isTemplate
  """column name"""
  metadata
  """column name"""
  name
  """column name"""
  pricingRules
  """column name"""
  serviceType
  """column name"""
  updatedAt
  """column name"""
  updatedBy
}

input ServicesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: ServicesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: ServicesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: ServicesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: ServicesDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: ServicesIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: ServicesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: ServicesSetInput
  """filter the rows which have to be updated"""
  where: ServicesBoolExp!
}

"""aggregate varPop on columns"""
type ServicesVarPopFields {
  defaultRate: Float
}

"""
order by varPop() on columns of table "services"
"""
input ServicesVarPopOrderBy {
  defaultRate: OrderBy
}

"""aggregate varSamp on columns"""
type ServicesVarSampFields {
  defaultRate: Float
}

"""
order by varSamp() on columns of table "services"
"""
input ServicesVarSampOrderBy {
  defaultRate: OrderBy
}

"""aggregate variance on columns"""
type ServicesVarianceFields {
  defaultRate: Float
}

"""
order by variance() on columns of table "services"
"""
input ServicesVarianceOrderBy {
  defaultRate: OrderBy
}

"""
columns and relationships of "staff_billing_performance"
"""
type StaffBillingPerformance {
  averageProfitMargin: numeric
  staffName: String
  staffUserId: uuid
  totalActualRevenue: numeric
  totalEstimatedRevenue: numeric
  totalHoursLogged: numeric
  totalPayrolls: bigint
}

"""
aggregated selection of "staff_billing_performance"
"""
type StaffBillingPerformanceAggregate {
  aggregate: StaffBillingPerformanceAggregateFields
  nodes: [StaffBillingPerformance!]!
}

"""
aggregate fields of "staff_billing_performance"
"""
type StaffBillingPerformanceAggregateFields {
  avg: StaffBillingPerformanceAvgFields
  count(columns: [StaffBillingPerformanceSelectColumn!], distinct: Boolean): Int!
  max: StaffBillingPerformanceMaxFields
  min: StaffBillingPerformanceMinFields
  stddev: StaffBillingPerformanceStddevFields
  stddevPop: StaffBillingPerformanceStddevPopFields
  stddevSamp: StaffBillingPerformanceStddevSampFields
  sum: StaffBillingPerformanceSumFields
  varPop: StaffBillingPerformanceVarPopFields
  varSamp: StaffBillingPerformanceVarSampFields
  variance: StaffBillingPerformanceVarianceFields
}

"""aggregate avg on columns"""
type StaffBillingPerformanceAvgFields {
  averageProfitMargin: Float
  totalActualRevenue: Float
  totalEstimatedRevenue: Float
  totalHoursLogged: Float
  totalPayrolls: Float
}

"""
Boolean expression to filter rows from the table "staff_billing_performance". All fields are combined with a logical 'AND'.
"""
input StaffBillingPerformanceBoolExp {
  _and: [StaffBillingPerformanceBoolExp!]
  _not: StaffBillingPerformanceBoolExp
  _or: [StaffBillingPerformanceBoolExp!]
  averageProfitMargin: NumericComparisonExp
  staffName: StringComparisonExp
  staffUserId: UuidComparisonExp
  totalActualRevenue: NumericComparisonExp
  totalEstimatedRevenue: NumericComparisonExp
  totalHoursLogged: NumericComparisonExp
  totalPayrolls: BigintComparisonExp
}

"""aggregate max on columns"""
type StaffBillingPerformanceMaxFields {
  averageProfitMargin: numeric
  staffName: String
  staffUserId: uuid
  totalActualRevenue: numeric
  totalEstimatedRevenue: numeric
  totalHoursLogged: numeric
  totalPayrolls: bigint
}

"""aggregate min on columns"""
type StaffBillingPerformanceMinFields {
  averageProfitMargin: numeric
  staffName: String
  staffUserId: uuid
  totalActualRevenue: numeric
  totalEstimatedRevenue: numeric
  totalHoursLogged: numeric
  totalPayrolls: bigint
}

"""Ordering options when selecting data from "staff_billing_performance"."""
input StaffBillingPerformanceOrderBy {
  averageProfitMargin: OrderBy
  staffName: OrderBy
  staffUserId: OrderBy
  totalActualRevenue: OrderBy
  totalEstimatedRevenue: OrderBy
  totalHoursLogged: OrderBy
  totalPayrolls: OrderBy
}

"""
select columns of table "staff_billing_performance"
"""
enum StaffBillingPerformanceSelectColumn {
  """column name"""
  averageProfitMargin
  """column name"""
  staffName
  """column name"""
  staffUserId
  """column name"""
  totalActualRevenue
  """column name"""
  totalEstimatedRevenue
  """column name"""
  totalHoursLogged
  """column name"""
  totalPayrolls
}

"""aggregate stddev on columns"""
type StaffBillingPerformanceStddevFields {
  averageProfitMargin: Float
  totalActualRevenue: Float
  totalEstimatedRevenue: Float
  totalHoursLogged: Float
  totalPayrolls: Float
}

"""aggregate stddevPop on columns"""
type StaffBillingPerformanceStddevPopFields {
  averageProfitMargin: Float
  totalActualRevenue: Float
  totalEstimatedRevenue: Float
  totalHoursLogged: Float
  totalPayrolls: Float
}

"""aggregate stddevSamp on columns"""
type StaffBillingPerformanceStddevSampFields {
  averageProfitMargin: Float
  totalActualRevenue: Float
  totalEstimatedRevenue: Float
  totalHoursLogged: Float
  totalPayrolls: Float
}

"""
Streaming cursor of the table "staff_billing_performance"
"""
input StaffBillingPerformanceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: StaffBillingPerformanceStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input StaffBillingPerformanceStreamCursorValueInput {
  averageProfitMargin: numeric
  staffName: String
  staffUserId: uuid
  totalActualRevenue: numeric
  totalEstimatedRevenue: numeric
  totalHoursLogged: numeric
  totalPayrolls: bigint
}

"""aggregate sum on columns"""
type StaffBillingPerformanceSumFields {
  averageProfitMargin: numeric
  totalActualRevenue: numeric
  totalEstimatedRevenue: numeric
  totalHoursLogged: numeric
  totalPayrolls: bigint
}

"""aggregate varPop on columns"""
type StaffBillingPerformanceVarPopFields {
  averageProfitMargin: Float
  totalActualRevenue: Float
  totalEstimatedRevenue: Float
  totalHoursLogged: Float
  totalPayrolls: Float
}

"""aggregate varSamp on columns"""
type StaffBillingPerformanceVarSampFields {
  averageProfitMargin: Float
  totalActualRevenue: Float
  totalEstimatedRevenue: Float
  totalHoursLogged: Float
  totalPayrolls: Float
}

"""aggregate variance on columns"""
type StaffBillingPerformanceVarianceFields {
  averageProfitMargin: Float
  totalActualRevenue: Float
  totalEstimatedRevenue: Float
  totalHoursLogged: Float
  totalPayrolls: Float
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringArrayComparisonExp {
  """is the array contained in the given array value"""
  _containedIn: [String!]
  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _isNull: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String
  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean
  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """does the column NOT match the given pattern"""
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "system_configuration"
"""
type SystemConfiguration {
  configKey: String!
  configType: String!
  configValue(
    """JSON select path"""
    path: String
  ): jsonb!
  createdAt: timestamptz
  description: String
  id: uuid!
  isActive: Boolean!
  updatedAt: timestamptz
}

"""
aggregated selection of "system_configuration"
"""
type SystemConfigurationAggregate {
  aggregate: SystemConfigurationAggregateFields
  nodes: [SystemConfiguration!]!
}

"""
aggregate fields of "system_configuration"
"""
type SystemConfigurationAggregateFields {
  count(columns: [SystemConfigurationSelectColumn!], distinct: Boolean): Int!
  max: SystemConfigurationMaxFields
  min: SystemConfigurationMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input SystemConfigurationAppendInput {
  configValue: jsonb
}

"""
Boolean expression to filter rows from the table "system_configuration". All fields are combined with a logical 'AND'.
"""
input SystemConfigurationBoolExp {
  _and: [SystemConfigurationBoolExp!]
  _not: SystemConfigurationBoolExp
  _or: [SystemConfigurationBoolExp!]
  configKey: StringComparisonExp
  configType: StringComparisonExp
  configValue: JsonbComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "system_configuration"
"""
enum SystemConfigurationConstraint {
  """
  unique or primary key constraint on columns "config_key"
  """
  system_configuration_config_key_key
  """
  unique or primary key constraint on columns "id"
  """
  system_configuration_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input SystemConfigurationDeleteAtPathInput {
  configValue: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input SystemConfigurationDeleteElemInput {
  configValue: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input SystemConfigurationDeleteKeyInput {
  configValue: String
}

"""
input type for inserting data into table "system_configuration"
"""
input SystemConfigurationInsertInput {
  configKey: String
  configType: String
  configValue: jsonb
  createdAt: timestamptz
  description: String
  id: uuid
  isActive: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type SystemConfigurationMaxFields {
  configKey: String
  configType: String
  createdAt: timestamptz
  description: String
  id: uuid
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type SystemConfigurationMinFields {
  configKey: String
  configType: String
  createdAt: timestamptz
  description: String
  id: uuid
  updatedAt: timestamptz
}

"""
response of any mutation on the table "system_configuration"
"""
type SystemConfigurationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [SystemConfiguration!]!
}

"""
on_conflict condition type for table "system_configuration"
"""
input SystemConfigurationOnConflict {
  constraint: SystemConfigurationConstraint!
  updateColumns: [SystemConfigurationUpdateColumn!]! = []
  where: SystemConfigurationBoolExp
}

"""Ordering options when selecting data from "system_configuration"."""
input SystemConfigurationOrderBy {
  configKey: OrderBy
  configType: OrderBy
  configValue: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  isActive: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: system_configuration"""
input SystemConfigurationPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input SystemConfigurationPrependInput {
  configValue: jsonb
}

"""
select columns of table "system_configuration"
"""
enum SystemConfigurationSelectColumn {
  """column name"""
  configKey
  """column name"""
  configType
  """column name"""
  configValue
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  updatedAt
}

"""
input type for updating data in table "system_configuration"
"""
input SystemConfigurationSetInput {
  configKey: String
  configType: String
  configValue: jsonb
  createdAt: timestamptz
  description: String
  id: uuid
  isActive: Boolean
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "system_configuration"
"""
input SystemConfigurationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SystemConfigurationStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SystemConfigurationStreamCursorValueInput {
  configKey: String
  configType: String
  configValue: jsonb
  createdAt: timestamptz
  description: String
  id: uuid
  isActive: Boolean
  updatedAt: timestamptz
}

"""
update columns of table "system_configuration"
"""
enum SystemConfigurationUpdateColumn {
  """column name"""
  configKey
  """column name"""
  configType
  """column name"""
  configValue
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  updatedAt
}

input SystemConfigurationUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: SystemConfigurationAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: SystemConfigurationDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: SystemConfigurationDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: SystemConfigurationDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: SystemConfigurationPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: SystemConfigurationSetInput
  """filter the rows which have to be updated"""
  where: SystemConfigurationBoolExp!
}

"""
columns and relationships of "system_health"
"""
type SystemHealth {
  activeUsers: Int
  alerts(
    """JSON select path"""
    path: String
  ): jsonb
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  id: uuid!
  memoryUsage: numeric
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  status: String
  timestamp: timestamptz
}

"""
aggregated selection of "system_health"
"""
type SystemHealthAggregate {
  aggregate: SystemHealthAggregateFields
  nodes: [SystemHealth!]!
}

"""
aggregate fields of "system_health"
"""
type SystemHealthAggregateFields {
  avg: SystemHealthAvgFields
  count(columns: [SystemHealthSelectColumn!], distinct: Boolean): Int!
  max: SystemHealthMaxFields
  min: SystemHealthMinFields
  stddev: SystemHealthStddevFields
  stddevPop: SystemHealthStddevPopFields
  stddevSamp: SystemHealthStddevSampFields
  sum: SystemHealthSumFields
  varPop: SystemHealthVarPopFields
  varSamp: SystemHealthVarSampFields
  variance: SystemHealthVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input SystemHealthAppendInput {
  alerts: jsonb
  metadata: jsonb
}

"""aggregate avg on columns"""
type SystemHealthAvgFields {
  activeUsers: Float
  apiResponseTime: Float
  cpuUsage: Float
  databaseResponseTime: Float
  diskUsage: Float
  errorRate: Float
  memoryUsage: Float
}

"""
Boolean expression to filter rows from the table "system_health". All fields are combined with a logical 'AND'.
"""
input SystemHealthBoolExp {
  _and: [SystemHealthBoolExp!]
  _not: SystemHealthBoolExp
  _or: [SystemHealthBoolExp!]
  activeUsers: IntComparisonExp
  alerts: JsonbComparisonExp
  apiResponseTime: IntComparisonExp
  cpuUsage: NumericComparisonExp
  databaseResponseTime: IntComparisonExp
  diskUsage: NumericComparisonExp
  errorRate: NumericComparisonExp
  id: UuidComparisonExp
  memoryUsage: NumericComparisonExp
  metadata: JsonbComparisonExp
  status: StringComparisonExp
  timestamp: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "system_health"
"""
enum SystemHealthConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  system_health_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input SystemHealthDeleteAtPathInput {
  alerts: [String!]
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input SystemHealthDeleteElemInput {
  alerts: Int
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input SystemHealthDeleteKeyInput {
  alerts: String
  metadata: String
}

"""
input type for incrementing numeric columns in table "system_health"
"""
input SystemHealthIncInput {
  activeUsers: Int
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  memoryUsage: numeric
}

"""
input type for inserting data into table "system_health"
"""
input SystemHealthInsertInput {
  activeUsers: Int
  alerts: jsonb
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  id: uuid
  memoryUsage: numeric
  metadata: jsonb
  status: String
  timestamp: timestamptz
}

"""aggregate max on columns"""
type SystemHealthMaxFields {
  activeUsers: Int
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  id: uuid
  memoryUsage: numeric
  status: String
  timestamp: timestamptz
}

"""aggregate min on columns"""
type SystemHealthMinFields {
  activeUsers: Int
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  id: uuid
  memoryUsage: numeric
  status: String
  timestamp: timestamptz
}

"""
response of any mutation on the table "system_health"
"""
type SystemHealthMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [SystemHealth!]!
}

"""
on_conflict condition type for table "system_health"
"""
input SystemHealthOnConflict {
  constraint: SystemHealthConstraint!
  updateColumns: [SystemHealthUpdateColumn!]! = []
  where: SystemHealthBoolExp
}

"""Ordering options when selecting data from "system_health"."""
input SystemHealthOrderBy {
  activeUsers: OrderBy
  alerts: OrderBy
  apiResponseTime: OrderBy
  cpuUsage: OrderBy
  databaseResponseTime: OrderBy
  diskUsage: OrderBy
  errorRate: OrderBy
  id: OrderBy
  memoryUsage: OrderBy
  metadata: OrderBy
  status: OrderBy
  timestamp: OrderBy
}

"""primary key columns input for table: system_health"""
input SystemHealthPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input SystemHealthPrependInput {
  alerts: jsonb
  metadata: jsonb
}

"""
select columns of table "system_health"
"""
enum SystemHealthSelectColumn {
  """column name"""
  activeUsers
  """column name"""
  alerts
  """column name"""
  apiResponseTime
  """column name"""
  cpuUsage
  """column name"""
  databaseResponseTime
  """column name"""
  diskUsage
  """column name"""
  errorRate
  """column name"""
  id
  """column name"""
  memoryUsage
  """column name"""
  metadata
  """column name"""
  status
  """column name"""
  timestamp
}

"""
input type for updating data in table "system_health"
"""
input SystemHealthSetInput {
  activeUsers: Int
  alerts: jsonb
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  id: uuid
  memoryUsage: numeric
  metadata: jsonb
  status: String
  timestamp: timestamptz
}

"""aggregate stddev on columns"""
type SystemHealthStddevFields {
  activeUsers: Float
  apiResponseTime: Float
  cpuUsage: Float
  databaseResponseTime: Float
  diskUsage: Float
  errorRate: Float
  memoryUsage: Float
}

"""aggregate stddevPop on columns"""
type SystemHealthStddevPopFields {
  activeUsers: Float
  apiResponseTime: Float
  cpuUsage: Float
  databaseResponseTime: Float
  diskUsage: Float
  errorRate: Float
  memoryUsage: Float
}

"""aggregate stddevSamp on columns"""
type SystemHealthStddevSampFields {
  activeUsers: Float
  apiResponseTime: Float
  cpuUsage: Float
  databaseResponseTime: Float
  diskUsage: Float
  errorRate: Float
  memoryUsage: Float
}

"""
Streaming cursor of the table "system_health"
"""
input SystemHealthStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SystemHealthStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SystemHealthStreamCursorValueInput {
  activeUsers: Int
  alerts: jsonb
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  id: uuid
  memoryUsage: numeric
  metadata: jsonb
  status: String
  timestamp: timestamptz
}

"""aggregate sum on columns"""
type SystemHealthSumFields {
  activeUsers: Int
  apiResponseTime: Int
  cpuUsage: numeric
  databaseResponseTime: Int
  diskUsage: numeric
  errorRate: numeric
  memoryUsage: numeric
}

"""
update columns of table "system_health"
"""
enum SystemHealthUpdateColumn {
  """column name"""
  activeUsers
  """column name"""
  alerts
  """column name"""
  apiResponseTime
  """column name"""
  cpuUsage
  """column name"""
  databaseResponseTime
  """column name"""
  diskUsage
  """column name"""
  errorRate
  """column name"""
  id
  """column name"""
  memoryUsage
  """column name"""
  metadata
  """column name"""
  status
  """column name"""
  timestamp
}

input SystemHealthUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: SystemHealthAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: SystemHealthDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: SystemHealthDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: SystemHealthDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: SystemHealthIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: SystemHealthPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: SystemHealthSetInput
  """filter the rows which have to be updated"""
  where: SystemHealthBoolExp!
}

"""aggregate varPop on columns"""
type SystemHealthVarPopFields {
  activeUsers: Float
  apiResponseTime: Float
  cpuUsage: Float
  databaseResponseTime: Float
  diskUsage: Float
  errorRate: Float
  memoryUsage: Float
}

"""aggregate varSamp on columns"""
type SystemHealthVarSampFields {
  activeUsers: Float
  apiResponseTime: Float
  cpuUsage: Float
  databaseResponseTime: Float
  diskUsage: Float
  errorRate: Float
  memoryUsage: Float
}

"""aggregate variance on columns"""
type SystemHealthVarianceFields {
  activeUsers: Float
  apiResponseTime: Float
  cpuUsage: Float
  databaseResponseTime: Float
  diskUsage: Float
  errorRate: Float
  memoryUsage: Float
}

"""
columns and relationships of "team_capacity_by_position"
"""
type TeamCapacityByPosition {
  avgAdminPercentage: numeric
  consultantCount: bigint
  position: user_position
  totalAdminHours: numeric
  totalPayrollCapacity: numeric
  totalWorkHours: numeric
}

"""
aggregated selection of "team_capacity_by_position"
"""
type TeamCapacityByPositionAggregate {
  aggregate: TeamCapacityByPositionAggregateFields
  nodes: [TeamCapacityByPosition!]!
}

"""
aggregate fields of "team_capacity_by_position"
"""
type TeamCapacityByPositionAggregateFields {
  avg: TeamCapacityByPositionAvgFields
  count(columns: [TeamCapacityByPositionSelectColumn!], distinct: Boolean): Int!
  max: TeamCapacityByPositionMaxFields
  min: TeamCapacityByPositionMinFields
  stddev: TeamCapacityByPositionStddevFields
  stddevPop: TeamCapacityByPositionStddevPopFields
  stddevSamp: TeamCapacityByPositionStddevSampFields
  sum: TeamCapacityByPositionSumFields
  varPop: TeamCapacityByPositionVarPopFields
  varSamp: TeamCapacityByPositionVarSampFields
  variance: TeamCapacityByPositionVarianceFields
}

"""aggregate avg on columns"""
type TeamCapacityByPositionAvgFields {
  avgAdminPercentage: Float
  consultantCount: Float
  totalAdminHours: Float
  totalPayrollCapacity: Float
  totalWorkHours: Float
}

"""
Boolean expression to filter rows from the table "team_capacity_by_position". All fields are combined with a logical 'AND'.
"""
input TeamCapacityByPositionBoolExp {
  _and: [TeamCapacityByPositionBoolExp!]
  _not: TeamCapacityByPositionBoolExp
  _or: [TeamCapacityByPositionBoolExp!]
  avgAdminPercentage: NumericComparisonExp
  consultantCount: BigintComparisonExp
  position: UserPositionComparisonExp
  totalAdminHours: NumericComparisonExp
  totalPayrollCapacity: NumericComparisonExp
  totalWorkHours: NumericComparisonExp
}

"""aggregate max on columns"""
type TeamCapacityByPositionMaxFields {
  avgAdminPercentage: numeric
  consultantCount: bigint
  position: user_position
  totalAdminHours: numeric
  totalPayrollCapacity: numeric
  totalWorkHours: numeric
}

"""aggregate min on columns"""
type TeamCapacityByPositionMinFields {
  avgAdminPercentage: numeric
  consultantCount: bigint
  position: user_position
  totalAdminHours: numeric
  totalPayrollCapacity: numeric
  totalWorkHours: numeric
}

"""Ordering options when selecting data from "team_capacity_by_position"."""
input TeamCapacityByPositionOrderBy {
  avgAdminPercentage: OrderBy
  consultantCount: OrderBy
  position: OrderBy
  totalAdminHours: OrderBy
  totalPayrollCapacity: OrderBy
  totalWorkHours: OrderBy
}

"""
select columns of table "team_capacity_by_position"
"""
enum TeamCapacityByPositionSelectColumn {
  """column name"""
  avgAdminPercentage
  """column name"""
  consultantCount
  """column name"""
  position
  """column name"""
  totalAdminHours
  """column name"""
  totalPayrollCapacity
  """column name"""
  totalWorkHours
}

"""aggregate stddev on columns"""
type TeamCapacityByPositionStddevFields {
  avgAdminPercentage: Float
  consultantCount: Float
  totalAdminHours: Float
  totalPayrollCapacity: Float
  totalWorkHours: Float
}

"""aggregate stddevPop on columns"""
type TeamCapacityByPositionStddevPopFields {
  avgAdminPercentage: Float
  consultantCount: Float
  totalAdminHours: Float
  totalPayrollCapacity: Float
  totalWorkHours: Float
}

"""aggregate stddevSamp on columns"""
type TeamCapacityByPositionStddevSampFields {
  avgAdminPercentage: Float
  consultantCount: Float
  totalAdminHours: Float
  totalPayrollCapacity: Float
  totalWorkHours: Float
}

"""
Streaming cursor of the table "team_capacity_by_position"
"""
input TeamCapacityByPositionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TeamCapacityByPositionStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TeamCapacityByPositionStreamCursorValueInput {
  avgAdminPercentage: numeric
  consultantCount: bigint
  position: user_position
  totalAdminHours: numeric
  totalPayrollCapacity: numeric
  totalWorkHours: numeric
}

"""aggregate sum on columns"""
type TeamCapacityByPositionSumFields {
  avgAdminPercentage: numeric
  consultantCount: bigint
  totalAdminHours: numeric
  totalPayrollCapacity: numeric
  totalWorkHours: numeric
}

"""aggregate varPop on columns"""
type TeamCapacityByPositionVarPopFields {
  avgAdminPercentage: Float
  consultantCount: Float
  totalAdminHours: Float
  totalPayrollCapacity: Float
  totalWorkHours: Float
}

"""aggregate varSamp on columns"""
type TeamCapacityByPositionVarSampFields {
  avgAdminPercentage: Float
  consultantCount: Float
  totalAdminHours: Float
  totalPayrollCapacity: Float
  totalWorkHours: Float
}

"""aggregate variance on columns"""
type TeamCapacityByPositionVarianceFields {
  avgAdminPercentage: Float
  consultantCount: Float
  totalAdminHours: Float
  totalPayrollCapacity: Float
  totalWorkHours: Float
}

"""Time tracking for profitability analysis"""
type TimeEntries {
  """An object relationship"""
  billingItem: BillingItems
  """Billing item this time relates to"""
  billingItemId: uuid
  billingNotes: String
  billingRate: numeric
  """An object relationship"""
  client: Clients!
  """Client this work was for"""
  clientId: uuid!
  createdAt: timestamptz
  """Description of work performed"""
  description: String
  """Hours spent on this work"""
  hoursSpent: numeric!
  id: uuid!
  isBillable: Boolean
  """An object relationship"""
  payroll: Payrolls
  """An object relationship"""
  payrollDate: PayrollDates
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: uuid
  """Specific payroll job this relates to"""
  payrollId: uuid
  """An object relationship"""
  staffUser: Users!
  """Staff member who worked on this"""
  staffUserId: uuid!
  timeUnits: Int
  updatedAt: timestamptz
  """Date the work was performed"""
  workDate: date!
}

"""
aggregated selection of "time_entries"
"""
type TimeEntriesAggregate {
  aggregate: TimeEntriesAggregateFields
  nodes: [TimeEntries!]!
}

input TimeEntriesAggregateBoolExp {
  bool_and: timeEntriesAggregateBoolExpBool_and
  bool_or: timeEntriesAggregateBoolExpBool_or
  count: timeEntriesAggregateBoolExpCount
}

"""
aggregate fields of "time_entries"
"""
type TimeEntriesAggregateFields {
  avg: TimeEntriesAvgFields
  count(columns: [TimeEntriesSelectColumn!], distinct: Boolean): Int!
  max: TimeEntriesMaxFields
  min: TimeEntriesMinFields
  stddev: TimeEntriesStddevFields
  stddevPop: TimeEntriesStddevPopFields
  stddevSamp: TimeEntriesStddevSampFields
  sum: TimeEntriesSumFields
  varPop: TimeEntriesVarPopFields
  varSamp: TimeEntriesVarSampFields
  variance: TimeEntriesVarianceFields
}

"""
order by aggregate values of table "time_entries"
"""
input TimeEntriesAggregateOrderBy {
  avg: TimeEntriesAvgOrderBy
  count: OrderBy
  max: TimeEntriesMaxOrderBy
  min: TimeEntriesMinOrderBy
  stddev: TimeEntriesStddevOrderBy
  stddevPop: TimeEntriesStddevPopOrderBy
  stddevSamp: TimeEntriesStddevSampOrderBy
  sum: TimeEntriesSumOrderBy
  varPop: TimeEntriesVarPopOrderBy
  varSamp: TimeEntriesVarSampOrderBy
  variance: TimeEntriesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "time_entries"
"""
input TimeEntriesArrRelInsertInput {
  data: [TimeEntriesInsertInput!]!
  """upsert condition"""
  onConflict: TimeEntriesOnConflict
}

"""aggregate avg on columns"""
type TimeEntriesAvgFields {
  billingRate: Float
  """Hours spent on this work"""
  hoursSpent: Float
  timeUnits: Float
}

"""
order by avg() on columns of table "time_entries"
"""
input TimeEntriesAvgOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""
Boolean expression to filter rows from the table "time_entries". All fields are combined with a logical 'AND'.
"""
input TimeEntriesBoolExp {
  _and: [TimeEntriesBoolExp!]
  _not: TimeEntriesBoolExp
  _or: [TimeEntriesBoolExp!]
  billingItem: BillingItemsBoolExp
  billingItemId: UuidComparisonExp
  billingNotes: StringComparisonExp
  billingRate: NumericComparisonExp
  client: ClientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  hoursSpent: NumericComparisonExp
  id: UuidComparisonExp
  isBillable: BooleanComparisonExp
  payroll: PayrollsBoolExp
  payrollDate: PayrollDatesBoolExp
  payrollDateId: UuidComparisonExp
  payrollId: UuidComparisonExp
  staffUser: UsersBoolExp
  staffUserId: UuidComparisonExp
  timeUnits: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
  workDate: DateComparisonExp
}

"""
unique or primary key constraints on table "time_entries"
"""
enum TimeEntriesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  time_entries_pkey
}

"""
input type for incrementing numeric columns in table "time_entries"
"""
input TimeEntriesIncInput {
  billingRate: numeric
  """Hours spent on this work"""
  hoursSpent: numeric
  timeUnits: Int
}

"""
input type for inserting data into table "time_entries"
"""
input TimeEntriesInsertInput {
  billingItem: BillingItemsObjRelInsertInput
  """Billing item this time relates to"""
  billingItemId: uuid
  billingNotes: String
  billingRate: numeric
  client: ClientsObjRelInsertInput
  """Client this work was for"""
  clientId: uuid
  createdAt: timestamptz
  """Description of work performed"""
  description: String
  """Hours spent on this work"""
  hoursSpent: numeric
  id: uuid
  isBillable: Boolean
  payroll: PayrollsObjRelInsertInput
  payrollDate: PayrollDatesObjRelInsertInput
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: uuid
  """Specific payroll job this relates to"""
  payrollId: uuid
  staffUser: UsersObjRelInsertInput
  """Staff member who worked on this"""
  staffUserId: uuid
  timeUnits: Int
  updatedAt: timestamptz
  """Date the work was performed"""
  workDate: date
}

"""aggregate max on columns"""
type TimeEntriesMaxFields {
  """Billing item this time relates to"""
  billingItemId: uuid
  billingNotes: String
  billingRate: numeric
  """Client this work was for"""
  clientId: uuid
  createdAt: timestamptz
  """Description of work performed"""
  description: String
  """Hours spent on this work"""
  hoursSpent: numeric
  id: uuid
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: uuid
  """Specific payroll job this relates to"""
  payrollId: uuid
  """Staff member who worked on this"""
  staffUserId: uuid
  timeUnits: Int
  updatedAt: timestamptz
  """Date the work was performed"""
  workDate: date
}

"""
order by max() on columns of table "time_entries"
"""
input TimeEntriesMaxOrderBy {
  """Billing item this time relates to"""
  billingItemId: OrderBy
  billingNotes: OrderBy
  billingRate: OrderBy
  """Client this work was for"""
  clientId: OrderBy
  createdAt: OrderBy
  """Description of work performed"""
  description: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  id: OrderBy
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: OrderBy
  """Specific payroll job this relates to"""
  payrollId: OrderBy
  """Staff member who worked on this"""
  staffUserId: OrderBy
  timeUnits: OrderBy
  updatedAt: OrderBy
  """Date the work was performed"""
  workDate: OrderBy
}

"""aggregate min on columns"""
type TimeEntriesMinFields {
  """Billing item this time relates to"""
  billingItemId: uuid
  billingNotes: String
  billingRate: numeric
  """Client this work was for"""
  clientId: uuid
  createdAt: timestamptz
  """Description of work performed"""
  description: String
  """Hours spent on this work"""
  hoursSpent: numeric
  id: uuid
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: uuid
  """Specific payroll job this relates to"""
  payrollId: uuid
  """Staff member who worked on this"""
  staffUserId: uuid
  timeUnits: Int
  updatedAt: timestamptz
  """Date the work was performed"""
  workDate: date
}

"""
order by min() on columns of table "time_entries"
"""
input TimeEntriesMinOrderBy {
  """Billing item this time relates to"""
  billingItemId: OrderBy
  billingNotes: OrderBy
  billingRate: OrderBy
  """Client this work was for"""
  clientId: OrderBy
  createdAt: OrderBy
  """Description of work performed"""
  description: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  id: OrderBy
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: OrderBy
  """Specific payroll job this relates to"""
  payrollId: OrderBy
  """Staff member who worked on this"""
  staffUserId: OrderBy
  timeUnits: OrderBy
  updatedAt: OrderBy
  """Date the work was performed"""
  workDate: OrderBy
}

"""
response of any mutation on the table "time_entries"
"""
type TimeEntriesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [TimeEntries!]!
}

"""
on_conflict condition type for table "time_entries"
"""
input TimeEntriesOnConflict {
  constraint: TimeEntriesConstraint!
  updateColumns: [TimeEntriesUpdateColumn!]! = []
  where: TimeEntriesBoolExp
}

"""Ordering options when selecting data from "time_entries"."""
input TimeEntriesOrderBy {
  billingItem: BillingItemsOrderBy
  billingItemId: OrderBy
  billingNotes: OrderBy
  billingRate: OrderBy
  client: ClientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  description: OrderBy
  hoursSpent: OrderBy
  id: OrderBy
  isBillable: OrderBy
  payroll: PayrollsOrderBy
  payrollDate: PayrollDatesOrderBy
  payrollDateId: OrderBy
  payrollId: OrderBy
  staffUser: UsersOrderBy
  staffUserId: OrderBy
  timeUnits: OrderBy
  updatedAt: OrderBy
  workDate: OrderBy
}

"""primary key columns input for table: time_entries"""
input TimeEntriesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "time_entries"
"""
enum TimeEntriesSelectColumn {
  """column name"""
  billingItemId
  """column name"""
  billingNotes
  """column name"""
  billingRate
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  hoursSpent
  """column name"""
  id
  """column name"""
  isBillable
  """column name"""
  payrollDateId
  """column name"""
  payrollId
  """column name"""
  staffUserId
  """column name"""
  timeUnits
  """column name"""
  updatedAt
  """column name"""
  workDate
}

"""
select "timeEntriesAggregateBoolExpBool_andArgumentsColumns" columns of table "time_entries"
"""
enum TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isBillable
}

"""
select "timeEntriesAggregateBoolExpBool_orArgumentsColumns" columns of table "time_entries"
"""
enum TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isBillable
}

"""
input type for updating data in table "time_entries"
"""
input TimeEntriesSetInput {
  """Billing item this time relates to"""
  billingItemId: uuid
  billingNotes: String
  billingRate: numeric
  """Client this work was for"""
  clientId: uuid
  createdAt: timestamptz
  """Description of work performed"""
  description: String
  """Hours spent on this work"""
  hoursSpent: numeric
  id: uuid
  isBillable: Boolean
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: uuid
  """Specific payroll job this relates to"""
  payrollId: uuid
  """Staff member who worked on this"""
  staffUserId: uuid
  timeUnits: Int
  updatedAt: timestamptz
  """Date the work was performed"""
  workDate: date
}

"""aggregate stddev on columns"""
type TimeEntriesStddevFields {
  billingRate: Float
  """Hours spent on this work"""
  hoursSpent: Float
  timeUnits: Float
}

"""
order by stddev() on columns of table "time_entries"
"""
input TimeEntriesStddevOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""aggregate stddevPop on columns"""
type TimeEntriesStddevPopFields {
  billingRate: Float
  """Hours spent on this work"""
  hoursSpent: Float
  timeUnits: Float
}

"""
order by stddevPop() on columns of table "time_entries"
"""
input TimeEntriesStddevPopOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""aggregate stddevSamp on columns"""
type TimeEntriesStddevSampFields {
  billingRate: Float
  """Hours spent on this work"""
  hoursSpent: Float
  timeUnits: Float
}

"""
order by stddevSamp() on columns of table "time_entries"
"""
input TimeEntriesStddevSampOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""
Streaming cursor of the table "time_entries"
"""
input TimeEntriesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TimeEntriesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TimeEntriesStreamCursorValueInput {
  """Billing item this time relates to"""
  billingItemId: uuid
  billingNotes: String
  billingRate: numeric
  """Client this work was for"""
  clientId: uuid
  createdAt: timestamptz
  """Description of work performed"""
  description: String
  """Hours spent on this work"""
  hoursSpent: numeric
  id: uuid
  isBillable: Boolean
  """
  Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking.
  """
  payrollDateId: uuid
  """Specific payroll job this relates to"""
  payrollId: uuid
  """Staff member who worked on this"""
  staffUserId: uuid
  timeUnits: Int
  updatedAt: timestamptz
  """Date the work was performed"""
  workDate: date
}

"""aggregate sum on columns"""
type TimeEntriesSumFields {
  billingRate: numeric
  """Hours spent on this work"""
  hoursSpent: numeric
  timeUnits: Int
}

"""
order by sum() on columns of table "time_entries"
"""
input TimeEntriesSumOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""
update columns of table "time_entries"
"""
enum TimeEntriesUpdateColumn {
  """column name"""
  billingItemId
  """column name"""
  billingNotes
  """column name"""
  billingRate
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  hoursSpent
  """column name"""
  id
  """column name"""
  isBillable
  """column name"""
  payrollDateId
  """column name"""
  payrollId
  """column name"""
  staffUserId
  """column name"""
  timeUnits
  """column name"""
  updatedAt
  """column name"""
  workDate
}

input TimeEntriesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: TimeEntriesIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: TimeEntriesSetInput
  """filter the rows which have to be updated"""
  where: TimeEntriesBoolExp!
}

"""aggregate varPop on columns"""
type TimeEntriesVarPopFields {
  billingRate: Float
  """Hours spent on this work"""
  hoursSpent: Float
  timeUnits: Float
}

"""
order by varPop() on columns of table "time_entries"
"""
input TimeEntriesVarPopOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""aggregate varSamp on columns"""
type TimeEntriesVarSampFields {
  billingRate: Float
  """Hours spent on this work"""
  hoursSpent: Float
  timeUnits: Float
}

"""
order by varSamp() on columns of table "time_entries"
"""
input TimeEntriesVarSampOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""aggregate variance on columns"""
type TimeEntriesVarianceFields {
  billingRate: Float
  """Hours spent on this work"""
  hoursSpent: Float
  timeUnits: Float
}

"""
order by variance() on columns of table "time_entries"
"""
input TimeEntriesVarianceOrderBy {
  billingRate: OrderBy
  """Hours spent on this work"""
  hoursSpent: OrderBy
  timeUnits: OrderBy
}

"""
columns and relationships of "time_tracking_summary"
"""
type TimeTrackingSummary {
  billableAmount: numeric
  billingNotes: String
  billingRate: numeric
  clientId: uuid
  clientName: String
  description: String
  hoursSpent: numeric
  id: uuid
  isBillable: Boolean
  payrollId: uuid
  payrollName: String
  staffName: String
  staffUserId: uuid
  timeUnits: Int
  workDate: date
}

"""
aggregated selection of "time_tracking_summary"
"""
type TimeTrackingSummaryAggregate {
  aggregate: TimeTrackingSummaryAggregateFields
  nodes: [TimeTrackingSummary!]!
}

"""
aggregate fields of "time_tracking_summary"
"""
type TimeTrackingSummaryAggregateFields {
  avg: TimeTrackingSummaryAvgFields
  count(columns: [TimeTrackingSummarySelectColumn!], distinct: Boolean): Int!
  max: TimeTrackingSummaryMaxFields
  min: TimeTrackingSummaryMinFields
  stddev: TimeTrackingSummaryStddevFields
  stddevPop: TimeTrackingSummaryStddevPopFields
  stddevSamp: TimeTrackingSummaryStddevSampFields
  sum: TimeTrackingSummarySumFields
  varPop: TimeTrackingSummaryVarPopFields
  varSamp: TimeTrackingSummaryVarSampFields
  variance: TimeTrackingSummaryVarianceFields
}

"""aggregate avg on columns"""
type TimeTrackingSummaryAvgFields {
  billableAmount: Float
  billingRate: Float
  hoursSpent: Float
  timeUnits: Float
}

"""
Boolean expression to filter rows from the table "time_tracking_summary". All fields are combined with a logical 'AND'.
"""
input TimeTrackingSummaryBoolExp {
  _and: [TimeTrackingSummaryBoolExp!]
  _not: TimeTrackingSummaryBoolExp
  _or: [TimeTrackingSummaryBoolExp!]
  billableAmount: NumericComparisonExp
  billingNotes: StringComparisonExp
  billingRate: NumericComparisonExp
  clientId: UuidComparisonExp
  clientName: StringComparisonExp
  description: StringComparisonExp
  hoursSpent: NumericComparisonExp
  id: UuidComparisonExp
  isBillable: BooleanComparisonExp
  payrollId: UuidComparisonExp
  payrollName: StringComparisonExp
  staffName: StringComparisonExp
  staffUserId: UuidComparisonExp
  timeUnits: IntComparisonExp
  workDate: DateComparisonExp
}

"""aggregate max on columns"""
type TimeTrackingSummaryMaxFields {
  billableAmount: numeric
  billingNotes: String
  billingRate: numeric
  clientId: uuid
  clientName: String
  description: String
  hoursSpent: numeric
  id: uuid
  payrollId: uuid
  payrollName: String
  staffName: String
  staffUserId: uuid
  timeUnits: Int
  workDate: date
}

"""aggregate min on columns"""
type TimeTrackingSummaryMinFields {
  billableAmount: numeric
  billingNotes: String
  billingRate: numeric
  clientId: uuid
  clientName: String
  description: String
  hoursSpent: numeric
  id: uuid
  payrollId: uuid
  payrollName: String
  staffName: String
  staffUserId: uuid
  timeUnits: Int
  workDate: date
}

"""Ordering options when selecting data from "time_tracking_summary"."""
input TimeTrackingSummaryOrderBy {
  billableAmount: OrderBy
  billingNotes: OrderBy
  billingRate: OrderBy
  clientId: OrderBy
  clientName: OrderBy
  description: OrderBy
  hoursSpent: OrderBy
  id: OrderBy
  isBillable: OrderBy
  payrollId: OrderBy
  payrollName: OrderBy
  staffName: OrderBy
  staffUserId: OrderBy
  timeUnits: OrderBy
  workDate: OrderBy
}

"""
select columns of table "time_tracking_summary"
"""
enum TimeTrackingSummarySelectColumn {
  """column name"""
  billableAmount
  """column name"""
  billingNotes
  """column name"""
  billingRate
  """column name"""
  clientId
  """column name"""
  clientName
  """column name"""
  description
  """column name"""
  hoursSpent
  """column name"""
  id
  """column name"""
  isBillable
  """column name"""
  payrollId
  """column name"""
  payrollName
  """column name"""
  staffName
  """column name"""
  staffUserId
  """column name"""
  timeUnits
  """column name"""
  workDate
}

"""aggregate stddev on columns"""
type TimeTrackingSummaryStddevFields {
  billableAmount: Float
  billingRate: Float
  hoursSpent: Float
  timeUnits: Float
}

"""aggregate stddevPop on columns"""
type TimeTrackingSummaryStddevPopFields {
  billableAmount: Float
  billingRate: Float
  hoursSpent: Float
  timeUnits: Float
}

"""aggregate stddevSamp on columns"""
type TimeTrackingSummaryStddevSampFields {
  billableAmount: Float
  billingRate: Float
  hoursSpent: Float
  timeUnits: Float
}

"""
Streaming cursor of the table "time_tracking_summary"
"""
input TimeTrackingSummaryStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TimeTrackingSummaryStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TimeTrackingSummaryStreamCursorValueInput {
  billableAmount: numeric
  billingNotes: String
  billingRate: numeric
  clientId: uuid
  clientName: String
  description: String
  hoursSpent: numeric
  id: uuid
  isBillable: Boolean
  payrollId: uuid
  payrollName: String
  staffName: String
  staffUserId: uuid
  timeUnits: Int
  workDate: date
}

"""aggregate sum on columns"""
type TimeTrackingSummarySumFields {
  billableAmount: numeric
  billingRate: numeric
  hoursSpent: numeric
  timeUnits: Int
}

"""aggregate varPop on columns"""
type TimeTrackingSummaryVarPopFields {
  billableAmount: Float
  billingRate: Float
  hoursSpent: Float
  timeUnits: Float
}

"""aggregate varSamp on columns"""
type TimeTrackingSummaryVarSampFields {
  billableAmount: Float
  billingRate: Float
  hoursSpent: Float
  timeUnits: Float
}

"""aggregate variance on columns"""
type TimeTrackingSummaryVarianceFields {
  billableAmount: Float
  billingRate: Float
  hoursSpent: Float
  timeUnits: Float
}

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input TimestampComparisonExp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _isNull: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""User favorite templates for quick access"""
type UserEmailTemplateFavorites {
  createdAt: timestamptz
  """An object relationship"""
  emailTemplate: EmailTemplates!
  id: uuid!
  templateId: uuid!
  """An object relationship"""
  user: Users!
  userId: uuid!
}

"""
aggregated selection of "user_email_template_favorites"
"""
type UserEmailTemplateFavoritesAggregate {
  aggregate: UserEmailTemplateFavoritesAggregateFields
  nodes: [UserEmailTemplateFavorites!]!
}

input UserEmailTemplateFavoritesAggregateBoolExp {
  count: userEmailTemplateFavoritesAggregateBoolExpCount
}

"""
aggregate fields of "user_email_template_favorites"
"""
type UserEmailTemplateFavoritesAggregateFields {
  count(columns: [UserEmailTemplateFavoritesSelectColumn!], distinct: Boolean): Int!
  max: UserEmailTemplateFavoritesMaxFields
  min: UserEmailTemplateFavoritesMinFields
}

"""
order by aggregate values of table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesAggregateOrderBy {
  count: OrderBy
  max: UserEmailTemplateFavoritesMaxOrderBy
  min: UserEmailTemplateFavoritesMinOrderBy
}

"""
input type for inserting array relation for remote table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesArrRelInsertInput {
  data: [UserEmailTemplateFavoritesInsertInput!]!
  """upsert condition"""
  onConflict: UserEmailTemplateFavoritesOnConflict
}

"""
Boolean expression to filter rows from the table "user_email_template_favorites". All fields are combined with a logical 'AND'.
"""
input UserEmailTemplateFavoritesBoolExp {
  _and: [UserEmailTemplateFavoritesBoolExp!]
  _not: UserEmailTemplateFavoritesBoolExp
  _or: [UserEmailTemplateFavoritesBoolExp!]
  createdAt: TimestamptzComparisonExp
  emailTemplate: EmailTemplatesBoolExp
  id: UuidComparisonExp
  templateId: UuidComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_email_template_favorites"
"""
enum UserEmailTemplateFavoritesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_email_template_favorites_pkey
  """
  unique or primary key constraint on columns "user_id", "template_id"
  """
  user_email_template_favorites_user_id_template_id_key
}

"""
input type for inserting data into table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesInsertInput {
  createdAt: timestamptz
  emailTemplate: EmailTemplatesObjRelInsertInput
  id: uuid
  templateId: uuid
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type UserEmailTemplateFavoritesMaxFields {
  createdAt: timestamptz
  id: uuid
  templateId: uuid
  userId: uuid
}

"""
order by max() on columns of table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  templateId: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type UserEmailTemplateFavoritesMinFields {
  createdAt: timestamptz
  id: uuid
  templateId: uuid
  userId: uuid
}

"""
order by min() on columns of table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  templateId: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_email_template_favorites"
"""
type UserEmailTemplateFavoritesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserEmailTemplateFavorites!]!
}

"""
on_conflict condition type for table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesOnConflict {
  constraint: UserEmailTemplateFavoritesConstraint!
  updateColumns: [UserEmailTemplateFavoritesUpdateColumn!]! = []
  where: UserEmailTemplateFavoritesBoolExp
}

"""
Ordering options when selecting data from "user_email_template_favorites".
"""
input UserEmailTemplateFavoritesOrderBy {
  createdAt: OrderBy
  emailTemplate: EmailTemplatesOrderBy
  id: OrderBy
  templateId: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_email_template_favorites"""
input UserEmailTemplateFavoritesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user_email_template_favorites"
"""
enum UserEmailTemplateFavoritesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  templateId
  """column name"""
  userId
}

"""
input type for updating data in table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesSetInput {
  createdAt: timestamptz
  id: uuid
  templateId: uuid
  userId: uuid
}

"""
Streaming cursor of the table "user_email_template_favorites"
"""
input UserEmailTemplateFavoritesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserEmailTemplateFavoritesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserEmailTemplateFavoritesStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  templateId: uuid
  userId: uuid
}

"""
update columns of table "user_email_template_favorites"
"""
enum UserEmailTemplateFavoritesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  templateId
  """column name"""
  userId
}

input UserEmailTemplateFavoritesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserEmailTemplateFavoritesSetInput
  """filter the rows which have to be updated"""
  where: UserEmailTemplateFavoritesBoolExp!
}

"""
Stores invitation metadata for two-stage user invitation flow with role-based access control
"""
type UserInvitations {
  acceptedAt: timestamptz
  acceptedBy: uuid
  """An object relationship"""
  acceptedByUser: Users
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz!
  email: String!
  expiresAt: timestamptz!
  firstName: String!
  id: uuid!
  invitationMetadata(
    """JSON select path"""
    path: String
  ): jsonb
  invitationStatus: invitation_status_enum!
  invitedAt: timestamptz!
  invitedBy: uuid!
  """An object relationship"""
  invitedByUser: Users!
  invitedRole: String!
  lastName: String!
  managerId: uuid
  """An object relationship"""
  managerUser: Users
  revokeReason: String
  revokedAt: timestamptz
  revokedBy: uuid
  """An object relationship"""
  revokedByUser: Users
  status: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "user_invitations"
"""
type UserInvitationsAggregate {
  aggregate: UserInvitationsAggregateFields
  nodes: [UserInvitations!]!
}

input UserInvitationsAggregateBoolExp {
  count: userInvitationsAggregateBoolExpCount
}

"""
aggregate fields of "user_invitations"
"""
type UserInvitationsAggregateFields {
  count(columns: [UserInvitationsSelectColumn!], distinct: Boolean): Int!
  max: UserInvitationsMaxFields
  min: UserInvitationsMinFields
}

"""
order by aggregate values of table "user_invitations"
"""
input UserInvitationsAggregateOrderBy {
  count: OrderBy
  max: UserInvitationsMaxOrderBy
  min: UserInvitationsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input UserInvitationsAppendInput {
  invitationMetadata: jsonb
}

"""
input type for inserting array relation for remote table "user_invitations"
"""
input UserInvitationsArrRelInsertInput {
  data: [UserInvitationsInsertInput!]!
  """upsert condition"""
  onConflict: UserInvitationsOnConflict
}

"""
Boolean expression to filter rows from the table "user_invitations". All fields are combined with a logical 'AND'.
"""
input UserInvitationsBoolExp {
  _and: [UserInvitationsBoolExp!]
  _not: UserInvitationsBoolExp
  _or: [UserInvitationsBoolExp!]
  acceptedAt: TimestamptzComparisonExp
  acceptedBy: UuidComparisonExp
  acceptedByUser: UsersBoolExp
  clerkInvitationId: StringComparisonExp
  clerkTicket: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  firstName: StringComparisonExp
  id: UuidComparisonExp
  invitationMetadata: JsonbComparisonExp
  invitationStatus: InvitationStatusEnumComparisonExp
  invitedAt: TimestamptzComparisonExp
  invitedBy: UuidComparisonExp
  invitedByUser: UsersBoolExp
  invitedRole: StringComparisonExp
  lastName: StringComparisonExp
  managerId: UuidComparisonExp
  managerUser: UsersBoolExp
  revokeReason: StringComparisonExp
  revokedAt: TimestamptzComparisonExp
  revokedBy: UuidComparisonExp
  revokedByUser: UsersBoolExp
  status: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "user_invitations"
"""
enum UserInvitationsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_invitations_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input UserInvitationsDeleteAtPathInput {
  invitationMetadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input UserInvitationsDeleteElemInput {
  invitationMetadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input UserInvitationsDeleteKeyInput {
  invitationMetadata: String
}

"""
input type for inserting data into table "user_invitations"
"""
input UserInvitationsInsertInput {
  acceptedAt: timestamptz
  acceptedBy: uuid
  acceptedByUser: UsersObjRelInsertInput
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationMetadata: jsonb
  invitationStatus: invitation_status_enum
  invitedAt: timestamptz
  invitedBy: uuid
  invitedByUser: UsersObjRelInsertInput
  invitedRole: String
  lastName: String
  managerId: uuid
  managerUser: UsersObjRelInsertInput
  revokeReason: String
  revokedAt: timestamptz
  revokedBy: uuid
  revokedByUser: UsersObjRelInsertInput
  status: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type UserInvitationsMaxFields {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationStatus: invitation_status_enum
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  revokeReason: String
  revokedAt: timestamptz
  revokedBy: uuid
  status: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "user_invitations"
"""
input UserInvitationsMaxOrderBy {
  acceptedAt: OrderBy
  acceptedBy: OrderBy
  clerkInvitationId: OrderBy
  clerkTicket: OrderBy
  createdAt: OrderBy
  email: OrderBy
  expiresAt: OrderBy
  firstName: OrderBy
  id: OrderBy
  invitationStatus: OrderBy
  invitedAt: OrderBy
  invitedBy: OrderBy
  invitedRole: OrderBy
  lastName: OrderBy
  managerId: OrderBy
  revokeReason: OrderBy
  revokedAt: OrderBy
  revokedBy: OrderBy
  status: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type UserInvitationsMinFields {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationStatus: invitation_status_enum
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  revokeReason: String
  revokedAt: timestamptz
  revokedBy: uuid
  status: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "user_invitations"
"""
input UserInvitationsMinOrderBy {
  acceptedAt: OrderBy
  acceptedBy: OrderBy
  clerkInvitationId: OrderBy
  clerkTicket: OrderBy
  createdAt: OrderBy
  email: OrderBy
  expiresAt: OrderBy
  firstName: OrderBy
  id: OrderBy
  invitationStatus: OrderBy
  invitedAt: OrderBy
  invitedBy: OrderBy
  invitedRole: OrderBy
  lastName: OrderBy
  managerId: OrderBy
  revokeReason: OrderBy
  revokedAt: OrderBy
  revokedBy: OrderBy
  status: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "user_invitations"
"""
type UserInvitationsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserInvitations!]!
}

"""
on_conflict condition type for table "user_invitations"
"""
input UserInvitationsOnConflict {
  constraint: UserInvitationsConstraint!
  updateColumns: [UserInvitationsUpdateColumn!]! = []
  where: UserInvitationsBoolExp
}

"""Ordering options when selecting data from "user_invitations"."""
input UserInvitationsOrderBy {
  acceptedAt: OrderBy
  acceptedBy: OrderBy
  acceptedByUser: UsersOrderBy
  clerkInvitationId: OrderBy
  clerkTicket: OrderBy
  createdAt: OrderBy
  email: OrderBy
  expiresAt: OrderBy
  firstName: OrderBy
  id: OrderBy
  invitationMetadata: OrderBy
  invitationStatus: OrderBy
  invitedAt: OrderBy
  invitedBy: OrderBy
  invitedByUser: UsersOrderBy
  invitedRole: OrderBy
  lastName: OrderBy
  managerId: OrderBy
  managerUser: UsersOrderBy
  revokeReason: OrderBy
  revokedAt: OrderBy
  revokedBy: OrderBy
  revokedByUser: UsersOrderBy
  status: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: user_invitations"""
input UserInvitationsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input UserInvitationsPrependInput {
  invitationMetadata: jsonb
}

"""
select columns of table "user_invitations"
"""
enum UserInvitationsSelectColumn {
  """column name"""
  acceptedAt
  """column name"""
  acceptedBy
  """column name"""
  clerkInvitationId
  """column name"""
  clerkTicket
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  expiresAt
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  invitationMetadata
  """column name"""
  invitationStatus
  """column name"""
  invitedAt
  """column name"""
  invitedBy
  """column name"""
  invitedRole
  """column name"""
  lastName
  """column name"""
  managerId
  """column name"""
  revokeReason
  """column name"""
  revokedAt
  """column name"""
  revokedBy
  """column name"""
  status
  """column name"""
  updatedAt
}

"""
input type for updating data in table "user_invitations"
"""
input UserInvitationsSetInput {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationMetadata: jsonb
  invitationStatus: invitation_status_enum
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  revokeReason: String
  revokedAt: timestamptz
  revokedBy: uuid
  status: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "user_invitations"
"""
input UserInvitationsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserInvitationsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserInvitationsStreamCursorValueInput {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationMetadata: jsonb
  invitationStatus: invitation_status_enum
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  revokeReason: String
  revokedAt: timestamptz
  revokedBy: uuid
  status: String
  updatedAt: timestamptz
}

"""
update columns of table "user_invitations"
"""
enum UserInvitationsUpdateColumn {
  """column name"""
  acceptedAt
  """column name"""
  acceptedBy
  """column name"""
  clerkInvitationId
  """column name"""
  clerkTicket
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  expiresAt
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  invitationMetadata
  """column name"""
  invitationStatus
  """column name"""
  invitedAt
  """column name"""
  invitedBy
  """column name"""
  invitedRole
  """column name"""
  lastName
  """column name"""
  managerId
  """column name"""
  revokeReason
  """column name"""
  revokedAt
  """column name"""
  revokedBy
  """column name"""
  status
  """column name"""
  updatedAt
}

input UserInvitationsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: UserInvitationsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: UserInvitationsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: UserInvitationsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: UserInvitationsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: UserInvitationsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: UserInvitationsSetInput
  """filter the rows which have to be updated"""
  where: UserInvitationsBoolExp!
}

"""
Boolean expression to compare columns of type "user_position". All fields are combined with logical 'AND'.
"""
input UserPositionComparisonExp {
  _eq: user_position
  _gt: user_position
  _gte: user_position
  _in: [user_position!]
  _isNull: Boolean
  _lt: user_position
  _lte: user_position
  _neq: user_position
  _nin: [user_position!]
}

"""
Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'.
"""
input UserRoleComparisonExp {
  _eq: user_role
  _gt: user_role
  _gte: user_role
  _in: [user_role!]
  _isNull: Boolean
  _lt: user_role
  _lte: user_role
  _neq: user_role
  _nin: [user_role!]
}

"""
columns and relationships of "user_roles"
"""
type UserRoles {
  createdAt: timestamptz!
  id: uuid!
  """An object relationship"""
  role: Roles!
  roleId: uuid!
  updatedAt: timestamptz!
  """An object relationship"""
  user: Users!
  userId: uuid!
}

"""
aggregated selection of "user_roles"
"""
type UserRolesAggregate {
  aggregate: UserRolesAggregateFields
  nodes: [UserRoles!]!
}

input UserRolesAggregateBoolExp {
  count: userRolesAggregateBoolExpCount
}

"""
aggregate fields of "user_roles"
"""
type UserRolesAggregateFields {
  count(columns: [UserRolesSelectColumn!], distinct: Boolean): Int!
  max: UserRolesMaxFields
  min: UserRolesMinFields
}

"""
order by aggregate values of table "user_roles"
"""
input UserRolesAggregateOrderBy {
  count: OrderBy
  max: UserRolesMaxOrderBy
  min: UserRolesMinOrderBy
}

"""
input type for inserting array relation for remote table "user_roles"
"""
input UserRolesArrRelInsertInput {
  data: [UserRolesInsertInput!]!
  """upsert condition"""
  onConflict: UserRolesOnConflict
}

"""
Boolean expression to filter rows from the table "user_roles". All fields are combined with a logical 'AND'.
"""
input UserRolesBoolExp {
  _and: [UserRolesBoolExp!]
  _not: UserRolesBoolExp
  _or: [UserRolesBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  role: RolesBoolExp
  roleId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_roles"
"""
enum UserRolesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey
  """
  unique or primary key constraint on columns "user_id", "role_id"
  """
  user_roles_user_id_role_id_key
}

"""
input type for inserting data into table "user_roles"
"""
input UserRolesInsertInput {
  createdAt: timestamptz
  id: uuid
  role: RolesObjRelInsertInput
  roleId: uuid
  updatedAt: timestamptz
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type UserRolesMaxFields {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "user_roles"
"""
input UserRolesMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type UserRolesMinFields {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "user_roles"
"""
input UserRolesMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_roles"
"""
type UserRolesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserRoles!]!
}

"""
on_conflict condition type for table "user_roles"
"""
input UserRolesOnConflict {
  constraint: UserRolesConstraint!
  updateColumns: [UserRolesUpdateColumn!]! = []
  where: UserRolesBoolExp
}

"""Ordering options when selecting data from "user_roles"."""
input UserRolesOrderBy {
  createdAt: OrderBy
  id: OrderBy
  role: RolesOrderBy
  roleId: OrderBy
  updatedAt: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_roles"""
input UserRolesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user_roles"
"""
enum UserRolesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  roleId
  """column name"""
  updatedAt
  """column name"""
  userId
}

"""
input type for updating data in table "user_roles"
"""
input UserRolesSetInput {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "user_roles"
"""
input UserRolesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserRolesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserRolesStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "user_roles"
"""
enum UserRolesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  roleId
  """column name"""
  updatedAt
  """column name"""
  userId
}

input UserRolesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserRolesSetInput
  """filter the rows which have to be updated"""
  where: UserRolesBoolExp!
}

"""
columns and relationships of "user_sessions"
"""
type UserSessions {
  createdAt: timestamptz
  expiresAt: timestamptz!
  id: uuid!
  ipAddress: inet
  isActive: Boolean
  lastActivity: timestamptz
  locationData(
    """JSON select path"""
    path: String
  ): jsonb
  logoutReason: String
  sessionToken: String!
  """An object relationship"""
  user: Users!
  userAgent: String
  userId: uuid!
}

"""
aggregated selection of "user_sessions"
"""
type UserSessionsAggregate {
  aggregate: UserSessionsAggregateFields
  nodes: [UserSessions!]!
}

input UserSessionsAggregateBoolExp {
  bool_and: userSessionsAggregateBoolExpBool_and
  bool_or: userSessionsAggregateBoolExpBool_or
  count: userSessionsAggregateBoolExpCount
}

"""
aggregate fields of "user_sessions"
"""
type UserSessionsAggregateFields {
  count(columns: [UserSessionsSelectColumn!], distinct: Boolean): Int!
  max: UserSessionsMaxFields
  min: UserSessionsMinFields
}

"""
order by aggregate values of table "user_sessions"
"""
input UserSessionsAggregateOrderBy {
  count: OrderBy
  max: UserSessionsMaxOrderBy
  min: UserSessionsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input UserSessionsAppendInput {
  locationData: jsonb
}

"""
input type for inserting array relation for remote table "user_sessions"
"""
input UserSessionsArrRelInsertInput {
  data: [UserSessionsInsertInput!]!
  """upsert condition"""
  onConflict: UserSessionsOnConflict
}

"""
Boolean expression to filter rows from the table "user_sessions". All fields are combined with a logical 'AND'.
"""
input UserSessionsBoolExp {
  _and: [UserSessionsBoolExp!]
  _not: UserSessionsBoolExp
  _or: [UserSessionsBoolExp!]
  createdAt: TimestamptzComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  isActive: BooleanComparisonExp
  lastActivity: TimestamptzComparisonExp
  locationData: JsonbComparisonExp
  logoutReason: StringComparisonExp
  sessionToken: StringComparisonExp
  user: UsersBoolExp
  userAgent: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_sessions"
"""
enum UserSessionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_sessions_pkey
  """
  unique or primary key constraint on columns "session_token"
  """
  user_sessions_session_token_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input UserSessionsDeleteAtPathInput {
  locationData: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input UserSessionsDeleteElemInput {
  locationData: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input UserSessionsDeleteKeyInput {
  locationData: String
}

"""
input type for inserting data into table "user_sessions"
"""
input UserSessionsInsertInput {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  ipAddress: inet
  isActive: Boolean
  lastActivity: timestamptz
  locationData: jsonb
  logoutReason: String
  sessionToken: String
  user: UsersObjRelInsertInput
  userAgent: String
  userId: uuid
}

"""aggregate max on columns"""
type UserSessionsMaxFields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  lastActivity: timestamptz
  logoutReason: String
  sessionToken: String
  userAgent: String
  userId: uuid
}

"""
order by max() on columns of table "user_sessions"
"""
input UserSessionsMaxOrderBy {
  createdAt: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  lastActivity: OrderBy
  logoutReason: OrderBy
  sessionToken: OrderBy
  userAgent: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type UserSessionsMinFields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  lastActivity: timestamptz
  logoutReason: String
  sessionToken: String
  userAgent: String
  userId: uuid
}

"""
order by min() on columns of table "user_sessions"
"""
input UserSessionsMinOrderBy {
  createdAt: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  lastActivity: OrderBy
  logoutReason: OrderBy
  sessionToken: OrderBy
  userAgent: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_sessions"
"""
type UserSessionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserSessions!]!
}

"""
on_conflict condition type for table "user_sessions"
"""
input UserSessionsOnConflict {
  constraint: UserSessionsConstraint!
  updateColumns: [UserSessionsUpdateColumn!]! = []
  where: UserSessionsBoolExp
}

"""Ordering options when selecting data from "user_sessions"."""
input UserSessionsOrderBy {
  createdAt: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  isActive: OrderBy
  lastActivity: OrderBy
  locationData: OrderBy
  logoutReason: OrderBy
  sessionToken: OrderBy
  user: UsersOrderBy
  userAgent: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_sessions"""
input UserSessionsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input UserSessionsPrependInput {
  locationData: jsonb
}

"""
select columns of table "user_sessions"
"""
enum UserSessionsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  expiresAt
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  isActive
  """column name"""
  lastActivity
  """column name"""
  locationData
  """column name"""
  logoutReason
  """column name"""
  sessionToken
  """column name"""
  userAgent
  """column name"""
  userId
}

"""
select "userSessionsAggregateBoolExpBool_andArgumentsColumns" columns of table "user_sessions"
"""
enum UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
}

"""
select "userSessionsAggregateBoolExpBool_orArgumentsColumns" columns of table "user_sessions"
"""
enum UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
}

"""
input type for updating data in table "user_sessions"
"""
input UserSessionsSetInput {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  ipAddress: inet
  isActive: Boolean
  lastActivity: timestamptz
  locationData: jsonb
  logoutReason: String
  sessionToken: String
  userAgent: String
  userId: uuid
}

"""
Streaming cursor of the table "user_sessions"
"""
input UserSessionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserSessionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserSessionsStreamCursorValueInput {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  ipAddress: inet
  isActive: Boolean
  lastActivity: timestamptz
  locationData: jsonb
  logoutReason: String
  sessionToken: String
  userAgent: String
  userId: uuid
}

"""
update columns of table "user_sessions"
"""
enum UserSessionsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  expiresAt
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  isActive
  """column name"""
  lastActivity
  """column name"""
  locationData
  """column name"""
  logoutReason
  """column name"""
  sessionToken
  """column name"""
  userAgent
  """column name"""
  userId
}

input UserSessionsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: UserSessionsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: UserSessionsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: UserSessionsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: UserSessionsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: UserSessionsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: UserSessionsSetInput
  """filter the rows which have to be updated"""
  where: UserSessionsBoolExp!
}

"""
columns and relationships of "user_skills"
"""
type UserSkills {
  proficiencyLevel: String
  skillName: String
  """An object relationship"""
  user: Users
  userId: uuid
}

"""
aggregated selection of "user_skills"
"""
type UserSkillsAggregate {
  aggregate: UserSkillsAggregateFields
  nodes: [UserSkills!]!
}

input UserSkillsAggregateBoolExp {
  count: userSkillsAggregateBoolExpCount
}

"""
aggregate fields of "user_skills"
"""
type UserSkillsAggregateFields {
  count(columns: [UserSkillsSelectColumn!], distinct: Boolean): Int!
  max: UserSkillsMaxFields
  min: UserSkillsMinFields
}

"""
order by aggregate values of table "user_skills"
"""
input UserSkillsAggregateOrderBy {
  count: OrderBy
  max: UserSkillsMaxOrderBy
  min: UserSkillsMinOrderBy
}

"""
input type for inserting array relation for remote table "user_skills"
"""
input UserSkillsArrRelInsertInput {
  data: [UserSkillsInsertInput!]!
}

"""
Boolean expression to filter rows from the table "user_skills". All fields are combined with a logical 'AND'.
"""
input UserSkillsBoolExp {
  _and: [UserSkillsBoolExp!]
  _not: UserSkillsBoolExp
  _or: [UserSkillsBoolExp!]
  proficiencyLevel: StringComparisonExp
  skillName: StringComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
input type for inserting data into table "user_skills"
"""
input UserSkillsInsertInput {
  proficiencyLevel: String
  skillName: String
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type UserSkillsMaxFields {
  proficiencyLevel: String
  skillName: String
  userId: uuid
}

"""
order by max() on columns of table "user_skills"
"""
input UserSkillsMaxOrderBy {
  proficiencyLevel: OrderBy
  skillName: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type UserSkillsMinFields {
  proficiencyLevel: String
  skillName: String
  userId: uuid
}

"""
order by min() on columns of table "user_skills"
"""
input UserSkillsMinOrderBy {
  proficiencyLevel: OrderBy
  skillName: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_skills"
"""
type UserSkillsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserSkills!]!
}

"""Ordering options when selecting data from "user_skills"."""
input UserSkillsOrderBy {
  proficiencyLevel: OrderBy
  skillName: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""
select columns of table "user_skills"
"""
enum UserSkillsSelectColumn {
  """column name"""
  proficiencyLevel
  """column name"""
  skillName
  """column name"""
  userId
}

"""
input type for updating data in table "user_skills"
"""
input UserSkillsSetInput {
  proficiencyLevel: String
  skillName: String
  userId: uuid
}

"""
Streaming cursor of the table "user_skills"
"""
input UserSkillsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserSkillsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserSkillsStreamCursorValueInput {
  proficiencyLevel: String
  skillName: String
  userId: uuid
}

input UserSkillsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserSkillsSetInput
  """filter the rows which have to be updated"""
  where: UserSkillsBoolExp!
}

"""
Boolean expression to compare columns of type "user_status_enum". All fields are combined with logical 'AND'.
"""
input UserStatusEnumComparisonExp {
  _eq: user_status_enum
  _gt: user_status_enum
  _gte: user_status_enum
  _in: [user_status_enum!]
  _isNull: Boolean
  _lt: user_status_enum
  _lte: user_status_enum
  _neq: user_status_enum
  _nin: [user_status_enum!]
}

"""
columns and relationships of "users"
"""
type Users {
  """An array relationship"""
  acceptedInvitations(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): [UserInvitations!]!
  """An aggregate relationship"""
  acceptedInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): UserInvitationsAggregate!
  """User address or location"""
  address: String
  """An array relationship"""
  approvedBillingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  approvedBillingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """An array relationship"""
  approvedEmailTemplates(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): [EmailTemplates!]!
  """An aggregate relationship"""
  approvedEmailTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): EmailTemplatesAggregate!
  """An array relationship"""
  assignmentChanges(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """An aggregate relationship"""
  assignmentChangesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): PayrollAssignmentAuditAggregate!
  """An array relationship"""
  assignmentsMade(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): [PayrollAssignments!]!
  """An aggregate relationship"""
  assignmentsMadeAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): PayrollAssignmentsAggregate!
  """An array relationship"""
  authoredNotes(
    """distinct select on columns"""
    distinctOn: [NotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [NotesOrderBy!]
    """filter the rows returned"""
    where: NotesBoolExp
  ): [Notes!]!
  """An aggregate relationship"""
  authoredNotesAggregate(
    """distinct select on columns"""
    distinctOn: [NotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [NotesOrderBy!]
    """filter the rows returned"""
    where: NotesBoolExp
  ): NotesAggregate!
  """An array relationship"""
  backupPayrollAssignments(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  backupPayrollAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """User biography or description"""
  bio: String
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  computedName: String
  """An array relationship"""
  confirmedBillingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  confirmedBillingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """An array relationship"""
  consultantAssignments(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): [PayrollAssignments!]!
  """An aggregate relationship"""
  consultantAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): PayrollAssignmentsAggregate!
  """Timestamp when the user was created"""
  createdAt: timestamptz
  """An array relationship"""
  createdBillingEventLogs(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): [BillingEventLog!]!
  """An aggregate relationship"""
  createdBillingEventLogsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): BillingEventLogAggregate!
  """An array relationship"""
  createdClientServiceAgreements(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): [ClientServiceAgreements!]!
  """An aggregate relationship"""
  createdClientServiceAgreementsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): ClientServiceAgreementsAggregate!
  """An array relationship"""
  createdEmailTemplates(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): [EmailTemplates!]!
  """An aggregate relationship"""
  createdEmailTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): EmailTemplatesAggregate!
  """An array relationship"""
  createdPermissionOverrides(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): [PermissionOverrides!]!
  """An aggregate relationship"""
  createdPermissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): PermissionOverridesAggregate!
  """An array relationship"""
  createdServicePricingRules(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): [ServicePricingRules!]!
  """An aggregate relationship"""
  createdServicePricingRulesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): ServicePricingRulesAggregate!
  """An array relationship"""
  createdServiceTemplates(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): [ServiceTemplates!]!
  """An aggregate relationship"""
  createdServiceTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): ServiceTemplatesAggregate!
  """An array relationship"""
  createdServices(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): [Services!]!
  """An aggregate relationship"""
  createdServicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): ServicesAggregate!
  """An array relationship"""
  dataBackups(
    """distinct select on columns"""
    distinctOn: [DataBackupsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DataBackupsOrderBy!]
    """filter the rows returned"""
    where: DataBackupsBoolExp
  ): [DataBackups!]!
  """An aggregate relationship"""
  dataBackupsAggregate(
    """distinct select on columns"""
    distinctOn: [DataBackupsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DataBackupsOrderBy!]
    """filter the rows returned"""
    where: DataBackupsBoolExp
  ): DataBackupsAggregate!
  deactivatedAt: timestamptz
  deactivatedBy: String
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
  """User's email address (unique)"""
  email: String!
  """An array relationship"""
  emailDrafts(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): [EmailDrafts!]!
  """An aggregate relationship"""
  emailDraftsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): EmailDraftsAggregate!
  """An array relationship"""
  emailTemplateFavorites(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): [UserEmailTemplateFavorites!]!
  """An aggregate relationship"""
  emailTemplateFavoritesAggregate(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): UserEmailTemplateFavoritesAggregate!
  firstName: String!
  """An array relationship"""
  fromConsultantAudits(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """An aggregate relationship"""
  fromConsultantAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): PayrollAssignmentAuditAggregate!
  """Unique identifier for the user"""
  id: uuid!
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  lastName: String!
  """An array relationship"""
  leaveRecords(
    """distinct select on columns"""
    distinctOn: [LeaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LeaveOrderBy!]
    """filter the rows returned"""
    where: LeaveBoolExp
  ): [Leave!]!
  """An aggregate relationship"""
  leaveRecordsAggregate(
    """distinct select on columns"""
    distinctOn: [LeaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LeaveOrderBy!]
    """filter the rows returned"""
    where: LeaveBoolExp
  ): LeaveAggregate!
  """An array relationship"""
  managedInvitations(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): [UserInvitations!]!
  """An aggregate relationship"""
  managedInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): UserInvitationsAggregate!
  """An array relationship"""
  managedPayrolls(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  managedPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """An array relationship"""
  managedTeamMembers(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """An aggregate relationship"""
  managedTeamMembersAggregate(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): UsersAggregate!
  """An array relationship"""
  managedUsers(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """An aggregate relationship"""
  managedUsersAggregate(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): UsersAggregate!
  """An object relationship"""
  manager: Users
  """Reference to the user's manager"""
  managerId: uuid
  """An array relationship"""
  originalConsultantAssignments(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): [PayrollAssignments!]!
  """An aggregate relationship"""
  originalConsultantAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): PayrollAssignmentsAggregate!
  """An array relationship"""
  permissionAuditLogs(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): [PermissionAuditLog!]!
  """An aggregate relationship"""
  permissionAuditLogsAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): PermissionAuditLogAggregate!
  """An array relationship"""
  permissionOverrides(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): [PermissionOverrides!]!
  """An aggregate relationship"""
  permissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): PermissionOverridesAggregate!
  """User contact phone number"""
  phone: String
  """Organizational position affecting admin time allocation"""
  position: user_position
  """An array relationship"""
  primaryPayrollAssignments(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  primaryPayrollAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """An array relationship"""
  quoteConversions(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): [QuoteConversions!]!
  """An aggregate relationship"""
  quoteConversionsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): QuoteConversionsAggregate!
  """An array relationship"""
  quoteTemplates(
    """distinct select on columns"""
    distinctOn: [QuoteTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteTemplatesOrderBy!]
    """filter the rows returned"""
    where: QuoteTemplatesBoolExp
  ): [QuoteTemplates!]!
  """An aggregate relationship"""
  quoteTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteTemplatesOrderBy!]
    """filter the rows returned"""
    where: QuoteTemplatesBoolExp
  ): QuoteTemplatesAggregate!
  """An array relationship"""
  quotes(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): [Quotes!]!
  """An aggregate relationship"""
  quotesAggregate(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): QuotesAggregate!
  """An array relationship"""
  resolvedSecurityAlerts(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): [SecurityAlerts!]!
  """An aggregate relationship"""
  resolvedSecurityAlertsAggregate(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): SecurityAlertsAggregate!
  """An array relationship"""
  revokedInvitations(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): [UserInvitations!]!
  """An aggregate relationship"""
  revokedInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): UserInvitationsAggregate!
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role!
  """An array relationship"""
  roleAssignments(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): [UserRoles!]!
  """An aggregate relationship"""
  roleAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): UserRolesAggregate!
  """An array relationship"""
  securityAlerts(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): [SecurityAlerts!]!
  """An aggregate relationship"""
  securityAlertsAggregate(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): SecurityAlertsAggregate!
  """An array relationship"""
  securitySettings(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): [SecuritySettings!]!
  """An aggregate relationship"""
  securitySettingsAggregate(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): SecuritySettingsAggregate!
  """An array relationship"""
  sentEmails(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): [EmailSendLogs!]!
  """An aggregate relationship"""
  sentEmailsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): EmailSendLogsAggregate!
  """An array relationship"""
  sentInvitations(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): [UserInvitations!]!
  """An aggregate relationship"""
  sentInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): UserInvitationsAggregate!
  """An array relationship"""
  skills(
    """distinct select on columns"""
    distinctOn: [UserSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSkillsOrderBy!]
    """filter the rows returned"""
    where: UserSkillsBoolExp
  ): [UserSkills!]!
  """An aggregate relationship"""
  skillsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSkillsOrderBy!]
    """filter the rows returned"""
    where: UserSkillsBoolExp
  ): UserSkillsAggregate!
  """An array relationship"""
  staffBillingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  staffBillingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """Current user status - must be consistent with isActive field"""
  status: user_status_enum!
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: String
  """Timestamp when status was last changed"""
  statusChangedAt: timestamptz
  """User ID who changed the status"""
  statusChangedBy: uuid
  """An object relationship"""
  statusChangedByUser: Users
  """An array relationship"""
  targetedPermissionAuditLogs(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): [PermissionAuditLog!]!
  """An aggregate relationship"""
  targetedPermissionAuditLogsAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): PermissionAuditLogAggregate!
  """An array relationship"""
  timeEntries(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """An aggregate relationship"""
  timeEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): TimeEntriesAggregate!
  """An array relationship"""
  toConsultantAudits(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """An aggregate relationship"""
  toConsultantAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): PayrollAssignmentAuditAggregate!
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """An array relationship"""
  updatedSecuritySettings(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): [SecuritySettings!]!
  """An aggregate relationship"""
  updatedSecuritySettingsAggregate(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): SecuritySettingsAggregate!
  """An array relationship"""
  updatedServiceTemplates(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): [ServiceTemplates!]!
  """An aggregate relationship"""
  updatedServiceTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): ServiceTemplatesAggregate!
  """An array relationship"""
  updatedServices(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): [Services!]!
  """An aggregate relationship"""
  updatedServicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): ServicesAggregate!
  """An array relationship"""
  uploadedFiles(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): [Files!]!
  """An aggregate relationship"""
  uploadedFilesAggregate(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): FilesAggregate!
  """An array relationship"""
  userSessions(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """An aggregate relationship"""
  userSessionsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): UserSessionsAggregate!
  """User's unique username for login"""
  username: String
  """An array relationship"""
  usersWithStatusChanges(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """An aggregate relationship"""
  usersWithStatusChangesAggregate(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): UsersAggregate!
  """An array relationship"""
  workSchedules(
    """distinct select on columns"""
    distinctOn: [WorkScheduleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [WorkScheduleOrderBy!]
    """filter the rows returned"""
    where: WorkScheduleBoolExp
  ): [WorkSchedule!]!
  """An aggregate relationship"""
  workSchedulesAggregate(
    """distinct select on columns"""
    distinctOn: [WorkScheduleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [WorkScheduleOrderBy!]
    """filter the rows returned"""
    where: WorkScheduleBoolExp
  ): WorkScheduleAggregate!
}

"""
aggregated selection of "users"
"""
type UsersAggregate {
  aggregate: UsersAggregateFields
  nodes: [Users!]!
}

input UsersAggregateBoolExp {
  bool_and: usersAggregateBoolExpBool_and
  bool_or: usersAggregateBoolExpBool_or
  count: usersAggregateBoolExpCount
}

"""
aggregate fields of "users"
"""
type UsersAggregateFields {
  avg: UsersAvgFields
  count(columns: [UsersSelectColumn!], distinct: Boolean): Int!
  max: UsersMaxFields
  min: UsersMinFields
  stddev: UsersStddevFields
  stddevPop: UsersStddevPopFields
  stddevSamp: UsersStddevSampFields
  sum: UsersSumFields
  varPop: UsersVarPopFields
  varSamp: UsersVarSampFields
  variance: UsersVarianceFields
}

"""
order by aggregate values of table "users"
"""
input UsersAggregateOrderBy {
  avg: UsersAvgOrderBy
  count: OrderBy
  max: UsersMaxOrderBy
  min: UsersMinOrderBy
  stddev: UsersStddevOrderBy
  stddevPop: UsersStddevPopOrderBy
  stddevSamp: UsersStddevSampOrderBy
  sum: UsersSumOrderBy
  varPop: UsersVarPopOrderBy
  varSamp: UsersVarSampOrderBy
  variance: UsersVarianceOrderBy
}

"""
input type for inserting array relation for remote table "users"
"""
input UsersArrRelInsertInput {
  data: [UsersInsertInput!]!
  """upsert condition"""
  onConflict: UsersOnConflict
}

"""aggregate avg on columns"""
type UsersAvgFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: Float
}

"""
order by avg() on columns of table "users"
"""
input UsersAvgOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input UsersBoolExp {
  _and: [UsersBoolExp!]
  _not: UsersBoolExp
  _or: [UsersBoolExp!]
  acceptedInvitations: UserInvitationsBoolExp
  acceptedInvitationsAggregate: UserInvitationsAggregateBoolExp
  address: StringComparisonExp
  approvedBillingItems: BillingItemsBoolExp
  approvedBillingItemsAggregate: BillingItemsAggregateBoolExp
  approvedEmailTemplates: EmailTemplatesBoolExp
  approvedEmailTemplatesAggregate: EmailTemplatesAggregateBoolExp
  assignmentChanges: PayrollAssignmentAuditBoolExp
  assignmentChangesAggregate: PayrollAssignmentAuditAggregateBoolExp
  assignmentsMade: PayrollAssignmentsBoolExp
  assignmentsMadeAggregate: PayrollAssignmentsAggregateBoolExp
  authoredNotes: NotesBoolExp
  authoredNotesAggregate: NotesAggregateBoolExp
  backupPayrollAssignments: PayrollsBoolExp
  backupPayrollAssignmentsAggregate: PayrollsAggregateBoolExp
  bio: StringComparisonExp
  clerkUserId: StringComparisonExp
  computedName: StringComparisonExp
  confirmedBillingItems: BillingItemsBoolExp
  confirmedBillingItemsAggregate: BillingItemsAggregateBoolExp
  consultantAssignments: PayrollAssignmentsBoolExp
  consultantAssignmentsAggregate: PayrollAssignmentsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBillingEventLogs: BillingEventLogBoolExp
  createdBillingEventLogsAggregate: BillingEventLogAggregateBoolExp
  createdClientServiceAgreements: ClientServiceAgreementsBoolExp
  createdClientServiceAgreementsAggregate: ClientServiceAgreementsAggregateBoolExp
  createdEmailTemplates: EmailTemplatesBoolExp
  createdEmailTemplatesAggregate: EmailTemplatesAggregateBoolExp
  createdPermissionOverrides: PermissionOverridesBoolExp
  createdPermissionOverridesAggregate: PermissionOverridesAggregateBoolExp
  createdServicePricingRules: ServicePricingRulesBoolExp
  createdServicePricingRulesAggregate: ServicePricingRulesAggregateBoolExp
  createdServiceTemplates: ServiceTemplatesBoolExp
  createdServiceTemplatesAggregate: ServiceTemplatesAggregateBoolExp
  createdServices: ServicesBoolExp
  createdServicesAggregate: ServicesAggregateBoolExp
  dataBackups: DataBackupsBoolExp
  dataBackupsAggregate: DataBackupsAggregateBoolExp
  deactivatedAt: TimestamptzComparisonExp
  deactivatedBy: StringComparisonExp
  defaultAdminTimePercentage: NumericComparisonExp
  email: StringComparisonExp
  emailDrafts: EmailDraftsBoolExp
  emailDraftsAggregate: EmailDraftsAggregateBoolExp
  emailTemplateFavorites: UserEmailTemplateFavoritesBoolExp
  emailTemplateFavoritesAggregate: UserEmailTemplateFavoritesAggregateBoolExp
  firstName: StringComparisonExp
  fromConsultantAudits: PayrollAssignmentAuditBoolExp
  fromConsultantAuditsAggregate: PayrollAssignmentAuditAggregateBoolExp
  id: UuidComparisonExp
  image: StringComparisonExp
  isActive: BooleanComparisonExp
  isStaff: BooleanComparisonExp
  lastName: StringComparisonExp
  leaveRecords: LeaveBoolExp
  leaveRecordsAggregate: LeaveAggregateBoolExp
  managedInvitations: UserInvitationsBoolExp
  managedInvitationsAggregate: UserInvitationsAggregateBoolExp
  managedPayrolls: PayrollsBoolExp
  managedPayrollsAggregate: PayrollsAggregateBoolExp
  managedTeamMembers: UsersBoolExp
  managedTeamMembersAggregate: UsersAggregateBoolExp
  managedUsers: UsersBoolExp
  managedUsersAggregate: UsersAggregateBoolExp
  manager: UsersBoolExp
  managerId: UuidComparisonExp
  originalConsultantAssignments: PayrollAssignmentsBoolExp
  originalConsultantAssignmentsAggregate: PayrollAssignmentsAggregateBoolExp
  permissionAuditLogs: PermissionAuditLogBoolExp
  permissionAuditLogsAggregate: PermissionAuditLogAggregateBoolExp
  permissionOverrides: PermissionOverridesBoolExp
  permissionOverridesAggregate: PermissionOverridesAggregateBoolExp
  phone: StringComparisonExp
  position: UserPositionComparisonExp
  primaryPayrollAssignments: PayrollsBoolExp
  primaryPayrollAssignmentsAggregate: PayrollsAggregateBoolExp
  quoteConversions: QuoteConversionsBoolExp
  quoteConversionsAggregate: QuoteConversionsAggregateBoolExp
  quoteTemplates: QuoteTemplatesBoolExp
  quoteTemplatesAggregate: QuoteTemplatesAggregateBoolExp
  quotes: QuotesBoolExp
  quotesAggregate: QuotesAggregateBoolExp
  resolvedSecurityAlerts: SecurityAlertsBoolExp
  resolvedSecurityAlertsAggregate: SecurityAlertsAggregateBoolExp
  revokedInvitations: UserInvitationsBoolExp
  revokedInvitationsAggregate: UserInvitationsAggregateBoolExp
  role: UserRoleComparisonExp
  roleAssignments: UserRolesBoolExp
  roleAssignmentsAggregate: UserRolesAggregateBoolExp
  securityAlerts: SecurityAlertsBoolExp
  securityAlertsAggregate: SecurityAlertsAggregateBoolExp
  securitySettings: SecuritySettingsBoolExp
  securitySettingsAggregate: SecuritySettingsAggregateBoolExp
  sentEmails: EmailSendLogsBoolExp
  sentEmailsAggregate: EmailSendLogsAggregateBoolExp
  sentInvitations: UserInvitationsBoolExp
  sentInvitationsAggregate: UserInvitationsAggregateBoolExp
  skills: UserSkillsBoolExp
  skillsAggregate: UserSkillsAggregateBoolExp
  staffBillingItems: BillingItemsBoolExp
  staffBillingItemsAggregate: BillingItemsAggregateBoolExp
  status: UserStatusEnumComparisonExp
  statusChangeReason: StringComparisonExp
  statusChangedAt: TimestamptzComparisonExp
  statusChangedBy: UuidComparisonExp
  statusChangedByUser: UsersBoolExp
  targetedPermissionAuditLogs: PermissionAuditLogBoolExp
  targetedPermissionAuditLogsAggregate: PermissionAuditLogAggregateBoolExp
  timeEntries: TimeEntriesBoolExp
  timeEntriesAggregate: TimeEntriesAggregateBoolExp
  toConsultantAudits: PayrollAssignmentAuditBoolExp
  toConsultantAuditsAggregate: PayrollAssignmentAuditAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  updatedSecuritySettings: SecuritySettingsBoolExp
  updatedSecuritySettingsAggregate: SecuritySettingsAggregateBoolExp
  updatedServiceTemplates: ServiceTemplatesBoolExp
  updatedServiceTemplatesAggregate: ServiceTemplatesAggregateBoolExp
  updatedServices: ServicesBoolExp
  updatedServicesAggregate: ServicesAggregateBoolExp
  uploadedFiles: FilesBoolExp
  uploadedFilesAggregate: FilesAggregateBoolExp
  userSessions: UserSessionsBoolExp
  userSessionsAggregate: UserSessionsAggregateBoolExp
  username: StringComparisonExp
  usersWithStatusChanges: UsersBoolExp
  usersWithStatusChangesAggregate: UsersAggregateBoolExp
  workSchedules: WorkScheduleBoolExp
  workSchedulesAggregate: WorkScheduleAggregateBoolExp
}

"""
unique or primary key constraints on table "users"
"""
enum UsersConstraint {
  """
  unique or primary key constraint on columns "clerk_user_id"
  """
  users_clerk_user_id_key
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
  """
  unique or primary key constraint on columns "username"
  """
  users_username_key
}

"""
input type for incrementing numeric columns in table "users"
"""
input UsersIncInput {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
}

"""
input type for inserting data into table "users"
"""
input UsersInsertInput {
  acceptedInvitations: UserInvitationsArrRelInsertInput
  """User address or location"""
  address: String
  approvedBillingItems: BillingItemsArrRelInsertInput
  approvedEmailTemplates: EmailTemplatesArrRelInsertInput
  assignmentChanges: PayrollAssignmentAuditArrRelInsertInput
  assignmentsMade: PayrollAssignmentsArrRelInsertInput
  authoredNotes: NotesArrRelInsertInput
  backupPayrollAssignments: PayrollsArrRelInsertInput
  """User biography or description"""
  bio: String
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  confirmedBillingItems: BillingItemsArrRelInsertInput
  consultantAssignments: PayrollAssignmentsArrRelInsertInput
  """Timestamp when the user was created"""
  createdAt: timestamptz
  createdBillingEventLogs: BillingEventLogArrRelInsertInput
  createdClientServiceAgreements: ClientServiceAgreementsArrRelInsertInput
  createdEmailTemplates: EmailTemplatesArrRelInsertInput
  createdPermissionOverrides: PermissionOverridesArrRelInsertInput
  createdServicePricingRules: ServicePricingRulesArrRelInsertInput
  createdServiceTemplates: ServiceTemplatesArrRelInsertInput
  createdServices: ServicesArrRelInsertInput
  dataBackups: DataBackupsArrRelInsertInput
  deactivatedAt: timestamptz
  deactivatedBy: String
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
  """User's email address (unique)"""
  email: String
  emailDrafts: EmailDraftsArrRelInsertInput
  emailTemplateFavorites: UserEmailTemplateFavoritesArrRelInsertInput
  firstName: String
  fromConsultantAudits: PayrollAssignmentAuditArrRelInsertInput
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  lastName: String
  leaveRecords: LeaveArrRelInsertInput
  managedInvitations: UserInvitationsArrRelInsertInput
  managedPayrolls: PayrollsArrRelInsertInput
  managedTeamMembers: UsersArrRelInsertInput
  managedUsers: UsersArrRelInsertInput
  manager: UsersObjRelInsertInput
  """Reference to the user's manager"""
  managerId: uuid
  originalConsultantAssignments: PayrollAssignmentsArrRelInsertInput
  permissionAuditLogs: PermissionAuditLogArrRelInsertInput
  permissionOverrides: PermissionOverridesArrRelInsertInput
  """User contact phone number"""
  phone: String
  """Organizational position affecting admin time allocation"""
  position: user_position
  primaryPayrollAssignments: PayrollsArrRelInsertInput
  quoteConversions: QuoteConversionsArrRelInsertInput
  quoteTemplates: QuoteTemplatesArrRelInsertInput
  quotes: QuotesArrRelInsertInput
  resolvedSecurityAlerts: SecurityAlertsArrRelInsertInput
  revokedInvitations: UserInvitationsArrRelInsertInput
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  roleAssignments: UserRolesArrRelInsertInput
  securityAlerts: SecurityAlertsArrRelInsertInput
  securitySettings: SecuritySettingsArrRelInsertInput
  sentEmails: EmailSendLogsArrRelInsertInput
  sentInvitations: UserInvitationsArrRelInsertInput
  skills: UserSkillsArrRelInsertInput
  staffBillingItems: BillingItemsArrRelInsertInput
  """Current user status - must be consistent with isActive field"""
  status: user_status_enum
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: String
  """Timestamp when status was last changed"""
  statusChangedAt: timestamptz
  """User ID who changed the status"""
  statusChangedBy: uuid
  statusChangedByUser: UsersObjRelInsertInput
  targetedPermissionAuditLogs: PermissionAuditLogArrRelInsertInput
  timeEntries: TimeEntriesArrRelInsertInput
  toConsultantAudits: PayrollAssignmentAuditArrRelInsertInput
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  updatedSecuritySettings: SecuritySettingsArrRelInsertInput
  updatedServiceTemplates: ServiceTemplatesArrRelInsertInput
  updatedServices: ServicesArrRelInsertInput
  uploadedFiles: FilesArrRelInsertInput
  userSessions: UserSessionsArrRelInsertInput
  """User's unique username for login"""
  username: String
  usersWithStatusChanges: UsersArrRelInsertInput
  workSchedules: WorkScheduleArrRelInsertInput
}

"""aggregate max on columns"""
type UsersMaxFields {
  """User address or location"""
  address: String
  """User biography or description"""
  bio: String
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  computedName: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
  """User's email address (unique)"""
  email: String
  firstName: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  lastName: String
  """Reference to the user's manager"""
  managerId: uuid
  """User contact phone number"""
  phone: String
  """Organizational position affecting admin time allocation"""
  position: user_position
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Current user status - must be consistent with isActive field"""
  status: user_status_enum
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: String
  """Timestamp when status was last changed"""
  statusChangedAt: timestamptz
  """User ID who changed the status"""
  statusChangedBy: uuid
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""
order by max() on columns of table "users"
"""
input UsersMaxOrderBy {
  """User address or location"""
  address: OrderBy
  """User biography or description"""
  bio: OrderBy
  """External identifier from Clerk authentication service"""
  clerkUserId: OrderBy
  computedName: OrderBy
  """Timestamp when the user was created"""
  createdAt: OrderBy
  deactivatedAt: OrderBy
  deactivatedBy: OrderBy
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
  """User's email address (unique)"""
  email: OrderBy
  firstName: OrderBy
  """Unique identifier for the user"""
  id: OrderBy
  """URL to the user's profile image"""
  image: OrderBy
  lastName: OrderBy
  """Reference to the user's manager"""
  managerId: OrderBy
  """User contact phone number"""
  phone: OrderBy
  """Organizational position affecting admin time allocation"""
  position: OrderBy
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: OrderBy
  """Current user status - must be consistent with isActive field"""
  status: OrderBy
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: OrderBy
  """Timestamp when status was last changed"""
  statusChangedAt: OrderBy
  """User ID who changed the status"""
  statusChangedBy: OrderBy
  """Timestamp when the user was last updated"""
  updatedAt: OrderBy
  """User's unique username for login"""
  username: OrderBy
}

"""aggregate min on columns"""
type UsersMinFields {
  """User address or location"""
  address: String
  """User biography or description"""
  bio: String
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  computedName: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
  """User's email address (unique)"""
  email: String
  firstName: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  lastName: String
  """Reference to the user's manager"""
  managerId: uuid
  """User contact phone number"""
  phone: String
  """Organizational position affecting admin time allocation"""
  position: user_position
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Current user status - must be consistent with isActive field"""
  status: user_status_enum
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: String
  """Timestamp when status was last changed"""
  statusChangedAt: timestamptz
  """User ID who changed the status"""
  statusChangedBy: uuid
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""
order by min() on columns of table "users"
"""
input UsersMinOrderBy {
  """User address or location"""
  address: OrderBy
  """User biography or description"""
  bio: OrderBy
  """External identifier from Clerk authentication service"""
  clerkUserId: OrderBy
  computedName: OrderBy
  """Timestamp when the user was created"""
  createdAt: OrderBy
  deactivatedAt: OrderBy
  deactivatedBy: OrderBy
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
  """User's email address (unique)"""
  email: OrderBy
  firstName: OrderBy
  """Unique identifier for the user"""
  id: OrderBy
  """URL to the user's profile image"""
  image: OrderBy
  lastName: OrderBy
  """Reference to the user's manager"""
  managerId: OrderBy
  """User contact phone number"""
  phone: OrderBy
  """Organizational position affecting admin time allocation"""
  position: OrderBy
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: OrderBy
  """Current user status - must be consistent with isActive field"""
  status: OrderBy
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: OrderBy
  """Timestamp when status was last changed"""
  statusChangedAt: OrderBy
  """User ID who changed the status"""
  statusChangedBy: OrderBy
  """Timestamp when the user was last updated"""
  updatedAt: OrderBy
  """User's unique username for login"""
  username: OrderBy
}

"""
response of any mutation on the table "users"
"""
type UsersMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input UsersObjRelInsertInput {
  data: UsersInsertInput!
  """upsert condition"""
  onConflict: UsersOnConflict
}

"""
on_conflict condition type for table "users"
"""
input UsersOnConflict {
  constraint: UsersConstraint!
  updateColumns: [UsersUpdateColumn!]! = []
  where: UsersBoolExp
}

"""Ordering options when selecting data from "users"."""
input UsersOrderBy {
  acceptedInvitationsAggregate: UserInvitationsAggregateOrderBy
  address: OrderBy
  approvedBillingItemsAggregate: BillingItemsAggregateOrderBy
  approvedEmailTemplatesAggregate: EmailTemplatesAggregateOrderBy
  assignmentChangesAggregate: PayrollAssignmentAuditAggregateOrderBy
  assignmentsMadeAggregate: PayrollAssignmentsAggregateOrderBy
  authoredNotesAggregate: NotesAggregateOrderBy
  backupPayrollAssignmentsAggregate: PayrollsAggregateOrderBy
  bio: OrderBy
  clerkUserId: OrderBy
  computedName: OrderBy
  confirmedBillingItemsAggregate: BillingItemsAggregateOrderBy
  consultantAssignmentsAggregate: PayrollAssignmentsAggregateOrderBy
  createdAt: OrderBy
  createdBillingEventLogsAggregate: BillingEventLogAggregateOrderBy
  createdClientServiceAgreementsAggregate: ClientServiceAgreementsAggregateOrderBy
  createdEmailTemplatesAggregate: EmailTemplatesAggregateOrderBy
  createdPermissionOverridesAggregate: PermissionOverridesAggregateOrderBy
  createdServicePricingRulesAggregate: ServicePricingRulesAggregateOrderBy
  createdServiceTemplatesAggregate: ServiceTemplatesAggregateOrderBy
  createdServicesAggregate: ServicesAggregateOrderBy
  dataBackupsAggregate: DataBackupsAggregateOrderBy
  deactivatedAt: OrderBy
  deactivatedBy: OrderBy
  defaultAdminTimePercentage: OrderBy
  email: OrderBy
  emailDraftsAggregate: EmailDraftsAggregateOrderBy
  emailTemplateFavoritesAggregate: UserEmailTemplateFavoritesAggregateOrderBy
  firstName: OrderBy
  fromConsultantAuditsAggregate: PayrollAssignmentAuditAggregateOrderBy
  id: OrderBy
  image: OrderBy
  isActive: OrderBy
  isStaff: OrderBy
  lastName: OrderBy
  leaveRecordsAggregate: LeaveAggregateOrderBy
  managedInvitationsAggregate: UserInvitationsAggregateOrderBy
  managedPayrollsAggregate: PayrollsAggregateOrderBy
  managedTeamMembersAggregate: UsersAggregateOrderBy
  managedUsersAggregate: UsersAggregateOrderBy
  manager: UsersOrderBy
  managerId: OrderBy
  originalConsultantAssignmentsAggregate: PayrollAssignmentsAggregateOrderBy
  permissionAuditLogsAggregate: PermissionAuditLogAggregateOrderBy
  permissionOverridesAggregate: PermissionOverridesAggregateOrderBy
  phone: OrderBy
  position: OrderBy
  primaryPayrollAssignmentsAggregate: PayrollsAggregateOrderBy
  quoteConversionsAggregate: QuoteConversionsAggregateOrderBy
  quoteTemplatesAggregate: QuoteTemplatesAggregateOrderBy
  quotesAggregate: QuotesAggregateOrderBy
  resolvedSecurityAlertsAggregate: SecurityAlertsAggregateOrderBy
  revokedInvitationsAggregate: UserInvitationsAggregateOrderBy
  role: OrderBy
  roleAssignmentsAggregate: UserRolesAggregateOrderBy
  securityAlertsAggregate: SecurityAlertsAggregateOrderBy
  securitySettingsAggregate: SecuritySettingsAggregateOrderBy
  sentEmailsAggregate: EmailSendLogsAggregateOrderBy
  sentInvitationsAggregate: UserInvitationsAggregateOrderBy
  skillsAggregate: UserSkillsAggregateOrderBy
  staffBillingItemsAggregate: BillingItemsAggregateOrderBy
  status: OrderBy
  statusChangeReason: OrderBy
  statusChangedAt: OrderBy
  statusChangedBy: OrderBy
  statusChangedByUser: UsersOrderBy
  targetedPermissionAuditLogsAggregate: PermissionAuditLogAggregateOrderBy
  timeEntriesAggregate: TimeEntriesAggregateOrderBy
  toConsultantAuditsAggregate: PayrollAssignmentAuditAggregateOrderBy
  updatedAt: OrderBy
  updatedSecuritySettingsAggregate: SecuritySettingsAggregateOrderBy
  updatedServiceTemplatesAggregate: ServiceTemplatesAggregateOrderBy
  updatedServicesAggregate: ServicesAggregateOrderBy
  uploadedFilesAggregate: FilesAggregateOrderBy
  userSessionsAggregate: UserSessionsAggregateOrderBy
  username: OrderBy
  usersWithStatusChangesAggregate: UsersAggregateOrderBy
  workSchedulesAggregate: WorkScheduleAggregateOrderBy
}

"""primary key columns input for table: users"""
input UsersPkColumnsInput {
  """Unique identifier for the user"""
  id: uuid!
}

"""
columns and relationships of "users_role_backup"
"""
type UsersRoleBackup {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
aggregated selection of "users_role_backup"
"""
type UsersRoleBackupAggregate {
  aggregate: UsersRoleBackupAggregateFields
  nodes: [UsersRoleBackup!]!
}

"""
aggregate fields of "users_role_backup"
"""
type UsersRoleBackupAggregateFields {
  count(columns: [UsersRoleBackupSelectColumn!], distinct: Boolean): Int!
  max: UsersRoleBackupMaxFields
  min: UsersRoleBackupMinFields
}

"""
Boolean expression to filter rows from the table "users_role_backup". All fields are combined with a logical 'AND'.
"""
input UsersRoleBackupBoolExp {
  _and: [UsersRoleBackupBoolExp!]
  _not: UsersRoleBackupBoolExp
  _or: [UsersRoleBackupBoolExp!]
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  role: UserRoleComparisonExp
}

"""
input type for inserting data into table "users_role_backup"
"""
input UsersRoleBackupInsertInput {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""aggregate max on columns"""
type UsersRoleBackupMaxFields {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""aggregate min on columns"""
type UsersRoleBackupMinFields {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
response of any mutation on the table "users_role_backup"
"""
type UsersRoleBackupMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UsersRoleBackup!]!
}

"""Ordering options when selecting data from "users_role_backup"."""
input UsersRoleBackupOrderBy {
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  role: OrderBy
}

"""
select columns of table "users_role_backup"
"""
enum UsersRoleBackupSelectColumn {
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  id
  """column name"""
  role
}

"""
input type for updating data in table "users_role_backup"
"""
input UsersRoleBackupSetInput {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
Streaming cursor of the table "users_role_backup"
"""
input UsersRoleBackupStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UsersRoleBackupStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UsersRoleBackupStreamCursorValueInput {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

input UsersRoleBackupUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UsersRoleBackupSetInput
  """filter the rows which have to be updated"""
  where: UsersRoleBackupBoolExp!
}

"""
select columns of table "users"
"""
enum UsersSelectColumn {
  """column name"""
  address
  """column name"""
  bio
  """column name"""
  clerkUserId
  """column name"""
  computedName
  """column name"""
  createdAt
  """column name"""
  deactivatedAt
  """column name"""
  deactivatedBy
  """column name"""
  defaultAdminTimePercentage
  """column name"""
  email
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  image
  """column name"""
  isActive
  """column name"""
  isStaff
  """column name"""
  lastName
  """column name"""
  managerId
  """column name"""
  phone
  """column name"""
  position
  """column name"""
  role
  """column name"""
  status
  """column name"""
  statusChangeReason
  """column name"""
  statusChangedAt
  """column name"""
  statusChangedBy
  """column name"""
  updatedAt
  """column name"""
  username
}

"""
select "usersAggregateBoolExpBool_andArgumentsColumns" columns of table "users"
"""
enum UsersSelectColumnUsersAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isStaff
}

"""
select "usersAggregateBoolExpBool_orArgumentsColumns" columns of table "users"
"""
enum UsersSelectColumnUsersAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isStaff
}

"""
input type for updating data in table "users"
"""
input UsersSetInput {
  """User address or location"""
  address: String
  """User biography or description"""
  bio: String
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
  """User's email address (unique)"""
  email: String
  firstName: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  lastName: String
  """Reference to the user's manager"""
  managerId: uuid
  """User contact phone number"""
  phone: String
  """Organizational position affecting admin time allocation"""
  position: user_position
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Current user status - must be consistent with isActive field"""
  status: user_status_enum
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: String
  """Timestamp when status was last changed"""
  statusChangedAt: timestamptz
  """User ID who changed the status"""
  statusChangedBy: uuid
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""aggregate stddev on columns"""
type UsersStddevFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: Float
}

"""
order by stddev() on columns of table "users"
"""
input UsersStddevOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""aggregate stddevPop on columns"""
type UsersStddevPopFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: Float
}

"""
order by stddevPop() on columns of table "users"
"""
input UsersStddevPopOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""aggregate stddevSamp on columns"""
type UsersStddevSampFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: Float
}

"""
order by stddevSamp() on columns of table "users"
"""
input UsersStddevSampOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""
Streaming cursor of the table "users"
"""
input UsersStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UsersStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UsersStreamCursorValueInput {
  """User address or location"""
  address: String
  """User biography or description"""
  bio: String
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  computedName: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
  """User's email address (unique)"""
  email: String
  firstName: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  lastName: String
  """Reference to the user's manager"""
  managerId: uuid
  """User contact phone number"""
  phone: String
  """Organizational position affecting admin time allocation"""
  position: user_position
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Current user status - must be consistent with isActive field"""
  status: user_status_enum
  """Reason for the status change (for audit purposes)"""
  statusChangeReason: String
  """Timestamp when status was last changed"""
  statusChangedAt: timestamptz
  """User ID who changed the status"""
  statusChangedBy: uuid
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""aggregate sum on columns"""
type UsersSumFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: numeric
}

"""
order by sum() on columns of table "users"
"""
input UsersSumOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""
update columns of table "users"
"""
enum UsersUpdateColumn {
  """column name"""
  address
  """column name"""
  bio
  """column name"""
  clerkUserId
  """column name"""
  createdAt
  """column name"""
  deactivatedAt
  """column name"""
  deactivatedBy
  """column name"""
  defaultAdminTimePercentage
  """column name"""
  email
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  image
  """column name"""
  isActive
  """column name"""
  isStaff
  """column name"""
  lastName
  """column name"""
  managerId
  """column name"""
  phone
  """column name"""
  position
  """column name"""
  role
  """column name"""
  status
  """column name"""
  statusChangeReason
  """column name"""
  statusChangedAt
  """column name"""
  statusChangedBy
  """column name"""
  updatedAt
  """column name"""
  username
}

input UsersUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: UsersIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: UsersSetInput
  """filter the rows which have to be updated"""
  where: UsersBoolExp!
}

"""aggregate varPop on columns"""
type UsersVarPopFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: Float
}

"""
order by varPop() on columns of table "users"
"""
input UsersVarPopOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""aggregate varSamp on columns"""
type UsersVarSampFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: Float
}

"""
order by varSamp() on columns of table "users"
"""
input UsersVarSampOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""aggregate variance on columns"""
type UsersVarianceFields {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: Float
}

"""
order by variance() on columns of table "users"
"""
input UsersVarianceOrderBy {
  """Default admin time percentage for this user"""
  defaultAdminTimePercentage: OrderBy
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "work_schedule"
"""
type WorkSchedule {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid!
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """An object relationship"""
  user: Users!
  """Reference to the user this schedule belongs to"""
  userId: uuid!
  """Whether to use position-based default admin time or custom override"""
  usesDefaultAdminTime: Boolean
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String!
  """Number of hours worked on this day"""
  workHours: numeric!
}

"""
aggregated selection of "work_schedule"
"""
type WorkScheduleAggregate {
  aggregate: WorkScheduleAggregateFields
  nodes: [WorkSchedule!]!
}

input WorkScheduleAggregateBoolExp {
  bool_and: workScheduleAggregateBoolExpBool_and
  bool_or: workScheduleAggregateBoolExpBool_or
  count: workScheduleAggregateBoolExpCount
}

"""
aggregate fields of "work_schedule"
"""
type WorkScheduleAggregateFields {
  avg: WorkScheduleAvgFields
  count(columns: [WorkScheduleSelectColumn!], distinct: Boolean): Int!
  max: WorkScheduleMaxFields
  min: WorkScheduleMinFields
  stddev: WorkScheduleStddevFields
  stddevPop: WorkScheduleStddevPopFields
  stddevSamp: WorkScheduleStddevSampFields
  sum: WorkScheduleSumFields
  varPop: WorkScheduleVarPopFields
  varSamp: WorkScheduleVarSampFields
  variance: WorkScheduleVarianceFields
}

"""
order by aggregate values of table "work_schedule"
"""
input WorkScheduleAggregateOrderBy {
  avg: WorkScheduleAvgOrderBy
  count: OrderBy
  max: WorkScheduleMaxOrderBy
  min: WorkScheduleMinOrderBy
  stddev: WorkScheduleStddevOrderBy
  stddevPop: WorkScheduleStddevPopOrderBy
  stddevSamp: WorkScheduleStddevSampOrderBy
  sum: WorkScheduleSumOrderBy
  varPop: WorkScheduleVarPopOrderBy
  varSamp: WorkScheduleVarSampOrderBy
  variance: WorkScheduleVarianceOrderBy
}

"""
input type for inserting array relation for remote table "work_schedule"
"""
input WorkScheduleArrRelInsertInput {
  data: [WorkScheduleInsertInput!]!
  """upsert condition"""
  onConflict: WorkScheduleOnConflict
}

"""aggregate avg on columns"""
type WorkScheduleAvgFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: Float
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: Float
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by avg() on columns of table "work_schedule"
"""
input WorkScheduleAvgOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
Boolean expression to filter rows from the table "work_schedule". All fields are combined with a logical 'AND'.
"""
input WorkScheduleBoolExp {
  _and: [WorkScheduleBoolExp!]
  _not: WorkScheduleBoolExp
  _or: [WorkScheduleBoolExp!]
  adminTimeHours: NumericComparisonExp
  createdAt: TimestampComparisonExp
  id: UuidComparisonExp
  payrollCapacityHours: NumericComparisonExp
  updatedAt: TimestampComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
  usesDefaultAdminTime: BooleanComparisonExp
  workDay: StringComparisonExp
  workHours: NumericComparisonExp
}

"""
unique or primary key constraints on table "work_schedule"
"""
enum WorkScheduleConstraint {
  """
  unique or primary key constraint on columns "user_id", "work_day"
  """
  unique_user_work_day
  """
  unique or primary key constraint on columns "id"
  """
  work_schedule_pkey
}

"""
input type for incrementing numeric columns in table "work_schedule"
"""
input WorkScheduleIncInput {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
input type for inserting data into table "work_schedule"
"""
input WorkScheduleInsertInput {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  user: UsersObjRelInsertInput
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Whether to use position-based default admin time or custom override"""
  usesDefaultAdminTime: Boolean
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""aggregate max on columns"""
type WorkScheduleMaxFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
order by max() on columns of table "work_schedule"
"""
input WorkScheduleMaxOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Timestamp when the schedule entry was created"""
  createdAt: OrderBy
  """Unique identifier for the work schedule entry"""
  id: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Timestamp when the schedule entry was last updated"""
  updatedAt: OrderBy
  """Reference to the user this schedule belongs to"""
  userId: OrderBy
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate min on columns"""
type WorkScheduleMinFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
order by min() on columns of table "work_schedule"
"""
input WorkScheduleMinOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Timestamp when the schedule entry was created"""
  createdAt: OrderBy
  """Unique identifier for the work schedule entry"""
  id: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Timestamp when the schedule entry was last updated"""
  updatedAt: OrderBy
  """Reference to the user this schedule belongs to"""
  userId: OrderBy
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
response of any mutation on the table "work_schedule"
"""
type WorkScheduleMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [WorkSchedule!]!
}

"""
on_conflict condition type for table "work_schedule"
"""
input WorkScheduleOnConflict {
  constraint: WorkScheduleConstraint!
  updateColumns: [WorkScheduleUpdateColumn!]! = []
  where: WorkScheduleBoolExp
}

"""Ordering options when selecting data from "work_schedule"."""
input WorkScheduleOrderBy {
  adminTimeHours: OrderBy
  createdAt: OrderBy
  id: OrderBy
  payrollCapacityHours: OrderBy
  updatedAt: OrderBy
  user: UsersOrderBy
  userId: OrderBy
  usesDefaultAdminTime: OrderBy
  workDay: OrderBy
  workHours: OrderBy
}

"""primary key columns input for table: work_schedule"""
input WorkSchedulePkColumnsInput {
  """Unique identifier for the work schedule entry"""
  id: uuid!
}

"""
select columns of table "work_schedule"
"""
enum WorkScheduleSelectColumn {
  """column name"""
  adminTimeHours
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  payrollCapacityHours
  """column name"""
  updatedAt
  """column name"""
  userId
  """column name"""
  usesDefaultAdminTime
  """column name"""
  workDay
  """column name"""
  workHours
}

"""
select "workScheduleAggregateBoolExpBool_andArgumentsColumns" columns of table "work_schedule"
"""
enum WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  usesDefaultAdminTime
}

"""
select "workScheduleAggregateBoolExpBool_orArgumentsColumns" columns of table "work_schedule"
"""
enum WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  usesDefaultAdminTime
}

"""
input type for updating data in table "work_schedule"
"""
input WorkScheduleSetInput {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Whether to use position-based default admin time or custom override"""
  usesDefaultAdminTime: Boolean
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""aggregate stddev on columns"""
type WorkScheduleStddevFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: Float
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: Float
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by stddev() on columns of table "work_schedule"
"""
input WorkScheduleStddevOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate stddevPop on columns"""
type WorkScheduleStddevPopFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: Float
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: Float
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by stddevPop() on columns of table "work_schedule"
"""
input WorkScheduleStddevPopOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate stddevSamp on columns"""
type WorkScheduleStddevSampFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: Float
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: Float
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by stddevSamp() on columns of table "work_schedule"
"""
input WorkScheduleStddevSampOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
Streaming cursor of the table "work_schedule"
"""
input WorkScheduleStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: WorkScheduleStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input WorkScheduleStreamCursorValueInput {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Whether to use position-based default admin time or custom override"""
  usesDefaultAdminTime: Boolean
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""aggregate sum on columns"""
type WorkScheduleSumFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: numeric
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: numeric
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
order by sum() on columns of table "work_schedule"
"""
input WorkScheduleSumOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
update columns of table "work_schedule"
"""
enum WorkScheduleUpdateColumn {
  """column name"""
  adminTimeHours
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  payrollCapacityHours
  """column name"""
  updatedAt
  """column name"""
  userId
  """column name"""
  usesDefaultAdminTime
  """column name"""
  workDay
  """column name"""
  workHours
}

input WorkScheduleUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: WorkScheduleIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: WorkScheduleSetInput
  """filter the rows which have to be updated"""
  where: WorkScheduleBoolExp!
}

"""aggregate varPop on columns"""
type WorkScheduleVarPopFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: Float
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: Float
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by varPop() on columns of table "work_schedule"
"""
input WorkScheduleVarPopOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate varSamp on columns"""
type WorkScheduleVarSampFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: Float
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: Float
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by varSamp() on columns of table "work_schedule"
"""
input WorkScheduleVarSampOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate variance on columns"""
type WorkScheduleVarianceFields {
  """Hours allocated to administrative tasks"""
  adminTimeHours: Float
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: Float
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by variance() on columns of table "work_schedule"
"""
input WorkScheduleVarianceOrderBy {
  """Hours allocated to administrative tasks"""
  adminTimeHours: OrderBy
  """Hours available for payroll processing (work_hours - admin_time_hours)"""
  payrollCapacityHours: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""Scalar _Any"""
scalar _Any

"""A union of all types that use the @key directive"""
union _Entity = AdjustmentRules | AppSettings | AuditAuditLog | AuditAuthEvents | AuditDataAccessLog | AuditPermissionChanges | AuditSlowQueries | BillingEventLog | BillingInvoice | BillingInvoiceItem | BillingItems | BillingPeriods | ClientExternalSystems | ClientServiceAgreements | Clients | DataBackups | EmailDrafts | EmailSendLogs | EmailTemplates | ExternalSystems | FeatureFlags | Files | Holidays | LatestPayrollVersionResults | Leave | Notes | PayrollActivationResults | PayrollAssignmentAudit | PayrollAssignments | PayrollCycles | PayrollDateTypes | PayrollDates | PayrollVersionHistoryResults | PayrollVersionResults | Payrolls | PermissionAuditLog | PermissionOverrides | Permissions | PositionAdminDefaults | RateLimits | Resources | RolePermissions | Roles | SecurityAlerts | SecuritySettings | ServicePricingRules | ServiceTemplates | Services | SystemConfiguration | SystemHealth | TimeEntries | UserEmailTemplateFavorites | UserInvitations | UserRoles | UserSessions | Users | WorkSchedule

type _Service {
  """SDL representation of schema"""
  sdl: String!
}

input adjustmentRulesAggregateBoolExpCount {
  arguments: [AdjustmentRulesSelectColumn!]
  distinct: Boolean
  filter: AdjustmentRulesBoolExp
  predicate: IntComparisonExp!
}

scalar bigint

input billingEventLogAggregateBoolExpCount {
  arguments: [BillingEventLogSelectColumn!]
  distinct: Boolean
  filter: BillingEventLogBoolExp
  predicate: IntComparisonExp!
}

input billingInvoiceAggregateBoolExpCount {
  arguments: [BillingInvoiceSelectColumn!]
  distinct: Boolean
  filter: BillingInvoiceBoolExp
  predicate: IntComparisonExp!
}

input billingInvoiceItemAggregateBoolExpCount {
  arguments: [BillingInvoiceItemSelectColumn!]
  distinct: Boolean
  filter: BillingInvoiceItemBoolExp
  predicate: IntComparisonExp!
}

input billingItemsAggregateBoolExpBool_and {
  arguments: BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: BillingItemsBoolExp
  predicate: BooleanComparisonExp!
}

input billingItemsAggregateBoolExpBool_or {
  arguments: BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: BillingItemsBoolExp
  predicate: BooleanComparisonExp!
}

input billingItemsAggregateBoolExpCount {
  arguments: [BillingItemsSelectColumn!]
  distinct: Boolean
  filter: BillingItemsBoolExp
  predicate: IntComparisonExp!
}

input billingPeriodsAggregateBoolExpCount {
  arguments: [BillingPeriodsSelectColumn!]
  distinct: Boolean
  filter: BillingPeriodsBoolExp
  predicate: IntComparisonExp!
}

scalar bpchar

input clientExternalSystemsAggregateBoolExpCount {
  arguments: [ClientExternalSystemsSelectColumn!]
  distinct: Boolean
  filter: ClientExternalSystemsBoolExp
  predicate: IntComparisonExp!
}

input clientServiceAgreementsAggregateBoolExpBool_and {
  arguments: ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ClientServiceAgreementsBoolExp
  predicate: BooleanComparisonExp!
}

input clientServiceAgreementsAggregateBoolExpBool_or {
  arguments: ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ClientServiceAgreementsBoolExp
  predicate: BooleanComparisonExp!
}

input clientServiceAgreementsAggregateBoolExpCount {
  arguments: [ClientServiceAgreementsSelectColumn!]
  distinct: Boolean
  filter: ClientServiceAgreementsBoolExp
  predicate: IntComparisonExp!
}

input createPayrollVersionArgs {
  p_created_by_user_id: uuid
  p_go_live_date: date
  p_new_backup_consultant_user_id: uuid
  p_new_client_id: uuid
  p_new_cycle_id: uuid
  p_new_date_type_id: uuid
  p_new_date_value: Int
  p_new_manager_user_id: uuid
  p_new_name: String
  p_new_primary_consultant_user_id: uuid
  p_original_payroll_id: uuid
  p_version_reason: String
}

input createPayrollVersionSimpleArgs {
  payroll_id: uuid
  version_reason: String
}

input dataBackupsAggregateBoolExpCount {
  arguments: [DataBackupsSelectColumn!]
  distinct: Boolean
  filter: DataBackupsBoolExp
  predicate: IntComparisonExp!
}

scalar date

input emailDraftsAggregateBoolExpCount {
  arguments: [EmailDraftsSelectColumn!]
  distinct: Boolean
  filter: EmailDraftsBoolExp
  predicate: IntComparisonExp!
}

input emailSendLogsAggregateBoolExpCount {
  arguments: [EmailSendLogsSelectColumn!]
  distinct: Boolean
  filter: EmailSendLogsBoolExp
  predicate: IntComparisonExp!
}

input emailTemplatesAggregateBoolExpBool_and {
  arguments: EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: EmailTemplatesBoolExp
  predicate: BooleanComparisonExp!
}

input emailTemplatesAggregateBoolExpBool_or {
  arguments: EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: EmailTemplatesBoolExp
  predicate: BooleanComparisonExp!
}

input emailTemplatesAggregateBoolExpCount {
  arguments: [EmailTemplatesSelectColumn!]
  distinct: Boolean
  filter: EmailTemplatesBoolExp
  predicate: IntComparisonExp!
}

input filesAggregateBoolExpBool_and {
  arguments: FilesSelectColumnFilesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: FilesBoolExp
  predicate: BooleanComparisonExp!
}

input filesAggregateBoolExpBool_or {
  arguments: FilesSelectColumnFilesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: FilesBoolExp
  predicate: BooleanComparisonExp!
}

input filesAggregateBoolExpCount {
  arguments: [FilesSelectColumn!]
  distinct: Boolean
  filter: FilesBoolExp
  predicate: IntComparisonExp!
}

input generatePayrollDatesArgs {
  p_end_date: date
  p_max_dates: Int
  p_payroll_id: uuid
  p_start_date: date
}

input getLatestPayrollVersionArgs {
  payroll_id: uuid
}

input getPayrollVersionHistoryArgs {
  payroll_id: uuid
}

scalar inet

scalar interval

scalar invitation_status_enum

scalar jsonb

input leaveAggregateBoolExpCount {
  arguments: [LeaveSelectColumn!]
  distinct: Boolean
  filter: LeaveBoolExp
  predicate: IntComparisonExp!
}

scalar leave_status_enum

"""mutation root"""
type mutation_root {
  """
  execute VOLATILE function "activate_payroll_versions" which returns "payroll_activation_results"
  """
  activatePayrollVersions(
    """distinct select on columns"""
    distinctOn: [PayrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollActivationResultsBoolExp
  ): [PayrollActivationResults!]!
  """
  execute VOLATILE function "create_payroll_version" which returns "payroll_version_results"
  """
  createPayrollVersion(
    """
    input parameters for function "createPayrollVersion"
    """
    args: createPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [PayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionResultsBoolExp
  ): [PayrollVersionResults!]!
  """
  execute VOLATILE function "create_payroll_version_simple" which returns "payroll_version_results"
  """
  createPayrollVersionSimple(
    """
    input parameters for function "createPayrollVersionSimple"
    """
    args: createPayrollVersionSimpleArgs!
    """distinct select on columns"""
    distinctOn: [PayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionResultsBoolExp
  ): [PayrollVersionResults!]!
  """
  delete data from the table: "adjustment_rules"
  """
  deleteAdjustmentRules(
    """filter the rows which have to be deleted"""
    where: AdjustmentRulesBoolExp!
  ): AdjustmentRulesMutationResponse
  """
  delete single row from the table: "adjustment_rules"
  """
  deleteAdjustmentRulesByPk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): AdjustmentRules
  """
  delete data from the table: "app_settings"
  """
  deleteAppSettings(
    """filter the rows which have to be deleted"""
    where: AppSettingsBoolExp!
  ): AppSettingsMutationResponse
  """
  delete single row from the table: "app_settings"
  """
  deleteAppSettingsByPk(
    """Unique identifier for application setting"""
    id: String!
  ): AppSettings
  """
  delete data from the table: "audit.audit_log"
  """
  deleteAuditAuditLog(
    """filter the rows which have to be deleted"""
    where: AuditAuditLogBoolExp!
  ): AuditAuditLogMutationResponse
  """
  delete single row from the table: "audit.audit_log"
  """
  deleteAuditAuditLogByPk(id: uuid!): AuditAuditLog
  """
  delete data from the table: "audit.auth_events"
  """
  deleteAuditAuthEvents(
    """filter the rows which have to be deleted"""
    where: AuditAuthEventsBoolExp!
  ): AuditAuthEventsMutationResponse
  """
  delete single row from the table: "audit.auth_events"
  """
  deleteAuditAuthEventsByPk(id: uuid!): AuditAuthEvents
  """
  delete data from the table: "audit.data_access_log"
  """
  deleteAuditDataAccessLog(
    """filter the rows which have to be deleted"""
    where: AuditDataAccessLogBoolExp!
  ): AuditDataAccessLogMutationResponse
  """
  delete single row from the table: "audit.data_access_log"
  """
  deleteAuditDataAccessLogByPk(id: uuid!): AuditDataAccessLog
  """
  delete data from the table: "audit.permission_changes"
  """
  deleteAuditPermissionChanges(
    """filter the rows which have to be deleted"""
    where: AuditPermissionChangesBoolExp!
  ): AuditPermissionChangesMutationResponse
  """
  delete single row from the table: "audit.permission_changes"
  """
  deleteAuditPermissionChangesByPk(id: uuid!): AuditPermissionChanges
  """
  delete data from the table: "audit.slow_queries"
  """
  deleteAuditSlowQueries(
    """filter the rows which have to be deleted"""
    where: AuditSlowQueriesBoolExp!
  ): AuditSlowQueriesMutationResponse
  """
  delete single row from the table: "audit.slow_queries"
  """
  deleteAuditSlowQueriesByPk(id: uuid!): AuditSlowQueries
  """
  delete data from the table: "audit.user_access_summary"
  """
  deleteAuditUserAccessSummary(
    """filter the rows which have to be deleted"""
    where: AuditUserAccessSummaryBoolExp!
  ): AuditUserAccessSummaryMutationResponse
  """
  delete data from the table: "billing_event_log"
  """
  deleteBillingEventLog(
    """filter the rows which have to be deleted"""
    where: BillingEventLogBoolExp!
  ): BillingEventLogMutationResponse
  """
  delete single row from the table: "billing_event_log"
  """
  deleteBillingEventLogByPk(id: uuid!): BillingEventLog
  """
  delete data from the table: "billing_invoice"
  """
  deleteBillingInvoice(
    """filter the rows which have to be deleted"""
    where: BillingInvoiceBoolExp!
  ): BillingInvoiceMutationResponse
  """
  delete single row from the table: "billing_invoice"
  """
  deleteBillingInvoiceByPk(id: uuid!): BillingInvoice
  """
  delete data from the table: "billing_invoice_item"
  """
  deleteBillingInvoiceItem(
    """filter the rows which have to be deleted"""
    where: BillingInvoiceItemBoolExp!
  ): BillingInvoiceItemMutationResponse
  """
  delete single row from the table: "billing_invoice_item"
  """
  deleteBillingInvoiceItemByPk(id: uuid!): BillingInvoiceItem
  """
  delete data from the table: "billing_items"
  """
  deleteBillingItems(
    """filter the rows which have to be deleted"""
    where: BillingItemsBoolExp!
  ): BillingItemsMutationResponse
  """
  delete single row from the table: "billing_items"
  """
  deleteBillingItemsByPk(id: uuid!): BillingItems
  """
  delete data from the table: "billing_periods"
  """
  deleteBillingPeriods(
    """filter the rows which have to be deleted"""
    where: BillingPeriodsBoolExp!
  ): BillingPeriodsMutationResponse
  """
  delete single row from the table: "billing_periods"
  """
  deleteBillingPeriodsByPk(id: uuid!): BillingPeriods
  """
  delete data from the table: "client_external_systems"
  """
  deleteClientExternalSystems(
    """filter the rows which have to be deleted"""
    where: ClientExternalSystemsBoolExp!
  ): ClientExternalSystemsMutationResponse
  """
  delete single row from the table: "client_external_systems"
  """
  deleteClientExternalSystemsByPk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): ClientExternalSystems
  """
  delete data from the table: "client_service_agreements"
  """
  deleteClientServiceAgreements(
    """filter the rows which have to be deleted"""
    where: ClientServiceAgreementsBoolExp!
  ): ClientServiceAgreementsMutationResponse
  """
  delete single row from the table: "client_service_agreements"
  """
  deleteClientServiceAgreementsByPk(id: uuid!): ClientServiceAgreements
  """
  delete data from the table: "clients"
  """
  deleteClients(
    """filter the rows which have to be deleted"""
    where: ClientsBoolExp!
  ): ClientsMutationResponse
  """
  delete single row from the table: "clients"
  """
  deleteClientsByPk(
    """Unique identifier for the client"""
    id: uuid!
  ): Clients
  """
  delete data from the table: "data_backups"
  """
  deleteDataBackups(
    """filter the rows which have to be deleted"""
    where: DataBackupsBoolExp!
  ): DataBackupsMutationResponse
  """
  delete single row from the table: "data_backups"
  """
  deleteDataBackupsByPk(id: uuid!): DataBackups
  """
  delete data from the table: "email_drafts"
  """
  deleteEmailDrafts(
    """filter the rows which have to be deleted"""
    where: EmailDraftsBoolExp!
  ): EmailDraftsMutationResponse
  """
  delete single row from the table: "email_drafts"
  """
  deleteEmailDraftsByPk(id: uuid!): EmailDrafts
  """
  delete data from the table: "email_send_logs"
  """
  deleteEmailSendLogs(
    """filter the rows which have to be deleted"""
    where: EmailSendLogsBoolExp!
  ): EmailSendLogsMutationResponse
  """
  delete single row from the table: "email_send_logs"
  """
  deleteEmailSendLogsByPk(id: uuid!): EmailSendLogs
  """
  delete data from the table: "email_templates"
  """
  deleteEmailTemplates(
    """filter the rows which have to be deleted"""
    where: EmailTemplatesBoolExp!
  ): EmailTemplatesMutationResponse
  """
  delete single row from the table: "email_templates"
  """
  deleteEmailTemplatesByPk(id: uuid!): EmailTemplates
  """
  delete data from the table: "external_systems"
  """
  deleteExternalSystems(
    """filter the rows which have to be deleted"""
    where: ExternalSystemsBoolExp!
  ): ExternalSystemsMutationResponse
  """
  delete single row from the table: "external_systems"
  """
  deleteExternalSystemsByPk(
    """Unique identifier for the external system"""
    id: uuid!
  ): ExternalSystems
  """
  delete data from the table: "feature_flags"
  """
  deleteFeatureFlags(
    """filter the rows which have to be deleted"""
    where: FeatureFlagsBoolExp!
  ): FeatureFlagsMutationResponse
  """
  delete single row from the table: "feature_flags"
  """
  deleteFeatureFlagsByPk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): FeatureFlags
  """
  delete data from the table: "files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: FilesBoolExp!
  ): FilesMutationResponse
  """
  delete single row from the table: "files"
  """
  deleteFilesByPk(id: uuid!): Files
  """
  delete data from the table: "holidays"
  """
  deleteHolidays(
    """filter the rows which have to be deleted"""
    where: HolidaysBoolExp!
  ): HolidaysMutationResponse
  """
  delete single row from the table: "holidays"
  """
  deleteHolidaysByPk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): Holidays
  """
  delete data from the table: "latest_payroll_version_results"
  """
  deleteLatestPayrollVersionResults(
    """filter the rows which have to be deleted"""
    where: LatestPayrollVersionResultsBoolExp!
  ): LatestPayrollVersionResultsMutationResponse
  """
  delete single row from the table: "latest_payroll_version_results"
  """
  deleteLatestPayrollVersionResultsByPk(id: uuid!): LatestPayrollVersionResults
  """
  delete data from the table: "leave"
  """
  deleteLeave(
    """filter the rows which have to be deleted"""
    where: LeaveBoolExp!
  ): LeaveMutationResponse
  """
  delete single row from the table: "leave"
  """
  deleteLeaveByPk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): Leave
  """
  delete data from the table: "notes"
  """
  deleteNotes(
    """filter the rows which have to be deleted"""
    where: NotesBoolExp!
  ): NotesMutationResponse
  """
  delete single row from the table: "notes"
  """
  deleteNotesByPk(
    """Unique identifier for the note"""
    id: uuid!
  ): Notes
  """
  delete data from the table: "payroll_activation_results"
  """
  deletePayrollActivationResults(
    """filter the rows which have to be deleted"""
    where: PayrollActivationResultsBoolExp!
  ): PayrollActivationResultsMutationResponse
  """
  delete single row from the table: "payroll_activation_results"
  """
  deletePayrollActivationResultsByPk(id: uuid!): PayrollActivationResults
  """
  delete data from the table: "payroll_assignment_audit"
  """
  deletePayrollAssignmentAudit(
    """filter the rows which have to be deleted"""
    where: PayrollAssignmentAuditBoolExp!
  ): PayrollAssignmentAuditMutationResponse
  """
  delete single row from the table: "payroll_assignment_audit"
  """
  deletePayrollAssignmentAuditByPk(id: uuid!): PayrollAssignmentAudit
  """
  delete data from the table: "payroll_assignments"
  """
  deletePayrollAssignments(
    """filter the rows which have to be deleted"""
    where: PayrollAssignmentsBoolExp!
  ): PayrollAssignmentsMutationResponse
  """
  delete single row from the table: "payroll_assignments"
  """
  deletePayrollAssignmentsByPk(id: uuid!): PayrollAssignments
  """
  delete data from the table: "payroll_cycles"
  """
  deletePayrollCycles(
    """filter the rows which have to be deleted"""
    where: PayrollCyclesBoolExp!
  ): PayrollCyclesMutationResponse
  """
  delete single row from the table: "payroll_cycles"
  """
  deletePayrollCyclesByPk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): PayrollCycles
  """
  delete data from the table: "payroll_date_types"
  """
  deletePayrollDateTypes(
    """filter the rows which have to be deleted"""
    where: PayrollDateTypesBoolExp!
  ): PayrollDateTypesMutationResponse
  """
  delete single row from the table: "payroll_date_types"
  """
  deletePayrollDateTypesByPk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): PayrollDateTypes
  """
  delete data from the table: "payroll_dates"
  """
  deletePayrollDates(
    """filter the rows which have to be deleted"""
    where: PayrollDatesBoolExp!
  ): PayrollDatesMutationResponse
  """
  delete single row from the table: "payroll_dates"
  """
  deletePayrollDatesByPk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): PayrollDates
  """
  delete data from the table: "payroll_required_skills"
  """
  deletePayrollRequiredSkills(
    """filter the rows which have to be deleted"""
    where: PayrollRequiredSkillsBoolExp!
  ): PayrollRequiredSkillsMutationResponse
  """
  delete data from the table: "payroll_version_history_results"
  """
  deletePayrollVersionHistoryResults(
    """filter the rows which have to be deleted"""
    where: PayrollVersionHistoryResultsBoolExp!
  ): PayrollVersionHistoryResultsMutationResponse
  """
  delete single row from the table: "payroll_version_history_results"
  """
  deletePayrollVersionHistoryResultsByPk(id: uuid!): PayrollVersionHistoryResults
  """
  delete data from the table: "payroll_version_results"
  """
  deletePayrollVersionResults(
    """filter the rows which have to be deleted"""
    where: PayrollVersionResultsBoolExp!
  ): PayrollVersionResultsMutationResponse
  """
  delete single row from the table: "payroll_version_results"
  """
  deletePayrollVersionResultsByPk(id: uuid!): PayrollVersionResults
  """
  delete data from the table: "payrolls"
  """
  deletePayrolls(
    """filter the rows which have to be deleted"""
    where: PayrollsBoolExp!
  ): PayrollsMutationResponse
  """
  delete single row from the table: "payrolls"
  """
  deletePayrollsByPk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): Payrolls
  """
  delete data from the table: "permission_audit_log"
  """
  deletePermissionAuditLog(
    """filter the rows which have to be deleted"""
    where: PermissionAuditLogBoolExp!
  ): PermissionAuditLogMutationResponse
  """
  delete single row from the table: "permission_audit_log"
  """
  deletePermissionAuditLogByPk(id: uuid!): PermissionAuditLog
  """
  delete data from the table: "permission_overrides"
  """
  deletePermissionOverrides(
    """filter the rows which have to be deleted"""
    where: PermissionOverridesBoolExp!
  ): PermissionOverridesMutationResponse
  """
  delete single row from the table: "permission_overrides"
  """
  deletePermissionOverridesByPk(id: uuid!): PermissionOverrides
  """
  delete data from the table: "permissions"
  """
  deletePermissions(
    """filter the rows which have to be deleted"""
    where: PermissionsBoolExp!
  ): PermissionsMutationResponse
  """
  delete single row from the table: "permissions"
  """
  deletePermissionsByPk(id: uuid!): Permissions
  """
  delete data from the table: "position_admin_defaults"
  """
  deletePositionAdminDefaults(
    """filter the rows which have to be deleted"""
    where: PositionAdminDefaultsBoolExp!
  ): PositionAdminDefaultsMutationResponse
  """
  delete single row from the table: "position_admin_defaults"
  """
  deletePositionAdminDefaultsByPk(position: user_position!): PositionAdminDefaults
  """
  delete data from the table: "quote_conversions"
  """
  deleteQuoteConversions(
    """filter the rows which have to be deleted"""
    where: QuoteConversionsBoolExp!
  ): QuoteConversionsMutationResponse
  """
  delete single row from the table: "quote_conversions"
  """
  deleteQuoteConversionsByPk(id: uuid!): QuoteConversions
  """
  delete data from the table: "quote_line_items"
  """
  deleteQuoteLineItems(
    """filter the rows which have to be deleted"""
    where: QuoteLineItemsBoolExp!
  ): QuoteLineItemsMutationResponse
  """
  delete single row from the table: "quote_line_items"
  """
  deleteQuoteLineItemsByPk(id: uuid!): QuoteLineItems
  """
  delete data from the table: "quote_templates"
  """
  deleteQuoteTemplates(
    """filter the rows which have to be deleted"""
    where: QuoteTemplatesBoolExp!
  ): QuoteTemplatesMutationResponse
  """
  delete single row from the table: "quote_templates"
  """
  deleteQuoteTemplatesByPk(id: uuid!): QuoteTemplates
  """
  delete data from the table: "quotes"
  """
  deleteQuotes(
    """filter the rows which have to be deleted"""
    where: QuotesBoolExp!
  ): QuotesMutationResponse
  """
  delete single row from the table: "quotes"
  """
  deleteQuotesByPk(id: uuid!): Quotes
  """
  delete data from the table: "rate_limits"
  """
  deleteRateLimits(
    """filter the rows which have to be deleted"""
    where: RateLimitsBoolExp!
  ): RateLimitsMutationResponse
  """
  delete single row from the table: "rate_limits"
  """
  deleteRateLimitsByPk(id: uuid!): RateLimits
  """
  delete data from the table: "resources"
  """
  deleteResources(
    """filter the rows which have to be deleted"""
    where: ResourcesBoolExp!
  ): ResourcesMutationResponse
  """
  delete single row from the table: "resources"
  """
  deleteResourcesByPk(id: uuid!): Resources
  """
  delete data from the table: "role_permissions"
  """
  deleteRolePermissions(
    """filter the rows which have to be deleted"""
    where: RolePermissionsBoolExp!
  ): RolePermissionsMutationResponse
  """
  delete single row from the table: "role_permissions"
  """
  deleteRolePermissionsByPk(id: uuid!): RolePermissions
  """
  delete data from the table: "roles"
  """
  deleteRoles(
    """filter the rows which have to be deleted"""
    where: RolesBoolExp!
  ): RolesMutationResponse
  """
  delete single row from the table: "roles"
  """
  deleteRolesByPk(id: uuid!): Roles
  """
  delete data from the table: "security_alerts"
  """
  deleteSecurityAlerts(
    """filter the rows which have to be deleted"""
    where: SecurityAlertsBoolExp!
  ): SecurityAlertsMutationResponse
  """
  delete single row from the table: "security_alerts"
  """
  deleteSecurityAlertsByPk(id: uuid!): SecurityAlerts
  """
  delete data from the table: "security_settings"
  """
  deleteSecuritySettings(
    """filter the rows which have to be deleted"""
    where: SecuritySettingsBoolExp!
  ): SecuritySettingsMutationResponse
  """
  delete single row from the table: "security_settings"
  """
  deleteSecuritySettingsByPk(id: uuid!): SecuritySettings
  """
  delete data from the table: "service_pricing_rules"
  """
  deleteServicePricingRules(
    """filter the rows which have to be deleted"""
    where: ServicePricingRulesBoolExp!
  ): ServicePricingRulesMutationResponse
  """
  delete single row from the table: "service_pricing_rules"
  """
  deleteServicePricingRulesByPk(id: uuid!): ServicePricingRules
  """
  delete data from the table: "service_templates"
  """
  deleteServiceTemplates(
    """filter the rows which have to be deleted"""
    where: ServiceTemplatesBoolExp!
  ): ServiceTemplatesMutationResponse
  """
  delete single row from the table: "service_templates"
  """
  deleteServiceTemplatesByPk(id: uuid!): ServiceTemplates
  """
  delete data from the table: "services"
  """
  deleteServices(
    """filter the rows which have to be deleted"""
    where: ServicesBoolExp!
  ): ServicesMutationResponse
  """
  delete single row from the table: "services"
  """
  deleteServicesByPk(id: uuid!): Services
  """
  delete data from the table: "system_configuration"
  """
  deleteSystemConfiguration(
    """filter the rows which have to be deleted"""
    where: SystemConfigurationBoolExp!
  ): SystemConfigurationMutationResponse
  """
  delete single row from the table: "system_configuration"
  """
  deleteSystemConfigurationByPk(id: uuid!): SystemConfiguration
  """
  delete data from the table: "system_health"
  """
  deleteSystemHealth(
    """filter the rows which have to be deleted"""
    where: SystemHealthBoolExp!
  ): SystemHealthMutationResponse
  """
  delete single row from the table: "system_health"
  """
  deleteSystemHealthByPk(id: uuid!): SystemHealth
  """
  delete data from the table: "time_entries"
  """
  deleteTimeEntries(
    """filter the rows which have to be deleted"""
    where: TimeEntriesBoolExp!
  ): TimeEntriesMutationResponse
  """
  delete single row from the table: "time_entries"
  """
  deleteTimeEntriesByPk(id: uuid!): TimeEntries
  """
  delete data from the table: "user_email_template_favorites"
  """
  deleteUserEmailTemplateFavorites(
    """filter the rows which have to be deleted"""
    where: UserEmailTemplateFavoritesBoolExp!
  ): UserEmailTemplateFavoritesMutationResponse
  """
  delete single row from the table: "user_email_template_favorites"
  """
  deleteUserEmailTemplateFavoritesByPk(id: uuid!): UserEmailTemplateFavorites
  """
  delete data from the table: "user_invitations"
  """
  deleteUserInvitations(
    """filter the rows which have to be deleted"""
    where: UserInvitationsBoolExp!
  ): UserInvitationsMutationResponse
  """
  delete single row from the table: "user_invitations"
  """
  deleteUserInvitationsByPk(id: uuid!): UserInvitations
  """
  delete data from the table: "user_roles"
  """
  deleteUserRoles(
    """filter the rows which have to be deleted"""
    where: UserRolesBoolExp!
  ): UserRolesMutationResponse
  """
  delete single row from the table: "user_roles"
  """
  deleteUserRolesByPk(id: uuid!): UserRoles
  """
  delete data from the table: "user_sessions"
  """
  deleteUserSessions(
    """filter the rows which have to be deleted"""
    where: UserSessionsBoolExp!
  ): UserSessionsMutationResponse
  """
  delete single row from the table: "user_sessions"
  """
  deleteUserSessionsByPk(id: uuid!): UserSessions
  """
  delete data from the table: "user_skills"
  """
  deleteUserSkills(
    """filter the rows which have to be deleted"""
    where: UserSkillsBoolExp!
  ): UserSkillsMutationResponse
  """
  delete data from the table: "users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: UsersBoolExp!
  ): UsersMutationResponse
  """
  delete single row from the table: "users"
  """
  deleteUsersByPk(
    """Unique identifier for the user"""
    id: uuid!
  ): Users
  """
  delete data from the table: "users_role_backup"
  """
  deleteUsersRoleBackup(
    """filter the rows which have to be deleted"""
    where: UsersRoleBackupBoolExp!
  ): UsersRoleBackupMutationResponse
  """
  delete data from the table: "work_schedule"
  """
  deleteWorkSchedule(
    """filter the rows which have to be deleted"""
    where: WorkScheduleBoolExp!
  ): WorkScheduleMutationResponse
  """
  delete single row from the table: "work_schedule"
  """
  deleteWorkScheduleByPk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): WorkSchedule
  """
  execute VOLATILE function "generate_payroll_dates" which returns "payroll_dates"
  """
  generatePayrollDates(
    """
    input parameters for function "generatePayrollDates"
    """
    args: generatePayrollDatesArgs!
    """distinct select on columns"""
    distinctOn: [PayrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDatesOrderBy!]
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): [PayrollDates!]!
  """
  insert data into the table: "adjustment_rules"
  """
  insertAdjustmentRules(
    """the rows to be inserted"""
    objects: [AdjustmentRulesInsertInput!]!
    """upsert condition"""
    onConflict: AdjustmentRulesOnConflict
  ): AdjustmentRulesMutationResponse
  """
  insert a single row into the table: "adjustment_rules"
  """
  insertAdjustmentRulesOne(
    """the row to be inserted"""
    object: AdjustmentRulesInsertInput!
    """upsert condition"""
    onConflict: AdjustmentRulesOnConflict
  ): AdjustmentRules
  """
  insert data into the table: "app_settings"
  """
  insertAppSettings(
    """the rows to be inserted"""
    objects: [AppSettingsInsertInput!]!
    """upsert condition"""
    onConflict: AppSettingsOnConflict
  ): AppSettingsMutationResponse
  """
  insert a single row into the table: "app_settings"
  """
  insertAppSettingsOne(
    """the row to be inserted"""
    object: AppSettingsInsertInput!
    """upsert condition"""
    onConflict: AppSettingsOnConflict
  ): AppSettings
  """
  insert data into the table: "audit.audit_log"
  """
  insertAuditAuditLog(
    """the rows to be inserted"""
    objects: [AuditAuditLogInsertInput!]!
    """upsert condition"""
    onConflict: AuditAuditLogOnConflict
  ): AuditAuditLogMutationResponse
  """
  insert a single row into the table: "audit.audit_log"
  """
  insertAuditAuditLogOne(
    """the row to be inserted"""
    object: AuditAuditLogInsertInput!
    """upsert condition"""
    onConflict: AuditAuditLogOnConflict
  ): AuditAuditLog
  """
  insert data into the table: "audit.auth_events"
  """
  insertAuditAuthEvents(
    """the rows to be inserted"""
    objects: [AuditAuthEventsInsertInput!]!
    """upsert condition"""
    onConflict: AuditAuthEventsOnConflict
  ): AuditAuthEventsMutationResponse
  """
  insert a single row into the table: "audit.auth_events"
  """
  insertAuditAuthEventsOne(
    """the row to be inserted"""
    object: AuditAuthEventsInsertInput!
    """upsert condition"""
    onConflict: AuditAuthEventsOnConflict
  ): AuditAuthEvents
  """
  insert data into the table: "audit.data_access_log"
  """
  insertAuditDataAccessLog(
    """the rows to be inserted"""
    objects: [AuditDataAccessLogInsertInput!]!
    """upsert condition"""
    onConflict: AuditDataAccessLogOnConflict
  ): AuditDataAccessLogMutationResponse
  """
  insert a single row into the table: "audit.data_access_log"
  """
  insertAuditDataAccessLogOne(
    """the row to be inserted"""
    object: AuditDataAccessLogInsertInput!
    """upsert condition"""
    onConflict: AuditDataAccessLogOnConflict
  ): AuditDataAccessLog
  """
  insert data into the table: "audit.permission_changes"
  """
  insertAuditPermissionChanges(
    """the rows to be inserted"""
    objects: [AuditPermissionChangesInsertInput!]!
    """upsert condition"""
    onConflict: AuditPermissionChangesOnConflict
  ): AuditPermissionChangesMutationResponse
  """
  insert a single row into the table: "audit.permission_changes"
  """
  insertAuditPermissionChangesOne(
    """the row to be inserted"""
    object: AuditPermissionChangesInsertInput!
    """upsert condition"""
    onConflict: AuditPermissionChangesOnConflict
  ): AuditPermissionChanges
  """
  insert data into the table: "audit.slow_queries"
  """
  insertAuditSlowQueries(
    """the rows to be inserted"""
    objects: [AuditSlowQueriesInsertInput!]!
    """upsert condition"""
    onConflict: AuditSlowQueriesOnConflict
  ): AuditSlowQueriesMutationResponse
  """
  insert a single row into the table: "audit.slow_queries"
  """
  insertAuditSlowQueriesOne(
    """the row to be inserted"""
    object: AuditSlowQueriesInsertInput!
    """upsert condition"""
    onConflict: AuditSlowQueriesOnConflict
  ): AuditSlowQueries
  """
  insert data into the table: "audit.user_access_summary"
  """
  insertAuditUserAccessSummary(
    """the rows to be inserted"""
    objects: [AuditUserAccessSummaryInsertInput!]!
  ): AuditUserAccessSummaryMutationResponse
  """
  insert a single row into the table: "audit.user_access_summary"
  """
  insertAuditUserAccessSummaryOne(
    """the row to be inserted"""
    object: AuditUserAccessSummaryInsertInput!
  ): AuditUserAccessSummary
  """
  insert data into the table: "billing_event_log"
  """
  insertBillingEventLog(
    """the rows to be inserted"""
    objects: [BillingEventLogInsertInput!]!
    """upsert condition"""
    onConflict: BillingEventLogOnConflict
  ): BillingEventLogMutationResponse
  """
  insert a single row into the table: "billing_event_log"
  """
  insertBillingEventLogOne(
    """the row to be inserted"""
    object: BillingEventLogInsertInput!
    """upsert condition"""
    onConflict: BillingEventLogOnConflict
  ): BillingEventLog
  """
  insert data into the table: "billing_invoice"
  """
  insertBillingInvoice(
    """the rows to be inserted"""
    objects: [BillingInvoiceInsertInput!]!
    """upsert condition"""
    onConflict: BillingInvoiceOnConflict
  ): BillingInvoiceMutationResponse
  """
  insert data into the table: "billing_invoice_item"
  """
  insertBillingInvoiceItem(
    """the rows to be inserted"""
    objects: [BillingInvoiceItemInsertInput!]!
    """upsert condition"""
    onConflict: BillingInvoiceItemOnConflict
  ): BillingInvoiceItemMutationResponse
  """
  insert a single row into the table: "billing_invoice_item"
  """
  insertBillingInvoiceItemOne(
    """the row to be inserted"""
    object: BillingInvoiceItemInsertInput!
    """upsert condition"""
    onConflict: BillingInvoiceItemOnConflict
  ): BillingInvoiceItem
  """
  insert a single row into the table: "billing_invoice"
  """
  insertBillingInvoiceOne(
    """the row to be inserted"""
    object: BillingInvoiceInsertInput!
    """upsert condition"""
    onConflict: BillingInvoiceOnConflict
  ): BillingInvoice
  """
  insert data into the table: "billing_items"
  """
  insertBillingItems(
    """the rows to be inserted"""
    objects: [BillingItemsInsertInput!]!
    """upsert condition"""
    onConflict: BillingItemsOnConflict
  ): BillingItemsMutationResponse
  """
  insert a single row into the table: "billing_items"
  """
  insertBillingItemsOne(
    """the row to be inserted"""
    object: BillingItemsInsertInput!
    """upsert condition"""
    onConflict: BillingItemsOnConflict
  ): BillingItems
  """
  insert data into the table: "billing_periods"
  """
  insertBillingPeriods(
    """the rows to be inserted"""
    objects: [BillingPeriodsInsertInput!]!
    """upsert condition"""
    onConflict: BillingPeriodsOnConflict
  ): BillingPeriodsMutationResponse
  """
  insert a single row into the table: "billing_periods"
  """
  insertBillingPeriodsOne(
    """the row to be inserted"""
    object: BillingPeriodsInsertInput!
    """upsert condition"""
    onConflict: BillingPeriodsOnConflict
  ): BillingPeriods
  """
  insert data into the table: "client_external_systems"
  """
  insertClientExternalSystems(
    """the rows to be inserted"""
    objects: [ClientExternalSystemsInsertInput!]!
    """upsert condition"""
    onConflict: ClientExternalSystemsOnConflict
  ): ClientExternalSystemsMutationResponse
  """
  insert a single row into the table: "client_external_systems"
  """
  insertClientExternalSystemsOne(
    """the row to be inserted"""
    object: ClientExternalSystemsInsertInput!
    """upsert condition"""
    onConflict: ClientExternalSystemsOnConflict
  ): ClientExternalSystems
  """
  insert data into the table: "client_service_agreements"
  """
  insertClientServiceAgreements(
    """the rows to be inserted"""
    objects: [ClientServiceAgreementsInsertInput!]!
    """upsert condition"""
    onConflict: ClientServiceAgreementsOnConflict
  ): ClientServiceAgreementsMutationResponse
  """
  insert a single row into the table: "client_service_agreements"
  """
  insertClientServiceAgreementsOne(
    """the row to be inserted"""
    object: ClientServiceAgreementsInsertInput!
    """upsert condition"""
    onConflict: ClientServiceAgreementsOnConflict
  ): ClientServiceAgreements
  """
  insert data into the table: "clients"
  """
  insertClients(
    """the rows to be inserted"""
    objects: [ClientsInsertInput!]!
    """upsert condition"""
    onConflict: ClientsOnConflict
  ): ClientsMutationResponse
  """
  insert a single row into the table: "clients"
  """
  insertClientsOne(
    """the row to be inserted"""
    object: ClientsInsertInput!
    """upsert condition"""
    onConflict: ClientsOnConflict
  ): Clients
  """
  insert data into the table: "data_backups"
  """
  insertDataBackups(
    """the rows to be inserted"""
    objects: [DataBackupsInsertInput!]!
    """upsert condition"""
    onConflict: DataBackupsOnConflict
  ): DataBackupsMutationResponse
  """
  insert a single row into the table: "data_backups"
  """
  insertDataBackupsOne(
    """the row to be inserted"""
    object: DataBackupsInsertInput!
    """upsert condition"""
    onConflict: DataBackupsOnConflict
  ): DataBackups
  """
  insert data into the table: "email_drafts"
  """
  insertEmailDrafts(
    """the rows to be inserted"""
    objects: [EmailDraftsInsertInput!]!
    """upsert condition"""
    onConflict: EmailDraftsOnConflict
  ): EmailDraftsMutationResponse
  """
  insert a single row into the table: "email_drafts"
  """
  insertEmailDraftsOne(
    """the row to be inserted"""
    object: EmailDraftsInsertInput!
    """upsert condition"""
    onConflict: EmailDraftsOnConflict
  ): EmailDrafts
  """
  insert data into the table: "email_send_logs"
  """
  insertEmailSendLogs(
    """the rows to be inserted"""
    objects: [EmailSendLogsInsertInput!]!
    """upsert condition"""
    onConflict: EmailSendLogsOnConflict
  ): EmailSendLogsMutationResponse
  """
  insert a single row into the table: "email_send_logs"
  """
  insertEmailSendLogsOne(
    """the row to be inserted"""
    object: EmailSendLogsInsertInput!
    """upsert condition"""
    onConflict: EmailSendLogsOnConflict
  ): EmailSendLogs
  """
  insert data into the table: "email_templates"
  """
  insertEmailTemplates(
    """the rows to be inserted"""
    objects: [EmailTemplatesInsertInput!]!
    """upsert condition"""
    onConflict: EmailTemplatesOnConflict
  ): EmailTemplatesMutationResponse
  """
  insert a single row into the table: "email_templates"
  """
  insertEmailTemplatesOne(
    """the row to be inserted"""
    object: EmailTemplatesInsertInput!
    """upsert condition"""
    onConflict: EmailTemplatesOnConflict
  ): EmailTemplates
  """
  insert data into the table: "external_systems"
  """
  insertExternalSystems(
    """the rows to be inserted"""
    objects: [ExternalSystemsInsertInput!]!
    """upsert condition"""
    onConflict: ExternalSystemsOnConflict
  ): ExternalSystemsMutationResponse
  """
  insert a single row into the table: "external_systems"
  """
  insertExternalSystemsOne(
    """the row to be inserted"""
    object: ExternalSystemsInsertInput!
    """upsert condition"""
    onConflict: ExternalSystemsOnConflict
  ): ExternalSystems
  """
  insert data into the table: "feature_flags"
  """
  insertFeatureFlags(
    """the rows to be inserted"""
    objects: [FeatureFlagsInsertInput!]!
    """upsert condition"""
    onConflict: FeatureFlagsOnConflict
  ): FeatureFlagsMutationResponse
  """
  insert a single row into the table: "feature_flags"
  """
  insertFeatureFlagsOne(
    """the row to be inserted"""
    object: FeatureFlagsInsertInput!
    """upsert condition"""
    onConflict: FeatureFlagsOnConflict
  ): FeatureFlags
  """
  insert data into the table: "files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [FilesInsertInput!]!
    """upsert condition"""
    onConflict: FilesOnConflict
  ): FilesMutationResponse
  """
  insert a single row into the table: "files"
  """
  insertFilesOne(
    """the row to be inserted"""
    object: FilesInsertInput!
    """upsert condition"""
    onConflict: FilesOnConflict
  ): Files
  """
  insert data into the table: "holidays"
  """
  insertHolidays(
    """the rows to be inserted"""
    objects: [HolidaysInsertInput!]!
    """upsert condition"""
    onConflict: HolidaysOnConflict
  ): HolidaysMutationResponse
  """
  insert a single row into the table: "holidays"
  """
  insertHolidaysOne(
    """the row to be inserted"""
    object: HolidaysInsertInput!
    """upsert condition"""
    onConflict: HolidaysOnConflict
  ): Holidays
  """
  insert data into the table: "latest_payroll_version_results"
  """
  insertLatestPayrollVersionResults(
    """the rows to be inserted"""
    objects: [LatestPayrollVersionResultsInsertInput!]!
    """upsert condition"""
    onConflict: LatestPayrollVersionResultsOnConflict
  ): LatestPayrollVersionResultsMutationResponse
  """
  insert a single row into the table: "latest_payroll_version_results"
  """
  insertLatestPayrollVersionResultsOne(
    """the row to be inserted"""
    object: LatestPayrollVersionResultsInsertInput!
    """upsert condition"""
    onConflict: LatestPayrollVersionResultsOnConflict
  ): LatestPayrollVersionResults
  """
  insert data into the table: "leave"
  """
  insertLeave(
    """the rows to be inserted"""
    objects: [LeaveInsertInput!]!
    """upsert condition"""
    onConflict: LeaveOnConflict
  ): LeaveMutationResponse
  """
  insert a single row into the table: "leave"
  """
  insertLeaveOne(
    """the row to be inserted"""
    object: LeaveInsertInput!
    """upsert condition"""
    onConflict: LeaveOnConflict
  ): Leave
  """
  insert data into the table: "notes"
  """
  insertNotes(
    """the rows to be inserted"""
    objects: [NotesInsertInput!]!
    """upsert condition"""
    onConflict: NotesOnConflict
  ): NotesMutationResponse
  """
  insert a single row into the table: "notes"
  """
  insertNotesOne(
    """the row to be inserted"""
    object: NotesInsertInput!
    """upsert condition"""
    onConflict: NotesOnConflict
  ): Notes
  """
  insert data into the table: "payroll_activation_results"
  """
  insertPayrollActivationResults(
    """the rows to be inserted"""
    objects: [PayrollActivationResultsInsertInput!]!
    """upsert condition"""
    onConflict: PayrollActivationResultsOnConflict
  ): PayrollActivationResultsMutationResponse
  """
  insert a single row into the table: "payroll_activation_results"
  """
  insertPayrollActivationResultsOne(
    """the row to be inserted"""
    object: PayrollActivationResultsInsertInput!
    """upsert condition"""
    onConflict: PayrollActivationResultsOnConflict
  ): PayrollActivationResults
  """
  insert data into the table: "payroll_assignment_audit"
  """
  insertPayrollAssignmentAudit(
    """the rows to be inserted"""
    objects: [PayrollAssignmentAuditInsertInput!]!
    """upsert condition"""
    onConflict: PayrollAssignmentAuditOnConflict
  ): PayrollAssignmentAuditMutationResponse
  """
  insert a single row into the table: "payroll_assignment_audit"
  """
  insertPayrollAssignmentAuditOne(
    """the row to be inserted"""
    object: PayrollAssignmentAuditInsertInput!
    """upsert condition"""
    onConflict: PayrollAssignmentAuditOnConflict
  ): PayrollAssignmentAudit
  """
  insert data into the table: "payroll_assignments"
  """
  insertPayrollAssignments(
    """the rows to be inserted"""
    objects: [PayrollAssignmentsInsertInput!]!
    """upsert condition"""
    onConflict: PayrollAssignmentsOnConflict
  ): PayrollAssignmentsMutationResponse
  """
  insert a single row into the table: "payroll_assignments"
  """
  insertPayrollAssignmentsOne(
    """the row to be inserted"""
    object: PayrollAssignmentsInsertInput!
    """upsert condition"""
    onConflict: PayrollAssignmentsOnConflict
  ): PayrollAssignments
  """
  insert data into the table: "payroll_cycles"
  """
  insertPayrollCycles(
    """the rows to be inserted"""
    objects: [PayrollCyclesInsertInput!]!
    """upsert condition"""
    onConflict: PayrollCyclesOnConflict
  ): PayrollCyclesMutationResponse
  """
  insert a single row into the table: "payroll_cycles"
  """
  insertPayrollCyclesOne(
    """the row to be inserted"""
    object: PayrollCyclesInsertInput!
    """upsert condition"""
    onConflict: PayrollCyclesOnConflict
  ): PayrollCycles
  """
  insert data into the table: "payroll_date_types"
  """
  insertPayrollDateTypes(
    """the rows to be inserted"""
    objects: [PayrollDateTypesInsertInput!]!
    """upsert condition"""
    onConflict: PayrollDateTypesOnConflict
  ): PayrollDateTypesMutationResponse
  """
  insert a single row into the table: "payroll_date_types"
  """
  insertPayrollDateTypesOne(
    """the row to be inserted"""
    object: PayrollDateTypesInsertInput!
    """upsert condition"""
    onConflict: PayrollDateTypesOnConflict
  ): PayrollDateTypes
  """
  insert data into the table: "payroll_dates"
  """
  insertPayrollDates(
    """the rows to be inserted"""
    objects: [PayrollDatesInsertInput!]!
    """upsert condition"""
    onConflict: PayrollDatesOnConflict
  ): PayrollDatesMutationResponse
  """
  insert a single row into the table: "payroll_dates"
  """
  insertPayrollDatesOne(
    """the row to be inserted"""
    object: PayrollDatesInsertInput!
    """upsert condition"""
    onConflict: PayrollDatesOnConflict
  ): PayrollDates
  """
  insert data into the table: "payroll_required_skills"
  """
  insertPayrollRequiredSkills(
    """the rows to be inserted"""
    objects: [PayrollRequiredSkillsInsertInput!]!
  ): PayrollRequiredSkillsMutationResponse
  """
  insert a single row into the table: "payroll_required_skills"
  """
  insertPayrollRequiredSkillsOne(
    """the row to be inserted"""
    object: PayrollRequiredSkillsInsertInput!
  ): PayrollRequiredSkills
  """
  insert data into the table: "payroll_version_history_results"
  """
  insertPayrollVersionHistoryResults(
    """the rows to be inserted"""
    objects: [PayrollVersionHistoryResultsInsertInput!]!
    """upsert condition"""
    onConflict: PayrollVersionHistoryResultsOnConflict
  ): PayrollVersionHistoryResultsMutationResponse
  """
  insert a single row into the table: "payroll_version_history_results"
  """
  insertPayrollVersionHistoryResultsOne(
    """the row to be inserted"""
    object: PayrollVersionHistoryResultsInsertInput!
    """upsert condition"""
    onConflict: PayrollVersionHistoryResultsOnConflict
  ): PayrollVersionHistoryResults
  """
  insert data into the table: "payroll_version_results"
  """
  insertPayrollVersionResults(
    """the rows to be inserted"""
    objects: [PayrollVersionResultsInsertInput!]!
    """upsert condition"""
    onConflict: PayrollVersionResultsOnConflict
  ): PayrollVersionResultsMutationResponse
  """
  insert a single row into the table: "payroll_version_results"
  """
  insertPayrollVersionResultsOne(
    """the row to be inserted"""
    object: PayrollVersionResultsInsertInput!
    """upsert condition"""
    onConflict: PayrollVersionResultsOnConflict
  ): PayrollVersionResults
  """
  insert data into the table: "payrolls"
  """
  insertPayrolls(
    """the rows to be inserted"""
    objects: [PayrollsInsertInput!]!
    """upsert condition"""
    onConflict: PayrollsOnConflict
  ): PayrollsMutationResponse
  """
  insert a single row into the table: "payrolls"
  """
  insertPayrollsOne(
    """the row to be inserted"""
    object: PayrollsInsertInput!
    """upsert condition"""
    onConflict: PayrollsOnConflict
  ): Payrolls
  """
  insert data into the table: "permission_audit_log"
  """
  insertPermissionAuditLog(
    """the rows to be inserted"""
    objects: [PermissionAuditLogInsertInput!]!
    """upsert condition"""
    onConflict: PermissionAuditLogOnConflict
  ): PermissionAuditLogMutationResponse
  """
  insert a single row into the table: "permission_audit_log"
  """
  insertPermissionAuditLogOne(
    """the row to be inserted"""
    object: PermissionAuditLogInsertInput!
    """upsert condition"""
    onConflict: PermissionAuditLogOnConflict
  ): PermissionAuditLog
  """
  insert data into the table: "permission_overrides"
  """
  insertPermissionOverrides(
    """the rows to be inserted"""
    objects: [PermissionOverridesInsertInput!]!
    """upsert condition"""
    onConflict: PermissionOverridesOnConflict
  ): PermissionOverridesMutationResponse
  """
  insert a single row into the table: "permission_overrides"
  """
  insertPermissionOverridesOne(
    """the row to be inserted"""
    object: PermissionOverridesInsertInput!
    """upsert condition"""
    onConflict: PermissionOverridesOnConflict
  ): PermissionOverrides
  """
  insert data into the table: "permissions"
  """
  insertPermissions(
    """the rows to be inserted"""
    objects: [PermissionsInsertInput!]!
    """upsert condition"""
    onConflict: PermissionsOnConflict
  ): PermissionsMutationResponse
  """
  insert a single row into the table: "permissions"
  """
  insertPermissionsOne(
    """the row to be inserted"""
    object: PermissionsInsertInput!
    """upsert condition"""
    onConflict: PermissionsOnConflict
  ): Permissions
  """
  insert data into the table: "position_admin_defaults"
  """
  insertPositionAdminDefaults(
    """the rows to be inserted"""
    objects: [PositionAdminDefaultsInsertInput!]!
    """upsert condition"""
    onConflict: PositionAdminDefaultsOnConflict
  ): PositionAdminDefaultsMutationResponse
  """
  insert a single row into the table: "position_admin_defaults"
  """
  insertPositionAdminDefaultsOne(
    """the row to be inserted"""
    object: PositionAdminDefaultsInsertInput!
    """upsert condition"""
    onConflict: PositionAdminDefaultsOnConflict
  ): PositionAdminDefaults
  """
  insert data into the table: "quote_conversions"
  """
  insertQuoteConversions(
    """the rows to be inserted"""
    objects: [QuoteConversionsInsertInput!]!
    """upsert condition"""
    onConflict: QuoteConversionsOnConflict
  ): QuoteConversionsMutationResponse
  """
  insert a single row into the table: "quote_conversions"
  """
  insertQuoteConversionsOne(
    """the row to be inserted"""
    object: QuoteConversionsInsertInput!
    """upsert condition"""
    onConflict: QuoteConversionsOnConflict
  ): QuoteConversions
  """
  insert data into the table: "quote_line_items"
  """
  insertQuoteLineItems(
    """the rows to be inserted"""
    objects: [QuoteLineItemsInsertInput!]!
    """upsert condition"""
    onConflict: QuoteLineItemsOnConflict
  ): QuoteLineItemsMutationResponse
  """
  insert a single row into the table: "quote_line_items"
  """
  insertQuoteLineItemsOne(
    """the row to be inserted"""
    object: QuoteLineItemsInsertInput!
    """upsert condition"""
    onConflict: QuoteLineItemsOnConflict
  ): QuoteLineItems
  """
  insert data into the table: "quote_templates"
  """
  insertQuoteTemplates(
    """the rows to be inserted"""
    objects: [QuoteTemplatesInsertInput!]!
    """upsert condition"""
    onConflict: QuoteTemplatesOnConflict
  ): QuoteTemplatesMutationResponse
  """
  insert a single row into the table: "quote_templates"
  """
  insertQuoteTemplatesOne(
    """the row to be inserted"""
    object: QuoteTemplatesInsertInput!
    """upsert condition"""
    onConflict: QuoteTemplatesOnConflict
  ): QuoteTemplates
  """
  insert data into the table: "quotes"
  """
  insertQuotes(
    """the rows to be inserted"""
    objects: [QuotesInsertInput!]!
    """upsert condition"""
    onConflict: QuotesOnConflict
  ): QuotesMutationResponse
  """
  insert a single row into the table: "quotes"
  """
  insertQuotesOne(
    """the row to be inserted"""
    object: QuotesInsertInput!
    """upsert condition"""
    onConflict: QuotesOnConflict
  ): Quotes
  """
  insert data into the table: "rate_limits"
  """
  insertRateLimits(
    """the rows to be inserted"""
    objects: [RateLimitsInsertInput!]!
    """upsert condition"""
    onConflict: RateLimitsOnConflict
  ): RateLimitsMutationResponse
  """
  insert a single row into the table: "rate_limits"
  """
  insertRateLimitsOne(
    """the row to be inserted"""
    object: RateLimitsInsertInput!
    """upsert condition"""
    onConflict: RateLimitsOnConflict
  ): RateLimits
  """
  insert data into the table: "resources"
  """
  insertResources(
    """the rows to be inserted"""
    objects: [ResourcesInsertInput!]!
    """upsert condition"""
    onConflict: ResourcesOnConflict
  ): ResourcesMutationResponse
  """
  insert a single row into the table: "resources"
  """
  insertResourcesOne(
    """the row to be inserted"""
    object: ResourcesInsertInput!
    """upsert condition"""
    onConflict: ResourcesOnConflict
  ): Resources
  """
  insert data into the table: "role_permissions"
  """
  insertRolePermissions(
    """the rows to be inserted"""
    objects: [RolePermissionsInsertInput!]!
    """upsert condition"""
    onConflict: RolePermissionsOnConflict
  ): RolePermissionsMutationResponse
  """
  insert a single row into the table: "role_permissions"
  """
  insertRolePermissionsOne(
    """the row to be inserted"""
    object: RolePermissionsInsertInput!
    """upsert condition"""
    onConflict: RolePermissionsOnConflict
  ): RolePermissions
  """
  insert data into the table: "roles"
  """
  insertRoles(
    """the rows to be inserted"""
    objects: [RolesInsertInput!]!
    """upsert condition"""
    onConflict: RolesOnConflict
  ): RolesMutationResponse
  """
  insert a single row into the table: "roles"
  """
  insertRolesOne(
    """the row to be inserted"""
    object: RolesInsertInput!
    """upsert condition"""
    onConflict: RolesOnConflict
  ): Roles
  """
  insert data into the table: "security_alerts"
  """
  insertSecurityAlerts(
    """the rows to be inserted"""
    objects: [SecurityAlertsInsertInput!]!
    """upsert condition"""
    onConflict: SecurityAlertsOnConflict
  ): SecurityAlertsMutationResponse
  """
  insert a single row into the table: "security_alerts"
  """
  insertSecurityAlertsOne(
    """the row to be inserted"""
    object: SecurityAlertsInsertInput!
    """upsert condition"""
    onConflict: SecurityAlertsOnConflict
  ): SecurityAlerts
  """
  insert data into the table: "security_settings"
  """
  insertSecuritySettings(
    """the rows to be inserted"""
    objects: [SecuritySettingsInsertInput!]!
    """upsert condition"""
    onConflict: SecuritySettingsOnConflict
  ): SecuritySettingsMutationResponse
  """
  insert a single row into the table: "security_settings"
  """
  insertSecuritySettingsOne(
    """the row to be inserted"""
    object: SecuritySettingsInsertInput!
    """upsert condition"""
    onConflict: SecuritySettingsOnConflict
  ): SecuritySettings
  """
  insert data into the table: "service_pricing_rules"
  """
  insertServicePricingRules(
    """the rows to be inserted"""
    objects: [ServicePricingRulesInsertInput!]!
    """upsert condition"""
    onConflict: ServicePricingRulesOnConflict
  ): ServicePricingRulesMutationResponse
  """
  insert a single row into the table: "service_pricing_rules"
  """
  insertServicePricingRulesOne(
    """the row to be inserted"""
    object: ServicePricingRulesInsertInput!
    """upsert condition"""
    onConflict: ServicePricingRulesOnConflict
  ): ServicePricingRules
  """
  insert data into the table: "service_templates"
  """
  insertServiceTemplates(
    """the rows to be inserted"""
    objects: [ServiceTemplatesInsertInput!]!
    """upsert condition"""
    onConflict: ServiceTemplatesOnConflict
  ): ServiceTemplatesMutationResponse
  """
  insert a single row into the table: "service_templates"
  """
  insertServiceTemplatesOne(
    """the row to be inserted"""
    object: ServiceTemplatesInsertInput!
    """upsert condition"""
    onConflict: ServiceTemplatesOnConflict
  ): ServiceTemplates
  """
  insert data into the table: "services"
  """
  insertServices(
    """the rows to be inserted"""
    objects: [ServicesInsertInput!]!
    """upsert condition"""
    onConflict: ServicesOnConflict
  ): ServicesMutationResponse
  """
  insert a single row into the table: "services"
  """
  insertServicesOne(
    """the row to be inserted"""
    object: ServicesInsertInput!
    """upsert condition"""
    onConflict: ServicesOnConflict
  ): Services
  """
  insert data into the table: "system_configuration"
  """
  insertSystemConfiguration(
    """the rows to be inserted"""
    objects: [SystemConfigurationInsertInput!]!
    """upsert condition"""
    onConflict: SystemConfigurationOnConflict
  ): SystemConfigurationMutationResponse
  """
  insert a single row into the table: "system_configuration"
  """
  insertSystemConfigurationOne(
    """the row to be inserted"""
    object: SystemConfigurationInsertInput!
    """upsert condition"""
    onConflict: SystemConfigurationOnConflict
  ): SystemConfiguration
  """
  insert data into the table: "system_health"
  """
  insertSystemHealth(
    """the rows to be inserted"""
    objects: [SystemHealthInsertInput!]!
    """upsert condition"""
    onConflict: SystemHealthOnConflict
  ): SystemHealthMutationResponse
  """
  insert a single row into the table: "system_health"
  """
  insertSystemHealthOne(
    """the row to be inserted"""
    object: SystemHealthInsertInput!
    """upsert condition"""
    onConflict: SystemHealthOnConflict
  ): SystemHealth
  """
  insert data into the table: "time_entries"
  """
  insertTimeEntries(
    """the rows to be inserted"""
    objects: [TimeEntriesInsertInput!]!
    """upsert condition"""
    onConflict: TimeEntriesOnConflict
  ): TimeEntriesMutationResponse
  """
  insert a single row into the table: "time_entries"
  """
  insertTimeEntriesOne(
    """the row to be inserted"""
    object: TimeEntriesInsertInput!
    """upsert condition"""
    onConflict: TimeEntriesOnConflict
  ): TimeEntries
  """
  insert data into the table: "user_email_template_favorites"
  """
  insertUserEmailTemplateFavorites(
    """the rows to be inserted"""
    objects: [UserEmailTemplateFavoritesInsertInput!]!
    """upsert condition"""
    onConflict: UserEmailTemplateFavoritesOnConflict
  ): UserEmailTemplateFavoritesMutationResponse
  """
  insert a single row into the table: "user_email_template_favorites"
  """
  insertUserEmailTemplateFavoritesOne(
    """the row to be inserted"""
    object: UserEmailTemplateFavoritesInsertInput!
    """upsert condition"""
    onConflict: UserEmailTemplateFavoritesOnConflict
  ): UserEmailTemplateFavorites
  """
  insert data into the table: "user_invitations"
  """
  insertUserInvitations(
    """the rows to be inserted"""
    objects: [UserInvitationsInsertInput!]!
    """upsert condition"""
    onConflict: UserInvitationsOnConflict
  ): UserInvitationsMutationResponse
  """
  insert a single row into the table: "user_invitations"
  """
  insertUserInvitationsOne(
    """the row to be inserted"""
    object: UserInvitationsInsertInput!
    """upsert condition"""
    onConflict: UserInvitationsOnConflict
  ): UserInvitations
  """
  insert data into the table: "user_roles"
  """
  insertUserRoles(
    """the rows to be inserted"""
    objects: [UserRolesInsertInput!]!
    """upsert condition"""
    onConflict: UserRolesOnConflict
  ): UserRolesMutationResponse
  """
  insert a single row into the table: "user_roles"
  """
  insertUserRolesOne(
    """the row to be inserted"""
    object: UserRolesInsertInput!
    """upsert condition"""
    onConflict: UserRolesOnConflict
  ): UserRoles
  """
  insert data into the table: "user_sessions"
  """
  insertUserSessions(
    """the rows to be inserted"""
    objects: [UserSessionsInsertInput!]!
    """upsert condition"""
    onConflict: UserSessionsOnConflict
  ): UserSessionsMutationResponse
  """
  insert a single row into the table: "user_sessions"
  """
  insertUserSessionsOne(
    """the row to be inserted"""
    object: UserSessionsInsertInput!
    """upsert condition"""
    onConflict: UserSessionsOnConflict
  ): UserSessions
  """
  insert data into the table: "user_skills"
  """
  insertUserSkills(
    """the rows to be inserted"""
    objects: [UserSkillsInsertInput!]!
  ): UserSkillsMutationResponse
  """
  insert a single row into the table: "user_skills"
  """
  insertUserSkillsOne(
    """the row to be inserted"""
    object: UserSkillsInsertInput!
  ): UserSkills
  """
  insert data into the table: "users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [UsersInsertInput!]!
    """upsert condition"""
    onConflict: UsersOnConflict
  ): UsersMutationResponse
  """
  insert a single row into the table: "users"
  """
  insertUsersOne(
    """the row to be inserted"""
    object: UsersInsertInput!
    """upsert condition"""
    onConflict: UsersOnConflict
  ): Users
  """
  insert data into the table: "users_role_backup"
  """
  insertUsersRoleBackup(
    """the rows to be inserted"""
    objects: [UsersRoleBackupInsertInput!]!
  ): UsersRoleBackupMutationResponse
  """
  insert a single row into the table: "users_role_backup"
  """
  insertUsersRoleBackupOne(
    """the row to be inserted"""
    object: UsersRoleBackupInsertInput!
  ): UsersRoleBackup
  """
  insert data into the table: "work_schedule"
  """
  insertWorkSchedule(
    """the rows to be inserted"""
    objects: [WorkScheduleInsertInput!]!
    """upsert condition"""
    onConflict: WorkScheduleOnConflict
  ): WorkScheduleMutationResponse
  """
  insert a single row into the table: "work_schedule"
  """
  insertWorkScheduleOne(
    """the row to be inserted"""
    object: WorkScheduleInsertInput!
    """upsert condition"""
    onConflict: WorkScheduleOnConflict
  ): WorkSchedule
  """
  update data of the table: "adjustment_rules"
  """
  updateAdjustmentRules(
    """sets the columns of the filtered rows to the given values"""
    _set: AdjustmentRulesSetInput
    """filter the rows which have to be updated"""
    where: AdjustmentRulesBoolExp!
  ): AdjustmentRulesMutationResponse
  """
  update single row of the table: "adjustment_rules"
  """
  updateAdjustmentRulesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AdjustmentRulesSetInput
    pkColumns: AdjustmentRulesPkColumnsInput!
  ): AdjustmentRules
  """
  update multiples rows of table: "adjustment_rules"
  """
  updateAdjustmentRulesMany(
    """updates to execute, in order"""
    updates: [AdjustmentRulesUpdates!]!
  ): [AdjustmentRulesMutationResponse]
  """
  update data of the table: "app_settings"
  """
  updateAppSettings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AppSettingsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AppSettingsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AppSettingsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AppSettingsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AppSettingsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AppSettingsSetInput
    """filter the rows which have to be updated"""
    where: AppSettingsBoolExp!
  ): AppSettingsMutationResponse
  """
  update single row of the table: "app_settings"
  """
  updateAppSettingsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AppSettingsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AppSettingsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AppSettingsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AppSettingsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AppSettingsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AppSettingsSetInput
    pkColumns: AppSettingsPkColumnsInput!
  ): AppSettings
  """
  update multiples rows of table: "app_settings"
  """
  updateAppSettingsMany(
    """updates to execute, in order"""
    updates: [AppSettingsUpdates!]!
  ): [AppSettingsMutationResponse]
  """
  update data of the table: "audit.audit_log"
  """
  updateAuditAuditLog(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditAuditLogAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditAuditLogDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditAuditLogDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditAuditLogDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditAuditLogPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditAuditLogSetInput
    """filter the rows which have to be updated"""
    where: AuditAuditLogBoolExp!
  ): AuditAuditLogMutationResponse
  """
  update single row of the table: "audit.audit_log"
  """
  updateAuditAuditLogByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditAuditLogAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditAuditLogDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditAuditLogDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditAuditLogDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditAuditLogPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditAuditLogSetInput
    pkColumns: AuditAuditLogPkColumnsInput!
  ): AuditAuditLog
  """
  update multiples rows of table: "audit.audit_log"
  """
  updateAuditAuditLogMany(
    """updates to execute, in order"""
    updates: [AuditAuditLogUpdates!]!
  ): [AuditAuditLogMutationResponse]
  """
  update data of the table: "audit.auth_events"
  """
  updateAuditAuthEvents(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditAuthEventsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditAuthEventsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditAuthEventsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditAuthEventsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditAuthEventsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditAuthEventsSetInput
    """filter the rows which have to be updated"""
    where: AuditAuthEventsBoolExp!
  ): AuditAuthEventsMutationResponse
  """
  update single row of the table: "audit.auth_events"
  """
  updateAuditAuthEventsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditAuthEventsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditAuthEventsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditAuthEventsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditAuthEventsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditAuthEventsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditAuthEventsSetInput
    pkColumns: AuditAuthEventsPkColumnsInput!
  ): AuditAuthEvents
  """
  update multiples rows of table: "audit.auth_events"
  """
  updateAuditAuthEventsMany(
    """updates to execute, in order"""
    updates: [AuditAuthEventsUpdates!]!
  ): [AuditAuthEventsMutationResponse]
  """
  update data of the table: "audit.data_access_log"
  """
  updateAuditDataAccessLog(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditDataAccessLogAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditDataAccessLogDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditDataAccessLogDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditDataAccessLogDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: AuditDataAccessLogIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditDataAccessLogPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditDataAccessLogSetInput
    """filter the rows which have to be updated"""
    where: AuditDataAccessLogBoolExp!
  ): AuditDataAccessLogMutationResponse
  """
  update single row of the table: "audit.data_access_log"
  """
  updateAuditDataAccessLogByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditDataAccessLogAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditDataAccessLogDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditDataAccessLogDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditDataAccessLogDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: AuditDataAccessLogIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditDataAccessLogPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditDataAccessLogSetInput
    pkColumns: AuditDataAccessLogPkColumnsInput!
  ): AuditDataAccessLog
  """
  update multiples rows of table: "audit.data_access_log"
  """
  updateAuditDataAccessLogMany(
    """updates to execute, in order"""
    updates: [AuditDataAccessLogUpdates!]!
  ): [AuditDataAccessLogMutationResponse]
  """
  update data of the table: "audit.permission_changes"
  """
  updateAuditPermissionChanges(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditPermissionChangesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditPermissionChangesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditPermissionChangesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditPermissionChangesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditPermissionChangesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditPermissionChangesSetInput
    """filter the rows which have to be updated"""
    where: AuditPermissionChangesBoolExp!
  ): AuditPermissionChangesMutationResponse
  """
  update single row of the table: "audit.permission_changes"
  """
  updateAuditPermissionChangesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: AuditPermissionChangesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: AuditPermissionChangesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: AuditPermissionChangesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: AuditPermissionChangesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: AuditPermissionChangesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: AuditPermissionChangesSetInput
    pkColumns: AuditPermissionChangesPkColumnsInput!
  ): AuditPermissionChanges
  """
  update multiples rows of table: "audit.permission_changes"
  """
  updateAuditPermissionChangesMany(
    """updates to execute, in order"""
    updates: [AuditPermissionChangesUpdates!]!
  ): [AuditPermissionChangesMutationResponse]
  """
  update data of the table: "audit.slow_queries"
  """
  updateAuditSlowQueries(
    """sets the columns of the filtered rows to the given values"""
    _set: AuditSlowQueriesSetInput
    """filter the rows which have to be updated"""
    where: AuditSlowQueriesBoolExp!
  ): AuditSlowQueriesMutationResponse
  """
  update single row of the table: "audit.slow_queries"
  """
  updateAuditSlowQueriesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: AuditSlowQueriesSetInput
    pkColumns: AuditSlowQueriesPkColumnsInput!
  ): AuditSlowQueries
  """
  update multiples rows of table: "audit.slow_queries"
  """
  updateAuditSlowQueriesMany(
    """updates to execute, in order"""
    updates: [AuditSlowQueriesUpdates!]!
  ): [AuditSlowQueriesMutationResponse]
  """
  update data of the table: "audit.user_access_summary"
  """
  updateAuditUserAccessSummary(
    """sets the columns of the filtered rows to the given values"""
    _set: AuditUserAccessSummarySetInput
    """filter the rows which have to be updated"""
    where: AuditUserAccessSummaryBoolExp!
  ): AuditUserAccessSummaryMutationResponse
  """
  update multiples rows of table: "audit.user_access_summary"
  """
  updateAuditUserAccessSummaryMany(
    """updates to execute, in order"""
    updates: [AuditUserAccessSummaryUpdates!]!
  ): [AuditUserAccessSummaryMutationResponse]
  """
  update data of the table: "billing_event_log"
  """
  updateBillingEventLog(
    """sets the columns of the filtered rows to the given values"""
    _set: BillingEventLogSetInput
    """filter the rows which have to be updated"""
    where: BillingEventLogBoolExp!
  ): BillingEventLogMutationResponse
  """
  update single row of the table: "billing_event_log"
  """
  updateBillingEventLogByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: BillingEventLogSetInput
    pkColumns: BillingEventLogPkColumnsInput!
  ): BillingEventLog
  """
  update multiples rows of table: "billing_event_log"
  """
  updateBillingEventLogMany(
    """updates to execute, in order"""
    updates: [BillingEventLogUpdates!]!
  ): [BillingEventLogMutationResponse]
  """
  update data of the table: "billing_invoice"
  """
  updateBillingInvoice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BillingInvoiceIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: BillingInvoiceSetInput
    """filter the rows which have to be updated"""
    where: BillingInvoiceBoolExp!
  ): BillingInvoiceMutationResponse
  """
  update single row of the table: "billing_invoice"
  """
  updateBillingInvoiceByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BillingInvoiceIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: BillingInvoiceSetInput
    pkColumns: BillingInvoicePkColumnsInput!
  ): BillingInvoice
  """
  update data of the table: "billing_invoice_item"
  """
  updateBillingInvoiceItem(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BillingInvoiceItemIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: BillingInvoiceItemSetInput
    """filter the rows which have to be updated"""
    where: BillingInvoiceItemBoolExp!
  ): BillingInvoiceItemMutationResponse
  """
  update single row of the table: "billing_invoice_item"
  """
  updateBillingInvoiceItemByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BillingInvoiceItemIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: BillingInvoiceItemSetInput
    pkColumns: BillingInvoiceItemPkColumnsInput!
  ): BillingInvoiceItem
  """
  update multiples rows of table: "billing_invoice_item"
  """
  updateBillingInvoiceItemMany(
    """updates to execute, in order"""
    updates: [BillingInvoiceItemUpdates!]!
  ): [BillingInvoiceItemMutationResponse]
  """
  update multiples rows of table: "billing_invoice"
  """
  updateBillingInvoiceMany(
    """updates to execute, in order"""
    updates: [BillingInvoiceUpdates!]!
  ): [BillingInvoiceMutationResponse]
  """
  update data of the table: "billing_items"
  """
  updateBillingItems(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BillingItemsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: BillingItemsSetInput
    """filter the rows which have to be updated"""
    where: BillingItemsBoolExp!
  ): BillingItemsMutationResponse
  """
  update single row of the table: "billing_items"
  """
  updateBillingItemsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: BillingItemsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: BillingItemsSetInput
    pkColumns: BillingItemsPkColumnsInput!
  ): BillingItems
  """
  update multiples rows of table: "billing_items"
  """
  updateBillingItemsMany(
    """updates to execute, in order"""
    updates: [BillingItemsUpdates!]!
  ): [BillingItemsMutationResponse]
  """
  update data of the table: "billing_periods"
  """
  updateBillingPeriods(
    """sets the columns of the filtered rows to the given values"""
    _set: BillingPeriodsSetInput
    """filter the rows which have to be updated"""
    where: BillingPeriodsBoolExp!
  ): BillingPeriodsMutationResponse
  """
  update single row of the table: "billing_periods"
  """
  updateBillingPeriodsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: BillingPeriodsSetInput
    pkColumns: BillingPeriodsPkColumnsInput!
  ): BillingPeriods
  """
  update multiples rows of table: "billing_periods"
  """
  updateBillingPeriodsMany(
    """updates to execute, in order"""
    updates: [BillingPeriodsUpdates!]!
  ): [BillingPeriodsMutationResponse]
  """
  update data of the table: "client_external_systems"
  """
  updateClientExternalSystems(
    """sets the columns of the filtered rows to the given values"""
    _set: ClientExternalSystemsSetInput
    """filter the rows which have to be updated"""
    where: ClientExternalSystemsBoolExp!
  ): ClientExternalSystemsMutationResponse
  """
  update single row of the table: "client_external_systems"
  """
  updateClientExternalSystemsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ClientExternalSystemsSetInput
    pkColumns: ClientExternalSystemsPkColumnsInput!
  ): ClientExternalSystems
  """
  update multiples rows of table: "client_external_systems"
  """
  updateClientExternalSystemsMany(
    """updates to execute, in order"""
    updates: [ClientExternalSystemsUpdates!]!
  ): [ClientExternalSystemsMutationResponse]
  """
  update data of the table: "client_service_agreements"
  """
  updateClientServiceAgreements(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ClientServiceAgreementsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ClientServiceAgreementsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ClientServiceAgreementsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ClientServiceAgreementsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ClientServiceAgreementsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ClientServiceAgreementsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ClientServiceAgreementsSetInput
    """filter the rows which have to be updated"""
    where: ClientServiceAgreementsBoolExp!
  ): ClientServiceAgreementsMutationResponse
  """
  update single row of the table: "client_service_agreements"
  """
  updateClientServiceAgreementsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ClientServiceAgreementsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ClientServiceAgreementsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ClientServiceAgreementsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ClientServiceAgreementsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ClientServiceAgreementsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ClientServiceAgreementsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ClientServiceAgreementsSetInput
    pkColumns: ClientServiceAgreementsPkColumnsInput!
  ): ClientServiceAgreements
  """
  update multiples rows of table: "client_service_agreements"
  """
  updateClientServiceAgreementsMany(
    """updates to execute, in order"""
    updates: [ClientServiceAgreementsUpdates!]!
  ): [ClientServiceAgreementsMutationResponse]
  """
  update data of the table: "clients"
  """
  updateClients(
    """sets the columns of the filtered rows to the given values"""
    _set: ClientsSetInput
    """filter the rows which have to be updated"""
    where: ClientsBoolExp!
  ): ClientsMutationResponse
  """
  update single row of the table: "clients"
  """
  updateClientsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ClientsSetInput
    pkColumns: ClientsPkColumnsInput!
  ): Clients
  """
  update multiples rows of table: "clients"
  """
  updateClientsMany(
    """updates to execute, in order"""
    updates: [ClientsUpdates!]!
  ): [ClientsMutationResponse]
  """
  update data of the table: "data_backups"
  """
  updateDataBackups(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: DataBackupsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: DataBackupsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: DataBackupsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: DataBackupsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: DataBackupsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: DataBackupsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: DataBackupsSetInput
    """filter the rows which have to be updated"""
    where: DataBackupsBoolExp!
  ): DataBackupsMutationResponse
  """
  update single row of the table: "data_backups"
  """
  updateDataBackupsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: DataBackupsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: DataBackupsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: DataBackupsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: DataBackupsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: DataBackupsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: DataBackupsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: DataBackupsSetInput
    pkColumns: DataBackupsPkColumnsInput!
  ): DataBackups
  """
  update multiples rows of table: "data_backups"
  """
  updateDataBackupsMany(
    """updates to execute, in order"""
    updates: [DataBackupsUpdates!]!
  ): [DataBackupsMutationResponse]
  """
  update data of the table: "email_drafts"
  """
  updateEmailDrafts(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EmailDraftsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EmailDraftsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EmailDraftsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EmailDraftsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EmailDraftsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: EmailDraftsSetInput
    """filter the rows which have to be updated"""
    where: EmailDraftsBoolExp!
  ): EmailDraftsMutationResponse
  """
  update single row of the table: "email_drafts"
  """
  updateEmailDraftsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EmailDraftsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EmailDraftsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EmailDraftsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EmailDraftsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EmailDraftsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: EmailDraftsSetInput
    pkColumns: EmailDraftsPkColumnsInput!
  ): EmailDrafts
  """
  update multiples rows of table: "email_drafts"
  """
  updateEmailDraftsMany(
    """updates to execute, in order"""
    updates: [EmailDraftsUpdates!]!
  ): [EmailDraftsMutationResponse]
  """
  update data of the table: "email_send_logs"
  """
  updateEmailSendLogs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EmailSendLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EmailSendLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EmailSendLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EmailSendLogsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EmailSendLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: EmailSendLogsSetInput
    """filter the rows which have to be updated"""
    where: EmailSendLogsBoolExp!
  ): EmailSendLogsMutationResponse
  """
  update single row of the table: "email_send_logs"
  """
  updateEmailSendLogsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EmailSendLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EmailSendLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EmailSendLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EmailSendLogsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EmailSendLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: EmailSendLogsSetInput
    pkColumns: EmailSendLogsPkColumnsInput!
  ): EmailSendLogs
  """
  update multiples rows of table: "email_send_logs"
  """
  updateEmailSendLogsMany(
    """updates to execute, in order"""
    updates: [EmailSendLogsUpdates!]!
  ): [EmailSendLogsMutationResponse]
  """
  update data of the table: "email_templates"
  """
  updateEmailTemplates(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EmailTemplatesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EmailTemplatesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EmailTemplatesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EmailTemplatesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EmailTemplatesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: EmailTemplatesSetInput
    """filter the rows which have to be updated"""
    where: EmailTemplatesBoolExp!
  ): EmailTemplatesMutationResponse
  """
  update single row of the table: "email_templates"
  """
  updateEmailTemplatesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: EmailTemplatesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: EmailTemplatesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: EmailTemplatesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: EmailTemplatesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: EmailTemplatesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: EmailTemplatesSetInput
    pkColumns: EmailTemplatesPkColumnsInput!
  ): EmailTemplates
  """
  update multiples rows of table: "email_templates"
  """
  updateEmailTemplatesMany(
    """updates to execute, in order"""
    updates: [EmailTemplatesUpdates!]!
  ): [EmailTemplatesMutationResponse]
  """
  update data of the table: "external_systems"
  """
  updateExternalSystems(
    """sets the columns of the filtered rows to the given values"""
    _set: ExternalSystemsSetInput
    """filter the rows which have to be updated"""
    where: ExternalSystemsBoolExp!
  ): ExternalSystemsMutationResponse
  """
  update single row of the table: "external_systems"
  """
  updateExternalSystemsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ExternalSystemsSetInput
    pkColumns: ExternalSystemsPkColumnsInput!
  ): ExternalSystems
  """
  update multiples rows of table: "external_systems"
  """
  updateExternalSystemsMany(
    """updates to execute, in order"""
    updates: [ExternalSystemsUpdates!]!
  ): [ExternalSystemsMutationResponse]
  """
  update data of the table: "feature_flags"
  """
  updateFeatureFlags(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: FeatureFlagsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: FeatureFlagsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: FeatureFlagsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: FeatureFlagsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: FeatureFlagsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: FeatureFlagsSetInput
    """filter the rows which have to be updated"""
    where: FeatureFlagsBoolExp!
  ): FeatureFlagsMutationResponse
  """
  update single row of the table: "feature_flags"
  """
  updateFeatureFlagsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: FeatureFlagsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: FeatureFlagsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: FeatureFlagsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: FeatureFlagsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: FeatureFlagsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: FeatureFlagsSetInput
    pkColumns: FeatureFlagsPkColumnsInput!
  ): FeatureFlags
  """
  update multiples rows of table: "feature_flags"
  """
  updateFeatureFlagsMany(
    """updates to execute, in order"""
    updates: [FeatureFlagsUpdates!]!
  ): [FeatureFlagsMutationResponse]
  """
  update data of the table: "files"
  """
  updateFiles(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: FilesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: FilesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: FilesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: FilesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: FilesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: FilesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: FilesSetInput
    """filter the rows which have to be updated"""
    where: FilesBoolExp!
  ): FilesMutationResponse
  """
  update single row of the table: "files"
  """
  updateFilesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: FilesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: FilesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: FilesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: FilesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: FilesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: FilesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: FilesSetInput
    pkColumns: FilesPkColumnsInput!
  ): Files
  """
  update multiples rows of table: "files"
  """
  updateFilesMany(
    """updates to execute, in order"""
    updates: [FilesUpdates!]!
  ): [FilesMutationResponse]
  """
  update data of the table: "holidays"
  """
  updateHolidays(
    """increments the numeric columns with given value of the filtered values"""
    _inc: HolidaysIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: HolidaysSetInput
    """filter the rows which have to be updated"""
    where: HolidaysBoolExp!
  ): HolidaysMutationResponse
  """
  update single row of the table: "holidays"
  """
  updateHolidaysByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: HolidaysIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: HolidaysSetInput
    pkColumns: HolidaysPkColumnsInput!
  ): Holidays
  """
  update multiples rows of table: "holidays"
  """
  updateHolidaysMany(
    """updates to execute, in order"""
    updates: [HolidaysUpdates!]!
  ): [HolidaysMutationResponse]
  """
  update data of the table: "latest_payroll_version_results"
  """
  updateLatestPayrollVersionResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: LatestPayrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: LatestPayrollVersionResultsSetInput
    """filter the rows which have to be updated"""
    where: LatestPayrollVersionResultsBoolExp!
  ): LatestPayrollVersionResultsMutationResponse
  """
  update single row of the table: "latest_payroll_version_results"
  """
  updateLatestPayrollVersionResultsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: LatestPayrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: LatestPayrollVersionResultsSetInput
    pkColumns: LatestPayrollVersionResultsPkColumnsInput!
  ): LatestPayrollVersionResults
  """
  update multiples rows of table: "latest_payroll_version_results"
  """
  updateLatestPayrollVersionResultsMany(
    """updates to execute, in order"""
    updates: [LatestPayrollVersionResultsUpdates!]!
  ): [LatestPayrollVersionResultsMutationResponse]
  """
  update data of the table: "leave"
  """
  updateLeave(
    """sets the columns of the filtered rows to the given values"""
    _set: LeaveSetInput
    """filter the rows which have to be updated"""
    where: LeaveBoolExp!
  ): LeaveMutationResponse
  """
  update single row of the table: "leave"
  """
  updateLeaveByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: LeaveSetInput
    pkColumns: LeavePkColumnsInput!
  ): Leave
  """
  update multiples rows of table: "leave"
  """
  updateLeaveMany(
    """updates to execute, in order"""
    updates: [LeaveUpdates!]!
  ): [LeaveMutationResponse]
  """
  update data of the table: "notes"
  """
  updateNotes(
    """sets the columns of the filtered rows to the given values"""
    _set: NotesSetInput
    """filter the rows which have to be updated"""
    where: NotesBoolExp!
  ): NotesMutationResponse
  """
  update single row of the table: "notes"
  """
  updateNotesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: NotesSetInput
    pkColumns: NotesPkColumnsInput!
  ): Notes
  """
  update multiples rows of table: "notes"
  """
  updateNotesMany(
    """updates to execute, in order"""
    updates: [NotesUpdates!]!
  ): [NotesMutationResponse]
  """
  update data of the table: "payroll_activation_results"
  """
  updatePayrollActivationResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollActivationResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollActivationResultsSetInput
    """filter the rows which have to be updated"""
    where: PayrollActivationResultsBoolExp!
  ): PayrollActivationResultsMutationResponse
  """
  update single row of the table: "payroll_activation_results"
  """
  updatePayrollActivationResultsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollActivationResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollActivationResultsSetInput
    pkColumns: PayrollActivationResultsPkColumnsInput!
  ): PayrollActivationResults
  """
  update multiples rows of table: "payroll_activation_results"
  """
  updatePayrollActivationResultsMany(
    """updates to execute, in order"""
    updates: [PayrollActivationResultsUpdates!]!
  ): [PayrollActivationResultsMutationResponse]
  """
  update data of the table: "payroll_assignment_audit"
  """
  updatePayrollAssignmentAudit(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollAssignmentAuditSetInput
    """filter the rows which have to be updated"""
    where: PayrollAssignmentAuditBoolExp!
  ): PayrollAssignmentAuditMutationResponse
  """
  update single row of the table: "payroll_assignment_audit"
  """
  updatePayrollAssignmentAuditByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollAssignmentAuditSetInput
    pkColumns: PayrollAssignmentAuditPkColumnsInput!
  ): PayrollAssignmentAudit
  """
  update multiples rows of table: "payroll_assignment_audit"
  """
  updatePayrollAssignmentAuditMany(
    """updates to execute, in order"""
    updates: [PayrollAssignmentAuditUpdates!]!
  ): [PayrollAssignmentAuditMutationResponse]
  """
  update data of the table: "payroll_assignments"
  """
  updatePayrollAssignments(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollAssignmentsSetInput
    """filter the rows which have to be updated"""
    where: PayrollAssignmentsBoolExp!
  ): PayrollAssignmentsMutationResponse
  """
  update single row of the table: "payroll_assignments"
  """
  updatePayrollAssignmentsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollAssignmentsSetInput
    pkColumns: PayrollAssignmentsPkColumnsInput!
  ): PayrollAssignments
  """
  update multiples rows of table: "payroll_assignments"
  """
  updatePayrollAssignmentsMany(
    """updates to execute, in order"""
    updates: [PayrollAssignmentsUpdates!]!
  ): [PayrollAssignmentsMutationResponse]
  """
  update data of the table: "payroll_cycles"
  """
  updatePayrollCycles(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollCyclesSetInput
    """filter the rows which have to be updated"""
    where: PayrollCyclesBoolExp!
  ): PayrollCyclesMutationResponse
  """
  update single row of the table: "payroll_cycles"
  """
  updatePayrollCyclesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollCyclesSetInput
    pkColumns: PayrollCyclesPkColumnsInput!
  ): PayrollCycles
  """
  update multiples rows of table: "payroll_cycles"
  """
  updatePayrollCyclesMany(
    """updates to execute, in order"""
    updates: [PayrollCyclesUpdates!]!
  ): [PayrollCyclesMutationResponse]
  """
  update data of the table: "payroll_date_types"
  """
  updatePayrollDateTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollDateTypesSetInput
    """filter the rows which have to be updated"""
    where: PayrollDateTypesBoolExp!
  ): PayrollDateTypesMutationResponse
  """
  update single row of the table: "payroll_date_types"
  """
  updatePayrollDateTypesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollDateTypesSetInput
    pkColumns: PayrollDateTypesPkColumnsInput!
  ): PayrollDateTypes
  """
  update multiples rows of table: "payroll_date_types"
  """
  updatePayrollDateTypesMany(
    """updates to execute, in order"""
    updates: [PayrollDateTypesUpdates!]!
  ): [PayrollDateTypesMutationResponse]
  """
  update data of the table: "payroll_dates"
  """
  updatePayrollDates(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollDatesSetInput
    """filter the rows which have to be updated"""
    where: PayrollDatesBoolExp!
  ): PayrollDatesMutationResponse
  """
  update single row of the table: "payroll_dates"
  """
  updatePayrollDatesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollDatesSetInput
    pkColumns: PayrollDatesPkColumnsInput!
  ): PayrollDates
  """
  update multiples rows of table: "payroll_dates"
  """
  updatePayrollDatesMany(
    """updates to execute, in order"""
    updates: [PayrollDatesUpdates!]!
  ): [PayrollDatesMutationResponse]
  """
  update data of the table: "payroll_required_skills"
  """
  updatePayrollRequiredSkills(
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollRequiredSkillsSetInput
    """filter the rows which have to be updated"""
    where: PayrollRequiredSkillsBoolExp!
  ): PayrollRequiredSkillsMutationResponse
  """
  update multiples rows of table: "payroll_required_skills"
  """
  updatePayrollRequiredSkillsMany(
    """updates to execute, in order"""
    updates: [PayrollRequiredSkillsUpdates!]!
  ): [PayrollRequiredSkillsMutationResponse]
  """
  update data of the table: "payroll_version_history_results"
  """
  updatePayrollVersionHistoryResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollVersionHistoryResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollVersionHistoryResultsSetInput
    """filter the rows which have to be updated"""
    where: PayrollVersionHistoryResultsBoolExp!
  ): PayrollVersionHistoryResultsMutationResponse
  """
  update single row of the table: "payroll_version_history_results"
  """
  updatePayrollVersionHistoryResultsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollVersionHistoryResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollVersionHistoryResultsSetInput
    pkColumns: PayrollVersionHistoryResultsPkColumnsInput!
  ): PayrollVersionHistoryResults
  """
  update multiples rows of table: "payroll_version_history_results"
  """
  updatePayrollVersionHistoryResultsMany(
    """updates to execute, in order"""
    updates: [PayrollVersionHistoryResultsUpdates!]!
  ): [PayrollVersionHistoryResultsMutationResponse]
  """
  update data of the table: "payroll_version_results"
  """
  updatePayrollVersionResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollVersionResultsSetInput
    """filter the rows which have to be updated"""
    where: PayrollVersionResultsBoolExp!
  ): PayrollVersionResultsMutationResponse
  """
  update single row of the table: "payroll_version_results"
  """
  updatePayrollVersionResultsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollVersionResultsSetInput
    pkColumns: PayrollVersionResultsPkColumnsInput!
  ): PayrollVersionResults
  """
  update multiples rows of table: "payroll_version_results"
  """
  updatePayrollVersionResultsMany(
    """updates to execute, in order"""
    updates: [PayrollVersionResultsUpdates!]!
  ): [PayrollVersionResultsMutationResponse]
  """
  update data of the table: "payrolls"
  """
  updatePayrolls(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollsSetInput
    """filter the rows which have to be updated"""
    where: PayrollsBoolExp!
  ): PayrollsMutationResponse
  """
  update single row of the table: "payrolls"
  """
  updatePayrollsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PayrollsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PayrollsSetInput
    pkColumns: PayrollsPkColumnsInput!
  ): Payrolls
  """
  update multiples rows of table: "payrolls"
  """
  updatePayrollsMany(
    """updates to execute, in order"""
    updates: [PayrollsUpdates!]!
  ): [PayrollsMutationResponse]
  """
  update data of the table: "permission_audit_log"
  """
  updatePermissionAuditLog(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PermissionAuditLogAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PermissionAuditLogDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PermissionAuditLogDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PermissionAuditLogDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PermissionAuditLogPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: PermissionAuditLogSetInput
    """filter the rows which have to be updated"""
    where: PermissionAuditLogBoolExp!
  ): PermissionAuditLogMutationResponse
  """
  update single row of the table: "permission_audit_log"
  """
  updatePermissionAuditLogByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PermissionAuditLogAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PermissionAuditLogDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PermissionAuditLogDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PermissionAuditLogDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PermissionAuditLogPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: PermissionAuditLogSetInput
    pkColumns: PermissionAuditLogPkColumnsInput!
  ): PermissionAuditLog
  """
  update multiples rows of table: "permission_audit_log"
  """
  updatePermissionAuditLogMany(
    """updates to execute, in order"""
    updates: [PermissionAuditLogUpdates!]!
  ): [PermissionAuditLogMutationResponse]
  """
  update data of the table: "permission_overrides"
  """
  updatePermissionOverrides(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PermissionOverridesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PermissionOverridesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PermissionOverridesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PermissionOverridesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PermissionOverridesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: PermissionOverridesSetInput
    """filter the rows which have to be updated"""
    where: PermissionOverridesBoolExp!
  ): PermissionOverridesMutationResponse
  """
  update single row of the table: "permission_overrides"
  """
  updatePermissionOverridesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: PermissionOverridesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PermissionOverridesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PermissionOverridesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PermissionOverridesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: PermissionOverridesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: PermissionOverridesSetInput
    pkColumns: PermissionOverridesPkColumnsInput!
  ): PermissionOverrides
  """
  update multiples rows of table: "permission_overrides"
  """
  updatePermissionOverridesMany(
    """updates to execute, in order"""
    updates: [PermissionOverridesUpdates!]!
  ): [PermissionOverridesMutationResponse]
  """
  update data of the table: "permissions"
  """
  updatePermissions(
    """sets the columns of the filtered rows to the given values"""
    _set: PermissionsSetInput
    """filter the rows which have to be updated"""
    where: PermissionsBoolExp!
  ): PermissionsMutationResponse
  """
  update single row of the table: "permissions"
  """
  updatePermissionsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: PermissionsSetInput
    pkColumns: PermissionsPkColumnsInput!
  ): Permissions
  """
  update multiples rows of table: "permissions"
  """
  updatePermissionsMany(
    """updates to execute, in order"""
    updates: [PermissionsUpdates!]!
  ): [PermissionsMutationResponse]
  """
  update data of the table: "position_admin_defaults"
  """
  updatePositionAdminDefaults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PositionAdminDefaultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PositionAdminDefaultsSetInput
    """filter the rows which have to be updated"""
    where: PositionAdminDefaultsBoolExp!
  ): PositionAdminDefaultsMutationResponse
  """
  update single row of the table: "position_admin_defaults"
  """
  updatePositionAdminDefaultsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: PositionAdminDefaultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: PositionAdminDefaultsSetInput
    pkColumns: PositionAdminDefaultsPkColumnsInput!
  ): PositionAdminDefaults
  """
  update multiples rows of table: "position_admin_defaults"
  """
  updatePositionAdminDefaultsMany(
    """updates to execute, in order"""
    updates: [PositionAdminDefaultsUpdates!]!
  ): [PositionAdminDefaultsMutationResponse]
  """
  update data of the table: "quote_conversions"
  """
  updateQuoteConversions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: QuoteConversionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: QuoteConversionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: QuoteConversionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: QuoteConversionsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuoteConversionsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: QuoteConversionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuoteConversionsSetInput
    """filter the rows which have to be updated"""
    where: QuoteConversionsBoolExp!
  ): QuoteConversionsMutationResponse
  """
  update single row of the table: "quote_conversions"
  """
  updateQuoteConversionsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: QuoteConversionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: QuoteConversionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: QuoteConversionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: QuoteConversionsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuoteConversionsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: QuoteConversionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuoteConversionsSetInput
    pkColumns: QuoteConversionsPkColumnsInput!
  ): QuoteConversions
  """
  update multiples rows of table: "quote_conversions"
  """
  updateQuoteConversionsMany(
    """updates to execute, in order"""
    updates: [QuoteConversionsUpdates!]!
  ): [QuoteConversionsMutationResponse]
  """
  update data of the table: "quote_line_items"
  """
  updateQuoteLineItems(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuoteLineItemsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuoteLineItemsSetInput
    """filter the rows which have to be updated"""
    where: QuoteLineItemsBoolExp!
  ): QuoteLineItemsMutationResponse
  """
  update single row of the table: "quote_line_items"
  """
  updateQuoteLineItemsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuoteLineItemsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuoteLineItemsSetInput
    pkColumns: QuoteLineItemsPkColumnsInput!
  ): QuoteLineItems
  """
  update multiples rows of table: "quote_line_items"
  """
  updateQuoteLineItemsMany(
    """updates to execute, in order"""
    updates: [QuoteLineItemsUpdates!]!
  ): [QuoteLineItemsMutationResponse]
  """
  update data of the table: "quote_templates"
  """
  updateQuoteTemplates(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: QuoteTemplatesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: QuoteTemplatesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: QuoteTemplatesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: QuoteTemplatesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuoteTemplatesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: QuoteTemplatesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuoteTemplatesSetInput
    """filter the rows which have to be updated"""
    where: QuoteTemplatesBoolExp!
  ): QuoteTemplatesMutationResponse
  """
  update single row of the table: "quote_templates"
  """
  updateQuoteTemplatesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: QuoteTemplatesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: QuoteTemplatesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: QuoteTemplatesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: QuoteTemplatesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuoteTemplatesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: QuoteTemplatesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuoteTemplatesSetInput
    pkColumns: QuoteTemplatesPkColumnsInput!
  ): QuoteTemplates
  """
  update multiples rows of table: "quote_templates"
  """
  updateQuoteTemplatesMany(
    """updates to execute, in order"""
    updates: [QuoteTemplatesUpdates!]!
  ): [QuoteTemplatesMutationResponse]
  """
  update data of the table: "quotes"
  """
  updateQuotes(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuotesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuotesSetInput
    """filter the rows which have to be updated"""
    where: QuotesBoolExp!
  ): QuotesMutationResponse
  """
  update single row of the table: "quotes"
  """
  updateQuotesByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: QuotesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: QuotesSetInput
    pkColumns: QuotesPkColumnsInput!
  ): Quotes
  """
  update multiples rows of table: "quotes"
  """
  updateQuotesMany(
    """updates to execute, in order"""
    updates: [QuotesUpdates!]!
  ): [QuotesMutationResponse]
  """
  update data of the table: "rate_limits"
  """
  updateRateLimits(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RateLimitsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: RateLimitsSetInput
    """filter the rows which have to be updated"""
    where: RateLimitsBoolExp!
  ): RateLimitsMutationResponse
  """
  update single row of the table: "rate_limits"
  """
  updateRateLimitsByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RateLimitsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: RateLimitsSetInput
    pkColumns: RateLimitsPkColumnsInput!
  ): RateLimits
  """
  update multiples rows of table: "rate_limits"
  """
  updateRateLimitsMany(
    """updates to execute, in order"""
    updates: [RateLimitsUpdates!]!
  ): [RateLimitsMutationResponse]
  """
  update data of the table: "resources"
  """
  updateResources(
    """sets the columns of the filtered rows to the given values"""
    _set: ResourcesSetInput
    """filter the rows which have to be updated"""
    where: ResourcesBoolExp!
  ): ResourcesMutationResponse
  """
  update single row of the table: "resources"
  """
  updateResourcesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: ResourcesSetInput
    pkColumns: ResourcesPkColumnsInput!
  ): Resources
  """
  update multiples rows of table: "resources"
  """
  updateResourcesMany(
    """updates to execute, in order"""
    updates: [ResourcesUpdates!]!
  ): [ResourcesMutationResponse]
  """
  update data of the table: "role_permissions"
  """
  updateRolePermissions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: RolePermissionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: RolePermissionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: RolePermissionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: RolePermissionsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: RolePermissionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: RolePermissionsSetInput
    """filter the rows which have to be updated"""
    where: RolePermissionsBoolExp!
  ): RolePermissionsMutationResponse
  """
  update single row of the table: "role_permissions"
  """
  updateRolePermissionsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: RolePermissionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: RolePermissionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: RolePermissionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: RolePermissionsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: RolePermissionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: RolePermissionsSetInput
    pkColumns: RolePermissionsPkColumnsInput!
  ): RolePermissions
  """
  update multiples rows of table: "role_permissions"
  """
  updateRolePermissionsMany(
    """updates to execute, in order"""
    updates: [RolePermissionsUpdates!]!
  ): [RolePermissionsMutationResponse]
  """
  update data of the table: "roles"
  """
  updateRoles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RolesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: RolesSetInput
    """filter the rows which have to be updated"""
    where: RolesBoolExp!
  ): RolesMutationResponse
  """
  update single row of the table: "roles"
  """
  updateRolesByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RolesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: RolesSetInput
    pkColumns: RolesPkColumnsInput!
  ): Roles
  """
  update multiples rows of table: "roles"
  """
  updateRolesMany(
    """updates to execute, in order"""
    updates: [RolesUpdates!]!
  ): [RolesMutationResponse]
  """
  update data of the table: "security_alerts"
  """
  updateSecurityAlerts(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SecurityAlertsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SecurityAlertsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SecurityAlertsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SecurityAlertsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SecurityAlertsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SecurityAlertsSetInput
    """filter the rows which have to be updated"""
    where: SecurityAlertsBoolExp!
  ): SecurityAlertsMutationResponse
  """
  update single row of the table: "security_alerts"
  """
  updateSecurityAlertsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SecurityAlertsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SecurityAlertsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SecurityAlertsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SecurityAlertsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SecurityAlertsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SecurityAlertsSetInput
    pkColumns: SecurityAlertsPkColumnsInput!
  ): SecurityAlerts
  """
  update multiples rows of table: "security_alerts"
  """
  updateSecurityAlertsMany(
    """updates to execute, in order"""
    updates: [SecurityAlertsUpdates!]!
  ): [SecurityAlertsMutationResponse]
  """
  update data of the table: "security_settings"
  """
  updateSecuritySettings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SecuritySettingsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SecuritySettingsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SecuritySettingsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SecuritySettingsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SecuritySettingsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SecuritySettingsSetInput
    """filter the rows which have to be updated"""
    where: SecuritySettingsBoolExp!
  ): SecuritySettingsMutationResponse
  """
  update single row of the table: "security_settings"
  """
  updateSecuritySettingsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SecuritySettingsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SecuritySettingsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SecuritySettingsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SecuritySettingsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SecuritySettingsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SecuritySettingsSetInput
    pkColumns: SecuritySettingsPkColumnsInput!
  ): SecuritySettings
  """
  update multiples rows of table: "security_settings"
  """
  updateSecuritySettingsMany(
    """updates to execute, in order"""
    updates: [SecuritySettingsUpdates!]!
  ): [SecuritySettingsMutationResponse]
  """
  update data of the table: "service_pricing_rules"
  """
  updateServicePricingRules(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ServicePricingRulesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ServicePricingRulesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ServicePricingRulesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ServicePricingRulesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServicePricingRulesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ServicePricingRulesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ServicePricingRulesSetInput
    """filter the rows which have to be updated"""
    where: ServicePricingRulesBoolExp!
  ): ServicePricingRulesMutationResponse
  """
  update single row of the table: "service_pricing_rules"
  """
  updateServicePricingRulesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ServicePricingRulesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ServicePricingRulesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ServicePricingRulesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ServicePricingRulesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServicePricingRulesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ServicePricingRulesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ServicePricingRulesSetInput
    pkColumns: ServicePricingRulesPkColumnsInput!
  ): ServicePricingRules
  """
  update multiples rows of table: "service_pricing_rules"
  """
  updateServicePricingRulesMany(
    """updates to execute, in order"""
    updates: [ServicePricingRulesUpdates!]!
  ): [ServicePricingRulesMutationResponse]
  """
  update data of the table: "service_templates"
  """
  updateServiceTemplates(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ServiceTemplatesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ServiceTemplatesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ServiceTemplatesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ServiceTemplatesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceTemplatesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ServiceTemplatesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ServiceTemplatesSetInput
    """filter the rows which have to be updated"""
    where: ServiceTemplatesBoolExp!
  ): ServiceTemplatesMutationResponse
  """
  update single row of the table: "service_templates"
  """
  updateServiceTemplatesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ServiceTemplatesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ServiceTemplatesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ServiceTemplatesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ServiceTemplatesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServiceTemplatesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ServiceTemplatesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ServiceTemplatesSetInput
    pkColumns: ServiceTemplatesPkColumnsInput!
  ): ServiceTemplates
  """
  update multiples rows of table: "service_templates"
  """
  updateServiceTemplatesMany(
    """updates to execute, in order"""
    updates: [ServiceTemplatesUpdates!]!
  ): [ServiceTemplatesMutationResponse]
  """
  update data of the table: "services"
  """
  updateServices(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ServicesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ServicesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ServicesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ServicesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServicesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ServicesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ServicesSetInput
    """filter the rows which have to be updated"""
    where: ServicesBoolExp!
  ): ServicesMutationResponse
  """
  update single row of the table: "services"
  """
  updateServicesByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: ServicesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: ServicesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: ServicesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: ServicesDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: ServicesIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: ServicesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: ServicesSetInput
    pkColumns: ServicesPkColumnsInput!
  ): Services
  """
  update multiples rows of table: "services"
  """
  updateServicesMany(
    """updates to execute, in order"""
    updates: [ServicesUpdates!]!
  ): [ServicesMutationResponse]
  """
  update data of the table: "system_configuration"
  """
  updateSystemConfiguration(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SystemConfigurationAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SystemConfigurationDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SystemConfigurationDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SystemConfigurationDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SystemConfigurationPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SystemConfigurationSetInput
    """filter the rows which have to be updated"""
    where: SystemConfigurationBoolExp!
  ): SystemConfigurationMutationResponse
  """
  update single row of the table: "system_configuration"
  """
  updateSystemConfigurationByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SystemConfigurationAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SystemConfigurationDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SystemConfigurationDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SystemConfigurationDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SystemConfigurationPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SystemConfigurationSetInput
    pkColumns: SystemConfigurationPkColumnsInput!
  ): SystemConfiguration
  """
  update multiples rows of table: "system_configuration"
  """
  updateSystemConfigurationMany(
    """updates to execute, in order"""
    updates: [SystemConfigurationUpdates!]!
  ): [SystemConfigurationMutationResponse]
  """
  update data of the table: "system_health"
  """
  updateSystemHealth(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SystemHealthAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SystemHealthDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SystemHealthDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SystemHealthDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: SystemHealthIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SystemHealthPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SystemHealthSetInput
    """filter the rows which have to be updated"""
    where: SystemHealthBoolExp!
  ): SystemHealthMutationResponse
  """
  update single row of the table: "system_health"
  """
  updateSystemHealthByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: SystemHealthAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: SystemHealthDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: SystemHealthDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: SystemHealthDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: SystemHealthIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: SystemHealthPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: SystemHealthSetInput
    pkColumns: SystemHealthPkColumnsInput!
  ): SystemHealth
  """
  update multiples rows of table: "system_health"
  """
  updateSystemHealthMany(
    """updates to execute, in order"""
    updates: [SystemHealthUpdates!]!
  ): [SystemHealthMutationResponse]
  """
  update data of the table: "time_entries"
  """
  updateTimeEntries(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TimeEntriesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: TimeEntriesSetInput
    """filter the rows which have to be updated"""
    where: TimeEntriesBoolExp!
  ): TimeEntriesMutationResponse
  """
  update single row of the table: "time_entries"
  """
  updateTimeEntriesByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: TimeEntriesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: TimeEntriesSetInput
    pkColumns: TimeEntriesPkColumnsInput!
  ): TimeEntries
  """
  update multiples rows of table: "time_entries"
  """
  updateTimeEntriesMany(
    """updates to execute, in order"""
    updates: [TimeEntriesUpdates!]!
  ): [TimeEntriesMutationResponse]
  """
  update data of the table: "user_email_template_favorites"
  """
  updateUserEmailTemplateFavorites(
    """sets the columns of the filtered rows to the given values"""
    _set: UserEmailTemplateFavoritesSetInput
    """filter the rows which have to be updated"""
    where: UserEmailTemplateFavoritesBoolExp!
  ): UserEmailTemplateFavoritesMutationResponse
  """
  update single row of the table: "user_email_template_favorites"
  """
  updateUserEmailTemplateFavoritesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserEmailTemplateFavoritesSetInput
    pkColumns: UserEmailTemplateFavoritesPkColumnsInput!
  ): UserEmailTemplateFavorites
  """
  update multiples rows of table: "user_email_template_favorites"
  """
  updateUserEmailTemplateFavoritesMany(
    """updates to execute, in order"""
    updates: [UserEmailTemplateFavoritesUpdates!]!
  ): [UserEmailTemplateFavoritesMutationResponse]
  """
  update data of the table: "user_invitations"
  """
  updateUserInvitations(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: UserInvitationsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: UserInvitationsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: UserInvitationsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: UserInvitationsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: UserInvitationsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: UserInvitationsSetInput
    """filter the rows which have to be updated"""
    where: UserInvitationsBoolExp!
  ): UserInvitationsMutationResponse
  """
  update single row of the table: "user_invitations"
  """
  updateUserInvitationsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: UserInvitationsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: UserInvitationsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: UserInvitationsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: UserInvitationsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: UserInvitationsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: UserInvitationsSetInput
    pkColumns: UserInvitationsPkColumnsInput!
  ): UserInvitations
  """
  update multiples rows of table: "user_invitations"
  """
  updateUserInvitationsMany(
    """updates to execute, in order"""
    updates: [UserInvitationsUpdates!]!
  ): [UserInvitationsMutationResponse]
  """
  update data of the table: "user_roles"
  """
  updateUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: UserRolesSetInput
    """filter the rows which have to be updated"""
    where: UserRolesBoolExp!
  ): UserRolesMutationResponse
  """
  update single row of the table: "user_roles"
  """
  updateUserRolesByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserRolesSetInput
    pkColumns: UserRolesPkColumnsInput!
  ): UserRoles
  """
  update multiples rows of table: "user_roles"
  """
  updateUserRolesMany(
    """updates to execute, in order"""
    updates: [UserRolesUpdates!]!
  ): [UserRolesMutationResponse]
  """
  update data of the table: "user_sessions"
  """
  updateUserSessions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: UserSessionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: UserSessionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: UserSessionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: UserSessionsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: UserSessionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: UserSessionsSetInput
    """filter the rows which have to be updated"""
    where: UserSessionsBoolExp!
  ): UserSessionsMutationResponse
  """
  update single row of the table: "user_sessions"
  """
  updateUserSessionsByPk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: UserSessionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: UserSessionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: UserSessionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: UserSessionsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: UserSessionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: UserSessionsSetInput
    pkColumns: UserSessionsPkColumnsInput!
  ): UserSessions
  """
  update multiples rows of table: "user_sessions"
  """
  updateUserSessionsMany(
    """updates to execute, in order"""
    updates: [UserSessionsUpdates!]!
  ): [UserSessionsMutationResponse]
  """
  update data of the table: "user_skills"
  """
  updateUserSkills(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSkillsSetInput
    """filter the rows which have to be updated"""
    where: UserSkillsBoolExp!
  ): UserSkillsMutationResponse
  """
  update multiples rows of table: "user_skills"
  """
  updateUserSkillsMany(
    """updates to execute, in order"""
    updates: [UserSkillsUpdates!]!
  ): [UserSkillsMutationResponse]
  """
  update data of the table: "users"
  """
  updateUsers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: UsersIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: UsersSetInput
    """filter the rows which have to be updated"""
    where: UsersBoolExp!
  ): UsersMutationResponse
  """
  update single row of the table: "users"
  """
  updateUsersByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: UsersIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: UsersSetInput
    pkColumns: UsersPkColumnsInput!
  ): Users
  """
  update multiples rows of table: "users"
  """
  updateUsersMany(
    """updates to execute, in order"""
    updates: [UsersUpdates!]!
  ): [UsersMutationResponse]
  """
  update data of the table: "users_role_backup"
  """
  updateUsersRoleBackup(
    """sets the columns of the filtered rows to the given values"""
    _set: UsersRoleBackupSetInput
    """filter the rows which have to be updated"""
    where: UsersRoleBackupBoolExp!
  ): UsersRoleBackupMutationResponse
  """
  update multiples rows of table: "users_role_backup"
  """
  updateUsersRoleBackupMany(
    """updates to execute, in order"""
    updates: [UsersRoleBackupUpdates!]!
  ): [UsersRoleBackupMutationResponse]
  """
  update data of the table: "work_schedule"
  """
  updateWorkSchedule(
    """increments the numeric columns with given value of the filtered values"""
    _inc: WorkScheduleIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: WorkScheduleSetInput
    """filter the rows which have to be updated"""
    where: WorkScheduleBoolExp!
  ): WorkScheduleMutationResponse
  """
  update single row of the table: "work_schedule"
  """
  updateWorkScheduleByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: WorkScheduleIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: WorkScheduleSetInput
    pkColumns: WorkSchedulePkColumnsInput!
  ): WorkSchedule
  """
  update multiples rows of table: "work_schedule"
  """
  updateWorkScheduleMany(
    """updates to execute, in order"""
    updates: [WorkScheduleUpdates!]!
  ): [WorkScheduleMutationResponse]
}

scalar name

input notesAggregateBoolExpBool_and {
  arguments: NotesSelectColumnNotesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: NotesBoolExp
  predicate: BooleanComparisonExp!
}

input notesAggregateBoolExpBool_or {
  arguments: NotesSelectColumnNotesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: NotesBoolExp
  predicate: BooleanComparisonExp!
}

input notesAggregateBoolExpCount {
  arguments: [NotesSelectColumn!]
  distinct: Boolean
  filter: NotesBoolExp
  predicate: IntComparisonExp!
}

scalar numeric

input payrollAssignmentAuditAggregateBoolExpCount {
  arguments: [PayrollAssignmentAuditSelectColumn!]
  distinct: Boolean
  filter: PayrollAssignmentAuditBoolExp
  predicate: IntComparisonExp!
}

input payrollAssignmentsAggregateBoolExpBool_and {
  arguments: PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PayrollAssignmentsBoolExp
  predicate: BooleanComparisonExp!
}

input payrollAssignmentsAggregateBoolExpBool_or {
  arguments: PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PayrollAssignmentsBoolExp
  predicate: BooleanComparisonExp!
}

input payrollAssignmentsAggregateBoolExpCount {
  arguments: [PayrollAssignmentsSelectColumn!]
  distinct: Boolean
  filter: PayrollAssignmentsBoolExp
  predicate: IntComparisonExp!
}

input payrollDatesAggregateBoolExpCount {
  arguments: [PayrollDatesSelectColumn!]
  distinct: Boolean
  filter: PayrollDatesBoolExp
  predicate: IntComparisonExp!
}

input payrollRequiredSkillsAggregateBoolExpCount {
  arguments: [PayrollRequiredSkillsSelectColumn!]
  distinct: Boolean
  filter: PayrollRequiredSkillsBoolExp
  predicate: IntComparisonExp!
}

scalar payroll_cycle_type

scalar payroll_date_type

scalar payroll_status

input payrollsAggregateBoolExpCount {
  arguments: [PayrollsSelectColumn!]
  distinct: Boolean
  filter: PayrollsBoolExp
  predicate: IntComparisonExp!
}

input permissionAuditLogAggregateBoolExpCount {
  arguments: [PermissionAuditLogSelectColumn!]
  distinct: Boolean
  filter: PermissionAuditLogBoolExp
  predicate: IntComparisonExp!
}

input permissionOverridesAggregateBoolExpBool_and {
  arguments: PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PermissionOverridesBoolExp
  predicate: BooleanComparisonExp!
}

input permissionOverridesAggregateBoolExpBool_or {
  arguments: PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PermissionOverridesBoolExp
  predicate: BooleanComparisonExp!
}

input permissionOverridesAggregateBoolExpCount {
  arguments: [PermissionOverridesSelectColumn!]
  distinct: Boolean
  filter: PermissionOverridesBoolExp
  predicate: IntComparisonExp!
}

scalar permission_action

input permissionsAggregateBoolExpCount {
  arguments: [PermissionsSelectColumn!]
  distinct: Boolean
  filter: PermissionsBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """query _Entity union"""
  _entities(representations: [_Any!]!): _Entity
  _service: _Service!
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): [AdjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): AdjustmentRulesAggregate!
  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustmentRulesByPk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): AdjustmentRules
  """
  fetch data from the table: "app_settings"
  """
  appSettings(
    """distinct select on columns"""
    distinctOn: [AppSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AppSettingsOrderBy!]
    """filter the rows returned"""
    where: AppSettingsBoolExp
  ): [AppSettings!]!
  """
  fetch aggregated fields from the table: "app_settings"
  """
  appSettingsAggregate(
    """distinct select on columns"""
    distinctOn: [AppSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AppSettingsOrderBy!]
    """filter the rows returned"""
    where: AppSettingsBoolExp
  ): AppSettingsAggregate!
  """fetch data from the table: "app_settings" using primary key columns"""
  appSettingsByPk(
    """Unique identifier for application setting"""
    id: String!
  ): AppSettings
  """
  fetch data from the table: "audit.audit_log"
  """
  auditAuditLog(
    """distinct select on columns"""
    distinctOn: [AuditAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuditLogOrderBy!]
    """filter the rows returned"""
    where: AuditAuditLogBoolExp
  ): [AuditAuditLog!]!
  """
  fetch aggregated fields from the table: "audit.audit_log"
  """
  auditAuditLogAggregate(
    """distinct select on columns"""
    distinctOn: [AuditAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuditLogOrderBy!]
    """filter the rows returned"""
    where: AuditAuditLogBoolExp
  ): AuditAuditLogAggregate!
  """fetch data from the table: "audit.audit_log" using primary key columns"""
  auditAuditLogByPk(id: uuid!): AuditAuditLog
  """
  fetch data from the table: "audit.auth_events"
  """
  auditAuthEvents(
    """distinct select on columns"""
    distinctOn: [AuditAuthEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuthEventsOrderBy!]
    """filter the rows returned"""
    where: AuditAuthEventsBoolExp
  ): [AuditAuthEvents!]!
  """
  fetch aggregated fields from the table: "audit.auth_events"
  """
  auditAuthEventsAggregate(
    """distinct select on columns"""
    distinctOn: [AuditAuthEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuthEventsOrderBy!]
    """filter the rows returned"""
    where: AuditAuthEventsBoolExp
  ): AuditAuthEventsAggregate!
  """
  fetch data from the table: "audit.auth_events" using primary key columns
  """
  auditAuthEventsByPk(id: uuid!): AuditAuthEvents
  """
  fetch data from the table: "audit.data_access_log"
  """
  auditDataAccessLog(
    """distinct select on columns"""
    distinctOn: [AuditDataAccessLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditDataAccessLogOrderBy!]
    """filter the rows returned"""
    where: AuditDataAccessLogBoolExp
  ): [AuditDataAccessLog!]!
  """
  fetch aggregated fields from the table: "audit.data_access_log"
  """
  auditDataAccessLogAggregate(
    """distinct select on columns"""
    distinctOn: [AuditDataAccessLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditDataAccessLogOrderBy!]
    """filter the rows returned"""
    where: AuditDataAccessLogBoolExp
  ): AuditDataAccessLogAggregate!
  """
  fetch data from the table: "audit.data_access_log" using primary key columns
  """
  auditDataAccessLogByPk(id: uuid!): AuditDataAccessLog
  """
  fetch data from the table: "audit.permission_changes"
  """
  auditPermissionChanges(
    """distinct select on columns"""
    distinctOn: [AuditPermissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionChangesOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionChangesBoolExp
  ): [AuditPermissionChanges!]!
  """
  fetch aggregated fields from the table: "audit.permission_changes"
  """
  auditPermissionChangesAggregate(
    """distinct select on columns"""
    distinctOn: [AuditPermissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionChangesOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionChangesBoolExp
  ): AuditPermissionChangesAggregate!
  """
  fetch data from the table: "audit.permission_changes" using primary key columns
  """
  auditPermissionChangesByPk(id: uuid!): AuditPermissionChanges
  """
  fetch data from the table: "audit.permission_usage_report"
  """
  auditPermissionUsageReport(
    """distinct select on columns"""
    distinctOn: [AuditPermissionUsageReportSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionUsageReportOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionUsageReportBoolExp
  ): [AuditPermissionUsageReport!]!
  """
  fetch aggregated fields from the table: "audit.permission_usage_report"
  """
  auditPermissionUsageReportAggregate(
    """distinct select on columns"""
    distinctOn: [AuditPermissionUsageReportSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionUsageReportOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionUsageReportBoolExp
  ): AuditPermissionUsageReportAggregate!
  """
  fetch data from the table: "audit.slow_queries"
  """
  auditSlowQueries(
    """distinct select on columns"""
    distinctOn: [AuditSlowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditSlowQueriesOrderBy!]
    """filter the rows returned"""
    where: AuditSlowQueriesBoolExp
  ): [AuditSlowQueries!]!
  """
  fetch aggregated fields from the table: "audit.slow_queries"
  """
  auditSlowQueriesAggregate(
    """distinct select on columns"""
    distinctOn: [AuditSlowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditSlowQueriesOrderBy!]
    """filter the rows returned"""
    where: AuditSlowQueriesBoolExp
  ): AuditSlowQueriesAggregate!
  """
  fetch data from the table: "audit.slow_queries" using primary key columns
  """
  auditSlowQueriesByPk(id: uuid!): AuditSlowQueries
  """
  fetch data from the table: "audit.user_access_summary"
  """
  auditUserAccessSummary(
    """distinct select on columns"""
    distinctOn: [AuditUserAccessSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditUserAccessSummaryOrderBy!]
    """filter the rows returned"""
    where: AuditUserAccessSummaryBoolExp
  ): [AuditUserAccessSummary!]!
  """
  fetch aggregated fields from the table: "audit.user_access_summary"
  """
  auditUserAccessSummaryAggregate(
    """distinct select on columns"""
    distinctOn: [AuditUserAccessSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditUserAccessSummaryOrderBy!]
    """filter the rows returned"""
    where: AuditUserAccessSummaryBoolExp
  ): AuditUserAccessSummaryAggregate!
  """
  fetch data from the table: "billing_automation_metrics"
  """
  billingAutomationMetrics(
    """distinct select on columns"""
    distinctOn: [BillingAutomationMetricsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingAutomationMetricsOrderBy!]
    """filter the rows returned"""
    where: BillingAutomationMetricsBoolExp
  ): [BillingAutomationMetrics!]!
  """
  fetch aggregated fields from the table: "billing_automation_metrics"
  """
  billingAutomationMetricsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingAutomationMetricsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingAutomationMetricsOrderBy!]
    """filter the rows returned"""
    where: BillingAutomationMetricsBoolExp
  ): BillingAutomationMetricsAggregate!
  """
  fetch data from the table: "billing_event_log"
  """
  billingEventLog(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): [BillingEventLog!]!
  """
  fetch aggregated fields from the table: "billing_event_log"
  """
  billingEventLogAggregate(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): BillingEventLogAggregate!
  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billingEventLogByPk(id: uuid!): BillingEventLog
  """
  fetch data from the table: "billing_invoice"
  """
  billingInvoice(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): [BillingInvoice!]!
  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billingInvoiceAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): BillingInvoiceAggregate!
  """fetch data from the table: "billing_invoice" using primary key columns"""
  billingInvoiceByPk(id: uuid!): BillingInvoice
  """
  fetch data from the table: "billing_invoice_item"
  """
  billingInvoiceItem(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): [BillingInvoiceItem!]!
  """
  fetch aggregated fields from the table: "billing_invoice_item"
  """
  billingInvoiceItemAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): BillingInvoiceItemAggregate!
  """
  fetch data from the table: "billing_invoice_item" using primary key columns
  """
  billingInvoiceItemByPk(id: uuid!): BillingInvoiceItem
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """fetch data from the table: "billing_items" using primary key columns"""
  billingItemsByPk(id: uuid!): BillingItems
  """An array relationship"""
  billingPeriods(
    """distinct select on columns"""
    distinctOn: [BillingPeriodsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingPeriodsOrderBy!]
    """filter the rows returned"""
    where: BillingPeriodsBoolExp
  ): [BillingPeriods!]!
  """An aggregate relationship"""
  billingPeriodsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingPeriodsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingPeriodsOrderBy!]
    """filter the rows returned"""
    where: BillingPeriodsBoolExp
  ): BillingPeriodsAggregate!
  """fetch data from the table: "billing_periods" using primary key columns"""
  billingPeriodsByPk(id: uuid!): BillingPeriods
  """An array relationship"""
  clientExternalSystems(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): [ClientExternalSystems!]!
  """An aggregate relationship"""
  clientExternalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): ClientExternalSystemsAggregate!
  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  clientExternalSystemsByPk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): ClientExternalSystems
  """
  fetch data from the table: "client_service_agreements"
  """
  clientServiceAgreements(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): [ClientServiceAgreements!]!
  """
  fetch aggregated fields from the table: "client_service_agreements"
  """
  clientServiceAgreementsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): ClientServiceAgreementsAggregate!
  """
  fetch data from the table: "client_service_agreements" using primary key columns
  """
  clientServiceAgreementsByPk(id: uuid!): ClientServiceAgreements
  """
  fetch data from the table: "client_services_with_rates"
  """
  clientServicesWithRates(
    """distinct select on columns"""
    distinctOn: [ClientServicesWithRatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServicesWithRatesOrderBy!]
    """filter the rows returned"""
    where: ClientServicesWithRatesBoolExp
  ): [ClientServicesWithRates!]!
  """
  fetch aggregated fields from the table: "client_services_with_rates"
  """
  clientServicesWithRatesAggregate(
    """distinct select on columns"""
    distinctOn: [ClientServicesWithRatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServicesWithRatesOrderBy!]
    """filter the rows returned"""
    where: ClientServicesWithRatesBoolExp
  ): ClientServicesWithRatesAggregate!
  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinctOn: [ClientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientsOrderBy!]
    """filter the rows returned"""
    where: ClientsBoolExp
  ): [Clients!]!
  """
  fetch aggregated fields from the table: "clients"
  """
  clientsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientsOrderBy!]
    """filter the rows returned"""
    where: ClientsBoolExp
  ): ClientsAggregate!
  """fetch data from the table: "clients" using primary key columns"""
  clientsByPk(
    """Unique identifier for the client"""
    id: uuid!
  ): Clients
  """
  fetch data from the table: "consultant_capacity_overview"
  """
  consultantCapacityOverview(
    """distinct select on columns"""
    distinctOn: [ConsultantCapacityOverviewSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ConsultantCapacityOverviewOrderBy!]
    """filter the rows returned"""
    where: ConsultantCapacityOverviewBoolExp
  ): [ConsultantCapacityOverview!]!
  """
  fetch aggregated fields from the table: "consultant_capacity_overview"
  """
  consultantCapacityOverviewAggregate(
    """distinct select on columns"""
    distinctOn: [ConsultantCapacityOverviewSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ConsultantCapacityOverviewOrderBy!]
    """filter the rows returned"""
    where: ConsultantCapacityOverviewBoolExp
  ): ConsultantCapacityOverviewAggregate!
  """
  fetch data from the table: "current_payrolls"
  """
  currentPayrolls(
    """distinct select on columns"""
    distinctOn: [CurrentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentPayrollsOrderBy!]
    """filter the rows returned"""
    where: CurrentPayrollsBoolExp
  ): [CurrentPayrolls!]!
  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  currentPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [CurrentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentPayrollsOrderBy!]
    """filter the rows returned"""
    where: CurrentPayrollsBoolExp
  ): CurrentPayrollsAggregate!
  """An array relationship"""
  dataBackups(
    """distinct select on columns"""
    distinctOn: [DataBackupsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DataBackupsOrderBy!]
    """filter the rows returned"""
    where: DataBackupsBoolExp
  ): [DataBackups!]!
  """An aggregate relationship"""
  dataBackupsAggregate(
    """distinct select on columns"""
    distinctOn: [DataBackupsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DataBackupsOrderBy!]
    """filter the rows returned"""
    where: DataBackupsBoolExp
  ): DataBackupsAggregate!
  """fetch data from the table: "data_backups" using primary key columns"""
  dataBackupsByPk(id: uuid!): DataBackups
  """An array relationship"""
  emailDrafts(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): [EmailDrafts!]!
  """An aggregate relationship"""
  emailDraftsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): EmailDraftsAggregate!
  """fetch data from the table: "email_drafts" using primary key columns"""
  emailDraftsByPk(id: uuid!): EmailDrafts
  """An array relationship"""
  emailSendLogs(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): [EmailSendLogs!]!
  """An aggregate relationship"""
  emailSendLogsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): EmailSendLogsAggregate!
  """fetch data from the table: "email_send_logs" using primary key columns"""
  emailSendLogsByPk(id: uuid!): EmailSendLogs
  """
  fetch data from the table: "email_templates"
  """
  emailTemplates(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): [EmailTemplates!]!
  """
  fetch aggregated fields from the table: "email_templates"
  """
  emailTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): EmailTemplatesAggregate!
  """fetch data from the table: "email_templates" using primary key columns"""
  emailTemplatesByPk(id: uuid!): EmailTemplates
  """
  fetch data from the table: "external_systems"
  """
  externalSystems(
    """distinct select on columns"""
    distinctOn: [ExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ExternalSystemsBoolExp
  ): [ExternalSystems!]!
  """
  fetch aggregated fields from the table: "external_systems"
  """
  externalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [ExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ExternalSystemsBoolExp
  ): ExternalSystemsAggregate!
  """
  fetch data from the table: "external_systems" using primary key columns
  """
  externalSystemsByPk(
    """Unique identifier for the external system"""
    id: uuid!
  ): ExternalSystems
  """
  fetch data from the table: "feature_flags"
  """
  featureFlags(
    """distinct select on columns"""
    distinctOn: [FeatureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FeatureFlagsOrderBy!]
    """filter the rows returned"""
    where: FeatureFlagsBoolExp
  ): [FeatureFlags!]!
  """
  fetch aggregated fields from the table: "feature_flags"
  """
  featureFlagsAggregate(
    """distinct select on columns"""
    distinctOn: [FeatureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FeatureFlagsOrderBy!]
    """filter the rows returned"""
    where: FeatureFlagsBoolExp
  ): FeatureFlagsAggregate!
  """fetch data from the table: "feature_flags" using primary key columns"""
  featureFlagsByPk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): FeatureFlags
  """An array relationship"""
  files(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): [Files!]!
  """An aggregate relationship"""
  filesAggregate(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): FilesAggregate!
  """fetch data from the table: "files" using primary key columns"""
  filesByPk(id: uuid!): Files
  """
  execute function "get_latest_payroll_version" which returns "latest_payroll_version_results"
  """
  getLatestPayrollVersion(
    """
    input parameters for function "getLatestPayrollVersion"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): [LatestPayrollVersionResults!]!
  """
  execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results"
  """
  getLatestPayrollVersionAggregate(
    """
    input parameters for function "getLatestPayrollVersionAggregate"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): LatestPayrollVersionResultsAggregate!
  """
  execute function "get_payroll_version_history" which returns "payroll_version_history_results"
  """
  getPayrollVersionHistory(
    """
    input parameters for function "getPayrollVersionHistory"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): [PayrollVersionHistoryResults!]!
  """
  execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results"
  """
  getPayrollVersionHistoryAggregate(
    """
    input parameters for function "getPayrollVersionHistoryAggregate"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): PayrollVersionHistoryResultsAggregate!
  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinctOn: [HolidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [HolidaysOrderBy!]
    """filter the rows returned"""
    where: HolidaysBoolExp
  ): [Holidays!]!
  """
  fetch aggregated fields from the table: "holidays"
  """
  holidaysAggregate(
    """distinct select on columns"""
    distinctOn: [HolidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [HolidaysOrderBy!]
    """filter the rows returned"""
    where: HolidaysBoolExp
  ): HolidaysAggregate!
  """fetch data from the table: "holidays" using primary key columns"""
  holidaysByPk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): Holidays
  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResults(
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): [LatestPayrollVersionResults!]!
  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): LatestPayrollVersionResultsAggregate!
  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latestPayrollVersionResultsByPk(id: uuid!): LatestPayrollVersionResults
  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinctOn: [LeaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LeaveOrderBy!]
    """filter the rows returned"""
    where: LeaveBoolExp
  ): [Leave!]!
  """
  fetch aggregated fields from the table: "leave"
  """
  leaveAggregate(
    """distinct select on columns"""
    distinctOn: [LeaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LeaveOrderBy!]
    """filter the rows returned"""
    where: LeaveBoolExp
  ): LeaveAggregate!
  """fetch data from the table: "leave" using primary key columns"""
  leaveByPk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): Leave
  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinctOn: [NotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [NotesOrderBy!]
    """filter the rows returned"""
    where: NotesBoolExp
  ): [Notes!]!
  """
  fetch aggregated fields from the table: "notes"
  """
  notesAggregate(
    """distinct select on columns"""
    distinctOn: [NotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [NotesOrderBy!]
    """filter the rows returned"""
    where: NotesBoolExp
  ): NotesAggregate!
  """fetch data from the table: "notes" using primary key columns"""
  notesByPk(
    """Unique identifier for the note"""
    id: uuid!
  ): Notes
  """
  fetch data from the table: "payroll_activation_results"
  """
  payrollActivationResults(
    """distinct select on columns"""
    distinctOn: [PayrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollActivationResultsBoolExp
  ): [PayrollActivationResults!]!
  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payrollActivationResultsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollActivationResultsBoolExp
  ): PayrollActivationResultsAggregate!
  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payrollActivationResultsByPk(id: uuid!): PayrollActivationResults
  """
  fetch data from the table: "payroll_assignment_audit"
  """
  payrollAssignmentAudit(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """
  fetch aggregated fields from the table: "payroll_assignment_audit"
  """
  payrollAssignmentAuditAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): PayrollAssignmentAuditAggregate!
  """
  fetch data from the table: "payroll_assignment_audit" using primary key columns
  """
  payrollAssignmentAuditByPk(id: uuid!): PayrollAssignmentAudit
  """
  fetch data from the table: "payroll_assignments"
  """
  payrollAssignments(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): [PayrollAssignments!]!
  """
  fetch aggregated fields from the table: "payroll_assignments"
  """
  payrollAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): PayrollAssignmentsAggregate!
  """
  fetch data from the table: "payroll_assignments" using primary key columns
  """
  payrollAssignmentsByPk(id: uuid!): PayrollAssignments
  """
  fetch data from the table: "payroll_cycles"
  """
  payrollCycles(
    """distinct select on columns"""
    distinctOn: [PayrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollCyclesOrderBy!]
    """filter the rows returned"""
    where: PayrollCyclesBoolExp
  ): [PayrollCycles!]!
  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payrollCyclesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollCyclesOrderBy!]
    """filter the rows returned"""
    where: PayrollCyclesBoolExp
  ): PayrollCyclesAggregate!
  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payrollCyclesByPk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): PayrollCycles
  """
  fetch data from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStats(
    """distinct select on columns"""
    distinctOn: [PayrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: PayrollDashboardStatsBoolExp
  ): [PayrollDashboardStats!]!
  """
  fetch aggregated fields from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStatsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: PayrollDashboardStatsBoolExp
  ): PayrollDashboardStatsAggregate!
  """
  fetch data from the table: "payroll_date_types"
  """
  payrollDateTypes(
    """distinct select on columns"""
    distinctOn: [PayrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: PayrollDateTypesBoolExp
  ): [PayrollDateTypes!]!
  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payrollDateTypesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: PayrollDateTypesBoolExp
  ): PayrollDateTypesAggregate!
  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payrollDateTypesByPk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): PayrollDateTypes
  """An array relationship"""
  payrollDates(
    """distinct select on columns"""
    distinctOn: [PayrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDatesOrderBy!]
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): [PayrollDates!]!
  """An aggregate relationship"""
  payrollDatesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDatesOrderBy!]
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): PayrollDatesAggregate!
  """fetch data from the table: "payroll_dates" using primary key columns"""
  payrollDatesByPk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): PayrollDates
  """
  fetch data from the table: "payroll_profitability"
  """
  payrollProfitability(
    """distinct select on columns"""
    distinctOn: [PayrollProfitabilitySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollProfitabilityOrderBy!]
    """filter the rows returned"""
    where: PayrollProfitabilityBoolExp
  ): [PayrollProfitability!]!
  """
  fetch aggregated fields from the table: "payroll_profitability"
  """
  payrollProfitabilityAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollProfitabilitySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollProfitabilityOrderBy!]
    """filter the rows returned"""
    where: PayrollProfitabilityBoolExp
  ): PayrollProfitabilityAggregate!
  """
  fetch data from the table: "payroll_required_skills"
  """
  payrollRequiredSkills(
    """distinct select on columns"""
    distinctOn: [PayrollRequiredSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollRequiredSkillsOrderBy!]
    """filter the rows returned"""
    where: PayrollRequiredSkillsBoolExp
  ): [PayrollRequiredSkills!]!
  """
  fetch aggregated fields from the table: "payroll_required_skills"
  """
  payrollRequiredSkillsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollRequiredSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollRequiredSkillsOrderBy!]
    """filter the rows returned"""
    where: PayrollRequiredSkillsBoolExp
  ): PayrollRequiredSkillsAggregate!
  """
  fetch data from the table: "payroll_triggers_status"
  """
  payrollTriggersStatus(
    """distinct select on columns"""
    distinctOn: [PayrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: PayrollTriggersStatusBoolExp
  ): [PayrollTriggersStatus!]!
  """
  fetch aggregated fields from the table: "payroll_triggers_status"
  """
  payrollTriggersStatusAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: PayrollTriggersStatusBoolExp
  ): PayrollTriggersStatusAggregate!
  """
  fetch data from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResults(
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): [PayrollVersionHistoryResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResultsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): PayrollVersionHistoryResultsAggregate!
  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payrollVersionHistoryResultsByPk(id: uuid!): PayrollVersionHistoryResults
  """
  fetch data from the table: "payroll_version_results"
  """
  payrollVersionResults(
    """distinct select on columns"""
    distinctOn: [PayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionResultsBoolExp
  ): [PayrollVersionResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionResultsBoolExp
  ): PayrollVersionResultsAggregate!
  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payrollVersionResultsByPk(id: uuid!): PayrollVersionResults
  """
  fetch data from the table: "payroll_workload_distribution"
  """
  payrollWorkloadDistribution(
    """distinct select on columns"""
    distinctOn: [PayrollWorkloadDistributionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollWorkloadDistributionOrderBy!]
    """filter the rows returned"""
    where: PayrollWorkloadDistributionBoolExp
  ): [PayrollWorkloadDistribution!]!
  """
  fetch aggregated fields from the table: "payroll_workload_distribution"
  """
  payrollWorkloadDistributionAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollWorkloadDistributionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollWorkloadDistributionOrderBy!]
    """filter the rows returned"""
    where: PayrollWorkloadDistributionBoolExp
  ): PayrollWorkloadDistributionAggregate!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """fetch data from the table: "payrolls" using primary key columns"""
  payrollsByPk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): Payrolls
  """
  fetch data from the table: "pending_billing_approvals"
  """
  pendingBillingApprovals(
    """distinct select on columns"""
    distinctOn: [PendingBillingApprovalsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PendingBillingApprovalsOrderBy!]
    """filter the rows returned"""
    where: PendingBillingApprovalsBoolExp
  ): [PendingBillingApprovals!]!
  """
  fetch aggregated fields from the table: "pending_billing_approvals"
  """
  pendingBillingApprovalsAggregate(
    """distinct select on columns"""
    distinctOn: [PendingBillingApprovalsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PendingBillingApprovalsOrderBy!]
    """filter the rows returned"""
    where: PendingBillingApprovalsBoolExp
  ): PendingBillingApprovalsAggregate!
  """
  fetch data from the table: "permission_audit_log"
  """
  permissionAuditLog(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): [PermissionAuditLog!]!
  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permissionAuditLogAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): PermissionAuditLogAggregate!
  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permissionAuditLogByPk(id: uuid!): PermissionAuditLog
  """An array relationship"""
  permissionOverrides(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): [PermissionOverrides!]!
  """An aggregate relationship"""
  permissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): PermissionOverridesAggregate!
  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permissionOverridesByPk(id: uuid!): PermissionOverrides
  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinctOn: [PermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionsOrderBy!]
    """filter the rows returned"""
    where: PermissionsBoolExp
  ): [Permissions!]!
  """An aggregate relationship"""
  permissionsAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionsOrderBy!]
    """filter the rows returned"""
    where: PermissionsBoolExp
  ): PermissionsAggregate!
  """fetch data from the table: "permissions" using primary key columns"""
  permissionsByPk(id: uuid!): Permissions
  """
  fetch data from the table: "position_admin_defaults"
  """
  positionAdminDefaults(
    """distinct select on columns"""
    distinctOn: [PositionAdminDefaultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PositionAdminDefaultsOrderBy!]
    """filter the rows returned"""
    where: PositionAdminDefaultsBoolExp
  ): [PositionAdminDefaults!]!
  """
  fetch aggregated fields from the table: "position_admin_defaults"
  """
  positionAdminDefaultsAggregate(
    """distinct select on columns"""
    distinctOn: [PositionAdminDefaultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PositionAdminDefaultsOrderBy!]
    """filter the rows returned"""
    where: PositionAdminDefaultsBoolExp
  ): PositionAdminDefaultsAggregate!
  """
  fetch data from the table: "position_admin_defaults" using primary key columns
  """
  positionAdminDefaultsByPk(position: user_position!): PositionAdminDefaults
  """
  fetch data from the table: "quote_analytics"
  """
  quoteAnalytics(
    """distinct select on columns"""
    distinctOn: [QuoteAnalyticsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteAnalyticsOrderBy!]
    """filter the rows returned"""
    where: QuoteAnalyticsBoolExp
  ): [QuoteAnalytics!]!
  """
  fetch aggregated fields from the table: "quote_analytics"
  """
  quoteAnalyticsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteAnalyticsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteAnalyticsOrderBy!]
    """filter the rows returned"""
    where: QuoteAnalyticsBoolExp
  ): QuoteAnalyticsAggregate!
  """An array relationship"""
  quoteConversions(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): [QuoteConversions!]!
  """An aggregate relationship"""
  quoteConversionsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): QuoteConversionsAggregate!
  """
  fetch data from the table: "quote_conversions" using primary key columns
  """
  quoteConversionsByPk(id: uuid!): QuoteConversions
  """An array relationship"""
  quoteLineItems(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): [QuoteLineItems!]!
  """An aggregate relationship"""
  quoteLineItemsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): QuoteLineItemsAggregate!
  """
  fetch data from the table: "quote_line_items" using primary key columns
  """
  quoteLineItemsByPk(id: uuid!): QuoteLineItems
  """An array relationship"""
  quoteTemplates(
    """distinct select on columns"""
    distinctOn: [QuoteTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteTemplatesOrderBy!]
    """filter the rows returned"""
    where: QuoteTemplatesBoolExp
  ): [QuoteTemplates!]!
  """An aggregate relationship"""
  quoteTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteTemplatesOrderBy!]
    """filter the rows returned"""
    where: QuoteTemplatesBoolExp
  ): QuoteTemplatesAggregate!
  """fetch data from the table: "quote_templates" using primary key columns"""
  quoteTemplatesByPk(id: uuid!): QuoteTemplates
  """An array relationship"""
  quotes(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): [Quotes!]!
  """An aggregate relationship"""
  quotesAggregate(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): QuotesAggregate!
  """fetch data from the table: "quotes" using primary key columns"""
  quotesByPk(id: uuid!): Quotes
  """
  fetch data from the table: "rate_limits"
  """
  rateLimits(
    """distinct select on columns"""
    distinctOn: [RateLimitsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RateLimitsOrderBy!]
    """filter the rows returned"""
    where: RateLimitsBoolExp
  ): [RateLimits!]!
  """
  fetch aggregated fields from the table: "rate_limits"
  """
  rateLimitsAggregate(
    """distinct select on columns"""
    distinctOn: [RateLimitsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RateLimitsOrderBy!]
    """filter the rows returned"""
    where: RateLimitsBoolExp
  ): RateLimitsAggregate!
  """fetch data from the table: "rate_limits" using primary key columns"""
  rateLimitsByPk(id: uuid!): RateLimits
  """
  fetch data from the table: "resources"
  """
  resources(
    """distinct select on columns"""
    distinctOn: [ResourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ResourcesOrderBy!]
    """filter the rows returned"""
    where: ResourcesBoolExp
  ): [Resources!]!
  """
  fetch aggregated fields from the table: "resources"
  """
  resourcesAggregate(
    """distinct select on columns"""
    distinctOn: [ResourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ResourcesOrderBy!]
    """filter the rows returned"""
    where: ResourcesBoolExp
  ): ResourcesAggregate!
  """fetch data from the table: "resources" using primary key columns"""
  resourcesByPk(id: uuid!): Resources
  """An array relationship"""
  rolePermissions(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): [RolePermissions!]!
  """An aggregate relationship"""
  rolePermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): RolePermissionsAggregate!
  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  rolePermissionsByPk(id: uuid!): RolePermissions
  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]
    """filter the rows returned"""
    where: RolesBoolExp
  ): [Roles!]!
  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]
    """filter the rows returned"""
    where: RolesBoolExp
  ): RolesAggregate!
  """fetch data from the table: "roles" using primary key columns"""
  rolesByPk(id: uuid!): Roles
  """An array relationship"""
  securityAlerts(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): [SecurityAlerts!]!
  """An aggregate relationship"""
  securityAlertsAggregate(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): SecurityAlertsAggregate!
  """fetch data from the table: "security_alerts" using primary key columns"""
  securityAlertsByPk(id: uuid!): SecurityAlerts
  """An array relationship"""
  securitySettings(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): [SecuritySettings!]!
  """An aggregate relationship"""
  securitySettingsAggregate(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): SecuritySettingsAggregate!
  """
  fetch data from the table: "security_settings" using primary key columns
  """
  securitySettingsByPk(id: uuid!): SecuritySettings
  """An array relationship"""
  servicePricingRules(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): [ServicePricingRules!]!
  """An aggregate relationship"""
  servicePricingRulesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): ServicePricingRulesAggregate!
  """
  fetch data from the table: "service_pricing_rules" using primary key columns
  """
  servicePricingRulesByPk(id: uuid!): ServicePricingRules
  """
  fetch data from the table: "service_templates"
  """
  serviceTemplates(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): [ServiceTemplates!]!
  """
  fetch aggregated fields from the table: "service_templates"
  """
  serviceTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): ServiceTemplatesAggregate!
  """
  fetch data from the table: "service_templates" using primary key columns
  """
  serviceTemplatesByPk(id: uuid!): ServiceTemplates
  """
  fetch data from the table: "services"
  """
  services(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): [Services!]!
  """
  fetch aggregated fields from the table: "services"
  """
  servicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): ServicesAggregate!
  """fetch data from the table: "services" using primary key columns"""
  servicesByPk(id: uuid!): Services
  """
  fetch data from the table: "staff_billing_performance"
  """
  staffBillingPerformance(
    """distinct select on columns"""
    distinctOn: [StaffBillingPerformanceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [StaffBillingPerformanceOrderBy!]
    """filter the rows returned"""
    where: StaffBillingPerformanceBoolExp
  ): [StaffBillingPerformance!]!
  """
  fetch aggregated fields from the table: "staff_billing_performance"
  """
  staffBillingPerformanceAggregate(
    """distinct select on columns"""
    distinctOn: [StaffBillingPerformanceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [StaffBillingPerformanceOrderBy!]
    """filter the rows returned"""
    where: StaffBillingPerformanceBoolExp
  ): StaffBillingPerformanceAggregate!
  """
  fetch data from the table: "system_configuration"
  """
  systemConfiguration(
    """distinct select on columns"""
    distinctOn: [SystemConfigurationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemConfigurationOrderBy!]
    """filter the rows returned"""
    where: SystemConfigurationBoolExp
  ): [SystemConfiguration!]!
  """
  fetch aggregated fields from the table: "system_configuration"
  """
  systemConfigurationAggregate(
    """distinct select on columns"""
    distinctOn: [SystemConfigurationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemConfigurationOrderBy!]
    """filter the rows returned"""
    where: SystemConfigurationBoolExp
  ): SystemConfigurationAggregate!
  """
  fetch data from the table: "system_configuration" using primary key columns
  """
  systemConfigurationByPk(id: uuid!): SystemConfiguration
  """
  fetch data from the table: "system_health"
  """
  systemHealth(
    """distinct select on columns"""
    distinctOn: [SystemHealthSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemHealthOrderBy!]
    """filter the rows returned"""
    where: SystemHealthBoolExp
  ): [SystemHealth!]!
  """
  fetch aggregated fields from the table: "system_health"
  """
  systemHealthAggregate(
    """distinct select on columns"""
    distinctOn: [SystemHealthSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemHealthOrderBy!]
    """filter the rows returned"""
    where: SystemHealthBoolExp
  ): SystemHealthAggregate!
  """fetch data from the table: "system_health" using primary key columns"""
  systemHealthByPk(id: uuid!): SystemHealth
  """
  fetch data from the table: "team_capacity_by_position"
  """
  teamCapacityByPosition(
    """distinct select on columns"""
    distinctOn: [TeamCapacityByPositionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TeamCapacityByPositionOrderBy!]
    """filter the rows returned"""
    where: TeamCapacityByPositionBoolExp
  ): [TeamCapacityByPosition!]!
  """
  fetch aggregated fields from the table: "team_capacity_by_position"
  """
  teamCapacityByPositionAggregate(
    """distinct select on columns"""
    distinctOn: [TeamCapacityByPositionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TeamCapacityByPositionOrderBy!]
    """filter the rows returned"""
    where: TeamCapacityByPositionBoolExp
  ): TeamCapacityByPositionAggregate!
  """An array relationship"""
  timeEntries(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """An aggregate relationship"""
  timeEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): TimeEntriesAggregate!
  """fetch data from the table: "time_entries" using primary key columns"""
  timeEntriesByPk(id: uuid!): TimeEntries
  """
  fetch data from the table: "time_tracking_summary"
  """
  timeTrackingSummary(
    """distinct select on columns"""
    distinctOn: [TimeTrackingSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeTrackingSummaryOrderBy!]
    """filter the rows returned"""
    where: TimeTrackingSummaryBoolExp
  ): [TimeTrackingSummary!]!
  """
  fetch aggregated fields from the table: "time_tracking_summary"
  """
  timeTrackingSummaryAggregate(
    """distinct select on columns"""
    distinctOn: [TimeTrackingSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeTrackingSummaryOrderBy!]
    """filter the rows returned"""
    where: TimeTrackingSummaryBoolExp
  ): TimeTrackingSummaryAggregate!
  """
  fetch data from the table: "user_email_template_favorites"
  """
  userEmailTemplateFavorites(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): [UserEmailTemplateFavorites!]!
  """
  fetch aggregated fields from the table: "user_email_template_favorites"
  """
  userEmailTemplateFavoritesAggregate(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): UserEmailTemplateFavoritesAggregate!
  """
  fetch data from the table: "user_email_template_favorites" using primary key columns
  """
  userEmailTemplateFavoritesByPk(id: uuid!): UserEmailTemplateFavorites
  """
  fetch data from the table: "user_invitations"
  """
  userInvitations(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): [UserInvitations!]!
  """
  fetch aggregated fields from the table: "user_invitations"
  """
  userInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): UserInvitationsAggregate!
  """
  fetch data from the table: "user_invitations" using primary key columns
  """
  userInvitationsByPk(id: uuid!): UserInvitations
  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): [UserRoles!]!
  """An aggregate relationship"""
  userRolesAggregate(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): UserRolesAggregate!
  """fetch data from the table: "user_roles" using primary key columns"""
  userRolesByPk(id: uuid!): UserRoles
  """An array relationship"""
  userSessions(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """An aggregate relationship"""
  userSessionsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): UserSessionsAggregate!
  """fetch data from the table: "user_sessions" using primary key columns"""
  userSessionsByPk(id: uuid!): UserSessions
  """
  fetch data from the table: "user_skills"
  """
  userSkills(
    """distinct select on columns"""
    distinctOn: [UserSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSkillsOrderBy!]
    """filter the rows returned"""
    where: UserSkillsBoolExp
  ): [UserSkills!]!
  """
  fetch aggregated fields from the table: "user_skills"
  """
  userSkillsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSkillsOrderBy!]
    """filter the rows returned"""
    where: UserSkillsBoolExp
  ): UserSkillsAggregate!
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): UsersAggregate!
  """fetch data from the table: "users" using primary key columns"""
  usersByPk(
    """Unique identifier for the user"""
    id: uuid!
  ): Users
  """
  fetch data from the table: "users_role_backup"
  """
  usersRoleBackup(
    """distinct select on columns"""
    distinctOn: [UsersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: UsersRoleBackupBoolExp
  ): [UsersRoleBackup!]!
  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  usersRoleBackupAggregate(
    """distinct select on columns"""
    distinctOn: [UsersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: UsersRoleBackupBoolExp
  ): UsersRoleBackupAggregate!
  """
  fetch data from the table: "work_schedule"
  """
  workSchedule(
    """distinct select on columns"""
    distinctOn: [WorkScheduleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [WorkScheduleOrderBy!]
    """filter the rows returned"""
    where: WorkScheduleBoolExp
  ): [WorkSchedule!]!
  """
  fetch aggregated fields from the table: "work_schedule"
  """
  workScheduleAggregate(
    """distinct select on columns"""
    distinctOn: [WorkScheduleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [WorkScheduleOrderBy!]
    """filter the rows returned"""
    where: WorkScheduleBoolExp
  ): WorkScheduleAggregate!
  """fetch data from the table: "work_schedule" using primary key columns"""
  workScheduleByPk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): WorkSchedule
}

input quoteConversionsAggregateBoolExpCount {
  arguments: [QuoteConversionsSelectColumn!]
  distinct: Boolean
  filter: QuoteConversionsBoolExp
  predicate: IntComparisonExp!
}

input quoteLineItemsAggregateBoolExpCount {
  arguments: [QuoteLineItemsSelectColumn!]
  distinct: Boolean
  filter: QuoteLineItemsBoolExp
  predicate: IntComparisonExp!
}

input quoteTemplatesAggregateBoolExpBool_and {
  arguments: QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: QuoteTemplatesBoolExp
  predicate: BooleanComparisonExp!
}

input quoteTemplatesAggregateBoolExpBool_or {
  arguments: QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: QuoteTemplatesBoolExp
  predicate: BooleanComparisonExp!
}

input quoteTemplatesAggregateBoolExpCount {
  arguments: [QuoteTemplatesSelectColumn!]
  distinct: Boolean
  filter: QuoteTemplatesBoolExp
  predicate: IntComparisonExp!
}

input quotesAggregateBoolExpCount {
  arguments: [QuotesSelectColumn!]
  distinct: Boolean
  filter: QuotesBoolExp
  predicate: IntComparisonExp!
}

input rolePermissionsAggregateBoolExpCount {
  arguments: [RolePermissionsSelectColumn!]
  distinct: Boolean
  filter: RolePermissionsBoolExp
  predicate: IntComparisonExp!
}

input securityAlertsAggregateBoolExpBool_and {
  arguments: SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: SecurityAlertsBoolExp
  predicate: BooleanComparisonExp!
}

input securityAlertsAggregateBoolExpBool_or {
  arguments: SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: SecurityAlertsBoolExp
  predicate: BooleanComparisonExp!
}

input securityAlertsAggregateBoolExpCount {
  arguments: [SecurityAlertsSelectColumn!]
  distinct: Boolean
  filter: SecurityAlertsBoolExp
  predicate: IntComparisonExp!
}

input securitySettingsAggregateBoolExpBool_and {
  arguments: SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: SecuritySettingsBoolExp
  predicate: BooleanComparisonExp!
}

input securitySettingsAggregateBoolExpBool_or {
  arguments: SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: SecuritySettingsBoolExp
  predicate: BooleanComparisonExp!
}

input securitySettingsAggregateBoolExpCount {
  arguments: [SecuritySettingsSelectColumn!]
  distinct: Boolean
  filter: SecuritySettingsBoolExp
  predicate: IntComparisonExp!
}

input servicePricingRulesAggregateBoolExpBool_and {
  arguments: ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ServicePricingRulesBoolExp
  predicate: BooleanComparisonExp!
}

input servicePricingRulesAggregateBoolExpBool_or {
  arguments: ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ServicePricingRulesBoolExp
  predicate: BooleanComparisonExp!
}

input servicePricingRulesAggregateBoolExpCount {
  arguments: [ServicePricingRulesSelectColumn!]
  distinct: Boolean
  filter: ServicePricingRulesBoolExp
  predicate: IntComparisonExp!
}

input serviceTemplatesAggregateBoolExpBool_and {
  arguments: ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ServiceTemplatesBoolExp
  predicate: BooleanComparisonExp!
}

input serviceTemplatesAggregateBoolExpBool_or {
  arguments: ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ServiceTemplatesBoolExp
  predicate: BooleanComparisonExp!
}

input serviceTemplatesAggregateBoolExpCount {
  arguments: [ServiceTemplatesSelectColumn!]
  distinct: Boolean
  filter: ServiceTemplatesBoolExp
  predicate: IntComparisonExp!
}

input servicesAggregateBoolExpBool_and {
  arguments: ServicesSelectColumnServicesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ServicesBoolExp
  predicate: BooleanComparisonExp!
}

input servicesAggregateBoolExpBool_or {
  arguments: ServicesSelectColumnServicesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ServicesBoolExp
  predicate: BooleanComparisonExp!
}

input servicesAggregateBoolExpCount {
  arguments: [ServicesSelectColumn!]
  distinct: Boolean
  filter: ServicesBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): [AdjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [AdjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AdjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): AdjustmentRulesAggregate!
  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustmentRulesByPk(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): AdjustmentRules
  """
  fetch data from the table in a streaming manner: "adjustment_rules"
  """
  adjustmentRulesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AdjustmentRulesStreamCursorInput]!
    """filter the rows returned"""
    where: AdjustmentRulesBoolExp
  ): [AdjustmentRules!]!
  """
  fetch data from the table: "app_settings"
  """
  appSettings(
    """distinct select on columns"""
    distinctOn: [AppSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AppSettingsOrderBy!]
    """filter the rows returned"""
    where: AppSettingsBoolExp
  ): [AppSettings!]!
  """
  fetch aggregated fields from the table: "app_settings"
  """
  appSettingsAggregate(
    """distinct select on columns"""
    distinctOn: [AppSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AppSettingsOrderBy!]
    """filter the rows returned"""
    where: AppSettingsBoolExp
  ): AppSettingsAggregate!
  """fetch data from the table: "app_settings" using primary key columns"""
  appSettingsByPk(
    """Unique identifier for application setting"""
    id: String!
  ): AppSettings
  """
  fetch data from the table in a streaming manner: "app_settings"
  """
  appSettingsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AppSettingsStreamCursorInput]!
    """filter the rows returned"""
    where: AppSettingsBoolExp
  ): [AppSettings!]!
  """
  fetch data from the table: "audit.audit_log"
  """
  auditAuditLog(
    """distinct select on columns"""
    distinctOn: [AuditAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuditLogOrderBy!]
    """filter the rows returned"""
    where: AuditAuditLogBoolExp
  ): [AuditAuditLog!]!
  """
  fetch aggregated fields from the table: "audit.audit_log"
  """
  auditAuditLogAggregate(
    """distinct select on columns"""
    distinctOn: [AuditAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuditLogOrderBy!]
    """filter the rows returned"""
    where: AuditAuditLogBoolExp
  ): AuditAuditLogAggregate!
  """fetch data from the table: "audit.audit_log" using primary key columns"""
  auditAuditLogByPk(id: uuid!): AuditAuditLog
  """
  fetch data from the table in a streaming manner: "audit.audit_log"
  """
  auditAuditLogStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuditAuditLogStreamCursorInput]!
    """filter the rows returned"""
    where: AuditAuditLogBoolExp
  ): [AuditAuditLog!]!
  """
  fetch data from the table: "audit.auth_events"
  """
  auditAuthEvents(
    """distinct select on columns"""
    distinctOn: [AuditAuthEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuthEventsOrderBy!]
    """filter the rows returned"""
    where: AuditAuthEventsBoolExp
  ): [AuditAuthEvents!]!
  """
  fetch aggregated fields from the table: "audit.auth_events"
  """
  auditAuthEventsAggregate(
    """distinct select on columns"""
    distinctOn: [AuditAuthEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditAuthEventsOrderBy!]
    """filter the rows returned"""
    where: AuditAuthEventsBoolExp
  ): AuditAuthEventsAggregate!
  """
  fetch data from the table: "audit.auth_events" using primary key columns
  """
  auditAuthEventsByPk(id: uuid!): AuditAuthEvents
  """
  fetch data from the table in a streaming manner: "audit.auth_events"
  """
  auditAuthEventsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuditAuthEventsStreamCursorInput]!
    """filter the rows returned"""
    where: AuditAuthEventsBoolExp
  ): [AuditAuthEvents!]!
  """
  fetch data from the table: "audit.data_access_log"
  """
  auditDataAccessLog(
    """distinct select on columns"""
    distinctOn: [AuditDataAccessLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditDataAccessLogOrderBy!]
    """filter the rows returned"""
    where: AuditDataAccessLogBoolExp
  ): [AuditDataAccessLog!]!
  """
  fetch aggregated fields from the table: "audit.data_access_log"
  """
  auditDataAccessLogAggregate(
    """distinct select on columns"""
    distinctOn: [AuditDataAccessLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditDataAccessLogOrderBy!]
    """filter the rows returned"""
    where: AuditDataAccessLogBoolExp
  ): AuditDataAccessLogAggregate!
  """
  fetch data from the table: "audit.data_access_log" using primary key columns
  """
  auditDataAccessLogByPk(id: uuid!): AuditDataAccessLog
  """
  fetch data from the table in a streaming manner: "audit.data_access_log"
  """
  auditDataAccessLogStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuditDataAccessLogStreamCursorInput]!
    """filter the rows returned"""
    where: AuditDataAccessLogBoolExp
  ): [AuditDataAccessLog!]!
  """
  fetch data from the table: "audit.permission_changes"
  """
  auditPermissionChanges(
    """distinct select on columns"""
    distinctOn: [AuditPermissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionChangesOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionChangesBoolExp
  ): [AuditPermissionChanges!]!
  """
  fetch aggregated fields from the table: "audit.permission_changes"
  """
  auditPermissionChangesAggregate(
    """distinct select on columns"""
    distinctOn: [AuditPermissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionChangesOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionChangesBoolExp
  ): AuditPermissionChangesAggregate!
  """
  fetch data from the table: "audit.permission_changes" using primary key columns
  """
  auditPermissionChangesByPk(id: uuid!): AuditPermissionChanges
  """
  fetch data from the table in a streaming manner: "audit.permission_changes"
  """
  auditPermissionChangesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuditPermissionChangesStreamCursorInput]!
    """filter the rows returned"""
    where: AuditPermissionChangesBoolExp
  ): [AuditPermissionChanges!]!
  """
  fetch data from the table: "audit.permission_usage_report"
  """
  auditPermissionUsageReport(
    """distinct select on columns"""
    distinctOn: [AuditPermissionUsageReportSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionUsageReportOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionUsageReportBoolExp
  ): [AuditPermissionUsageReport!]!
  """
  fetch aggregated fields from the table: "audit.permission_usage_report"
  """
  auditPermissionUsageReportAggregate(
    """distinct select on columns"""
    distinctOn: [AuditPermissionUsageReportSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditPermissionUsageReportOrderBy!]
    """filter the rows returned"""
    where: AuditPermissionUsageReportBoolExp
  ): AuditPermissionUsageReportAggregate!
  """
  fetch data from the table in a streaming manner: "audit.permission_usage_report"
  """
  auditPermissionUsageReportStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuditPermissionUsageReportStreamCursorInput]!
    """filter the rows returned"""
    where: AuditPermissionUsageReportBoolExp
  ): [AuditPermissionUsageReport!]!
  """
  fetch data from the table: "audit.slow_queries"
  """
  auditSlowQueries(
    """distinct select on columns"""
    distinctOn: [AuditSlowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditSlowQueriesOrderBy!]
    """filter the rows returned"""
    where: AuditSlowQueriesBoolExp
  ): [AuditSlowQueries!]!
  """
  fetch aggregated fields from the table: "audit.slow_queries"
  """
  auditSlowQueriesAggregate(
    """distinct select on columns"""
    distinctOn: [AuditSlowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditSlowQueriesOrderBy!]
    """filter the rows returned"""
    where: AuditSlowQueriesBoolExp
  ): AuditSlowQueriesAggregate!
  """
  fetch data from the table: "audit.slow_queries" using primary key columns
  """
  auditSlowQueriesByPk(id: uuid!): AuditSlowQueries
  """
  fetch data from the table in a streaming manner: "audit.slow_queries"
  """
  auditSlowQueriesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuditSlowQueriesStreamCursorInput]!
    """filter the rows returned"""
    where: AuditSlowQueriesBoolExp
  ): [AuditSlowQueries!]!
  """
  fetch data from the table: "audit.user_access_summary"
  """
  auditUserAccessSummary(
    """distinct select on columns"""
    distinctOn: [AuditUserAccessSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditUserAccessSummaryOrderBy!]
    """filter the rows returned"""
    where: AuditUserAccessSummaryBoolExp
  ): [AuditUserAccessSummary!]!
  """
  fetch aggregated fields from the table: "audit.user_access_summary"
  """
  auditUserAccessSummaryAggregate(
    """distinct select on columns"""
    distinctOn: [AuditUserAccessSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuditUserAccessSummaryOrderBy!]
    """filter the rows returned"""
    where: AuditUserAccessSummaryBoolExp
  ): AuditUserAccessSummaryAggregate!
  """
  fetch data from the table in a streaming manner: "audit.user_access_summary"
  """
  auditUserAccessSummaryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuditUserAccessSummaryStreamCursorInput]!
    """filter the rows returned"""
    where: AuditUserAccessSummaryBoolExp
  ): [AuditUserAccessSummary!]!
  """
  fetch data from the table: "billing_automation_metrics"
  """
  billingAutomationMetrics(
    """distinct select on columns"""
    distinctOn: [BillingAutomationMetricsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingAutomationMetricsOrderBy!]
    """filter the rows returned"""
    where: BillingAutomationMetricsBoolExp
  ): [BillingAutomationMetrics!]!
  """
  fetch aggregated fields from the table: "billing_automation_metrics"
  """
  billingAutomationMetricsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingAutomationMetricsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingAutomationMetricsOrderBy!]
    """filter the rows returned"""
    where: BillingAutomationMetricsBoolExp
  ): BillingAutomationMetricsAggregate!
  """
  fetch data from the table in a streaming manner: "billing_automation_metrics"
  """
  billingAutomationMetricsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [BillingAutomationMetricsStreamCursorInput]!
    """filter the rows returned"""
    where: BillingAutomationMetricsBoolExp
  ): [BillingAutomationMetrics!]!
  """
  fetch data from the table: "billing_event_log"
  """
  billingEventLog(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): [BillingEventLog!]!
  """
  fetch aggregated fields from the table: "billing_event_log"
  """
  billingEventLogAggregate(
    """distinct select on columns"""
    distinctOn: [BillingEventLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingEventLogOrderBy!]
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): BillingEventLogAggregate!
  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billingEventLogByPk(id: uuid!): BillingEventLog
  """
  fetch data from the table in a streaming manner: "billing_event_log"
  """
  billingEventLogStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [BillingEventLogStreamCursorInput]!
    """filter the rows returned"""
    where: BillingEventLogBoolExp
  ): [BillingEventLog!]!
  """
  fetch data from the table: "billing_invoice"
  """
  billingInvoice(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): [BillingInvoice!]!
  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billingInvoiceAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): BillingInvoiceAggregate!
  """fetch data from the table: "billing_invoice" using primary key columns"""
  billingInvoiceByPk(id: uuid!): BillingInvoice
  """
  fetch data from the table: "billing_invoice_item"
  """
  billingInvoiceItem(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): [BillingInvoiceItem!]!
  """
  fetch aggregated fields from the table: "billing_invoice_item"
  """
  billingInvoiceItemAggregate(
    """distinct select on columns"""
    distinctOn: [BillingInvoiceItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingInvoiceItemOrderBy!]
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): BillingInvoiceItemAggregate!
  """
  fetch data from the table: "billing_invoice_item" using primary key columns
  """
  billingInvoiceItemByPk(id: uuid!): BillingInvoiceItem
  """
  fetch data from the table in a streaming manner: "billing_invoice_item"
  """
  billingInvoiceItemStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [BillingInvoiceItemStreamCursorInput]!
    """filter the rows returned"""
    where: BillingInvoiceItemBoolExp
  ): [BillingInvoiceItem!]!
  """
  fetch data from the table in a streaming manner: "billing_invoice"
  """
  billingInvoiceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [BillingInvoiceStreamCursorInput]!
    """filter the rows returned"""
    where: BillingInvoiceBoolExp
  ): [BillingInvoice!]!
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingItemsOrderBy!]
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): BillingItemsAggregate!
  """fetch data from the table: "billing_items" using primary key columns"""
  billingItemsByPk(id: uuid!): BillingItems
  """
  fetch data from the table in a streaming manner: "billing_items"
  """
  billingItemsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [BillingItemsStreamCursorInput]!
    """filter the rows returned"""
    where: BillingItemsBoolExp
  ): [BillingItems!]!
  """An array relationship"""
  billingPeriods(
    """distinct select on columns"""
    distinctOn: [BillingPeriodsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingPeriodsOrderBy!]
    """filter the rows returned"""
    where: BillingPeriodsBoolExp
  ): [BillingPeriods!]!
  """An aggregate relationship"""
  billingPeriodsAggregate(
    """distinct select on columns"""
    distinctOn: [BillingPeriodsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [BillingPeriodsOrderBy!]
    """filter the rows returned"""
    where: BillingPeriodsBoolExp
  ): BillingPeriodsAggregate!
  """fetch data from the table: "billing_periods" using primary key columns"""
  billingPeriodsByPk(id: uuid!): BillingPeriods
  """
  fetch data from the table in a streaming manner: "billing_periods"
  """
  billingPeriodsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [BillingPeriodsStreamCursorInput]!
    """filter the rows returned"""
    where: BillingPeriodsBoolExp
  ): [BillingPeriods!]!
  """An array relationship"""
  clientExternalSystems(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): [ClientExternalSystems!]!
  """An aggregate relationship"""
  clientExternalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): ClientExternalSystemsAggregate!
  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  clientExternalSystemsByPk(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): ClientExternalSystems
  """
  fetch data from the table in a streaming manner: "client_external_systems"
  """
  clientExternalSystemsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ClientExternalSystemsStreamCursorInput]!
    """filter the rows returned"""
    where: ClientExternalSystemsBoolExp
  ): [ClientExternalSystems!]!
  """
  fetch data from the table: "client_service_agreements"
  """
  clientServiceAgreements(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): [ClientServiceAgreements!]!
  """
  fetch aggregated fields from the table: "client_service_agreements"
  """
  clientServiceAgreementsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientServiceAgreementsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServiceAgreementsOrderBy!]
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): ClientServiceAgreementsAggregate!
  """
  fetch data from the table: "client_service_agreements" using primary key columns
  """
  clientServiceAgreementsByPk(id: uuid!): ClientServiceAgreements
  """
  fetch data from the table in a streaming manner: "client_service_agreements"
  """
  clientServiceAgreementsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ClientServiceAgreementsStreamCursorInput]!
    """filter the rows returned"""
    where: ClientServiceAgreementsBoolExp
  ): [ClientServiceAgreements!]!
  """
  fetch data from the table: "client_services_with_rates"
  """
  clientServicesWithRates(
    """distinct select on columns"""
    distinctOn: [ClientServicesWithRatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServicesWithRatesOrderBy!]
    """filter the rows returned"""
    where: ClientServicesWithRatesBoolExp
  ): [ClientServicesWithRates!]!
  """
  fetch aggregated fields from the table: "client_services_with_rates"
  """
  clientServicesWithRatesAggregate(
    """distinct select on columns"""
    distinctOn: [ClientServicesWithRatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientServicesWithRatesOrderBy!]
    """filter the rows returned"""
    where: ClientServicesWithRatesBoolExp
  ): ClientServicesWithRatesAggregate!
  """
  fetch data from the table in a streaming manner: "client_services_with_rates"
  """
  clientServicesWithRatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ClientServicesWithRatesStreamCursorInput]!
    """filter the rows returned"""
    where: ClientServicesWithRatesBoolExp
  ): [ClientServicesWithRates!]!
  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinctOn: [ClientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientsOrderBy!]
    """filter the rows returned"""
    where: ClientsBoolExp
  ): [Clients!]!
  """
  fetch aggregated fields from the table: "clients"
  """
  clientsAggregate(
    """distinct select on columns"""
    distinctOn: [ClientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClientsOrderBy!]
    """filter the rows returned"""
    where: ClientsBoolExp
  ): ClientsAggregate!
  """fetch data from the table: "clients" using primary key columns"""
  clientsByPk(
    """Unique identifier for the client"""
    id: uuid!
  ): Clients
  """
  fetch data from the table in a streaming manner: "clients"
  """
  clientsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ClientsStreamCursorInput]!
    """filter the rows returned"""
    where: ClientsBoolExp
  ): [Clients!]!
  """
  fetch data from the table: "consultant_capacity_overview"
  """
  consultantCapacityOverview(
    """distinct select on columns"""
    distinctOn: [ConsultantCapacityOverviewSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ConsultantCapacityOverviewOrderBy!]
    """filter the rows returned"""
    where: ConsultantCapacityOverviewBoolExp
  ): [ConsultantCapacityOverview!]!
  """
  fetch aggregated fields from the table: "consultant_capacity_overview"
  """
  consultantCapacityOverviewAggregate(
    """distinct select on columns"""
    distinctOn: [ConsultantCapacityOverviewSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ConsultantCapacityOverviewOrderBy!]
    """filter the rows returned"""
    where: ConsultantCapacityOverviewBoolExp
  ): ConsultantCapacityOverviewAggregate!
  """
  fetch data from the table in a streaming manner: "consultant_capacity_overview"
  """
  consultantCapacityOverviewStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ConsultantCapacityOverviewStreamCursorInput]!
    """filter the rows returned"""
    where: ConsultantCapacityOverviewBoolExp
  ): [ConsultantCapacityOverview!]!
  """
  fetch data from the table: "current_payrolls"
  """
  currentPayrolls(
    """distinct select on columns"""
    distinctOn: [CurrentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentPayrollsOrderBy!]
    """filter the rows returned"""
    where: CurrentPayrollsBoolExp
  ): [CurrentPayrolls!]!
  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  currentPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [CurrentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentPayrollsOrderBy!]
    """filter the rows returned"""
    where: CurrentPayrollsBoolExp
  ): CurrentPayrollsAggregate!
  """
  fetch data from the table in a streaming manner: "current_payrolls"
  """
  currentPayrollsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [CurrentPayrollsStreamCursorInput]!
    """filter the rows returned"""
    where: CurrentPayrollsBoolExp
  ): [CurrentPayrolls!]!
  """An array relationship"""
  dataBackups(
    """distinct select on columns"""
    distinctOn: [DataBackupsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DataBackupsOrderBy!]
    """filter the rows returned"""
    where: DataBackupsBoolExp
  ): [DataBackups!]!
  """An aggregate relationship"""
  dataBackupsAggregate(
    """distinct select on columns"""
    distinctOn: [DataBackupsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DataBackupsOrderBy!]
    """filter the rows returned"""
    where: DataBackupsBoolExp
  ): DataBackupsAggregate!
  """fetch data from the table: "data_backups" using primary key columns"""
  dataBackupsByPk(id: uuid!): DataBackups
  """
  fetch data from the table in a streaming manner: "data_backups"
  """
  dataBackupsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [DataBackupsStreamCursorInput]!
    """filter the rows returned"""
    where: DataBackupsBoolExp
  ): [DataBackups!]!
  """An array relationship"""
  emailDrafts(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): [EmailDrafts!]!
  """An aggregate relationship"""
  emailDraftsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailDraftsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailDraftsOrderBy!]
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): EmailDraftsAggregate!
  """fetch data from the table: "email_drafts" using primary key columns"""
  emailDraftsByPk(id: uuid!): EmailDrafts
  """
  fetch data from the table in a streaming manner: "email_drafts"
  """
  emailDraftsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EmailDraftsStreamCursorInput]!
    """filter the rows returned"""
    where: EmailDraftsBoolExp
  ): [EmailDrafts!]!
  """An array relationship"""
  emailSendLogs(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): [EmailSendLogs!]!
  """An aggregate relationship"""
  emailSendLogsAggregate(
    """distinct select on columns"""
    distinctOn: [EmailSendLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailSendLogsOrderBy!]
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): EmailSendLogsAggregate!
  """fetch data from the table: "email_send_logs" using primary key columns"""
  emailSendLogsByPk(id: uuid!): EmailSendLogs
  """
  fetch data from the table in a streaming manner: "email_send_logs"
  """
  emailSendLogsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EmailSendLogsStreamCursorInput]!
    """filter the rows returned"""
    where: EmailSendLogsBoolExp
  ): [EmailSendLogs!]!
  """
  fetch data from the table: "email_templates"
  """
  emailTemplates(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): [EmailTemplates!]!
  """
  fetch aggregated fields from the table: "email_templates"
  """
  emailTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [EmailTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EmailTemplatesOrderBy!]
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): EmailTemplatesAggregate!
  """fetch data from the table: "email_templates" using primary key columns"""
  emailTemplatesByPk(id: uuid!): EmailTemplates
  """
  fetch data from the table in a streaming manner: "email_templates"
  """
  emailTemplatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EmailTemplatesStreamCursorInput]!
    """filter the rows returned"""
    where: EmailTemplatesBoolExp
  ): [EmailTemplates!]!
  """
  fetch data from the table: "external_systems"
  """
  externalSystems(
    """distinct select on columns"""
    distinctOn: [ExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ExternalSystemsBoolExp
  ): [ExternalSystems!]!
  """
  fetch aggregated fields from the table: "external_systems"
  """
  externalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [ExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: ExternalSystemsBoolExp
  ): ExternalSystemsAggregate!
  """
  fetch data from the table: "external_systems" using primary key columns
  """
  externalSystemsByPk(
    """Unique identifier for the external system"""
    id: uuid!
  ): ExternalSystems
  """
  fetch data from the table in a streaming manner: "external_systems"
  """
  externalSystemsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ExternalSystemsStreamCursorInput]!
    """filter the rows returned"""
    where: ExternalSystemsBoolExp
  ): [ExternalSystems!]!
  """
  fetch data from the table: "feature_flags"
  """
  featureFlags(
    """distinct select on columns"""
    distinctOn: [FeatureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FeatureFlagsOrderBy!]
    """filter the rows returned"""
    where: FeatureFlagsBoolExp
  ): [FeatureFlags!]!
  """
  fetch aggregated fields from the table: "feature_flags"
  """
  featureFlagsAggregate(
    """distinct select on columns"""
    distinctOn: [FeatureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FeatureFlagsOrderBy!]
    """filter the rows returned"""
    where: FeatureFlagsBoolExp
  ): FeatureFlagsAggregate!
  """fetch data from the table: "feature_flags" using primary key columns"""
  featureFlagsByPk(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): FeatureFlags
  """
  fetch data from the table in a streaming manner: "feature_flags"
  """
  featureFlagsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [FeatureFlagsStreamCursorInput]!
    """filter the rows returned"""
    where: FeatureFlagsBoolExp
  ): [FeatureFlags!]!
  """An array relationship"""
  files(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): [Files!]!
  """An aggregate relationship"""
  filesAggregate(
    """distinct select on columns"""
    distinctOn: [FilesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [FilesOrderBy!]
    """filter the rows returned"""
    where: FilesBoolExp
  ): FilesAggregate!
  """fetch data from the table: "files" using primary key columns"""
  filesByPk(id: uuid!): Files
  """
  fetch data from the table in a streaming manner: "files"
  """
  filesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [FilesStreamCursorInput]!
    """filter the rows returned"""
    where: FilesBoolExp
  ): [Files!]!
  """
  execute function "get_latest_payroll_version" which returns "latest_payroll_version_results"
  """
  getLatestPayrollVersion(
    """
    input parameters for function "getLatestPayrollVersion"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): [LatestPayrollVersionResults!]!
  """
  execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results"
  """
  getLatestPayrollVersionAggregate(
    """
    input parameters for function "getLatestPayrollVersionAggregate"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): LatestPayrollVersionResultsAggregate!
  """
  execute function "get_payroll_version_history" which returns "payroll_version_history_results"
  """
  getPayrollVersionHistory(
    """
    input parameters for function "getPayrollVersionHistory"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): [PayrollVersionHistoryResults!]!
  """
  execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results"
  """
  getPayrollVersionHistoryAggregate(
    """
    input parameters for function "getPayrollVersionHistoryAggregate"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): PayrollVersionHistoryResultsAggregate!
  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinctOn: [HolidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [HolidaysOrderBy!]
    """filter the rows returned"""
    where: HolidaysBoolExp
  ): [Holidays!]!
  """
  fetch aggregated fields from the table: "holidays"
  """
  holidaysAggregate(
    """distinct select on columns"""
    distinctOn: [HolidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [HolidaysOrderBy!]
    """filter the rows returned"""
    where: HolidaysBoolExp
  ): HolidaysAggregate!
  """fetch data from the table: "holidays" using primary key columns"""
  holidaysByPk(
    """Unique identifier for the holiday"""
    id: uuid!
  ): Holidays
  """
  fetch data from the table in a streaming manner: "holidays"
  """
  holidaysStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [HolidaysStreamCursorInput]!
    """filter the rows returned"""
    where: HolidaysBoolExp
  ): [Holidays!]!
  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResults(
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): [LatestPayrollVersionResults!]!
  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [LatestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LatestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): LatestPayrollVersionResultsAggregate!
  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latestPayrollVersionResultsByPk(id: uuid!): LatestPayrollVersionResults
  """
  fetch data from the table in a streaming manner: "latest_payroll_version_results"
  """
  latestPayrollVersionResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [LatestPayrollVersionResultsStreamCursorInput]!
    """filter the rows returned"""
    where: LatestPayrollVersionResultsBoolExp
  ): [LatestPayrollVersionResults!]!
  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinctOn: [LeaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LeaveOrderBy!]
    """filter the rows returned"""
    where: LeaveBoolExp
  ): [Leave!]!
  """
  fetch aggregated fields from the table: "leave"
  """
  leaveAggregate(
    """distinct select on columns"""
    distinctOn: [LeaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [LeaveOrderBy!]
    """filter the rows returned"""
    where: LeaveBoolExp
  ): LeaveAggregate!
  """fetch data from the table: "leave" using primary key columns"""
  leaveByPk(
    """Unique identifier for the leave record"""
    id: uuid!
  ): Leave
  """
  fetch data from the table in a streaming manner: "leave"
  """
  leaveStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [LeaveStreamCursorInput]!
    """filter the rows returned"""
    where: LeaveBoolExp
  ): [Leave!]!
  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinctOn: [NotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [NotesOrderBy!]
    """filter the rows returned"""
    where: NotesBoolExp
  ): [Notes!]!
  """
  fetch aggregated fields from the table: "notes"
  """
  notesAggregate(
    """distinct select on columns"""
    distinctOn: [NotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [NotesOrderBy!]
    """filter the rows returned"""
    where: NotesBoolExp
  ): NotesAggregate!
  """fetch data from the table: "notes" using primary key columns"""
  notesByPk(
    """Unique identifier for the note"""
    id: uuid!
  ): Notes
  """
  fetch data from the table in a streaming manner: "notes"
  """
  notesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [NotesStreamCursorInput]!
    """filter the rows returned"""
    where: NotesBoolExp
  ): [Notes!]!
  """
  fetch data from the table: "payroll_activation_results"
  """
  payrollActivationResults(
    """distinct select on columns"""
    distinctOn: [PayrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollActivationResultsBoolExp
  ): [PayrollActivationResults!]!
  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payrollActivationResultsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollActivationResultsBoolExp
  ): PayrollActivationResultsAggregate!
  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payrollActivationResultsByPk(id: uuid!): PayrollActivationResults
  """
  fetch data from the table in a streaming manner: "payroll_activation_results"
  """
  payrollActivationResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollActivationResultsStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollActivationResultsBoolExp
  ): [PayrollActivationResults!]!
  """
  fetch data from the table: "payroll_assignment_audit"
  """
  payrollAssignmentAudit(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """
  fetch aggregated fields from the table: "payroll_assignment_audit"
  """
  payrollAssignmentAuditAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentAuditSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentAuditOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): PayrollAssignmentAuditAggregate!
  """
  fetch data from the table: "payroll_assignment_audit" using primary key columns
  """
  payrollAssignmentAuditByPk(id: uuid!): PayrollAssignmentAudit
  """
  fetch data from the table in a streaming manner: "payroll_assignment_audit"
  """
  payrollAssignmentAuditStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollAssignmentAuditStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollAssignmentAuditBoolExp
  ): [PayrollAssignmentAudit!]!
  """
  fetch data from the table: "payroll_assignments"
  """
  payrollAssignments(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): [PayrollAssignments!]!
  """
  fetch aggregated fields from the table: "payroll_assignments"
  """
  payrollAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): PayrollAssignmentsAggregate!
  """
  fetch data from the table: "payroll_assignments" using primary key columns
  """
  payrollAssignmentsByPk(id: uuid!): PayrollAssignments
  """
  fetch data from the table in a streaming manner: "payroll_assignments"
  """
  payrollAssignmentsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollAssignmentsStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollAssignmentsBoolExp
  ): [PayrollAssignments!]!
  """
  fetch data from the table: "payroll_cycles"
  """
  payrollCycles(
    """distinct select on columns"""
    distinctOn: [PayrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollCyclesOrderBy!]
    """filter the rows returned"""
    where: PayrollCyclesBoolExp
  ): [PayrollCycles!]!
  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payrollCyclesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollCyclesOrderBy!]
    """filter the rows returned"""
    where: PayrollCyclesBoolExp
  ): PayrollCyclesAggregate!
  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payrollCyclesByPk(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): PayrollCycles
  """
  fetch data from the table in a streaming manner: "payroll_cycles"
  """
  payrollCyclesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollCyclesStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollCyclesBoolExp
  ): [PayrollCycles!]!
  """
  fetch data from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStats(
    """distinct select on columns"""
    distinctOn: [PayrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: PayrollDashboardStatsBoolExp
  ): [PayrollDashboardStats!]!
  """
  fetch aggregated fields from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStatsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: PayrollDashboardStatsBoolExp
  ): PayrollDashboardStatsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_dashboard_stats"
  """
  payrollDashboardStatsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollDashboardStatsStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollDashboardStatsBoolExp
  ): [PayrollDashboardStats!]!
  """
  fetch data from the table: "payroll_date_types"
  """
  payrollDateTypes(
    """distinct select on columns"""
    distinctOn: [PayrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: PayrollDateTypesBoolExp
  ): [PayrollDateTypes!]!
  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payrollDateTypesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: PayrollDateTypesBoolExp
  ): PayrollDateTypesAggregate!
  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payrollDateTypesByPk(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): PayrollDateTypes
  """
  fetch data from the table in a streaming manner: "payroll_date_types"
  """
  payrollDateTypesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollDateTypesStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollDateTypesBoolExp
  ): [PayrollDateTypes!]!
  """An array relationship"""
  payrollDates(
    """distinct select on columns"""
    distinctOn: [PayrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDatesOrderBy!]
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): [PayrollDates!]!
  """An aggregate relationship"""
  payrollDatesAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollDatesOrderBy!]
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): PayrollDatesAggregate!
  """fetch data from the table: "payroll_dates" using primary key columns"""
  payrollDatesByPk(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): PayrollDates
  """
  fetch data from the table in a streaming manner: "payroll_dates"
  """
  payrollDatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollDatesStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollDatesBoolExp
  ): [PayrollDates!]!
  """
  fetch data from the table: "payroll_profitability"
  """
  payrollProfitability(
    """distinct select on columns"""
    distinctOn: [PayrollProfitabilitySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollProfitabilityOrderBy!]
    """filter the rows returned"""
    where: PayrollProfitabilityBoolExp
  ): [PayrollProfitability!]!
  """
  fetch aggregated fields from the table: "payroll_profitability"
  """
  payrollProfitabilityAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollProfitabilitySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollProfitabilityOrderBy!]
    """filter the rows returned"""
    where: PayrollProfitabilityBoolExp
  ): PayrollProfitabilityAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_profitability"
  """
  payrollProfitabilityStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollProfitabilityStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollProfitabilityBoolExp
  ): [PayrollProfitability!]!
  """
  fetch data from the table: "payroll_required_skills"
  """
  payrollRequiredSkills(
    """distinct select on columns"""
    distinctOn: [PayrollRequiredSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollRequiredSkillsOrderBy!]
    """filter the rows returned"""
    where: PayrollRequiredSkillsBoolExp
  ): [PayrollRequiredSkills!]!
  """
  fetch aggregated fields from the table: "payroll_required_skills"
  """
  payrollRequiredSkillsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollRequiredSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollRequiredSkillsOrderBy!]
    """filter the rows returned"""
    where: PayrollRequiredSkillsBoolExp
  ): PayrollRequiredSkillsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_required_skills"
  """
  payrollRequiredSkillsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollRequiredSkillsStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollRequiredSkillsBoolExp
  ): [PayrollRequiredSkills!]!
  """
  fetch data from the table: "payroll_triggers_status"
  """
  payrollTriggersStatus(
    """distinct select on columns"""
    distinctOn: [PayrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: PayrollTriggersStatusBoolExp
  ): [PayrollTriggersStatus!]!
  """
  fetch aggregated fields from the table: "payroll_triggers_status"
  """
  payrollTriggersStatusAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: PayrollTriggersStatusBoolExp
  ): PayrollTriggersStatusAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_triggers_status"
  """
  payrollTriggersStatusStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollTriggersStatusStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollTriggersStatusBoolExp
  ): [PayrollTriggersStatus!]!
  """
  fetch data from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResults(
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): [PayrollVersionHistoryResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResultsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): PayrollVersionHistoryResultsAggregate!
  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payrollVersionHistoryResultsByPk(id: uuid!): PayrollVersionHistoryResults
  """
  fetch data from the table in a streaming manner: "payroll_version_history_results"
  """
  payrollVersionHistoryResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollVersionHistoryResultsStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollVersionHistoryResultsBoolExp
  ): [PayrollVersionHistoryResults!]!
  """
  fetch data from the table: "payroll_version_results"
  """
  payrollVersionResults(
    """distinct select on columns"""
    distinctOn: [PayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionResultsBoolExp
  ): [PayrollVersionResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: PayrollVersionResultsBoolExp
  ): PayrollVersionResultsAggregate!
  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payrollVersionResultsByPk(id: uuid!): PayrollVersionResults
  """
  fetch data from the table in a streaming manner: "payroll_version_results"
  """
  payrollVersionResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollVersionResultsStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollVersionResultsBoolExp
  ): [PayrollVersionResults!]!
  """
  fetch data from the table: "payroll_workload_distribution"
  """
  payrollWorkloadDistribution(
    """distinct select on columns"""
    distinctOn: [PayrollWorkloadDistributionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollWorkloadDistributionOrderBy!]
    """filter the rows returned"""
    where: PayrollWorkloadDistributionBoolExp
  ): [PayrollWorkloadDistribution!]!
  """
  fetch aggregated fields from the table: "payroll_workload_distribution"
  """
  payrollWorkloadDistributionAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollWorkloadDistributionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollWorkloadDistributionOrderBy!]
    """filter the rows returned"""
    where: PayrollWorkloadDistributionBoolExp
  ): PayrollWorkloadDistributionAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_workload_distribution"
  """
  payrollWorkloadDistributionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollWorkloadDistributionStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollWorkloadDistributionBoolExp
  ): [PayrollWorkloadDistribution!]!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [PayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PayrollsOrderBy!]
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): PayrollsAggregate!
  """fetch data from the table: "payrolls" using primary key columns"""
  payrollsByPk(
    """Unique identifier for the payroll"""
    id: uuid!
  ): Payrolls
  """
  fetch data from the table in a streaming manner: "payrolls"
  """
  payrollsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PayrollsStreamCursorInput]!
    """filter the rows returned"""
    where: PayrollsBoolExp
  ): [Payrolls!]!
  """
  fetch data from the table: "pending_billing_approvals"
  """
  pendingBillingApprovals(
    """distinct select on columns"""
    distinctOn: [PendingBillingApprovalsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PendingBillingApprovalsOrderBy!]
    """filter the rows returned"""
    where: PendingBillingApprovalsBoolExp
  ): [PendingBillingApprovals!]!
  """
  fetch aggregated fields from the table: "pending_billing_approvals"
  """
  pendingBillingApprovalsAggregate(
    """distinct select on columns"""
    distinctOn: [PendingBillingApprovalsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PendingBillingApprovalsOrderBy!]
    """filter the rows returned"""
    where: PendingBillingApprovalsBoolExp
  ): PendingBillingApprovalsAggregate!
  """
  fetch data from the table in a streaming manner: "pending_billing_approvals"
  """
  pendingBillingApprovalsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PendingBillingApprovalsStreamCursorInput]!
    """filter the rows returned"""
    where: PendingBillingApprovalsBoolExp
  ): [PendingBillingApprovals!]!
  """
  fetch data from the table: "permission_audit_log"
  """
  permissionAuditLog(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): [PermissionAuditLog!]!
  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permissionAuditLogAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionAuditLogSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionAuditLogOrderBy!]
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): PermissionAuditLogAggregate!
  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permissionAuditLogByPk(id: uuid!): PermissionAuditLog
  """
  fetch data from the table in a streaming manner: "permission_audit_log"
  """
  permissionAuditLogStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PermissionAuditLogStreamCursorInput]!
    """filter the rows returned"""
    where: PermissionAuditLogBoolExp
  ): [PermissionAuditLog!]!
  """An array relationship"""
  permissionOverrides(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): [PermissionOverrides!]!
  """An aggregate relationship"""
  permissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionOverridesOrderBy!]
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): PermissionOverridesAggregate!
  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permissionOverridesByPk(id: uuid!): PermissionOverrides
  """
  fetch data from the table in a streaming manner: "permission_overrides"
  """
  permissionOverridesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PermissionOverridesStreamCursorInput]!
    """filter the rows returned"""
    where: PermissionOverridesBoolExp
  ): [PermissionOverrides!]!
  """An array relationship"""
  permissions(
    """distinct select on columns"""
    distinctOn: [PermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionsOrderBy!]
    """filter the rows returned"""
    where: PermissionsBoolExp
  ): [Permissions!]!
  """An aggregate relationship"""
  permissionsAggregate(
    """distinct select on columns"""
    distinctOn: [PermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PermissionsOrderBy!]
    """filter the rows returned"""
    where: PermissionsBoolExp
  ): PermissionsAggregate!
  """fetch data from the table: "permissions" using primary key columns"""
  permissionsByPk(id: uuid!): Permissions
  """
  fetch data from the table in a streaming manner: "permissions"
  """
  permissionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PermissionsStreamCursorInput]!
    """filter the rows returned"""
    where: PermissionsBoolExp
  ): [Permissions!]!
  """
  fetch data from the table: "position_admin_defaults"
  """
  positionAdminDefaults(
    """distinct select on columns"""
    distinctOn: [PositionAdminDefaultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PositionAdminDefaultsOrderBy!]
    """filter the rows returned"""
    where: PositionAdminDefaultsBoolExp
  ): [PositionAdminDefaults!]!
  """
  fetch aggregated fields from the table: "position_admin_defaults"
  """
  positionAdminDefaultsAggregate(
    """distinct select on columns"""
    distinctOn: [PositionAdminDefaultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PositionAdminDefaultsOrderBy!]
    """filter the rows returned"""
    where: PositionAdminDefaultsBoolExp
  ): PositionAdminDefaultsAggregate!
  """
  fetch data from the table: "position_admin_defaults" using primary key columns
  """
  positionAdminDefaultsByPk(position: user_position!): PositionAdminDefaults
  """
  fetch data from the table in a streaming manner: "position_admin_defaults"
  """
  positionAdminDefaultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PositionAdminDefaultsStreamCursorInput]!
    """filter the rows returned"""
    where: PositionAdminDefaultsBoolExp
  ): [PositionAdminDefaults!]!
  """
  fetch data from the table: "quote_analytics"
  """
  quoteAnalytics(
    """distinct select on columns"""
    distinctOn: [QuoteAnalyticsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteAnalyticsOrderBy!]
    """filter the rows returned"""
    where: QuoteAnalyticsBoolExp
  ): [QuoteAnalytics!]!
  """
  fetch aggregated fields from the table: "quote_analytics"
  """
  quoteAnalyticsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteAnalyticsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteAnalyticsOrderBy!]
    """filter the rows returned"""
    where: QuoteAnalyticsBoolExp
  ): QuoteAnalyticsAggregate!
  """
  fetch data from the table in a streaming manner: "quote_analytics"
  """
  quoteAnalyticsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [QuoteAnalyticsStreamCursorInput]!
    """filter the rows returned"""
    where: QuoteAnalyticsBoolExp
  ): [QuoteAnalytics!]!
  """An array relationship"""
  quoteConversions(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): [QuoteConversions!]!
  """An aggregate relationship"""
  quoteConversionsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteConversionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteConversionsOrderBy!]
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): QuoteConversionsAggregate!
  """
  fetch data from the table: "quote_conversions" using primary key columns
  """
  quoteConversionsByPk(id: uuid!): QuoteConversions
  """
  fetch data from the table in a streaming manner: "quote_conversions"
  """
  quoteConversionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [QuoteConversionsStreamCursorInput]!
    """filter the rows returned"""
    where: QuoteConversionsBoolExp
  ): [QuoteConversions!]!
  """An array relationship"""
  quoteLineItems(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): [QuoteLineItems!]!
  """An aggregate relationship"""
  quoteLineItemsAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteLineItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteLineItemsOrderBy!]
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): QuoteLineItemsAggregate!
  """
  fetch data from the table: "quote_line_items" using primary key columns
  """
  quoteLineItemsByPk(id: uuid!): QuoteLineItems
  """
  fetch data from the table in a streaming manner: "quote_line_items"
  """
  quoteLineItemsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [QuoteLineItemsStreamCursorInput]!
    """filter the rows returned"""
    where: QuoteLineItemsBoolExp
  ): [QuoteLineItems!]!
  """An array relationship"""
  quoteTemplates(
    """distinct select on columns"""
    distinctOn: [QuoteTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteTemplatesOrderBy!]
    """filter the rows returned"""
    where: QuoteTemplatesBoolExp
  ): [QuoteTemplates!]!
  """An aggregate relationship"""
  quoteTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [QuoteTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuoteTemplatesOrderBy!]
    """filter the rows returned"""
    where: QuoteTemplatesBoolExp
  ): QuoteTemplatesAggregate!
  """fetch data from the table: "quote_templates" using primary key columns"""
  quoteTemplatesByPk(id: uuid!): QuoteTemplates
  """
  fetch data from the table in a streaming manner: "quote_templates"
  """
  quoteTemplatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [QuoteTemplatesStreamCursorInput]!
    """filter the rows returned"""
    where: QuoteTemplatesBoolExp
  ): [QuoteTemplates!]!
  """An array relationship"""
  quotes(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): [Quotes!]!
  """An aggregate relationship"""
  quotesAggregate(
    """distinct select on columns"""
    distinctOn: [QuotesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuotesOrderBy!]
    """filter the rows returned"""
    where: QuotesBoolExp
  ): QuotesAggregate!
  """fetch data from the table: "quotes" using primary key columns"""
  quotesByPk(id: uuid!): Quotes
  """
  fetch data from the table in a streaming manner: "quotes"
  """
  quotesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [QuotesStreamCursorInput]!
    """filter the rows returned"""
    where: QuotesBoolExp
  ): [Quotes!]!
  """
  fetch data from the table: "rate_limits"
  """
  rateLimits(
    """distinct select on columns"""
    distinctOn: [RateLimitsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RateLimitsOrderBy!]
    """filter the rows returned"""
    where: RateLimitsBoolExp
  ): [RateLimits!]!
  """
  fetch aggregated fields from the table: "rate_limits"
  """
  rateLimitsAggregate(
    """distinct select on columns"""
    distinctOn: [RateLimitsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RateLimitsOrderBy!]
    """filter the rows returned"""
    where: RateLimitsBoolExp
  ): RateLimitsAggregate!
  """fetch data from the table: "rate_limits" using primary key columns"""
  rateLimitsByPk(id: uuid!): RateLimits
  """
  fetch data from the table in a streaming manner: "rate_limits"
  """
  rateLimitsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [RateLimitsStreamCursorInput]!
    """filter the rows returned"""
    where: RateLimitsBoolExp
  ): [RateLimits!]!
  """
  fetch data from the table: "resources"
  """
  resources(
    """distinct select on columns"""
    distinctOn: [ResourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ResourcesOrderBy!]
    """filter the rows returned"""
    where: ResourcesBoolExp
  ): [Resources!]!
  """
  fetch aggregated fields from the table: "resources"
  """
  resourcesAggregate(
    """distinct select on columns"""
    distinctOn: [ResourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ResourcesOrderBy!]
    """filter the rows returned"""
    where: ResourcesBoolExp
  ): ResourcesAggregate!
  """fetch data from the table: "resources" using primary key columns"""
  resourcesByPk(id: uuid!): Resources
  """
  fetch data from the table in a streaming manner: "resources"
  """
  resourcesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ResourcesStreamCursorInput]!
    """filter the rows returned"""
    where: ResourcesBoolExp
  ): [Resources!]!
  """An array relationship"""
  rolePermissions(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): [RolePermissions!]!
  """An aggregate relationship"""
  rolePermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [RolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolePermissionsOrderBy!]
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): RolePermissionsAggregate!
  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  rolePermissionsByPk(id: uuid!): RolePermissions
  """
  fetch data from the table in a streaming manner: "role_permissions"
  """
  rolePermissionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [RolePermissionsStreamCursorInput]!
    """filter the rows returned"""
    where: RolePermissionsBoolExp
  ): [RolePermissions!]!
  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]
    """filter the rows returned"""
    where: RolesBoolExp
  ): [Roles!]!
  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [RolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RolesOrderBy!]
    """filter the rows returned"""
    where: RolesBoolExp
  ): RolesAggregate!
  """fetch data from the table: "roles" using primary key columns"""
  rolesByPk(id: uuid!): Roles
  """
  fetch data from the table in a streaming manner: "roles"
  """
  rolesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [RolesStreamCursorInput]!
    """filter the rows returned"""
    where: RolesBoolExp
  ): [Roles!]!
  """An array relationship"""
  securityAlerts(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): [SecurityAlerts!]!
  """An aggregate relationship"""
  securityAlertsAggregate(
    """distinct select on columns"""
    distinctOn: [SecurityAlertsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecurityAlertsOrderBy!]
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): SecurityAlertsAggregate!
  """fetch data from the table: "security_alerts" using primary key columns"""
  securityAlertsByPk(id: uuid!): SecurityAlerts
  """
  fetch data from the table in a streaming manner: "security_alerts"
  """
  securityAlertsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [SecurityAlertsStreamCursorInput]!
    """filter the rows returned"""
    where: SecurityAlertsBoolExp
  ): [SecurityAlerts!]!
  """An array relationship"""
  securitySettings(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): [SecuritySettings!]!
  """An aggregate relationship"""
  securitySettingsAggregate(
    """distinct select on columns"""
    distinctOn: [SecuritySettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SecuritySettingsOrderBy!]
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): SecuritySettingsAggregate!
  """
  fetch data from the table: "security_settings" using primary key columns
  """
  securitySettingsByPk(id: uuid!): SecuritySettings
  """
  fetch data from the table in a streaming manner: "security_settings"
  """
  securitySettingsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [SecuritySettingsStreamCursorInput]!
    """filter the rows returned"""
    where: SecuritySettingsBoolExp
  ): [SecuritySettings!]!
  """An array relationship"""
  servicePricingRules(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): [ServicePricingRules!]!
  """An aggregate relationship"""
  servicePricingRulesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicePricingRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicePricingRulesOrderBy!]
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): ServicePricingRulesAggregate!
  """
  fetch data from the table: "service_pricing_rules" using primary key columns
  """
  servicePricingRulesByPk(id: uuid!): ServicePricingRules
  """
  fetch data from the table in a streaming manner: "service_pricing_rules"
  """
  servicePricingRulesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ServicePricingRulesStreamCursorInput]!
    """filter the rows returned"""
    where: ServicePricingRulesBoolExp
  ): [ServicePricingRules!]!
  """
  fetch data from the table: "service_templates"
  """
  serviceTemplates(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): [ServiceTemplates!]!
  """
  fetch aggregated fields from the table: "service_templates"
  """
  serviceTemplatesAggregate(
    """distinct select on columns"""
    distinctOn: [ServiceTemplatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServiceTemplatesOrderBy!]
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): ServiceTemplatesAggregate!
  """
  fetch data from the table: "service_templates" using primary key columns
  """
  serviceTemplatesByPk(id: uuid!): ServiceTemplates
  """
  fetch data from the table in a streaming manner: "service_templates"
  """
  serviceTemplatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ServiceTemplatesStreamCursorInput]!
    """filter the rows returned"""
    where: ServiceTemplatesBoolExp
  ): [ServiceTemplates!]!
  """
  fetch data from the table: "services"
  """
  services(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): [Services!]!
  """
  fetch aggregated fields from the table: "services"
  """
  servicesAggregate(
    """distinct select on columns"""
    distinctOn: [ServicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ServicesOrderBy!]
    """filter the rows returned"""
    where: ServicesBoolExp
  ): ServicesAggregate!
  """fetch data from the table: "services" using primary key columns"""
  servicesByPk(id: uuid!): Services
  """
  fetch data from the table in a streaming manner: "services"
  """
  servicesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ServicesStreamCursorInput]!
    """filter the rows returned"""
    where: ServicesBoolExp
  ): [Services!]!
  """
  fetch data from the table: "staff_billing_performance"
  """
  staffBillingPerformance(
    """distinct select on columns"""
    distinctOn: [StaffBillingPerformanceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [StaffBillingPerformanceOrderBy!]
    """filter the rows returned"""
    where: StaffBillingPerformanceBoolExp
  ): [StaffBillingPerformance!]!
  """
  fetch aggregated fields from the table: "staff_billing_performance"
  """
  staffBillingPerformanceAggregate(
    """distinct select on columns"""
    distinctOn: [StaffBillingPerformanceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [StaffBillingPerformanceOrderBy!]
    """filter the rows returned"""
    where: StaffBillingPerformanceBoolExp
  ): StaffBillingPerformanceAggregate!
  """
  fetch data from the table in a streaming manner: "staff_billing_performance"
  """
  staffBillingPerformanceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [StaffBillingPerformanceStreamCursorInput]!
    """filter the rows returned"""
    where: StaffBillingPerformanceBoolExp
  ): [StaffBillingPerformance!]!
  """
  fetch data from the table: "system_configuration"
  """
  systemConfiguration(
    """distinct select on columns"""
    distinctOn: [SystemConfigurationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemConfigurationOrderBy!]
    """filter the rows returned"""
    where: SystemConfigurationBoolExp
  ): [SystemConfiguration!]!
  """
  fetch aggregated fields from the table: "system_configuration"
  """
  systemConfigurationAggregate(
    """distinct select on columns"""
    distinctOn: [SystemConfigurationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemConfigurationOrderBy!]
    """filter the rows returned"""
    where: SystemConfigurationBoolExp
  ): SystemConfigurationAggregate!
  """
  fetch data from the table: "system_configuration" using primary key columns
  """
  systemConfigurationByPk(id: uuid!): SystemConfiguration
  """
  fetch data from the table in a streaming manner: "system_configuration"
  """
  systemConfigurationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [SystemConfigurationStreamCursorInput]!
    """filter the rows returned"""
    where: SystemConfigurationBoolExp
  ): [SystemConfiguration!]!
  """
  fetch data from the table: "system_health"
  """
  systemHealth(
    """distinct select on columns"""
    distinctOn: [SystemHealthSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemHealthOrderBy!]
    """filter the rows returned"""
    where: SystemHealthBoolExp
  ): [SystemHealth!]!
  """
  fetch aggregated fields from the table: "system_health"
  """
  systemHealthAggregate(
    """distinct select on columns"""
    distinctOn: [SystemHealthSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SystemHealthOrderBy!]
    """filter the rows returned"""
    where: SystemHealthBoolExp
  ): SystemHealthAggregate!
  """fetch data from the table: "system_health" using primary key columns"""
  systemHealthByPk(id: uuid!): SystemHealth
  """
  fetch data from the table in a streaming manner: "system_health"
  """
  systemHealthStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [SystemHealthStreamCursorInput]!
    """filter the rows returned"""
    where: SystemHealthBoolExp
  ): [SystemHealth!]!
  """
  fetch data from the table: "team_capacity_by_position"
  """
  teamCapacityByPosition(
    """distinct select on columns"""
    distinctOn: [TeamCapacityByPositionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TeamCapacityByPositionOrderBy!]
    """filter the rows returned"""
    where: TeamCapacityByPositionBoolExp
  ): [TeamCapacityByPosition!]!
  """
  fetch aggregated fields from the table: "team_capacity_by_position"
  """
  teamCapacityByPositionAggregate(
    """distinct select on columns"""
    distinctOn: [TeamCapacityByPositionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TeamCapacityByPositionOrderBy!]
    """filter the rows returned"""
    where: TeamCapacityByPositionBoolExp
  ): TeamCapacityByPositionAggregate!
  """
  fetch data from the table in a streaming manner: "team_capacity_by_position"
  """
  teamCapacityByPositionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [TeamCapacityByPositionStreamCursorInput]!
    """filter the rows returned"""
    where: TeamCapacityByPositionBoolExp
  ): [TeamCapacityByPosition!]!
  """An array relationship"""
  timeEntries(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """An aggregate relationship"""
  timeEntriesAggregate(
    """distinct select on columns"""
    distinctOn: [TimeEntriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeEntriesOrderBy!]
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): TimeEntriesAggregate!
  """fetch data from the table: "time_entries" using primary key columns"""
  timeEntriesByPk(id: uuid!): TimeEntries
  """
  fetch data from the table in a streaming manner: "time_entries"
  """
  timeEntriesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [TimeEntriesStreamCursorInput]!
    """filter the rows returned"""
    where: TimeEntriesBoolExp
  ): [TimeEntries!]!
  """
  fetch data from the table: "time_tracking_summary"
  """
  timeTrackingSummary(
    """distinct select on columns"""
    distinctOn: [TimeTrackingSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeTrackingSummaryOrderBy!]
    """filter the rows returned"""
    where: TimeTrackingSummaryBoolExp
  ): [TimeTrackingSummary!]!
  """
  fetch aggregated fields from the table: "time_tracking_summary"
  """
  timeTrackingSummaryAggregate(
    """distinct select on columns"""
    distinctOn: [TimeTrackingSummarySelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TimeTrackingSummaryOrderBy!]
    """filter the rows returned"""
    where: TimeTrackingSummaryBoolExp
  ): TimeTrackingSummaryAggregate!
  """
  fetch data from the table in a streaming manner: "time_tracking_summary"
  """
  timeTrackingSummaryStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [TimeTrackingSummaryStreamCursorInput]!
    """filter the rows returned"""
    where: TimeTrackingSummaryBoolExp
  ): [TimeTrackingSummary!]!
  """
  fetch data from the table: "user_email_template_favorites"
  """
  userEmailTemplateFavorites(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): [UserEmailTemplateFavorites!]!
  """
  fetch aggregated fields from the table: "user_email_template_favorites"
  """
  userEmailTemplateFavoritesAggregate(
    """distinct select on columns"""
    distinctOn: [UserEmailTemplateFavoritesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserEmailTemplateFavoritesOrderBy!]
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): UserEmailTemplateFavoritesAggregate!
  """
  fetch data from the table: "user_email_template_favorites" using primary key columns
  """
  userEmailTemplateFavoritesByPk(id: uuid!): UserEmailTemplateFavorites
  """
  fetch data from the table in a streaming manner: "user_email_template_favorites"
  """
  userEmailTemplateFavoritesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserEmailTemplateFavoritesStreamCursorInput]!
    """filter the rows returned"""
    where: UserEmailTemplateFavoritesBoolExp
  ): [UserEmailTemplateFavorites!]!
  """
  fetch data from the table: "user_invitations"
  """
  userInvitations(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): [UserInvitations!]!
  """
  fetch aggregated fields from the table: "user_invitations"
  """
  userInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [UserInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserInvitationsOrderBy!]
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): UserInvitationsAggregate!
  """
  fetch data from the table: "user_invitations" using primary key columns
  """
  userInvitationsByPk(id: uuid!): UserInvitations
  """
  fetch data from the table in a streaming manner: "user_invitations"
  """
  userInvitationsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserInvitationsStreamCursorInput]!
    """filter the rows returned"""
    where: UserInvitationsBoolExp
  ): [UserInvitations!]!
  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): [UserRoles!]!
  """An aggregate relationship"""
  userRolesAggregate(
    """distinct select on columns"""
    distinctOn: [UserRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRolesOrderBy!]
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): UserRolesAggregate!
  """fetch data from the table: "user_roles" using primary key columns"""
  userRolesByPk(id: uuid!): UserRoles
  """
  fetch data from the table in a streaming manner: "user_roles"
  """
  userRolesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserRolesStreamCursorInput]!
    """filter the rows returned"""
    where: UserRolesBoolExp
  ): [UserRoles!]!
  """An array relationship"""
  userSessions(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """An aggregate relationship"""
  userSessionsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): UserSessionsAggregate!
  """fetch data from the table: "user_sessions" using primary key columns"""
  userSessionsByPk(id: uuid!): UserSessions
  """
  fetch data from the table in a streaming manner: "user_sessions"
  """
  userSessionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserSessionsStreamCursorInput]!
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """
  fetch data from the table: "user_skills"
  """
  userSkills(
    """distinct select on columns"""
    distinctOn: [UserSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSkillsOrderBy!]
    """filter the rows returned"""
    where: UserSkillsBoolExp
  ): [UserSkills!]!
  """
  fetch aggregated fields from the table: "user_skills"
  """
  userSkillsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSkillsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSkillsOrderBy!]
    """filter the rows returned"""
    where: UserSkillsBoolExp
  ): UserSkillsAggregate!
  """
  fetch data from the table in a streaming manner: "user_skills"
  """
  userSkillsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserSkillsStreamCursorInput]!
    """filter the rows returned"""
    where: UserSkillsBoolExp
  ): [UserSkills!]!
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): UsersAggregate!
  """fetch data from the table: "users" using primary key columns"""
  usersByPk(
    """Unique identifier for the user"""
    id: uuid!
  ): Users
  """
  fetch data from the table: "users_role_backup"
  """
  usersRoleBackup(
    """distinct select on columns"""
    distinctOn: [UsersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: UsersRoleBackupBoolExp
  ): [UsersRoleBackup!]!
  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  usersRoleBackupAggregate(
    """distinct select on columns"""
    distinctOn: [UsersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: UsersRoleBackupBoolExp
  ): UsersRoleBackupAggregate!
  """
  fetch data from the table in a streaming manner: "users_role_backup"
  """
  usersRoleBackupStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UsersRoleBackupStreamCursorInput]!
    """filter the rows returned"""
    where: UsersRoleBackupBoolExp
  ): [UsersRoleBackup!]!
  """
  fetch data from the table in a streaming manner: "users"
  """
  usersStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UsersStreamCursorInput]!
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """
  fetch data from the table: "work_schedule"
  """
  workSchedule(
    """distinct select on columns"""
    distinctOn: [WorkScheduleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [WorkScheduleOrderBy!]
    """filter the rows returned"""
    where: WorkScheduleBoolExp
  ): [WorkSchedule!]!
  """
  fetch aggregated fields from the table: "work_schedule"
  """
  workScheduleAggregate(
    """distinct select on columns"""
    distinctOn: [WorkScheduleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [WorkScheduleOrderBy!]
    """filter the rows returned"""
    where: WorkScheduleBoolExp
  ): WorkScheduleAggregate!
  """fetch data from the table: "work_schedule" using primary key columns"""
  workScheduleByPk(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): WorkSchedule
  """
  fetch data from the table in a streaming manner: "work_schedule"
  """
  workScheduleStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [WorkScheduleStreamCursorInput]!
    """filter the rows returned"""
    where: WorkScheduleBoolExp
  ): [WorkSchedule!]!
}

input timeEntriesAggregateBoolExpBool_and {
  arguments: TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TimeEntriesBoolExp
  predicate: BooleanComparisonExp!
}

input timeEntriesAggregateBoolExpBool_or {
  arguments: TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TimeEntriesBoolExp
  predicate: BooleanComparisonExp!
}

input timeEntriesAggregateBoolExpCount {
  arguments: [TimeEntriesSelectColumn!]
  distinct: Boolean
  filter: TimeEntriesBoolExp
  predicate: IntComparisonExp!
}

scalar timestamp

scalar timestamptz

input userEmailTemplateFavoritesAggregateBoolExpCount {
  arguments: [UserEmailTemplateFavoritesSelectColumn!]
  distinct: Boolean
  filter: UserEmailTemplateFavoritesBoolExp
  predicate: IntComparisonExp!
}

input userInvitationsAggregateBoolExpCount {
  arguments: [UserInvitationsSelectColumn!]
  distinct: Boolean
  filter: UserInvitationsBoolExp
  predicate: IntComparisonExp!
}

input userRolesAggregateBoolExpCount {
  arguments: [UserRolesSelectColumn!]
  distinct: Boolean
  filter: UserRolesBoolExp
  predicate: IntComparisonExp!
}

input userSessionsAggregateBoolExpBool_and {
  arguments: UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: UserSessionsBoolExp
  predicate: BooleanComparisonExp!
}

input userSessionsAggregateBoolExpBool_or {
  arguments: UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: UserSessionsBoolExp
  predicate: BooleanComparisonExp!
}

input userSessionsAggregateBoolExpCount {
  arguments: [UserSessionsSelectColumn!]
  distinct: Boolean
  filter: UserSessionsBoolExp
  predicate: IntComparisonExp!
}

input userSkillsAggregateBoolExpCount {
  arguments: [UserSkillsSelectColumn!]
  distinct: Boolean
  filter: UserSkillsBoolExp
  predicate: IntComparisonExp!
}

scalar user_position

scalar user_role

scalar user_status_enum

input usersAggregateBoolExpBool_and {
  arguments: UsersSelectColumnUsersAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: UsersBoolExp
  predicate: BooleanComparisonExp!
}

input usersAggregateBoolExpBool_or {
  arguments: UsersSelectColumnUsersAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: UsersBoolExp
  predicate: BooleanComparisonExp!
}

input usersAggregateBoolExpCount {
  arguments: [UsersSelectColumn!]
  distinct: Boolean
  filter: UsersBoolExp
  predicate: IntComparisonExp!
}

scalar uuid

input workScheduleAggregateBoolExpBool_and {
  arguments: WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: WorkScheduleBoolExp
  predicate: BooleanComparisonExp!
}

input workScheduleAggregateBoolExpBool_or {
  arguments: WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: WorkScheduleBoolExp
  predicate: BooleanComparisonExp!
}

input workScheduleAggregateBoolExpCount {
  arguments: [WorkScheduleSelectColumn!]
  distinct: Boolean
  filter: WorkScheduleBoolExp
  predicate: IntComparisonExp!
}