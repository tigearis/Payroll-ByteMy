schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false
  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

type AffectedAssignment {
  adjustedEftDate: String!
  id: String!
  newConsultantId: String!
  originalConsultantId: String!
  payrollDateId: String!
}

input AuditEventInput {
  action: String!
  ipAddress: String
  metadata: json
  resourceId: String
  resourceType: String!
  userAgent: String
  userId: String!
}

type AuditEventResponse {
  eventId: String
  message: String
  success: Boolean!
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input BpcharComparisonExp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar
  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _isNull: Boolean
  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar
  """does the column NOT match the given pattern"""
  _nlike: bpchar
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar
  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

type CommitPayrollAssignmentsOutput {
  affectedAssignments: [AffectedAssignment!]
  errors: [String!]
  message: String
  success: Boolean!
}

input ComplianceReportInput {
  endDate: String!
  includeDetails: Boolean
  reportType: String!
  startDate: String!
}

type ComplianceReportResponse {
  generatedAt: String!
  reportUrl: String
  success: Boolean!
  summary: json
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC
  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input InetComparisonExp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _isNull: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input IntervalComparisonExp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _isNull: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp
  """is the column contained in the given json value"""
  _containedIn: jsonb
  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  """does the string exist as a top-level key in the column"""
  _hasKey: String
  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]
  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'.
"""
input LeaveStatusEnumComparisonExp {
  _eq: leave_status_enum
  _gt: leave_status_enum
  _gte: leave_status_enum
  _in: [leave_status_enum!]
  _isNull: Boolean
  _lt: leave_status_enum
  _lte: leave_status_enum
  _neq: leave_status_enum
  _nin: [leave_status_enum!]
}

type Mutation {
  checkSuspiciousActivity(timeWindow: Int, userId: String): SuspiciousActivityResponse
  commitPayrollAssignments(changes: [PayrollAssignmentInput!]!): CommitPayrollAssignmentsOutput
  generateComplianceReport(input: ComplianceReportInput!): ComplianceReportResponse
  logAuditEvent(event: AuditEventInput!): AuditEventResponse
}

"""
Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'.
"""
input NameComparisonExp {
  _eq: name
  _gt: name
  _gte: name
  _in: [name!]
  _isNull: Boolean
  _lt: name
  _lte: name
  _neq: name
  _nin: [name!]
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC
  """in ascending order, nulls first"""
  ASC_NULLS_FIRST
  """in ascending order, nulls last"""
  ASC_NULLS_LAST
  """in descending order, nulls first"""
  DESC
  """in descending order, nulls first"""
  DESC_NULLS_FIRST
  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

input PayrollAssignmentInput {
  date: String!
  fromConsultantId: String!
  payrollId: String!
  toConsultantId: String!
}

"""
Boolean expression to compare columns of type "payroll_cycle_type". All fields are combined with logical 'AND'.
"""
input PayrollCycleTypeComparisonExp {
  _eq: payroll_cycle_type
  _gt: payroll_cycle_type
  _gte: payroll_cycle_type
  _in: [payroll_cycle_type!]
  _isNull: Boolean
  _lt: payroll_cycle_type
  _lte: payroll_cycle_type
  _neq: payroll_cycle_type
  _nin: [payroll_cycle_type!]
}

"""
Boolean expression to compare columns of type "payroll_date_type". All fields are combined with logical 'AND'.
"""
input PayrollDateTypeComparisonExp {
  _eq: payroll_date_type
  _gt: payroll_date_type
  _gte: payroll_date_type
  _in: [payroll_date_type!]
  _isNull: Boolean
  _lt: payroll_date_type
  _lte: payroll_date_type
  _neq: payroll_date_type
  _nin: [payroll_date_type!]
}

"""
Boolean expression to compare columns of type "payroll_status". All fields are combined with logical 'AND'.
"""
input PayrollStatusComparisonExp {
  _eq: payroll_status
  _gt: payroll_status
  _gte: payroll_status
  _in: [payroll_status!]
  _isNull: Boolean
  _lt: payroll_status
  _lte: payroll_status
  _neq: payroll_status
  _nin: [payroll_status!]
}

"""
Boolean expression to compare columns of type "permission_action". All fields are combined with logical 'AND'.
"""
input PermissionActionComparisonExp {
  _eq: permission_action
  _gt: permission_action
  _gte: permission_action
  _in: [permission_action!]
  _isNull: Boolean
  _lt: permission_action
  _lte: permission_action
  _neq: permission_action
  _nin: [permission_action!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringArrayComparisonExp {
  """is the array contained in the given array value"""
  _containedIn: [String!]
  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _isNull: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String
  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean
  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """does the column NOT match the given pattern"""
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """does the column match the given SQL regular expression"""
  _similar: String
}

type SuspiciousActivityResponse {
  events: [SuspiciousEvent!]
  message: String
  success: Boolean!
  suspicious: Boolean!
}

type SuspiciousEvent {
  count: Int!
  eventType: String!
  severity: String!
  timeframe: String!
}

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input TimestampComparisonExp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _isNull: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'.
"""
input UserRoleComparisonExp {
  _eq: user_role
  _gt: user_role
  _gte: user_role
  _in: [user_role!]
  _isNull: Boolean
  _lt: user_role
  _lte: user_role
  _neq: user_role
  _nin: [user_role!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""Scalar _Any"""
scalar _Any

"""A union of all types that use the @key directive"""
union _Entity = adjustmentRules | appSettings | auditLogs | authEvents | billingEventLogs | billingInvoice | billingInvoices | billingItems | billingPlans | clientBillingAssignments | clientExternalSystems | clients | dataAccessLogs | externalSystems | featureFlags | holidays | latestPayrollVersionResults | leave | notes | payrollActivationResults | payrollAssignmentAudits | payrollAssignments | payrollCycles | payrollDateTypes | payrollDates | payrollVersionHistoryResults | payrollVersionResults | payrolls | permissionAuditLogs | permissionChanges | permissionOverrides | permissions | resources | rolePermissions | roles | slowQueries | userInvitations | userRoles | users | workSchedules

type _Service {
  """SDL representation of schema"""
  sdl: String!
}

"""
columns and relationships of "adjustment_rules"
"""
type adjustmentRules {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid!
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid!
  """Unique identifier for the adjustment rule"""
  id: uuid!
  """An object relationship"""
  relatedPayrollCycle: payrollCycles!
  """An object relationship"""
  relatedPayrollDateType: payrollDateTypes!
  """Code/formula used to calculate date adjustments"""
  ruleCode: String!
  """Human-readable description of the adjustment rule"""
  ruleDescription: String!
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "adjustment_rules"
"""
type adjustmentRulesAggregate {
  aggregate: adjustmentRulesAggregateFields
  nodes: [adjustmentRules!]!
}

input adjustmentRulesAggregateBoolExp {
  count: adjustmentRulesAggregateBoolExpCount
}

input adjustmentRulesAggregateBoolExpCount {
  arguments: [adjustmentRulesSelectColumn!]
  distinct: Boolean
  filter: adjustmentRulesBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "adjustment_rules"
"""
type adjustmentRulesAggregateFields {
  count(columns: [adjustmentRulesSelectColumn!], distinct: Boolean): Int!
  max: adjustmentRulesMaxFields
  min: adjustmentRulesMinFields
}

"""
order by aggregate values of table "adjustment_rules"
"""
input adjustmentRulesAggregateOrderBy {
  count: OrderBy
  max: adjustmentRulesMaxOrderBy
  min: adjustmentRulesMinOrderBy
}

"""
input type for inserting array relation for remote table "adjustment_rules"
"""
input adjustmentRulesArrRelInsertInput {
  data: [adjustmentRulesInsertInput!]!
  """upsert condition"""
  onConflict: adjustmentRulesOnConflict
}

"""
Boolean expression to filter rows from the table "adjustment_rules". All fields are combined with a logical 'AND'.
"""
input adjustmentRulesBoolExp {
  _and: [adjustmentRulesBoolExp!]
  _not: adjustmentRulesBoolExp
  _or: [adjustmentRulesBoolExp!]
  createdAt: TimestamptzComparisonExp
  cycleId: UuidComparisonExp
  dateTypeId: UuidComparisonExp
  id: UuidComparisonExp
  relatedPayrollCycle: payrollCyclesBoolExp
  relatedPayrollDateType: payrollDateTypesBoolExp
  ruleCode: StringComparisonExp
  ruleDescription: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "adjustment_rules"
"""
enum adjustmentRulesConstraint {
  """
  unique or primary key constraint on columns "date_type_id", "cycle_id"
  """
  adjustment_rules_cycle_id_date_type_id_key
  """
  unique or primary key constraint on columns "id"
  """
  adjustment_rules_pkey
}

"""
input type for inserting data into table "adjustment_rules"
"""
input adjustmentRulesInsertInput {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  relatedPayrollCycle: payrollCyclesObjRelInsertInput
  relatedPayrollDateType: payrollDateTypesObjRelInsertInput
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type adjustmentRulesMaxFields {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "adjustment_rules"
"""
input adjustmentRulesMaxOrderBy {
  """Timestamp when the rule was created"""
  createdAt: OrderBy
  """Reference to the payroll cycle this rule applies to"""
  cycleId: OrderBy
  """Reference to the payroll date type this rule affects"""
  dateTypeId: OrderBy
  """Unique identifier for the adjustment rule"""
  id: OrderBy
  """Code/formula used to calculate date adjustments"""
  ruleCode: OrderBy
  """Human-readable description of the adjustment rule"""
  ruleDescription: OrderBy
  """Timestamp when the rule was last updated"""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type adjustmentRulesMinFields {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "adjustment_rules"
"""
input adjustmentRulesMinOrderBy {
  """Timestamp when the rule was created"""
  createdAt: OrderBy
  """Reference to the payroll cycle this rule applies to"""
  cycleId: OrderBy
  """Reference to the payroll date type this rule affects"""
  dateTypeId: OrderBy
  """Unique identifier for the adjustment rule"""
  id: OrderBy
  """Code/formula used to calculate date adjustments"""
  ruleCode: OrderBy
  """Human-readable description of the adjustment rule"""
  ruleDescription: OrderBy
  """Timestamp when the rule was last updated"""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "adjustment_rules"
"""
type adjustmentRulesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [adjustmentRules!]!
}

"""
on_conflict condition type for table "adjustment_rules"
"""
input adjustmentRulesOnConflict {
  constraint: adjustmentRulesConstraint!
  updateColumns: [adjustmentRulesUpdateColumn!]! = []
  where: adjustmentRulesBoolExp
}

"""Ordering options when selecting data from "adjustment_rules"."""
input adjustmentRulesOrderBy {
  createdAt: OrderBy
  cycleId: OrderBy
  dateTypeId: OrderBy
  id: OrderBy
  relatedPayrollCycle: payrollCyclesOrderBy
  relatedPayrollDateType: payrollDateTypesOrderBy
  ruleCode: OrderBy
  ruleDescription: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: adjustment_rules"""
input adjustmentRulesPkColumnsInput {
  """Unique identifier for the adjustment rule"""
  id: uuid!
}

"""
select columns of table "adjustment_rules"
"""
enum adjustmentRulesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  id
  """column name"""
  ruleCode
  """column name"""
  ruleDescription
  """column name"""
  updatedAt
}

"""
input type for updating data in table "adjustment_rules"
"""
input adjustmentRulesSetInput {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "adjustmentRules"
"""
input adjustmentRulesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: adjustmentRulesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input adjustmentRulesStreamCursorValueInput {
  """Timestamp when the rule was created"""
  createdAt: timestamptz
  """Reference to the payroll cycle this rule applies to"""
  cycleId: uuid
  """Reference to the payroll date type this rule affects"""
  dateTypeId: uuid
  """Unique identifier for the adjustment rule"""
  id: uuid
  """Code/formula used to calculate date adjustments"""
  ruleCode: String
  """Human-readable description of the adjustment rule"""
  ruleDescription: String
  """Timestamp when the rule was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "adjustment_rules"
"""
enum adjustmentRulesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  id
  """column name"""
  ruleCode
  """column name"""
  ruleDescription
  """column name"""
  updatedAt
}

input adjustmentRulesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: adjustmentRulesSetInput
  """filter the rows which have to be updated"""
  where: adjustmentRulesBoolExp!
}

"""
columns and relationships of "app_settings"
"""
type appSettings {
  """Unique identifier for application setting"""
  id: String!
  """JSON structure containing application permission configurations"""
  permissions(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "app_settings"
"""
type appSettingsAggregate {
  aggregate: appSettingsAggregateFields
  nodes: [appSettings!]!
}

"""
aggregate fields of "app_settings"
"""
type appSettingsAggregateFields {
  count(columns: [appSettingsSelectColumn!], distinct: Boolean): Int!
  max: appSettingsMaxFields
  min: appSettingsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input appSettingsAppendInput {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Boolean expression to filter rows from the table "app_settings". All fields are combined with a logical 'AND'.
"""
input appSettingsBoolExp {
  _and: [appSettingsBoolExp!]
  _not: appSettingsBoolExp
  _or: [appSettingsBoolExp!]
  id: StringComparisonExp
  permissions: JsonbComparisonExp
}

"""
unique or primary key constraints on table "app_settings"
"""
enum appSettingsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  app_settings_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input appSettingsDeleteAtPathInput {
  """JSON structure containing application permission configurations"""
  permissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input appSettingsDeleteElemInput {
  """JSON structure containing application permission configurations"""
  permissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input appSettingsDeleteKeyInput {
  """JSON structure containing application permission configurations"""
  permissions: String
}

"""
input type for inserting data into table "app_settings"
"""
input appSettingsInsertInput {
  """Unique identifier for application setting"""
  id: String
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""aggregate max on columns"""
type appSettingsMaxFields {
  """Unique identifier for application setting"""
  id: String
}

"""aggregate min on columns"""
type appSettingsMinFields {
  """Unique identifier for application setting"""
  id: String
}

"""
response of any mutation on the table "app_settings"
"""
type appSettingsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [appSettings!]!
}

"""
on_conflict condition type for table "app_settings"
"""
input appSettingsOnConflict {
  constraint: appSettingsConstraint!
  updateColumns: [appSettingsUpdateColumn!]! = []
  where: appSettingsBoolExp
}

"""Ordering options when selecting data from "app_settings"."""
input appSettingsOrderBy {
  id: OrderBy
  permissions: OrderBy
}

"""primary key columns input for table: app_settings"""
input appSettingsPkColumnsInput {
  """Unique identifier for application setting"""
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input appSettingsPrependInput {
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
select columns of table "app_settings"
"""
enum appSettingsSelectColumn {
  """column name"""
  id
  """column name"""
  permissions
}

"""
input type for updating data in table "app_settings"
"""
input appSettingsSetInput {
  """Unique identifier for application setting"""
  id: String
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
Streaming cursor of the table "appSettings"
"""
input appSettingsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: appSettingsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input appSettingsStreamCursorValueInput {
  """Unique identifier for application setting"""
  id: String
  """JSON structure containing application permission configurations"""
  permissions: jsonb
}

"""
update columns of table "app_settings"
"""
enum appSettingsUpdateColumn {
  """column name"""
  id
  """column name"""
  permissions
}

input appSettingsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: appSettingsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: appSettingsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: appSettingsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: appSettingsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: appSettingsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: appSettingsSetInput
  """filter the rows which have to be updated"""
  where: appSettingsBoolExp!
}

"""
columns and relationships of "audit.audit_log"
"""
type auditLogs {
  action: String!
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz!
  id: uuid!
  ipAddress: inet
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newValues(
    """JSON select path"""
    path: String
  ): jsonb
  oldValues(
    """JSON select path"""
    path: String
  ): jsonb
  requestId: String
  resourceId: String
  resourceType: String!
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
aggregated selection of "audit.audit_log"
"""
type auditLogsAggregate {
  aggregate: auditLogsAggregateFields
  nodes: [auditLogs!]!
}

"""
aggregate fields of "audit.audit_log"
"""
type auditLogsAggregateFields {
  count(columns: [auditLogsSelectColumn!], distinct: Boolean): Int!
  max: auditLogsMaxFields
  min: auditLogsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auditLogsAppendInput {
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
}

"""
Boolean expression to filter rows from the table "audit.audit_log". All fields are combined with a logical 'AND'.
"""
input auditLogsBoolExp {
  _and: [auditLogsBoolExp!]
  _not: auditLogsBoolExp
  _or: [auditLogsBoolExp!]
  action: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  errorMessage: StringComparisonExp
  eventTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  metadata: JsonbComparisonExp
  newValues: JsonbComparisonExp
  oldValues: JsonbComparisonExp
  requestId: StringComparisonExp
  resourceId: StringComparisonExp
  resourceType: StringComparisonExp
  sessionId: StringComparisonExp
  success: BooleanComparisonExp
  userAgent: StringComparisonExp
  userEmail: StringComparisonExp
  userId: UuidComparisonExp
  userRole: StringComparisonExp
}

"""
unique or primary key constraints on table "audit.audit_log"
"""
enum auditLogsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auditLogsDeleteAtPathInput {
  metadata: [String!]
  newValues: [String!]
  oldValues: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auditLogsDeleteElemInput {
  metadata: Int
  newValues: Int
  oldValues: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auditLogsDeleteKeyInput {
  metadata: String
  newValues: String
  oldValues: String
}

"""
input type for inserting data into table "audit.audit_log"
"""
input auditLogsInsertInput {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""aggregate max on columns"""
type auditLogsMaxFields {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""aggregate min on columns"""
type auditLogsMinFields {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
response of any mutation on the table "audit.audit_log"
"""
type auditLogsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [auditLogs!]!
}

"""
on_conflict condition type for table "audit.audit_log"
"""
input auditLogsOnConflict {
  constraint: auditLogsConstraint!
  updateColumns: [auditLogsUpdateColumn!]! = []
  where: auditLogsBoolExp
}

"""Ordering options when selecting data from "audit.audit_log"."""
input auditLogsOrderBy {
  action: OrderBy
  createdAt: OrderBy
  errorMessage: OrderBy
  eventTime: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  metadata: OrderBy
  newValues: OrderBy
  oldValues: OrderBy
  requestId: OrderBy
  resourceId: OrderBy
  resourceType: OrderBy
  sessionId: OrderBy
  success: OrderBy
  userAgent: OrderBy
  userEmail: OrderBy
  userId: OrderBy
  userRole: OrderBy
}

"""primary key columns input for table: audit.audit_log"""
input auditLogsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auditLogsPrependInput {
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
}

"""
select columns of table "audit.audit_log"
"""
enum auditLogsSelectColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  errorMessage
  """column name"""
  eventTime
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  newValues
  """column name"""
  oldValues
  """column name"""
  requestId
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  sessionId
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
  """column name"""
  userRole
}

"""
input type for updating data in table "audit.audit_log"
"""
input auditLogsSetInput {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
Streaming cursor of the table "auditLogs"
"""
input auditLogsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: auditLogsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input auditLogsStreamCursorValueInput {
  action: String
  createdAt: timestamptz
  errorMessage: String
  eventTime: timestamptz
  id: uuid
  ipAddress: inet
  metadata: jsonb
  newValues: jsonb
  oldValues: jsonb
  requestId: String
  resourceId: String
  resourceType: String
  sessionId: String
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
  userRole: String
}

"""
update columns of table "audit.audit_log"
"""
enum auditLogsUpdateColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  errorMessage
  """column name"""
  eventTime
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  newValues
  """column name"""
  oldValues
  """column name"""
  requestId
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  sessionId
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
  """column name"""
  userRole
}

input auditLogsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: auditLogsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: auditLogsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: auditLogsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: auditLogsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: auditLogsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: auditLogsSetInput
  """filter the rows which have to be updated"""
  where: auditLogsBoolExp!
}

"""
columns and relationships of "audit.auth_events"
"""
type authEvents {
  createdAt: timestamptz
  eventTime: timestamptz!
  eventType: String!
  failureReason: String
  id: uuid!
  ipAddress: inet
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
aggregated selection of "audit.auth_events"
"""
type authEventsAggregate {
  aggregate: authEventsAggregateFields
  nodes: [authEvents!]!
}

"""
aggregate fields of "audit.auth_events"
"""
type authEventsAggregateFields {
  count(columns: [authEventsSelectColumn!], distinct: Boolean): Int!
  max: authEventsMaxFields
  min: authEventsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authEventsAppendInput {
  metadata: jsonb
}

"""
Boolean expression to filter rows from the table "audit.auth_events". All fields are combined with a logical 'AND'.
"""
input authEventsBoolExp {
  _and: [authEventsBoolExp!]
  _not: authEventsBoolExp
  _or: [authEventsBoolExp!]
  createdAt: TimestamptzComparisonExp
  eventTime: TimestamptzComparisonExp
  eventType: StringComparisonExp
  failureReason: StringComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  metadata: JsonbComparisonExp
  success: BooleanComparisonExp
  userAgent: StringComparisonExp
  userEmail: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.auth_events"
"""
enum authEventsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  auth_events_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authEventsDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authEventsDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authEventsDeleteKeyInput {
  metadata: String
}

"""
input type for inserting data into table "audit.auth_events"
"""
input authEventsInsertInput {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""aggregate max on columns"""
type authEventsMaxFields {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  userAgent: String
  userEmail: String
  userId: uuid
}

"""aggregate min on columns"""
type authEventsMinFields {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
response of any mutation on the table "audit.auth_events"
"""
type authEventsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [authEvents!]!
}

"""
on_conflict condition type for table "audit.auth_events"
"""
input authEventsOnConflict {
  constraint: authEventsConstraint!
  updateColumns: [authEventsUpdateColumn!]! = []
  where: authEventsBoolExp
}

"""Ordering options when selecting data from "audit.auth_events"."""
input authEventsOrderBy {
  createdAt: OrderBy
  eventTime: OrderBy
  eventType: OrderBy
  failureReason: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  metadata: OrderBy
  success: OrderBy
  userAgent: OrderBy
  userEmail: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: audit.auth_events"""
input authEventsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authEventsPrependInput {
  metadata: jsonb
}

"""
select columns of table "audit.auth_events"
"""
enum authEventsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  eventTime
  """column name"""
  eventType
  """column name"""
  failureReason
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
}

"""
input type for updating data in table "audit.auth_events"
"""
input authEventsSetInput {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
Streaming cursor of the table "authEvents"
"""
input authEventsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: authEventsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input authEventsStreamCursorValueInput {
  createdAt: timestamptz
  eventTime: timestamptz
  eventType: String
  failureReason: String
  id: uuid
  ipAddress: inet
  metadata: jsonb
  success: Boolean
  userAgent: String
  userEmail: String
  userId: uuid
}

"""
update columns of table "audit.auth_events"
"""
enum authEventsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  eventTime
  """column name"""
  eventType
  """column name"""
  failureReason
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  success
  """column name"""
  userAgent
  """column name"""
  userEmail
  """column name"""
  userId
}

input authEventsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authEventsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: authEventsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: authEventsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: authEventsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authEventsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: authEventsSetInput
  """filter the rows which have to be updated"""
  where: authEventsBoolExp!
}

"""
columns and relationships of "neon_auth.users_sync"
"""
type authUsersSync {
  """Timestamp when the user was created in the auth system"""
  createdAt: timestamptz
  """Timestamp when the user was deleted in the auth system"""
  deletedAt: timestamptz
  """User's email address from authentication provider"""
  email: String
  """Unique identifier from the authentication provider"""
  id: String!
  """User's full name from authentication provider"""
  name: String
  """Complete JSON data from the authentication provider"""
  rawJson(
    """JSON select path"""
    path: String
  ): jsonb!
  """Timestamp when the user was last updated in the auth system"""
  updatedAt: timestamptz
}

"""
aggregated selection of "neon_auth.users_sync"
"""
type authUsersSyncAggregate {
  aggregate: authUsersSyncAggregateFields
  nodes: [authUsersSync!]!
}

"""
aggregate fields of "neon_auth.users_sync"
"""
type authUsersSyncAggregateFields {
  count(columns: [authUsersSyncSelectColumn!], distinct: Boolean): Int!
  max: authUsersSyncMaxFields
  min: authUsersSyncMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authUsersSyncAppendInput {
  """Complete JSON data from the authentication provider"""
  rawJson: jsonb
}

"""
Boolean expression to filter rows from the table "neon_auth.users_sync". All fields are combined with a logical 'AND'.
"""
input authUsersSyncBoolExp {
  _and: [authUsersSyncBoolExp!]
  _not: authUsersSyncBoolExp
  _or: [authUsersSyncBoolExp!]
  createdAt: TimestamptzComparisonExp
  deletedAt: TimestamptzComparisonExp
  email: StringComparisonExp
  id: StringComparisonExp
  name: StringComparisonExp
  rawJson: JsonbComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "neon_auth.users_sync"
"""
enum authUsersSyncConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_sync_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authUsersSyncDeleteAtPathInput {
  """Complete JSON data from the authentication provider"""
  rawJson: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authUsersSyncDeleteElemInput {
  """Complete JSON data from the authentication provider"""
  rawJson: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authUsersSyncDeleteKeyInput {
  """Complete JSON data from the authentication provider"""
  rawJson: String
}

"""
input type for inserting data into table "neon_auth.users_sync"
"""
input authUsersSyncInsertInput {
  """Timestamp when the user was deleted in the auth system"""
  deletedAt: timestamptz
  """Complete JSON data from the authentication provider"""
  rawJson: jsonb
  """Timestamp when the user was last updated in the auth system"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type authUsersSyncMaxFields {
  """Timestamp when the user was created in the auth system"""
  createdAt: timestamptz
  """Timestamp when the user was deleted in the auth system"""
  deletedAt: timestamptz
  """User's email address from authentication provider"""
  email: String
  """Unique identifier from the authentication provider"""
  id: String
  """User's full name from authentication provider"""
  name: String
  """Timestamp when the user was last updated in the auth system"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type authUsersSyncMinFields {
  """Timestamp when the user was created in the auth system"""
  createdAt: timestamptz
  """Timestamp when the user was deleted in the auth system"""
  deletedAt: timestamptz
  """User's email address from authentication provider"""
  email: String
  """Unique identifier from the authentication provider"""
  id: String
  """User's full name from authentication provider"""
  name: String
  """Timestamp when the user was last updated in the auth system"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "neon_auth.users_sync"
"""
type authUsersSyncMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [authUsersSync!]!
}

"""
on_conflict condition type for table "neon_auth.users_sync"
"""
input authUsersSyncOnConflict {
  constraint: authUsersSyncConstraint!
  updateColumns: [authUsersSyncUpdateColumn!]! = []
  where: authUsersSyncBoolExp
}

"""Ordering options when selecting data from "neon_auth.users_sync"."""
input authUsersSyncOrderBy {
  createdAt: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  id: OrderBy
  name: OrderBy
  rawJson: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: neon_auth.users_sync"""
input authUsersSyncPkColumnsInput {
  """Unique identifier from the authentication provider"""
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authUsersSyncPrependInput {
  """Complete JSON data from the authentication provider"""
  rawJson: jsonb
}

"""
select columns of table "neon_auth.users_sync"
"""
enum authUsersSyncSelectColumn {
  """column name"""
  createdAt
  """column name"""
  deletedAt
  """column name"""
  email
  """column name"""
  id
  """column name"""
  name
  """column name"""
  rawJson
  """column name"""
  updatedAt
}

"""
input type for updating data in table "neon_auth.users_sync"
"""
input authUsersSyncSetInput {
  """Timestamp when the user was deleted in the auth system"""
  deletedAt: timestamptz
  """Complete JSON data from the authentication provider"""
  rawJson: jsonb
  """Timestamp when the user was last updated in the auth system"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "authUsersSync"
"""
input authUsersSyncStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: authUsersSyncStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input authUsersSyncStreamCursorValueInput {
  """Timestamp when the user was created in the auth system"""
  createdAt: timestamptz
  """Timestamp when the user was deleted in the auth system"""
  deletedAt: timestamptz
  """User's email address from authentication provider"""
  email: String
  """Unique identifier from the authentication provider"""
  id: String
  """User's full name from authentication provider"""
  name: String
  """Complete JSON data from the authentication provider"""
  rawJson: jsonb
  """Timestamp when the user was last updated in the auth system"""
  updatedAt: timestamptz
}

"""
update columns of table "neon_auth.users_sync"
"""
enum authUsersSyncUpdateColumn {
  """column name"""
  deletedAt
  """column name"""
  rawJson
  """column name"""
  updatedAt
}

input authUsersSyncUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authUsersSyncAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: authUsersSyncDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: authUsersSyncDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: authUsersSyncDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authUsersSyncPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: authUsersSyncSetInput
  """filter the rows which have to be updated"""
  where: authUsersSyncBoolExp!
}

scalar bigint

"""
columns and relationships of "billing_event_log"
"""
type billingEventLogs {
  """An object relationship"""
  billingInvoice: billingInvoices
  createdAt: timestamptz
  createdBy: uuid
  """An object relationship"""
  createdByUser: users
  eventType: String!
  id: uuid!
  invoiceId: uuid
  message: String
}

"""
aggregated selection of "billing_event_log"
"""
type billingEventLogsAggregate {
  aggregate: billingEventLogsAggregateFields
  nodes: [billingEventLogs!]!
}

input billingEventLogsAggregateBoolExp {
  count: billingEventLogsAggregateBoolExpCount
}

input billingEventLogsAggregateBoolExpCount {
  arguments: [billingEventLogsSelectColumn!]
  distinct: Boolean
  filter: billingEventLogsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "billing_event_log"
"""
type billingEventLogsAggregateFields {
  count(columns: [billingEventLogsSelectColumn!], distinct: Boolean): Int!
  max: billingEventLogsMaxFields
  min: billingEventLogsMinFields
}

"""
order by aggregate values of table "billing_event_log"
"""
input billingEventLogsAggregateOrderBy {
  count: OrderBy
  max: billingEventLogsMaxOrderBy
  min: billingEventLogsMinOrderBy
}

"""
input type for inserting array relation for remote table "billing_event_log"
"""
input billingEventLogsArrRelInsertInput {
  data: [billingEventLogsInsertInput!]!
  """upsert condition"""
  onConflict: billingEventLogsOnConflict
}

"""
Boolean expression to filter rows from the table "billing_event_log". All fields are combined with a logical 'AND'.
"""
input billingEventLogsBoolExp {
  _and: [billingEventLogsBoolExp!]
  _not: billingEventLogsBoolExp
  _or: [billingEventLogsBoolExp!]
  billingInvoice: billingInvoicesBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: usersBoolExp
  eventType: StringComparisonExp
  id: UuidComparisonExp
  invoiceId: UuidComparisonExp
  message: StringComparisonExp
}

"""
unique or primary key constraints on table "billing_event_log"
"""
enum billingEventLogsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_event_log_pkey
}

"""
input type for inserting data into table "billing_event_log"
"""
input billingEventLogsInsertInput {
  billingInvoice: billingInvoicesObjRelInsertInput
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: usersObjRelInsertInput
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""aggregate max on columns"""
type billingEventLogsMaxFields {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
order by max() on columns of table "billing_event_log"
"""
input billingEventLogsMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  eventType: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  message: OrderBy
}

"""aggregate min on columns"""
type billingEventLogsMinFields {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
order by min() on columns of table "billing_event_log"
"""
input billingEventLogsMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  eventType: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  message: OrderBy
}

"""
response of any mutation on the table "billing_event_log"
"""
type billingEventLogsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [billingEventLogs!]!
}

"""
on_conflict condition type for table "billing_event_log"
"""
input billingEventLogsOnConflict {
  constraint: billingEventLogsConstraint!
  updateColumns: [billingEventLogsUpdateColumn!]! = []
  where: billingEventLogsBoolExp
}

"""Ordering options when selecting data from "billing_event_log"."""
input billingEventLogsOrderBy {
  billingInvoice: billingInvoicesOrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: usersOrderBy
  eventType: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  message: OrderBy
}

"""primary key columns input for table: billing_event_log"""
input billingEventLogsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_event_log"
"""
enum billingEventLogsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  eventType
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  message
}

"""
input type for updating data in table "billing_event_log"
"""
input billingEventLogsSetInput {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
Streaming cursor of the table "billingEventLogs"
"""
input billingEventLogsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: billingEventLogsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input billingEventLogsStreamCursorValueInput {
  createdAt: timestamptz
  createdBy: uuid
  eventType: String
  id: uuid
  invoiceId: uuid
  message: String
}

"""
update columns of table "billing_event_log"
"""
enum billingEventLogsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  eventType
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  message
}

input billingEventLogsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: billingEventLogsSetInput
  """filter the rows which have to be updated"""
  where: billingEventLogsBoolExp!
}

"""
columns and relationships of "billing_invoice"
"""
type billingInvoice {
  """An array relationship"""
  billingEventLogs(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): [billingEventLogs!]!
  """An aggregate relationship"""
  billingEventLogsAggregate(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): billingEventLogsAggregate!
  billingPeriodEnd: date!
  billingPeriodStart: date!
  """An object relationship"""
  client: clients!
  clientId: uuid!
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid!
  issuedDate: date
  notes: String
  status: String!
  totalAmount: numeric!
  updatedAt: timestamptz
}

"""
aggregated selection of "billing_invoice"
"""
type billingInvoiceAggregate {
  aggregate: billingInvoiceAggregateFields
  nodes: [billingInvoice!]!
}

input billingInvoiceAggregateBoolExp {
  count: billingInvoiceAggregateBoolExpCount
}

input billingInvoiceAggregateBoolExpCount {
  arguments: [billingInvoiceSelectColumn!]
  distinct: Boolean
  filter: billingInvoiceBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "billing_invoice"
"""
type billingInvoiceAggregateFields {
  avg: billingInvoiceAvgFields
  count(columns: [billingInvoiceSelectColumn!], distinct: Boolean): Int!
  max: billingInvoiceMaxFields
  min: billingInvoiceMinFields
  stddev: billingInvoiceStddevFields
  stddevPop: billingInvoiceStddevPopFields
  stddevSamp: billingInvoiceStddevSampFields
  sum: billingInvoiceSumFields
  varPop: billingInvoiceVarPopFields
  varSamp: billingInvoiceVarSampFields
  variance: billingInvoiceVarianceFields
}

"""
order by aggregate values of table "billing_invoice"
"""
input billingInvoiceAggregateOrderBy {
  avg: billingInvoiceAvgOrderBy
  count: OrderBy
  max: billingInvoiceMaxOrderBy
  min: billingInvoiceMinOrderBy
  stddev: billingInvoiceStddevOrderBy
  stddevPop: billingInvoiceStddevPopOrderBy
  stddevSamp: billingInvoiceStddevSampOrderBy
  sum: billingInvoiceSumOrderBy
  varPop: billingInvoiceVarPopOrderBy
  varSamp: billingInvoiceVarSampOrderBy
  variance: billingInvoiceVarianceOrderBy
}

"""
input type for inserting array relation for remote table "billing_invoice"
"""
input billingInvoiceArrRelInsertInput {
  data: [billingInvoiceInsertInput!]!
  """upsert condition"""
  onConflict: billingInvoiceOnConflict
}

"""aggregate avg on columns"""
type billingInvoiceAvgFields {
  totalAmount: Float
}

"""
order by avg() on columns of table "billing_invoice"
"""
input billingInvoiceAvgOrderBy {
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "billing_invoice". All fields are combined with a logical 'AND'.
"""
input billingInvoiceBoolExp {
  _and: [billingInvoiceBoolExp!]
  _not: billingInvoiceBoolExp
  _or: [billingInvoiceBoolExp!]
  billingEventLogs: billingEventLogsBoolExp
  billingEventLogsAggregate: billingEventLogsAggregateBoolExp
  billingPeriodEnd: DateComparisonExp
  billingPeriodStart: DateComparisonExp
  client: clientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: StringComparisonExp
  dueDate: DateComparisonExp
  id: UuidComparisonExp
  issuedDate: DateComparisonExp
  notes: StringComparisonExp
  status: StringComparisonExp
  totalAmount: NumericComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "billing_invoice"
"""
enum billingInvoiceConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoice_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoice"
"""
input billingInvoiceIncInput {
  totalAmount: numeric
}

"""
input type for inserting data into table "billing_invoice"
"""
input billingInvoiceInsertInput {
  billingEventLogs: billingEventLogsArrRelInsertInput
  billingPeriodEnd: date
  billingPeriodStart: date
  client: clientsObjRelInsertInput
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  issuedDate: date
  notes: String
  status: String
  totalAmount: numeric
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type billingInvoiceMaxFields {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  issuedDate: date
  notes: String
  status: String
  totalAmount: numeric
  updatedAt: timestamptz
}

"""
order by max() on columns of table "billing_invoice"
"""
input billingInvoiceMaxOrderBy {
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  dueDate: OrderBy
  id: OrderBy
  issuedDate: OrderBy
  notes: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type billingInvoiceMinFields {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  issuedDate: date
  notes: String
  status: String
  totalAmount: numeric
  updatedAt: timestamptz
}

"""
order by min() on columns of table "billing_invoice"
"""
input billingInvoiceMinOrderBy {
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  dueDate: OrderBy
  id: OrderBy
  issuedDate: OrderBy
  notes: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "billing_invoice"
"""
type billingInvoiceMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [billingInvoice!]!
}

"""
on_conflict condition type for table "billing_invoice"
"""
input billingInvoiceOnConflict {
  constraint: billingInvoiceConstraint!
  updateColumns: [billingInvoiceUpdateColumn!]! = []
  where: billingInvoiceBoolExp
}

"""Ordering options when selecting data from "billing_invoice"."""
input billingInvoiceOrderBy {
  billingEventLogsAggregate: billingEventLogsAggregateOrderBy
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  client: clientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  dueDate: OrderBy
  id: OrderBy
  issuedDate: OrderBy
  notes: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: billing_invoice"""
input billingInvoicePkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_invoice"
"""
enum billingInvoiceSelectColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodStart
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  currency
  """column name"""
  dueDate
  """column name"""
  id
  """column name"""
  issuedDate
  """column name"""
  notes
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  updatedAt
}

"""
input type for updating data in table "billing_invoice"
"""
input billingInvoiceSetInput {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  issuedDate: date
  notes: String
  status: String
  totalAmount: numeric
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type billingInvoiceStddevFields {
  totalAmount: Float
}

"""
order by stddev() on columns of table "billing_invoice"
"""
input billingInvoiceStddevOrderBy {
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type billingInvoiceStddevPopFields {
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "billing_invoice"
"""
input billingInvoiceStddevPopOrderBy {
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type billingInvoiceStddevSampFields {
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "billing_invoice"
"""
input billingInvoiceStddevSampOrderBy {
  totalAmount: OrderBy
}

"""
Streaming cursor of the table "billingInvoice"
"""
input billingInvoiceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: billingInvoiceStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input billingInvoiceStreamCursorValueInput {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamptz
  currency: String
  dueDate: date
  id: uuid
  issuedDate: date
  notes: String
  status: String
  totalAmount: numeric
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type billingInvoiceSumFields {
  totalAmount: numeric
}

"""
order by sum() on columns of table "billing_invoice"
"""
input billingInvoiceSumOrderBy {
  totalAmount: OrderBy
}

"""
update columns of table "billing_invoice"
"""
enum billingInvoiceUpdateColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodStart
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  currency
  """column name"""
  dueDate
  """column name"""
  id
  """column name"""
  issuedDate
  """column name"""
  notes
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  updatedAt
}

input billingInvoiceUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billingInvoiceIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: billingInvoiceSetInput
  """filter the rows which have to be updated"""
  where: billingInvoiceBoolExp!
}

"""aggregate varPop on columns"""
type billingInvoiceVarPopFields {
  totalAmount: Float
}

"""
order by varPop() on columns of table "billing_invoice"
"""
input billingInvoiceVarPopOrderBy {
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type billingInvoiceVarSampFields {
  totalAmount: Float
}

"""
order by varSamp() on columns of table "billing_invoice"
"""
input billingInvoiceVarSampOrderBy {
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type billingInvoiceVarianceFields {
  totalAmount: Float
}

"""
order by variance() on columns of table "billing_invoice"
"""
input billingInvoiceVarianceOrderBy {
  totalAmount: OrderBy
}

"""
columns and relationships of "billing_invoices"
"""
type billingInvoices {
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): [billingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): billingItemsAggregate!
  billingPeriodEnd: date!
  billingPeriodStart: date!
  """An object relationship"""
  client: clients
  clientId: uuid
  createdAt: timestamp
  id: uuid!
  invoiceNumber: String!
  status: String
  totalAmount: numeric
  updatedAt: timestamp
}

"""
aggregated selection of "billing_invoices"
"""
type billingInvoicesAggregate {
  aggregate: billingInvoicesAggregateFields
  nodes: [billingInvoices!]!
}

input billingInvoicesAggregateBoolExp {
  count: billingInvoicesAggregateBoolExpCount
}

input billingInvoicesAggregateBoolExpCount {
  arguments: [billingInvoicesSelectColumn!]
  distinct: Boolean
  filter: billingInvoicesBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "billing_invoices"
"""
type billingInvoicesAggregateFields {
  avg: billingInvoicesAvgFields
  count(columns: [billingInvoicesSelectColumn!], distinct: Boolean): Int!
  max: billingInvoicesMaxFields
  min: billingInvoicesMinFields
  stddev: billingInvoicesStddevFields
  stddevPop: billingInvoicesStddevPopFields
  stddevSamp: billingInvoicesStddevSampFields
  sum: billingInvoicesSumFields
  varPop: billingInvoicesVarPopFields
  varSamp: billingInvoicesVarSampFields
  variance: billingInvoicesVarianceFields
}

"""
order by aggregate values of table "billing_invoices"
"""
input billingInvoicesAggregateOrderBy {
  avg: billingInvoicesAvgOrderBy
  count: OrderBy
  max: billingInvoicesMaxOrderBy
  min: billingInvoicesMinOrderBy
  stddev: billingInvoicesStddevOrderBy
  stddevPop: billingInvoicesStddevPopOrderBy
  stddevSamp: billingInvoicesStddevSampOrderBy
  sum: billingInvoicesSumOrderBy
  varPop: billingInvoicesVarPopOrderBy
  varSamp: billingInvoicesVarSampOrderBy
  variance: billingInvoicesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "billing_invoices"
"""
input billingInvoicesArrRelInsertInput {
  data: [billingInvoicesInsertInput!]!
  """upsert condition"""
  onConflict: billingInvoicesOnConflict
}

"""aggregate avg on columns"""
type billingInvoicesAvgFields {
  totalAmount: Float
}

"""
order by avg() on columns of table "billing_invoices"
"""
input billingInvoicesAvgOrderBy {
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "billing_invoices". All fields are combined with a logical 'AND'.
"""
input billingInvoicesBoolExp {
  _and: [billingInvoicesBoolExp!]
  _not: billingInvoicesBoolExp
  _or: [billingInvoicesBoolExp!]
  billingItems: billingItemsBoolExp
  billingItemsAggregate: billingItemsAggregateBoolExp
  billingPeriodEnd: DateComparisonExp
  billingPeriodStart: DateComparisonExp
  client: clientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestampComparisonExp
  id: UuidComparisonExp
  invoiceNumber: StringComparisonExp
  status: StringComparisonExp
  totalAmount: NumericComparisonExp
  updatedAt: TimestampComparisonExp
}

"""
unique or primary key constraints on table "billing_invoices"
"""
enum billingInvoicesConstraint {
  """
  unique or primary key constraint on columns "invoice_number"
  """
  billing_invoices_invoice_number_key
  """
  unique or primary key constraint on columns "id"
  """
  billing_invoices_pkey
}

"""
input type for incrementing numeric columns in table "billing_invoices"
"""
input billingInvoicesIncInput {
  totalAmount: numeric
}

"""
input type for inserting data into table "billing_invoices"
"""
input billingInvoicesInsertInput {
  billingItems: billingItemsArrRelInsertInput
  billingPeriodEnd: date
  billingPeriodStart: date
  client: clientsObjRelInsertInput
  clientId: uuid
  createdAt: timestamp
  id: uuid
  invoiceNumber: String
  status: String
  totalAmount: numeric
  updatedAt: timestamp
}

"""aggregate max on columns"""
type billingInvoicesMaxFields {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamp
  id: uuid
  invoiceNumber: String
  status: String
  totalAmount: numeric
  updatedAt: timestamp
}

"""
order by max() on columns of table "billing_invoices"
"""
input billingInvoicesMaxOrderBy {
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type billingInvoicesMinFields {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamp
  id: uuid
  invoiceNumber: String
  status: String
  totalAmount: numeric
  updatedAt: timestamp
}

"""
order by min() on columns of table "billing_invoices"
"""
input billingInvoicesMinOrderBy {
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "billing_invoices"
"""
type billingInvoicesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [billingInvoices!]!
}

"""
input type for inserting object relation for remote table "billing_invoices"
"""
input billingInvoicesObjRelInsertInput {
  data: billingInvoicesInsertInput!
  """upsert condition"""
  onConflict: billingInvoicesOnConflict
}

"""
on_conflict condition type for table "billing_invoices"
"""
input billingInvoicesOnConflict {
  constraint: billingInvoicesConstraint!
  updateColumns: [billingInvoicesUpdateColumn!]! = []
  where: billingInvoicesBoolExp
}

"""Ordering options when selecting data from "billing_invoices"."""
input billingInvoicesOrderBy {
  billingItemsAggregate: billingItemsAggregateOrderBy
  billingPeriodEnd: OrderBy
  billingPeriodStart: OrderBy
  client: clientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  status: OrderBy
  totalAmount: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: billing_invoices"""
input billingInvoicesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_invoices"
"""
enum billingInvoicesSelectColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodStart
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  invoiceNumber
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  updatedAt
}

"""
input type for updating data in table "billing_invoices"
"""
input billingInvoicesSetInput {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamp
  id: uuid
  invoiceNumber: String
  status: String
  totalAmount: numeric
  updatedAt: timestamp
}

"""aggregate stddev on columns"""
type billingInvoicesStddevFields {
  totalAmount: Float
}

"""
order by stddev() on columns of table "billing_invoices"
"""
input billingInvoicesStddevOrderBy {
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type billingInvoicesStddevPopFields {
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "billing_invoices"
"""
input billingInvoicesStddevPopOrderBy {
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type billingInvoicesStddevSampFields {
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "billing_invoices"
"""
input billingInvoicesStddevSampOrderBy {
  totalAmount: OrderBy
}

"""
Streaming cursor of the table "billingInvoices"
"""
input billingInvoicesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: billingInvoicesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input billingInvoicesStreamCursorValueInput {
  billingPeriodEnd: date
  billingPeriodStart: date
  clientId: uuid
  createdAt: timestamp
  id: uuid
  invoiceNumber: String
  status: String
  totalAmount: numeric
  updatedAt: timestamp
}

"""aggregate sum on columns"""
type billingInvoicesSumFields {
  totalAmount: numeric
}

"""
order by sum() on columns of table "billing_invoices"
"""
input billingInvoicesSumOrderBy {
  totalAmount: OrderBy
}

"""
update columns of table "billing_invoices"
"""
enum billingInvoicesUpdateColumn {
  """column name"""
  billingPeriodEnd
  """column name"""
  billingPeriodStart
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  invoiceNumber
  """column name"""
  status
  """column name"""
  totalAmount
  """column name"""
  updatedAt
}

input billingInvoicesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billingInvoicesIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: billingInvoicesSetInput
  """filter the rows which have to be updated"""
  where: billingInvoicesBoolExp!
}

"""aggregate varPop on columns"""
type billingInvoicesVarPopFields {
  totalAmount: Float
}

"""
order by varPop() on columns of table "billing_invoices"
"""
input billingInvoicesVarPopOrderBy {
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type billingInvoicesVarSampFields {
  totalAmount: Float
}

"""
order by varSamp() on columns of table "billing_invoices"
"""
input billingInvoicesVarSampOrderBy {
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type billingInvoicesVarianceFields {
  totalAmount: Float
}

"""
order by variance() on columns of table "billing_invoices"
"""
input billingInvoicesVarianceOrderBy {
  totalAmount: OrderBy
}

"""
columns and relationships of "billing_items"
"""
type billingItems {
  amount: numeric
  createdAt: timestamp
  description: String
  id: uuid!
  invoiceId: uuid
  payrollId: uuid
  quantity: Int!
  """An object relationship"""
  relatedInvoice: billingInvoices
  """An object relationship"""
  relatedPayroll: payrolls
  unitPrice: numeric!
}

"""
aggregated selection of "billing_items"
"""
type billingItemsAggregate {
  aggregate: billingItemsAggregateFields
  nodes: [billingItems!]!
}

input billingItemsAggregateBoolExp {
  count: billingItemsAggregateBoolExpCount
}

input billingItemsAggregateBoolExpCount {
  arguments: [billingItemsSelectColumn!]
  distinct: Boolean
  filter: billingItemsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "billing_items"
"""
type billingItemsAggregateFields {
  avg: billingItemsAvgFields
  count(columns: [billingItemsSelectColumn!], distinct: Boolean): Int!
  max: billingItemsMaxFields
  min: billingItemsMinFields
  stddev: billingItemsStddevFields
  stddevPop: billingItemsStddevPopFields
  stddevSamp: billingItemsStddevSampFields
  sum: billingItemsSumFields
  varPop: billingItemsVarPopFields
  varSamp: billingItemsVarSampFields
  variance: billingItemsVarianceFields
}

"""
order by aggregate values of table "billing_items"
"""
input billingItemsAggregateOrderBy {
  avg: billingItemsAvgOrderBy
  count: OrderBy
  max: billingItemsMaxOrderBy
  min: billingItemsMinOrderBy
  stddev: billingItemsStddevOrderBy
  stddevPop: billingItemsStddevPopOrderBy
  stddevSamp: billingItemsStddevSampOrderBy
  sum: billingItemsSumOrderBy
  varPop: billingItemsVarPopOrderBy
  varSamp: billingItemsVarSampOrderBy
  variance: billingItemsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "billing_items"
"""
input billingItemsArrRelInsertInput {
  data: [billingItemsInsertInput!]!
  """upsert condition"""
  onConflict: billingItemsOnConflict
}

"""aggregate avg on columns"""
type billingItemsAvgFields {
  amount: Float
  quantity: Float
  unitPrice: Float
}

"""
order by avg() on columns of table "billing_items"
"""
input billingItemsAvgOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""
Boolean expression to filter rows from the table "billing_items". All fields are combined with a logical 'AND'.
"""
input billingItemsBoolExp {
  _and: [billingItemsBoolExp!]
  _not: billingItemsBoolExp
  _or: [billingItemsBoolExp!]
  amount: NumericComparisonExp
  createdAt: TimestampComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  invoiceId: UuidComparisonExp
  payrollId: UuidComparisonExp
  quantity: IntComparisonExp
  relatedInvoice: billingInvoicesBoolExp
  relatedPayroll: payrollsBoolExp
  unitPrice: NumericComparisonExp
}

"""
unique or primary key constraints on table "billing_items"
"""
enum billingItemsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_items_pkey
}

"""
input type for incrementing numeric columns in table "billing_items"
"""
input billingItemsIncInput {
  quantity: Int
  unitPrice: numeric
}

"""
input type for inserting data into table "billing_items"
"""
input billingItemsInsertInput {
  createdAt: timestamp
  description: String
  id: uuid
  invoiceId: uuid
  payrollId: uuid
  quantity: Int
  relatedInvoice: billingInvoicesObjRelInsertInput
  relatedPayroll: payrollsObjRelInsertInput
  unitPrice: numeric
}

"""aggregate max on columns"""
type billingItemsMaxFields {
  amount: numeric
  createdAt: timestamp
  description: String
  id: uuid
  invoiceId: uuid
  payrollId: uuid
  quantity: Int
  unitPrice: numeric
}

"""
order by max() on columns of table "billing_items"
"""
input billingItemsMaxOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  payrollId: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""aggregate min on columns"""
type billingItemsMinFields {
  amount: numeric
  createdAt: timestamp
  description: String
  id: uuid
  invoiceId: uuid
  payrollId: uuid
  quantity: Int
  unitPrice: numeric
}

"""
order by min() on columns of table "billing_items"
"""
input billingItemsMinOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  payrollId: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""
response of any mutation on the table "billing_items"
"""
type billingItemsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [billingItems!]!
}

"""
on_conflict condition type for table "billing_items"
"""
input billingItemsOnConflict {
  constraint: billingItemsConstraint!
  updateColumns: [billingItemsUpdateColumn!]! = []
  where: billingItemsBoolExp
}

"""Ordering options when selecting data from "billing_items"."""
input billingItemsOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  invoiceId: OrderBy
  payrollId: OrderBy
  quantity: OrderBy
  relatedInvoice: billingInvoicesOrderBy
  relatedPayroll: payrollsOrderBy
  unitPrice: OrderBy
}

"""primary key columns input for table: billing_items"""
input billingItemsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_items"
"""
enum billingItemsSelectColumn {
  """column name"""
  amount
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  payrollId
  """column name"""
  quantity
  """column name"""
  unitPrice
}

"""
input type for updating data in table "billing_items"
"""
input billingItemsSetInput {
  createdAt: timestamp
  description: String
  id: uuid
  invoiceId: uuid
  payrollId: uuid
  quantity: Int
  unitPrice: numeric
}

"""aggregate stddev on columns"""
type billingItemsStddevFields {
  amount: Float
  quantity: Float
  unitPrice: Float
}

"""
order by stddev() on columns of table "billing_items"
"""
input billingItemsStddevOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""aggregate stddevPop on columns"""
type billingItemsStddevPopFields {
  amount: Float
  quantity: Float
  unitPrice: Float
}

"""
order by stddevPop() on columns of table "billing_items"
"""
input billingItemsStddevPopOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""aggregate stddevSamp on columns"""
type billingItemsStddevSampFields {
  amount: Float
  quantity: Float
  unitPrice: Float
}

"""
order by stddevSamp() on columns of table "billing_items"
"""
input billingItemsStddevSampOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""
Streaming cursor of the table "billingItems"
"""
input billingItemsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: billingItemsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input billingItemsStreamCursorValueInput {
  amount: numeric
  createdAt: timestamp
  description: String
  id: uuid
  invoiceId: uuid
  payrollId: uuid
  quantity: Int
  unitPrice: numeric
}

"""aggregate sum on columns"""
type billingItemsSumFields {
  amount: numeric
  quantity: Int
  unitPrice: numeric
}

"""
order by sum() on columns of table "billing_items"
"""
input billingItemsSumOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""
update columns of table "billing_items"
"""
enum billingItemsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  invoiceId
  """column name"""
  payrollId
  """column name"""
  quantity
  """column name"""
  unitPrice
}

input billingItemsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billingItemsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: billingItemsSetInput
  """filter the rows which have to be updated"""
  where: billingItemsBoolExp!
}

"""aggregate varPop on columns"""
type billingItemsVarPopFields {
  amount: Float
  quantity: Float
  unitPrice: Float
}

"""
order by varPop() on columns of table "billing_items"
"""
input billingItemsVarPopOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""aggregate varSamp on columns"""
type billingItemsVarSampFields {
  amount: Float
  quantity: Float
  unitPrice: Float
}

"""
order by varSamp() on columns of table "billing_items"
"""
input billingItemsVarSampOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""aggregate variance on columns"""
type billingItemsVarianceFields {
  amount: Float
  quantity: Float
  unitPrice: Float
}

"""
order by variance() on columns of table "billing_items"
"""
input billingItemsVarianceOrderBy {
  amount: OrderBy
  quantity: OrderBy
  unitPrice: OrderBy
}

"""
columns and relationships of "billing_plan"
"""
type billingPlans {
  """An array relationship"""
  clientBillingAssignments(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): [clientBillingAssignments!]!
  """An aggregate relationship"""
  clientBillingAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): clientBillingAssignmentsAggregate!
  createdAt: timestamptz
  currency: String!
  description: String
  id: uuid!
  name: String!
  ratePerPayroll: numeric!
  updatedAt: timestamptz
}

"""
aggregated selection of "billing_plan"
"""
type billingPlansAggregate {
  aggregate: billingPlansAggregateFields
  nodes: [billingPlans!]!
}

"""
aggregate fields of "billing_plan"
"""
type billingPlansAggregateFields {
  avg: billingPlansAvgFields
  count(columns: [billingPlansSelectColumn!], distinct: Boolean): Int!
  max: billingPlansMaxFields
  min: billingPlansMinFields
  stddev: billingPlansStddevFields
  stddevPop: billingPlansStddevPopFields
  stddevSamp: billingPlansStddevSampFields
  sum: billingPlansSumFields
  varPop: billingPlansVarPopFields
  varSamp: billingPlansVarSampFields
  variance: billingPlansVarianceFields
}

"""aggregate avg on columns"""
type billingPlansAvgFields {
  ratePerPayroll: Float
}

"""
Boolean expression to filter rows from the table "billing_plan". All fields are combined with a logical 'AND'.
"""
input billingPlansBoolExp {
  _and: [billingPlansBoolExp!]
  _not: billingPlansBoolExp
  _or: [billingPlansBoolExp!]
  clientBillingAssignments: clientBillingAssignmentsBoolExp
  clientBillingAssignmentsAggregate: clientBillingAssignmentsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  currency: StringComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  ratePerPayroll: NumericComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "billing_plan"
"""
enum billingPlansConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  billing_plan_pkey
}

"""
input type for incrementing numeric columns in table "billing_plan"
"""
input billingPlansIncInput {
  ratePerPayroll: numeric
}

"""
input type for inserting data into table "billing_plan"
"""
input billingPlansInsertInput {
  clientBillingAssignments: clientBillingAssignmentsArrRelInsertInput
  createdAt: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  ratePerPayroll: numeric
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type billingPlansMaxFields {
  createdAt: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  ratePerPayroll: numeric
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type billingPlansMinFields {
  createdAt: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  ratePerPayroll: numeric
  updatedAt: timestamptz
}

"""
response of any mutation on the table "billing_plan"
"""
type billingPlansMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [billingPlans!]!
}

"""
input type for inserting object relation for remote table "billing_plan"
"""
input billingPlansObjRelInsertInput {
  data: billingPlansInsertInput!
  """upsert condition"""
  onConflict: billingPlansOnConflict
}

"""
on_conflict condition type for table "billing_plan"
"""
input billingPlansOnConflict {
  constraint: billingPlansConstraint!
  updateColumns: [billingPlansUpdateColumn!]! = []
  where: billingPlansBoolExp
}

"""Ordering options when selecting data from "billing_plan"."""
input billingPlansOrderBy {
  clientBillingAssignmentsAggregate: clientBillingAssignmentsAggregateOrderBy
  createdAt: OrderBy
  currency: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  ratePerPayroll: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: billing_plan"""
input billingPlansPkColumnsInput {
  id: uuid!
}

"""
select columns of table "billing_plan"
"""
enum billingPlansSelectColumn {
  """column name"""
  createdAt
  """column name"""
  currency
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  ratePerPayroll
  """column name"""
  updatedAt
}

"""
input type for updating data in table "billing_plan"
"""
input billingPlansSetInput {
  createdAt: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  ratePerPayroll: numeric
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type billingPlansStddevFields {
  ratePerPayroll: Float
}

"""aggregate stddevPop on columns"""
type billingPlansStddevPopFields {
  ratePerPayroll: Float
}

"""aggregate stddevSamp on columns"""
type billingPlansStddevSampFields {
  ratePerPayroll: Float
}

"""
Streaming cursor of the table "billingPlans"
"""
input billingPlansStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: billingPlansStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input billingPlansStreamCursorValueInput {
  createdAt: timestamptz
  currency: String
  description: String
  id: uuid
  name: String
  ratePerPayroll: numeric
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type billingPlansSumFields {
  ratePerPayroll: numeric
}

"""
update columns of table "billing_plan"
"""
enum billingPlansUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  currency
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  ratePerPayroll
  """column name"""
  updatedAt
}

input billingPlansUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: billingPlansIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: billingPlansSetInput
  """filter the rows which have to be updated"""
  where: billingPlansBoolExp!
}

"""aggregate varPop on columns"""
type billingPlansVarPopFields {
  ratePerPayroll: Float
}

"""aggregate varSamp on columns"""
type billingPlansVarSampFields {
  ratePerPayroll: Float
}

"""aggregate variance on columns"""
type billingPlansVarianceFields {
  ratePerPayroll: Float
}

scalar bpchar

"""
columns and relationships of "client_billing_assignment"
"""
type clientBillingAssignments {
  """An object relationship"""
  assignedBillingPlan: billingPlans!
  """An object relationship"""
  assignedClient: clients!
  billingPlanId: uuid!
  clientId: uuid!
  createdAt: timestamptz
  endDate: date
  id: uuid!
  isActive: Boolean
  startDate: date!
  updatedAt: timestamptz
}

"""
aggregated selection of "client_billing_assignment"
"""
type clientBillingAssignmentsAggregate {
  aggregate: clientBillingAssignmentsAggregateFields
  nodes: [clientBillingAssignments!]!
}

input clientBillingAssignmentsAggregateBoolExp {
  bool_and: clientBillingAssignmentsAggregateBoolExpBool_and
  bool_or: clientBillingAssignmentsAggregateBoolExpBool_or
  count: clientBillingAssignmentsAggregateBoolExpCount
}

input clientBillingAssignmentsAggregateBoolExpBool_and {
  arguments: clientBillingAssignmentsSelectColumnClientBillingAssignmentsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: clientBillingAssignmentsBoolExp
  predicate: BooleanComparisonExp!
}

input clientBillingAssignmentsAggregateBoolExpBool_or {
  arguments: clientBillingAssignmentsSelectColumnClientBillingAssignmentsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: clientBillingAssignmentsBoolExp
  predicate: BooleanComparisonExp!
}

input clientBillingAssignmentsAggregateBoolExpCount {
  arguments: [clientBillingAssignmentsSelectColumn!]
  distinct: Boolean
  filter: clientBillingAssignmentsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "client_billing_assignment"
"""
type clientBillingAssignmentsAggregateFields {
  count(columns: [clientBillingAssignmentsSelectColumn!], distinct: Boolean): Int!
  max: clientBillingAssignmentsMaxFields
  min: clientBillingAssignmentsMinFields
}

"""
order by aggregate values of table "client_billing_assignment"
"""
input clientBillingAssignmentsAggregateOrderBy {
  count: OrderBy
  max: clientBillingAssignmentsMaxOrderBy
  min: clientBillingAssignmentsMinOrderBy
}

"""
input type for inserting array relation for remote table "client_billing_assignment"
"""
input clientBillingAssignmentsArrRelInsertInput {
  data: [clientBillingAssignmentsInsertInput!]!
  """upsert condition"""
  onConflict: clientBillingAssignmentsOnConflict
}

"""
Boolean expression to filter rows from the table "client_billing_assignment". All fields are combined with a logical 'AND'.
"""
input clientBillingAssignmentsBoolExp {
  _and: [clientBillingAssignmentsBoolExp!]
  _not: clientBillingAssignmentsBoolExp
  _or: [clientBillingAssignmentsBoolExp!]
  assignedBillingPlan: billingPlansBoolExp
  assignedClient: clientsBoolExp
  billingPlanId: UuidComparisonExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  startDate: DateComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "client_billing_assignment"
"""
enum clientBillingAssignmentsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  client_billing_assignment_pkey
}

"""
input type for inserting data into table "client_billing_assignment"
"""
input clientBillingAssignmentsInsertInput {
  assignedBillingPlan: billingPlansObjRelInsertInput
  assignedClient: clientsObjRelInsertInput
  billingPlanId: uuid
  clientId: uuid
  createdAt: timestamptz
  endDate: date
  id: uuid
  isActive: Boolean
  startDate: date
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type clientBillingAssignmentsMaxFields {
  billingPlanId: uuid
  clientId: uuid
  createdAt: timestamptz
  endDate: date
  id: uuid
  startDate: date
  updatedAt: timestamptz
}

"""
order by max() on columns of table "client_billing_assignment"
"""
input clientBillingAssignmentsMaxOrderBy {
  billingPlanId: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  endDate: OrderBy
  id: OrderBy
  startDate: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type clientBillingAssignmentsMinFields {
  billingPlanId: uuid
  clientId: uuid
  createdAt: timestamptz
  endDate: date
  id: uuid
  startDate: date
  updatedAt: timestamptz
}

"""
order by min() on columns of table "client_billing_assignment"
"""
input clientBillingAssignmentsMinOrderBy {
  billingPlanId: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  endDate: OrderBy
  id: OrderBy
  startDate: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "client_billing_assignment"
"""
type clientBillingAssignmentsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [clientBillingAssignments!]!
}

"""
on_conflict condition type for table "client_billing_assignment"
"""
input clientBillingAssignmentsOnConflict {
  constraint: clientBillingAssignmentsConstraint!
  updateColumns: [clientBillingAssignmentsUpdateColumn!]! = []
  where: clientBillingAssignmentsBoolExp
}

"""Ordering options when selecting data from "client_billing_assignment"."""
input clientBillingAssignmentsOrderBy {
  assignedBillingPlan: billingPlansOrderBy
  assignedClient: clientsOrderBy
  billingPlanId: OrderBy
  clientId: OrderBy
  createdAt: OrderBy
  endDate: OrderBy
  id: OrderBy
  isActive: OrderBy
  startDate: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: client_billing_assignment"""
input clientBillingAssignmentsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "client_billing_assignment"
"""
enum clientBillingAssignmentsSelectColumn {
  """column name"""
  billingPlanId
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  endDate
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  startDate
  """column name"""
  updatedAt
}

"""
select "clientBillingAssignmentsAggregateBoolExpBool_andArgumentsColumns" columns of table "client_billing_assignment"
"""
enum clientBillingAssignmentsSelectColumnClientBillingAssignmentsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
}

"""
select "clientBillingAssignmentsAggregateBoolExpBool_orArgumentsColumns" columns of table "client_billing_assignment"
"""
enum clientBillingAssignmentsSelectColumnClientBillingAssignmentsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
}

"""
input type for updating data in table "client_billing_assignment"
"""
input clientBillingAssignmentsSetInput {
  billingPlanId: uuid
  clientId: uuid
  createdAt: timestamptz
  endDate: date
  id: uuid
  isActive: Boolean
  startDate: date
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "clientBillingAssignments"
"""
input clientBillingAssignmentsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: clientBillingAssignmentsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input clientBillingAssignmentsStreamCursorValueInput {
  billingPlanId: uuid
  clientId: uuid
  createdAt: timestamptz
  endDate: date
  id: uuid
  isActive: Boolean
  startDate: date
  updatedAt: timestamptz
}

"""
update columns of table "client_billing_assignment"
"""
enum clientBillingAssignmentsUpdateColumn {
  """column name"""
  billingPlanId
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  endDate
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  startDate
  """column name"""
  updatedAt
}

input clientBillingAssignmentsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: clientBillingAssignmentsSetInput
  """filter the rows which have to be updated"""
  where: clientBillingAssignmentsBoolExp!
}

"""
columns and relationships of "client_external_systems"
"""
type clientExternalSystems {
  """Reference to the client"""
  clientId: uuid!
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Reference to the external system"""
  externalSystemId: uuid!
  """Unique identifier for the client-system mapping"""
  id: uuid!
  """An object relationship"""
  linkedClient: clients!
  """An object relationship"""
  linkedExternalSystem: externalSystems!
  """Client identifier in the external system"""
  systemClientId: String
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "client_external_systems"
"""
type clientExternalSystemsAggregate {
  aggregate: clientExternalSystemsAggregateFields
  nodes: [clientExternalSystems!]!
}

input clientExternalSystemsAggregateBoolExp {
  count: clientExternalSystemsAggregateBoolExpCount
}

input clientExternalSystemsAggregateBoolExpCount {
  arguments: [clientExternalSystemsSelectColumn!]
  distinct: Boolean
  filter: clientExternalSystemsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "client_external_systems"
"""
type clientExternalSystemsAggregateFields {
  count(columns: [clientExternalSystemsSelectColumn!], distinct: Boolean): Int!
  max: clientExternalSystemsMaxFields
  min: clientExternalSystemsMinFields
}

"""
order by aggregate values of table "client_external_systems"
"""
input clientExternalSystemsAggregateOrderBy {
  count: OrderBy
  max: clientExternalSystemsMaxOrderBy
  min: clientExternalSystemsMinOrderBy
}

"""
input type for inserting array relation for remote table "client_external_systems"
"""
input clientExternalSystemsArrRelInsertInput {
  data: [clientExternalSystemsInsertInput!]!
  """upsert condition"""
  onConflict: clientExternalSystemsOnConflict
}

"""
Boolean expression to filter rows from the table "client_external_systems". All fields are combined with a logical 'AND'.
"""
input clientExternalSystemsBoolExp {
  _and: [clientExternalSystemsBoolExp!]
  _not: clientExternalSystemsBoolExp
  _or: [clientExternalSystemsBoolExp!]
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  externalSystemId: UuidComparisonExp
  id: UuidComparisonExp
  linkedClient: clientsBoolExp
  linkedExternalSystem: externalSystemsBoolExp
  systemClientId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "client_external_systems"
"""
enum clientExternalSystemsConstraint {
  """
  unique or primary key constraint on columns "client_id", "system_id"
  """
  client_external_systems_client_id_system_id_key
  """
  unique or primary key constraint on columns "id"
  """
  client_external_systems_pkey
}

"""
input type for inserting data into table "client_external_systems"
"""
input clientExternalSystemsInsertInput {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Reference to the external system"""
  externalSystemId: uuid
  """Unique identifier for the client-system mapping"""
  id: uuid
  linkedClient: clientsObjRelInsertInput
  linkedExternalSystem: externalSystemsObjRelInsertInput
  """Client identifier in the external system"""
  systemClientId: String
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type clientExternalSystemsMaxFields {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Reference to the external system"""
  externalSystemId: uuid
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "client_external_systems"
"""
input clientExternalSystemsMaxOrderBy {
  """Reference to the client"""
  clientId: OrderBy
  """Timestamp when the mapping was created"""
  createdAt: OrderBy
  """Reference to the external system"""
  externalSystemId: OrderBy
  """Unique identifier for the client-system mapping"""
  id: OrderBy
  """Client identifier in the external system"""
  systemClientId: OrderBy
  """Timestamp when the mapping was last updated"""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type clientExternalSystemsMinFields {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Reference to the external system"""
  externalSystemId: uuid
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "client_external_systems"
"""
input clientExternalSystemsMinOrderBy {
  """Reference to the client"""
  clientId: OrderBy
  """Timestamp when the mapping was created"""
  createdAt: OrderBy
  """Reference to the external system"""
  externalSystemId: OrderBy
  """Unique identifier for the client-system mapping"""
  id: OrderBy
  """Client identifier in the external system"""
  systemClientId: OrderBy
  """Timestamp when the mapping was last updated"""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "client_external_systems"
"""
type clientExternalSystemsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [clientExternalSystems!]!
}

"""
on_conflict condition type for table "client_external_systems"
"""
input clientExternalSystemsOnConflict {
  constraint: clientExternalSystemsConstraint!
  updateColumns: [clientExternalSystemsUpdateColumn!]! = []
  where: clientExternalSystemsBoolExp
}

"""Ordering options when selecting data from "client_external_systems"."""
input clientExternalSystemsOrderBy {
  clientId: OrderBy
  createdAt: OrderBy
  externalSystemId: OrderBy
  id: OrderBy
  linkedClient: clientsOrderBy
  linkedExternalSystem: externalSystemsOrderBy
  systemClientId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: client_external_systems"""
input clientExternalSystemsPkColumnsInput {
  """Unique identifier for the client-system mapping"""
  id: uuid!
}

"""
select columns of table "client_external_systems"
"""
enum clientExternalSystemsSelectColumn {
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  externalSystemId
  """column name"""
  id
  """column name"""
  systemClientId
  """column name"""
  updatedAt
}

"""
input type for updating data in table "client_external_systems"
"""
input clientExternalSystemsSetInput {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Reference to the external system"""
  externalSystemId: uuid
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "clientExternalSystems"
"""
input clientExternalSystemsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: clientExternalSystemsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input clientExternalSystemsStreamCursorValueInput {
  """Reference to the client"""
  clientId: uuid
  """Timestamp when the mapping was created"""
  createdAt: timestamptz
  """Reference to the external system"""
  externalSystemId: uuid
  """Unique identifier for the client-system mapping"""
  id: uuid
  """Client identifier in the external system"""
  systemClientId: String
  """Timestamp when the mapping was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "client_external_systems"
"""
enum clientExternalSystemsUpdateColumn {
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  externalSystemId
  """column name"""
  id
  """column name"""
  systemClientId
  """column name"""
  updatedAt
}

input clientExternalSystemsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: clientExternalSystemsSetInput
  """filter the rows which have to be updated"""
  where: clientExternalSystemsBoolExp!
}

"""
columns and relationships of "clients"
"""
type clients {
  """Whether the client is currently active"""
  active: Boolean
  """An array relationship"""
  billingAssignments(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): [clientBillingAssignments!]!
  """An aggregate relationship"""
  billingAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): clientBillingAssignmentsAggregate!
  """An array relationship"""
  billingInvoices(
    """distinct select on columns"""
    distinctOn: [billingInvoicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoicesOrderBy!]
    """filter the rows returned"""
    where: billingInvoicesBoolExp
  ): [billingInvoices!]!
  """An aggregate relationship"""
  billingInvoicesAggregate(
    """distinct select on columns"""
    distinctOn: [billingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoiceOrderBy!]
    """filter the rows returned"""
    where: billingInvoiceBoolExp
  ): billingInvoiceAggregate!
  """An array relationship"""
  billing_invoices(
    """distinct select on columns"""
    distinctOn: [billingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoiceOrderBy!]
    """filter the rows returned"""
    where: billingInvoiceBoolExp
  ): [billingInvoice!]!
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """An array relationship"""
  externalSystems(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): [clientExternalSystems!]!
  """An aggregate relationship"""
  externalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): clientExternalSystemsAggregate!
  """Unique identifier for the client"""
  id: uuid!
  """Client company name"""
  name: String!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "clients"
"""
type clientsAggregate {
  aggregate: clientsAggregateFields
  nodes: [clients!]!
}

input clientsAggregateBoolExp {
  bool_and: clientsAggregateBoolExpBool_and
  bool_or: clientsAggregateBoolExpBool_or
  count: clientsAggregateBoolExpCount
}

input clientsAggregateBoolExpBool_and {
  arguments: clientsSelectColumnClientsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: clientsBoolExp
  predicate: BooleanComparisonExp!
}

input clientsAggregateBoolExpBool_or {
  arguments: clientsSelectColumnClientsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: clientsBoolExp
  predicate: BooleanComparisonExp!
}

input clientsAggregateBoolExpCount {
  arguments: [clientsSelectColumn!]
  distinct: Boolean
  filter: clientsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "clients"
"""
type clientsAggregateFields {
  count(columns: [clientsSelectColumn!], distinct: Boolean): Int!
  max: clientsMaxFields
  min: clientsMinFields
}

"""
order by aggregate values of table "clients"
"""
input clientsAggregateOrderBy {
  count: OrderBy
  max: clientsMaxOrderBy
  min: clientsMinOrderBy
}

"""
input type for inserting array relation for remote table "clients"
"""
input clientsArrRelInsertInput {
  data: [clientsInsertInput!]!
  """upsert condition"""
  onConflict: clientsOnConflict
}

"""
Boolean expression to filter rows from the table "clients". All fields are combined with a logical 'AND'.
"""
input clientsBoolExp {
  _and: [clientsBoolExp!]
  _not: clientsBoolExp
  _or: [clientsBoolExp!]
  active: BooleanComparisonExp
  billingAssignments: clientBillingAssignmentsBoolExp
  billingAssignmentsAggregate: clientBillingAssignmentsAggregateBoolExp
  billingInvoices: billingInvoicesBoolExp
  billingInvoicesAggregate: billingInvoicesAggregateBoolExp
  billing_invoices: billingInvoiceBoolExp
  billing_invoicesAggregate: billingInvoiceAggregateBoolExp
  contactEmail: StringComparisonExp
  contactPerson: StringComparisonExp
  contactPhone: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  externalSystems: clientExternalSystemsBoolExp
  externalSystemsAggregate: clientExternalSystemsAggregateBoolExp
  id: UuidComparisonExp
  name: StringComparisonExp
  payrolls: payrollsBoolExp
  payrollsAggregate: payrollsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "clients"
"""
enum clientsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  clients_pkey
}

"""
input type for inserting data into table "clients"
"""
input clientsInsertInput {
  """Whether the client is currently active"""
  active: Boolean
  billingAssignments: clientBillingAssignmentsArrRelInsertInput
  billingInvoices: billingInvoicesArrRelInsertInput
  billing_invoices: billingInvoiceArrRelInsertInput
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  externalSystems: clientExternalSystemsArrRelInsertInput
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  payrolls: payrollsArrRelInsertInput
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type clientsMaxFields {
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "clients"
"""
input clientsMaxOrderBy {
  """Email address for the client contact"""
  contactEmail: OrderBy
  """Primary contact person at the client"""
  contactPerson: OrderBy
  """Phone number for the client contact"""
  contactPhone: OrderBy
  """Timestamp when the client was created"""
  createdAt: OrderBy
  """Unique identifier for the client"""
  id: OrderBy
  """Client company name"""
  name: OrderBy
  """Timestamp when the client was last updated"""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type clientsMinFields {
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "clients"
"""
input clientsMinOrderBy {
  """Email address for the client contact"""
  contactEmail: OrderBy
  """Primary contact person at the client"""
  contactPerson: OrderBy
  """Phone number for the client contact"""
  contactPhone: OrderBy
  """Timestamp when the client was created"""
  createdAt: OrderBy
  """Unique identifier for the client"""
  id: OrderBy
  """Client company name"""
  name: OrderBy
  """Timestamp when the client was last updated"""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "clients"
"""
type clientsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [clients!]!
}

"""
input type for inserting object relation for remote table "clients"
"""
input clientsObjRelInsertInput {
  data: clientsInsertInput!
  """upsert condition"""
  onConflict: clientsOnConflict
}

"""
on_conflict condition type for table "clients"
"""
input clientsOnConflict {
  constraint: clientsConstraint!
  updateColumns: [clientsUpdateColumn!]! = []
  where: clientsBoolExp
}

"""Ordering options when selecting data from "clients"."""
input clientsOrderBy {
  active: OrderBy
  billingAssignmentsAggregate: clientBillingAssignmentsAggregateOrderBy
  billingInvoicesAggregate: billingInvoicesAggregateOrderBy
  billing_invoicesAggregate: billingInvoiceAggregateOrderBy
  contactEmail: OrderBy
  contactPerson: OrderBy
  contactPhone: OrderBy
  createdAt: OrderBy
  externalSystemsAggregate: clientExternalSystemsAggregateOrderBy
  id: OrderBy
  name: OrderBy
  payrollsAggregate: payrollsAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: clients"""
input clientsPkColumnsInput {
  """Unique identifier for the client"""
  id: uuid!
}

"""
select columns of table "clients"
"""
enum clientsSelectColumn {
  """column name"""
  active
  """column name"""
  contactEmail
  """column name"""
  contactPerson
  """column name"""
  contactPhone
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
select "clientsAggregateBoolExpBool_andArgumentsColumns" columns of table "clients"
"""
enum clientsSelectColumnClientsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  active
}

"""
select "clientsAggregateBoolExpBool_orArgumentsColumns" columns of table "clients"
"""
enum clientsSelectColumnClientsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  active
}

"""
input type for updating data in table "clients"
"""
input clientsSetInput {
  """Whether the client is currently active"""
  active: Boolean
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "clients"
"""
input clientsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: clientsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input clientsStreamCursorValueInput {
  """Whether the client is currently active"""
  active: Boolean
  """Email address for the client contact"""
  contactEmail: String
  """Primary contact person at the client"""
  contactPerson: String
  """Phone number for the client contact"""
  contactPhone: String
  """Timestamp when the client was created"""
  createdAt: timestamptz
  """Unique identifier for the client"""
  id: uuid
  """Client company name"""
  name: String
  """Timestamp when the client was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "clients"
"""
enum clientsUpdateColumn {
  """column name"""
  active
  """column name"""
  contactEmail
  """column name"""
  contactPerson
  """column name"""
  contactPhone
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input clientsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: clientsSetInput
  """filter the rows which have to be updated"""
  where: clientsBoolExp!
}

input createPayrollVersionArgs {
  p_created_by_user_id: uuid
  p_go_live_date: date
  p_new_backup_consultant_user_id: uuid
  p_new_client_id: uuid
  p_new_cycle_id: uuid
  p_new_date_type_id: uuid
  p_new_date_value: Int
  p_new_manager_user_id: uuid
  p_new_name: String
  p_new_primary_consultant_user_id: uuid
  p_original_payroll_id: uuid
  p_version_reason: String
}

input createPayrollVersionSimpleArgs {
  payroll_id: uuid
  version_reason: String
}

"""
columns and relationships of "current_payrolls"
"""
type currentPayrolls {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregated selection of "current_payrolls"
"""
type currentPayrollsAggregate {
  aggregate: currentPayrollsAggregateFields
  nodes: [currentPayrolls!]!
}

"""
aggregate fields of "current_payrolls"
"""
type currentPayrollsAggregateFields {
  avg: currentPayrollsAvgFields
  count(columns: [currentPayrollsSelectColumn!], distinct: Boolean): Int!
  max: currentPayrollsMaxFields
  min: currentPayrollsMinFields
  stddev: currentPayrollsStddevFields
  stddevPop: currentPayrollsStddevPopFields
  stddevSamp: currentPayrollsStddevSampFields
  sum: currentPayrollsSumFields
  varPop: currentPayrollsVarPopFields
  varSamp: currentPayrollsVarSampFields
  variance: currentPayrollsVarianceFields
}

"""aggregate avg on columns"""
type currentPayrollsAvgFields {
  dateValue: Float
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "current_payrolls". All fields are combined with a logical 'AND'.
"""
input currentPayrollsBoolExp {
  _and: [currentPayrollsBoolExp!]
  _not: currentPayrollsBoolExp
  _or: [currentPayrollsBoolExp!]
  backupConsultantUserId: UuidComparisonExp
  clientId: UuidComparisonExp
  clientName: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  cycleId: UuidComparisonExp
  dateTypeId: UuidComparisonExp
  dateValue: IntComparisonExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  managerUserId: UuidComparisonExp
  name: StringComparisonExp
  parentPayrollId: UuidComparisonExp
  payrollCycleName: PayrollCycleTypeComparisonExp
  payrollDateTypeName: PayrollDateTypeComparisonExp
  primaryConsultantUserId: UuidComparisonExp
  supersededDate: DateComparisonExp
  updatedAt: TimestamptzComparisonExp
  versionNumber: IntComparisonExp
  versionReason: StringComparisonExp
}

"""aggregate max on columns"""
type currentPayrollsMaxFields {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate min on columns"""
type currentPayrollsMinFields {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""Ordering options when selecting data from "current_payrolls"."""
input currentPayrollsOrderBy {
  backupConsultantUserId: OrderBy
  clientId: OrderBy
  clientName: OrderBy
  createdAt: OrderBy
  cycleId: OrderBy
  dateTypeId: OrderBy
  dateValue: OrderBy
  goLiveDate: OrderBy
  id: OrderBy
  managerUserId: OrderBy
  name: OrderBy
  parentPayrollId: OrderBy
  payrollCycleName: OrderBy
  payrollDateTypeName: OrderBy
  primaryConsultantUserId: OrderBy
  supersededDate: OrderBy
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""
select columns of table "current_payrolls"
"""
enum currentPayrollsSelectColumn {
  """column name"""
  backupConsultantUserId
  """column name"""
  clientId
  """column name"""
  clientName
  """column name"""
  createdAt
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  dateValue
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  parentPayrollId
  """column name"""
  payrollCycleName
  """column name"""
  payrollDateTypeName
  """column name"""
  primaryConsultantUserId
  """column name"""
  supersededDate
  """column name"""
  updatedAt
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

"""aggregate stddev on columns"""
type currentPayrollsStddevFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type currentPayrollsStddevPopFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type currentPayrollsStddevSampFields {
  dateValue: Float
  versionNumber: Float
}

"""
Streaming cursor of the table "currentPayrolls"
"""
input currentPayrollsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: currentPayrollsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input currentPayrollsStreamCursorValueInput {
  backupConsultantUserId: uuid
  clientId: uuid
  clientName: String
  createdAt: timestamptz
  cycleId: uuid
  dateTypeId: uuid
  dateValue: Int
  goLiveDate: date
  id: uuid
  managerUserId: uuid
  name: String
  parentPayrollId: uuid
  payrollCycleName: payroll_cycle_type
  payrollDateTypeName: payroll_date_type
  primaryConsultantUserId: uuid
  supersededDate: date
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate sum on columns"""
type currentPayrollsSumFields {
  dateValue: Int
  versionNumber: Int
}

"""aggregate varPop on columns"""
type currentPayrollsVarPopFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type currentPayrollsVarSampFields {
  dateValue: Float
  versionNumber: Float
}

"""aggregate variance on columns"""
type currentPayrollsVarianceFields {
  dateValue: Float
  versionNumber: Float
}

"""
columns and relationships of "audit.data_access_log"
"""
type dataAccessLogs {
  accessType: String!
  accessedAt: timestamptz!
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid!
  ipAddress: inet
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String!
  rowCount: Int
  sessionId: String
  userId: uuid!
}

"""
aggregated selection of "audit.data_access_log"
"""
type dataAccessLogsAggregate {
  aggregate: dataAccessLogsAggregateFields
  nodes: [dataAccessLogs!]!
}

"""
aggregate fields of "audit.data_access_log"
"""
type dataAccessLogsAggregateFields {
  avg: dataAccessLogsAvgFields
  count(columns: [dataAccessLogsSelectColumn!], distinct: Boolean): Int!
  max: dataAccessLogsMaxFields
  min: dataAccessLogsMinFields
  stddev: dataAccessLogsStddevFields
  stddevPop: dataAccessLogsStddevPopFields
  stddevSamp: dataAccessLogsStddevSampFields
  sum: dataAccessLogsSumFields
  varPop: dataAccessLogsVarPopFields
  varSamp: dataAccessLogsVarSampFields
  variance: dataAccessLogsVarianceFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input dataAccessLogsAppendInput {
  metadata: jsonb
}

"""aggregate avg on columns"""
type dataAccessLogsAvgFields {
  rowCount: Float
}

"""
Boolean expression to filter rows from the table "audit.data_access_log". All fields are combined with a logical 'AND'.
"""
input dataAccessLogsBoolExp {
  _and: [dataAccessLogsBoolExp!]
  _not: dataAccessLogsBoolExp
  _or: [dataAccessLogsBoolExp!]
  accessType: StringComparisonExp
  accessedAt: TimestamptzComparisonExp
  dataClassification: StringComparisonExp
  fieldsAccessed: StringArrayComparisonExp
  id: UuidComparisonExp
  ipAddress: InetComparisonExp
  metadata: JsonbComparisonExp
  queryExecuted: StringComparisonExp
  resourceId: StringComparisonExp
  resourceType: StringComparisonExp
  rowCount: IntComparisonExp
  sessionId: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.data_access_log"
"""
enum dataAccessLogsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  data_access_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input dataAccessLogsDeleteAtPathInput {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input dataAccessLogsDeleteElemInput {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input dataAccessLogsDeleteKeyInput {
  metadata: String
}

"""
input type for incrementing numeric columns in table "audit.data_access_log"
"""
input dataAccessLogsIncInput {
  rowCount: Int
}

"""
input type for inserting data into table "audit.data_access_log"
"""
input dataAccessLogsInsertInput {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate max on columns"""
type dataAccessLogsMaxFields {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate min on columns"""
type dataAccessLogsMinFields {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""
response of any mutation on the table "audit.data_access_log"
"""
type dataAccessLogsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [dataAccessLogs!]!
}

"""
on_conflict condition type for table "audit.data_access_log"
"""
input dataAccessLogsOnConflict {
  constraint: dataAccessLogsConstraint!
  updateColumns: [dataAccessLogsUpdateColumn!]! = []
  where: dataAccessLogsBoolExp
}

"""Ordering options when selecting data from "audit.data_access_log"."""
input dataAccessLogsOrderBy {
  accessType: OrderBy
  accessedAt: OrderBy
  dataClassification: OrderBy
  fieldsAccessed: OrderBy
  id: OrderBy
  ipAddress: OrderBy
  metadata: OrderBy
  queryExecuted: OrderBy
  resourceId: OrderBy
  resourceType: OrderBy
  rowCount: OrderBy
  sessionId: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: audit.data_access_log"""
input dataAccessLogsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input dataAccessLogsPrependInput {
  metadata: jsonb
}

"""
select columns of table "audit.data_access_log"
"""
enum dataAccessLogsSelectColumn {
  """column name"""
  accessType
  """column name"""
  accessedAt
  """column name"""
  dataClassification
  """column name"""
  fieldsAccessed
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  queryExecuted
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  rowCount
  """column name"""
  sessionId
  """column name"""
  userId
}

"""
input type for updating data in table "audit.data_access_log"
"""
input dataAccessLogsSetInput {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate stddev on columns"""
type dataAccessLogsStddevFields {
  rowCount: Float
}

"""aggregate stddevPop on columns"""
type dataAccessLogsStddevPopFields {
  rowCount: Float
}

"""aggregate stddevSamp on columns"""
type dataAccessLogsStddevSampFields {
  rowCount: Float
}

"""
Streaming cursor of the table "dataAccessLogs"
"""
input dataAccessLogsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: dataAccessLogsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input dataAccessLogsStreamCursorValueInput {
  accessType: String
  accessedAt: timestamptz
  dataClassification: String
  fieldsAccessed: [String!]
  id: uuid
  ipAddress: inet
  metadata: jsonb
  queryExecuted: String
  resourceId: String
  resourceType: String
  rowCount: Int
  sessionId: String
  userId: uuid
}

"""aggregate sum on columns"""
type dataAccessLogsSumFields {
  rowCount: Int
}

"""
update columns of table "audit.data_access_log"
"""
enum dataAccessLogsUpdateColumn {
  """column name"""
  accessType
  """column name"""
  accessedAt
  """column name"""
  dataClassification
  """column name"""
  fieldsAccessed
  """column name"""
  id
  """column name"""
  ipAddress
  """column name"""
  metadata
  """column name"""
  queryExecuted
  """column name"""
  resourceId
  """column name"""
  resourceType
  """column name"""
  rowCount
  """column name"""
  sessionId
  """column name"""
  userId
}

input dataAccessLogsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: dataAccessLogsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: dataAccessLogsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: dataAccessLogsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: dataAccessLogsDeleteKeyInput
  """increments the numeric columns with given value of the filtered values"""
  _inc: dataAccessLogsIncInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: dataAccessLogsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: dataAccessLogsSetInput
  """filter the rows which have to be updated"""
  where: dataAccessLogsBoolExp!
}

"""aggregate varPop on columns"""
type dataAccessLogsVarPopFields {
  rowCount: Float
}

"""aggregate varSamp on columns"""
type dataAccessLogsVarSampFields {
  rowCount: Float
}

"""aggregate variance on columns"""
type dataAccessLogsVarianceFields {
  rowCount: Float
}

scalar date

"""
columns and relationships of "external_systems"
"""
type externalSystems {
  """An array relationship"""
  clientExternalSystems(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): [clientExternalSystems!]!
  """An aggregate relationship"""
  clientExternalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): clientExternalSystemsAggregate!
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid!
  """Name of the external system"""
  name: String!
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String!
}

"""
aggregated selection of "external_systems"
"""
type externalSystemsAggregate {
  aggregate: externalSystemsAggregateFields
  nodes: [externalSystems!]!
}

"""
aggregate fields of "external_systems"
"""
type externalSystemsAggregateFields {
  count(columns: [externalSystemsSelectColumn!], distinct: Boolean): Int!
  max: externalSystemsMaxFields
  min: externalSystemsMinFields
}

"""
Boolean expression to filter rows from the table "external_systems". All fields are combined with a logical 'AND'.
"""
input externalSystemsBoolExp {
  _and: [externalSystemsBoolExp!]
  _not: externalSystemsBoolExp
  _or: [externalSystemsBoolExp!]
  clientExternalSystems: clientExternalSystemsBoolExp
  clientExternalSystemsAggregate: clientExternalSystemsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  icon: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  url: StringComparisonExp
}

"""
unique or primary key constraints on table "external_systems"
"""
enum externalSystemsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  external_systems_pkey
}

"""
input type for inserting data into table "external_systems"
"""
input externalSystemsInsertInput {
  clientExternalSystems: clientExternalSystemsArrRelInsertInput
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""aggregate max on columns"""
type externalSystemsMaxFields {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""aggregate min on columns"""
type externalSystemsMinFields {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""
response of any mutation on the table "external_systems"
"""
type externalSystemsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [externalSystems!]!
}

"""
input type for inserting object relation for remote table "external_systems"
"""
input externalSystemsObjRelInsertInput {
  data: externalSystemsInsertInput!
  """upsert condition"""
  onConflict: externalSystemsOnConflict
}

"""
on_conflict condition type for table "external_systems"
"""
input externalSystemsOnConflict {
  constraint: externalSystemsConstraint!
  updateColumns: [externalSystemsUpdateColumn!]! = []
  where: externalSystemsBoolExp
}

"""Ordering options when selecting data from "external_systems"."""
input externalSystemsOrderBy {
  clientExternalSystemsAggregate: clientExternalSystemsAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  icon: OrderBy
  id: OrderBy
  name: OrderBy
  updatedAt: OrderBy
  url: OrderBy
}

"""primary key columns input for table: external_systems"""
input externalSystemsPkColumnsInput {
  """Unique identifier for the external system"""
  id: uuid!
}

"""
select columns of table "external_systems"
"""
enum externalSystemsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  icon
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
  """column name"""
  url
}

"""
input type for updating data in table "external_systems"
"""
input externalSystemsSetInput {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""
Streaming cursor of the table "externalSystems"
"""
input externalSystemsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: externalSystemsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input externalSystemsStreamCursorValueInput {
  """Timestamp when the system was created"""
  createdAt: timestamptz
  """Description of the external system and its purpose"""
  description: String
  """Path or reference to the system icon"""
  icon: String
  """Unique identifier for the external system"""
  id: uuid
  """Name of the external system"""
  name: String
  """Timestamp when the system was last updated"""
  updatedAt: timestamptz
  """URL endpoint for the external system"""
  url: String
}

"""
update columns of table "external_systems"
"""
enum externalSystemsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  icon
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
  """column name"""
  url
}

input externalSystemsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: externalSystemsSetInput
  """filter the rows which have to be updated"""
  where: externalSystemsBoolExp!
}

"""
columns and relationships of "feature_flags"
"""
type featureFlags {
  """JSON array of roles that can access this feature"""
  allowedRoles(
    """JSON select path"""
    path: String
  ): jsonb!
  """Name of the feature controlled by this flag"""
  featureName: String!
  """Unique identifier for the feature flag"""
  id: uuid!
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "feature_flags"
"""
type featureFlagsAggregate {
  aggregate: featureFlagsAggregateFields
  nodes: [featureFlags!]!
}

"""
aggregate fields of "feature_flags"
"""
type featureFlagsAggregateFields {
  count(columns: [featureFlagsSelectColumn!], distinct: Boolean): Int!
  max: featureFlagsMaxFields
  min: featureFlagsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input featureFlagsAppendInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
}

"""
Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'.
"""
input featureFlagsBoolExp {
  _and: [featureFlagsBoolExp!]
  _not: featureFlagsBoolExp
  _or: [featureFlagsBoolExp!]
  allowedRoles: JsonbComparisonExp
  featureName: StringComparisonExp
  id: UuidComparisonExp
  isEnabled: BooleanComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "feature_flags"
"""
enum featureFlagsConstraint {
  """
  unique or primary key constraint on columns "feature_name"
  """
  feature_flags_feature_name_key
  """
  unique or primary key constraint on columns "id"
  """
  feature_flags_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input featureFlagsDeleteAtPathInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input featureFlagsDeleteElemInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input featureFlagsDeleteKeyInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: String
}

"""
input type for inserting data into table "feature_flags"
"""
input featureFlagsInsertInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type featureFlagsMaxFields {
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type featureFlagsMinFields {
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "feature_flags"
"""
type featureFlagsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [featureFlags!]!
}

"""
on_conflict condition type for table "feature_flags"
"""
input featureFlagsOnConflict {
  constraint: featureFlagsConstraint!
  updateColumns: [featureFlagsUpdateColumn!]! = []
  where: featureFlagsBoolExp
}

"""Ordering options when selecting data from "feature_flags"."""
input featureFlagsOrderBy {
  allowedRoles: OrderBy
  featureName: OrderBy
  id: OrderBy
  isEnabled: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: feature_flags"""
input featureFlagsPkColumnsInput {
  """Unique identifier for the feature flag"""
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input featureFlagsPrependInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
}

"""
select columns of table "feature_flags"
"""
enum featureFlagsSelectColumn {
  """column name"""
  allowedRoles
  """column name"""
  featureName
  """column name"""
  id
  """column name"""
  isEnabled
  """column name"""
  updatedAt
}

"""
input type for updating data in table "feature_flags"
"""
input featureFlagsSetInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "featureFlags"
"""
input featureFlagsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: featureFlagsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input featureFlagsStreamCursorValueInput {
  """JSON array of roles that can access this feature"""
  allowedRoles: jsonb
  """Name of the feature controlled by this flag"""
  featureName: String
  """Unique identifier for the feature flag"""
  id: uuid
  """Whether the feature is currently enabled"""
  isEnabled: Boolean
  """Timestamp when the feature flag was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "feature_flags"
"""
enum featureFlagsUpdateColumn {
  """column name"""
  allowedRoles
  """column name"""
  featureName
  """column name"""
  id
  """column name"""
  isEnabled
  """column name"""
  updatedAt
}

input featureFlagsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: featureFlagsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: featureFlagsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: featureFlagsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: featureFlagsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: featureFlagsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: featureFlagsSetInput
  """filter the rows which have to be updated"""
  where: featureFlagsBoolExp!
}

input generatePayrollDatesArgs {
  p_end_date: date
  p_max_dates: Int
  p_payroll_id: uuid
  p_start_date: date
}

input getLatestPayrollVersionArgs {
  payroll_id: uuid
}

input getPayrollVersionHistoryArgs {
  payroll_id: uuid
}

"""
columns and relationships of "holidays"
"""
type holidays {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar!
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date!
  """Unique identifier for the holiday"""
  id: uuid!
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String!
  """Name of the holiday in English"""
  name: String!
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]!
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "holidays"
"""
type holidaysAggregate {
  aggregate: holidaysAggregateFields
  nodes: [holidays!]!
}

"""
aggregate fields of "holidays"
"""
type holidaysAggregateFields {
  avg: holidaysAvgFields
  count(columns: [holidaysSelectColumn!], distinct: Boolean): Int!
  max: holidaysMaxFields
  min: holidaysMinFields
  stddev: holidaysStddevFields
  stddevPop: holidaysStddevPopFields
  stddevSamp: holidaysStddevSampFields
  sum: holidaysSumFields
  varPop: holidaysVarPopFields
  varSamp: holidaysVarSampFields
  variance: holidaysVarianceFields
}

"""aggregate avg on columns"""
type holidaysAvgFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""
Boolean expression to filter rows from the table "holidays". All fields are combined with a logical 'AND'.
"""
input holidaysBoolExp {
  _and: [holidaysBoolExp!]
  _not: holidaysBoolExp
  _or: [holidaysBoolExp!]
  countryCode: BpcharComparisonExp
  createdAt: TimestamptzComparisonExp
  date: DateComparisonExp
  id: UuidComparisonExp
  isFixed: BooleanComparisonExp
  isGlobal: BooleanComparisonExp
  launchYear: IntComparisonExp
  localName: StringComparisonExp
  name: StringComparisonExp
  region: StringArrayComparisonExp
  types: StringArrayComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "holidays"
"""
enum holidaysConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  holidays_pkey
}

"""
input type for incrementing numeric columns in table "holidays"
"""
input holidaysIncInput {
  """First year when the holiday was observed"""
  launchYear: Int
}

"""
input type for inserting data into table "holidays"
"""
input holidaysInsertInput {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type holidaysMaxFields {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type holidaysMinFields {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "holidays"
"""
type holidaysMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [holidays!]!
}

"""
on_conflict condition type for table "holidays"
"""
input holidaysOnConflict {
  constraint: holidaysConstraint!
  updateColumns: [holidaysUpdateColumn!]! = []
  where: holidaysBoolExp
}

"""Ordering options when selecting data from "holidays"."""
input holidaysOrderBy {
  countryCode: OrderBy
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
  isFixed: OrderBy
  isGlobal: OrderBy
  launchYear: OrderBy
  localName: OrderBy
  name: OrderBy
  region: OrderBy
  types: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: holidays"""
input holidaysPkColumnsInput {
  """Unique identifier for the holiday"""
  id: uuid!
}

"""
select columns of table "holidays"
"""
enum holidaysSelectColumn {
  """column name"""
  countryCode
  """column name"""
  createdAt
  """column name"""
  date
  """column name"""
  id
  """column name"""
  isFixed
  """column name"""
  isGlobal
  """column name"""
  launchYear
  """column name"""
  localName
  """column name"""
  name
  """column name"""
  region
  """column name"""
  types
  """column name"""
  updatedAt
}

"""
input type for updating data in table "holidays"
"""
input holidaysSetInput {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type holidaysStddevFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate stddevPop on columns"""
type holidaysStddevPopFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate stddevSamp on columns"""
type holidaysStddevSampFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""
Streaming cursor of the table "holidays"
"""
input holidaysStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: holidaysStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input holidaysStreamCursorValueInput {
  """ISO country code where the holiday is observed"""
  countryCode: bpchar
  """Timestamp when the holiday record was created"""
  createdAt: timestamptz
  """Date of the holiday"""
  date: date
  """Unique identifier for the holiday"""
  id: uuid
  """Whether the holiday occurs on the same date each year"""
  isFixed: Boolean
  """Whether the holiday is observed globally"""
  isGlobal: Boolean
  """First year when the holiday was observed"""
  launchYear: Int
  """Name of the holiday in local language"""
  localName: String
  """Name of the holiday in English"""
  name: String
  """Array of regions within the country where the holiday applies"""
  region: [String!]
  """Array of holiday types (e.g., public, bank, religious)"""
  types: [String!]
  """Timestamp when the holiday record was last updated"""
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type holidaysSumFields {
  """First year when the holiday was observed"""
  launchYear: Int
}

"""
update columns of table "holidays"
"""
enum holidaysUpdateColumn {
  """column name"""
  countryCode
  """column name"""
  createdAt
  """column name"""
  date
  """column name"""
  id
  """column name"""
  isFixed
  """column name"""
  isGlobal
  """column name"""
  launchYear
  """column name"""
  localName
  """column name"""
  name
  """column name"""
  region
  """column name"""
  types
  """column name"""
  updatedAt
}

input holidaysUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: holidaysIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: holidaysSetInput
  """filter the rows which have to be updated"""
  where: holidaysBoolExp!
}

"""aggregate varPop on columns"""
type holidaysVarPopFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate varSamp on columns"""
type holidaysVarSampFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

"""aggregate variance on columns"""
type holidaysVarianceFields {
  """First year when the holiday was observed"""
  launchYear: Float
}

scalar inet

scalar interval

scalar json

scalar jsonb

"""
columns and relationships of "latest_payroll_version_results"
"""
type latestPayrollVersionResults {
  active: Boolean!
  goLiveDate: date
  id: uuid!
  name: String!
  payrollId: uuid!
  queriedAt: timestamptz
  versionNumber: Int!
}

type latestPayrollVersionResultsAggregate {
  aggregate: latestPayrollVersionResultsAggregateFields
  nodes: [latestPayrollVersionResults!]!
}

"""
aggregate fields of "latest_payroll_version_results"
"""
type latestPayrollVersionResultsAggregateFields {
  avg: latestPayrollVersionResultsAvgFields
  count(columns: [latestPayrollVersionResultsSelectColumn!], distinct: Boolean): Int!
  max: latestPayrollVersionResultsMaxFields
  min: latestPayrollVersionResultsMinFields
  stddev: latestPayrollVersionResultsStddevFields
  stddevPop: latestPayrollVersionResultsStddevPopFields
  stddevSamp: latestPayrollVersionResultsStddevSampFields
  sum: latestPayrollVersionResultsSumFields
  varPop: latestPayrollVersionResultsVarPopFields
  varSamp: latestPayrollVersionResultsVarSampFields
  variance: latestPayrollVersionResultsVarianceFields
}

"""aggregate avg on columns"""
type latestPayrollVersionResultsAvgFields {
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "latest_payroll_version_results". All fields are combined with a logical 'AND'.
"""
input latestPayrollVersionResultsBoolExp {
  _and: [latestPayrollVersionResultsBoolExp!]
  _not: latestPayrollVersionResultsBoolExp
  _or: [latestPayrollVersionResultsBoolExp!]
  active: BooleanComparisonExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  payrollId: UuidComparisonExp
  queriedAt: TimestamptzComparisonExp
  versionNumber: IntComparisonExp
}

"""
unique or primary key constraints on table "latest_payroll_version_results"
"""
enum latestPayrollVersionResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  latest_payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "latest_payroll_version_results"
"""
input latestPayrollVersionResultsIncInput {
  versionNumber: Int
}

"""
input type for inserting data into table "latest_payroll_version_results"
"""
input latestPayrollVersionResultsInsertInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate max on columns"""
type latestPayrollVersionResultsMaxFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate min on columns"""
type latestPayrollVersionResultsMinFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""
response of any mutation on the table "latest_payroll_version_results"
"""
type latestPayrollVersionResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [latestPayrollVersionResults!]!
}

"""
on_conflict condition type for table "latest_payroll_version_results"
"""
input latestPayrollVersionResultsOnConflict {
  constraint: latestPayrollVersionResultsConstraint!
  updateColumns: [latestPayrollVersionResultsUpdateColumn!]! = []
  where: latestPayrollVersionResultsBoolExp
}

"""
Ordering options when selecting data from "latest_payroll_version_results".
"""
input latestPayrollVersionResultsOrderBy {
  active: OrderBy
  goLiveDate: OrderBy
  id: OrderBy
  name: OrderBy
  payrollId: OrderBy
  queriedAt: OrderBy
  versionNumber: OrderBy
}

"""primary key columns input for table: latest_payroll_version_results"""
input latestPayrollVersionResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "latest_payroll_version_results"
"""
enum latestPayrollVersionResultsSelectColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  versionNumber
}

"""
input type for updating data in table "latest_payroll_version_results"
"""
input latestPayrollVersionResultsSetInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate stddev on columns"""
type latestPayrollVersionResultsStddevFields {
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type latestPayrollVersionResultsStddevPopFields {
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type latestPayrollVersionResultsStddevSampFields {
  versionNumber: Float
}

"""
Streaming cursor of the table "latestPayrollVersionResults"
"""
input latestPayrollVersionResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: latestPayrollVersionResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input latestPayrollVersionResultsStreamCursorValueInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  versionNumber: Int
}

"""aggregate sum on columns"""
type latestPayrollVersionResultsSumFields {
  versionNumber: Int
}

"""
update columns of table "latest_payroll_version_results"
"""
enum latestPayrollVersionResultsUpdateColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  versionNumber
}

input latestPayrollVersionResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: latestPayrollVersionResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: latestPayrollVersionResultsSetInput
  """filter the rows which have to be updated"""
  where: latestPayrollVersionResultsBoolExp!
}

"""aggregate varPop on columns"""
type latestPayrollVersionResultsVarPopFields {
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type latestPayrollVersionResultsVarSampFields {
  versionNumber: Float
}

"""aggregate variance on columns"""
type latestPayrollVersionResultsVarianceFields {
  versionNumber: Float
}

"""
columns and relationships of "leave"
"""
type leave {
  """Last day of the leave period"""
  endDate: date!
  """Unique identifier for the leave record"""
  id: uuid!
  """An object relationship"""
  leaveRequester: users!
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String!
  """An object relationship"""
  leaveUser: users!
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date!
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Reference to the user taking leave"""
  userId: uuid!
}

"""
aggregated selection of "leave"
"""
type leaveAggregate {
  aggregate: leaveAggregateFields
  nodes: [leave!]!
}

input leaveAggregateBoolExp {
  count: leaveAggregateBoolExpCount
}

input leaveAggregateBoolExpCount {
  arguments: [leaveSelectColumn!]
  distinct: Boolean
  filter: leaveBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "leave"
"""
type leaveAggregateFields {
  count(columns: [leaveSelectColumn!], distinct: Boolean): Int!
  max: leaveMaxFields
  min: leaveMinFields
}

"""
order by aggregate values of table "leave"
"""
input leaveAggregateOrderBy {
  count: OrderBy
  max: leaveMaxOrderBy
  min: leaveMinOrderBy
}

"""
input type for inserting array relation for remote table "leave"
"""
input leaveArrRelInsertInput {
  data: [leaveInsertInput!]!
  """upsert condition"""
  onConflict: leaveOnConflict
}

"""
Boolean expression to filter rows from the table "leave". All fields are combined with a logical 'AND'.
"""
input leaveBoolExp {
  _and: [leaveBoolExp!]
  _not: leaveBoolExp
  _or: [leaveBoolExp!]
  endDate: DateComparisonExp
  id: UuidComparisonExp
  leaveRequester: usersBoolExp
  leaveType: StringComparisonExp
  leaveUser: usersBoolExp
  reason: StringComparisonExp
  startDate: DateComparisonExp
  status: LeaveStatusEnumComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "leave"
"""
enum leaveConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  leave_pkey
}

"""
input type for inserting data into table "leave"
"""
input leaveInsertInput {
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  leaveRequester: usersObjRelInsertInput
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  leaveUser: usersObjRelInsertInput
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Reference to the user taking leave"""
  userId: uuid
}

"""aggregate max on columns"""
type leaveMaxFields {
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Reference to the user taking leave"""
  userId: uuid
}

"""
order by max() on columns of table "leave"
"""
input leaveMaxOrderBy {
  """Last day of the leave period"""
  endDate: OrderBy
  """Unique identifier for the leave record"""
  id: OrderBy
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: OrderBy
  """Reason provided for the leave request"""
  reason: OrderBy
  """First day of the leave period"""
  startDate: OrderBy
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: OrderBy
  """Reference to the user taking leave"""
  userId: OrderBy
}

"""aggregate min on columns"""
type leaveMinFields {
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Reference to the user taking leave"""
  userId: uuid
}

"""
order by min() on columns of table "leave"
"""
input leaveMinOrderBy {
  """Last day of the leave period"""
  endDate: OrderBy
  """Unique identifier for the leave record"""
  id: OrderBy
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: OrderBy
  """Reason provided for the leave request"""
  reason: OrderBy
  """First day of the leave period"""
  startDate: OrderBy
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: OrderBy
  """Reference to the user taking leave"""
  userId: OrderBy
}

"""
response of any mutation on the table "leave"
"""
type leaveMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [leave!]!
}

"""
on_conflict condition type for table "leave"
"""
input leaveOnConflict {
  constraint: leaveConstraint!
  updateColumns: [leaveUpdateColumn!]! = []
  where: leaveBoolExp
}

"""Ordering options when selecting data from "leave"."""
input leaveOrderBy {
  endDate: OrderBy
  id: OrderBy
  leaveRequester: usersOrderBy
  leaveType: OrderBy
  leaveUser: usersOrderBy
  reason: OrderBy
  startDate: OrderBy
  status: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: leave"""
input leavePkColumnsInput {
  """Unique identifier for the leave record"""
  id: uuid!
}

"""
select columns of table "leave"
"""
enum leaveSelectColumn {
  """column name"""
  endDate
  """column name"""
  id
  """column name"""
  leaveType
  """column name"""
  reason
  """column name"""
  startDate
  """column name"""
  status
  """column name"""
  userId
}

"""
input type for updating data in table "leave"
"""
input leaveSetInput {
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Reference to the user taking leave"""
  userId: uuid
}

"""
Streaming cursor of the table "leave"
"""
input leaveStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: leaveStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input leaveStreamCursorValueInput {
  """Last day of the leave period"""
  endDate: date
  """Unique identifier for the leave record"""
  id: uuid
  """Type of leave (vacation, sick, personal, etc.)"""
  leaveType: String
  """Reason provided for the leave request"""
  reason: String
  """First day of the leave period"""
  startDate: date
  """Current status of the leave request (Pending, Approved, Denied)"""
  status: leave_status_enum
  """Reference to the user taking leave"""
  userId: uuid
}

"""
update columns of table "leave"
"""
enum leaveUpdateColumn {
  """column name"""
  endDate
  """column name"""
  id
  """column name"""
  leaveType
  """column name"""
  reason
  """column name"""
  startDate
  """column name"""
  status
  """column name"""
  userId
}

input leaveUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: leaveSetInput
  """filter the rows which have to be updated"""
  where: leaveBoolExp!
}

scalar leave_status_enum

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "adjustment_rules"
  """
  bulkDeleteAdjustmentRules(
    """filter the rows which have to be deleted"""
    where: adjustmentRulesBoolExp!
  ): adjustmentRulesMutationResponse
  """
  delete data from the table: "app_settings"
  """
  bulkDeleteAppSettings(
    """filter the rows which have to be deleted"""
    where: appSettingsBoolExp!
  ): appSettingsMutationResponse
  """
  delete data from the table: "audit.audit_log"
  """
  bulkDeleteAuditLogs(
    """filter the rows which have to be deleted"""
    where: auditLogsBoolExp!
  ): auditLogsMutationResponse
  """
  delete data from the table: "audit.auth_events"
  """
  bulkDeleteAuthEvents(
    """filter the rows which have to be deleted"""
    where: authEventsBoolExp!
  ): authEventsMutationResponse
  """
  delete data from the table: "billing_event_log"
  """
  bulkDeleteBillingEventLogs(
    """filter the rows which have to be deleted"""
    where: billingEventLogsBoolExp!
  ): billingEventLogsMutationResponse
  """
  delete data from the table: "billing_invoice"
  """
  bulkDeleteBillingInvoice(
    """filter the rows which have to be deleted"""
    where: billingInvoiceBoolExp!
  ): billingInvoiceMutationResponse
  """
  delete data from the table: "billing_invoices"
  """
  bulkDeleteBillingInvoices(
    """filter the rows which have to be deleted"""
    where: billingInvoicesBoolExp!
  ): billingInvoicesMutationResponse
  """
  delete data from the table: "billing_items"
  """
  bulkDeleteBillingItems(
    """filter the rows which have to be deleted"""
    where: billingItemsBoolExp!
  ): billingItemsMutationResponse
  """
  delete data from the table: "billing_plan"
  """
  bulkDeleteBillingPlans(
    """filter the rows which have to be deleted"""
    where: billingPlansBoolExp!
  ): billingPlansMutationResponse
  """
  delete data from the table: "client_billing_assignment"
  """
  bulkDeleteClientBillingAssignments(
    """filter the rows which have to be deleted"""
    where: clientBillingAssignmentsBoolExp!
  ): clientBillingAssignmentsMutationResponse
  """
  delete data from the table: "client_external_systems"
  """
  bulkDeleteClientExternalSystems(
    """filter the rows which have to be deleted"""
    where: clientExternalSystemsBoolExp!
  ): clientExternalSystemsMutationResponse
  """
  delete data from the table: "clients"
  """
  bulkDeleteClients(
    """filter the rows which have to be deleted"""
    where: clientsBoolExp!
  ): clientsMutationResponse
  """
  delete data from the table: "audit.data_access_log"
  """
  bulkDeleteDataAccessLogs(
    """filter the rows which have to be deleted"""
    where: dataAccessLogsBoolExp!
  ): dataAccessLogsMutationResponse
  """
  delete data from the table: "external_systems"
  """
  bulkDeleteExternalSystems(
    """filter the rows which have to be deleted"""
    where: externalSystemsBoolExp!
  ): externalSystemsMutationResponse
  """
  delete data from the table: "feature_flags"
  """
  bulkDeleteFeatureFlags(
    """filter the rows which have to be deleted"""
    where: featureFlagsBoolExp!
  ): featureFlagsMutationResponse
  """
  delete data from the table: "holidays"
  """
  bulkDeleteHolidays(
    """filter the rows which have to be deleted"""
    where: holidaysBoolExp!
  ): holidaysMutationResponse
  """
  delete data from the table: "latest_payroll_version_results"
  """
  bulkDeleteLatestPayrollVersionResults(
    """filter the rows which have to be deleted"""
    where: latestPayrollVersionResultsBoolExp!
  ): latestPayrollVersionResultsMutationResponse
  """
  delete data from the table: "leave"
  """
  bulkDeleteLeave(
    """filter the rows which have to be deleted"""
    where: leaveBoolExp!
  ): leaveMutationResponse
  """
  delete data from the table: "notes"
  """
  bulkDeleteNotes(
    """filter the rows which have to be deleted"""
    where: notesBoolExp!
  ): notesMutationResponse
  """
  delete data from the table: "payroll_activation_results"
  """
  bulkDeletePayrollActivationResults(
    """filter the rows which have to be deleted"""
    where: payrollActivationResultsBoolExp!
  ): payrollActivationResultsMutationResponse
  """
  delete data from the table: "payroll_assignment_audit"
  """
  bulkDeletePayrollAssignmentAudits(
    """filter the rows which have to be deleted"""
    where: payrollAssignmentAuditsBoolExp!
  ): payrollAssignmentAuditsMutationResponse
  """
  delete data from the table: "payroll_assignments"
  """
  bulkDeletePayrollAssignments(
    """filter the rows which have to be deleted"""
    where: payrollAssignmentsBoolExp!
  ): payrollAssignmentsMutationResponse
  """
  delete data from the table: "payroll_cycles"
  """
  bulkDeletePayrollCycles(
    """filter the rows which have to be deleted"""
    where: payrollCyclesBoolExp!
  ): payrollCyclesMutationResponse
  """
  delete data from the table: "payroll_date_types"
  """
  bulkDeletePayrollDateTypes(
    """filter the rows which have to be deleted"""
    where: payrollDateTypesBoolExp!
  ): payrollDateTypesMutationResponse
  """
  delete data from the table: "payroll_dates"
  """
  bulkDeletePayrollDates(
    """filter the rows which have to be deleted"""
    where: payrollDatesBoolExp!
  ): payrollDatesMutationResponse
  """
  delete data from the table: "payroll_version_history_results"
  """
  bulkDeletePayrollVersionHistoryResults(
    """filter the rows which have to be deleted"""
    where: payrollVersionHistoryResultsBoolExp!
  ): payrollVersionHistoryResultsMutationResponse
  """
  delete data from the table: "payroll_version_results"
  """
  bulkDeletePayrollVersionResults(
    """filter the rows which have to be deleted"""
    where: payrollVersionResultsBoolExp!
  ): payrollVersionResultsMutationResponse
  """
  delete data from the table: "payrolls"
  """
  bulkDeletePayrolls(
    """filter the rows which have to be deleted"""
    where: payrollsBoolExp!
  ): payrollsMutationResponse
  """
  delete data from the table: "permission_audit_log"
  """
  bulkDeletePermissionAuditLogs(
    """filter the rows which have to be deleted"""
    where: permissionAuditLogsBoolExp!
  ): permissionAuditLogsMutationResponse
  """
  delete data from the table: "audit.permission_changes"
  """
  bulkDeletePermissionChanges(
    """filter the rows which have to be deleted"""
    where: permissionChangesBoolExp!
  ): permissionChangesMutationResponse
  """
  delete data from the table: "permission_overrides"
  """
  bulkDeletePermissionOverrides(
    """filter the rows which have to be deleted"""
    where: permissionOverridesBoolExp!
  ): permissionOverridesMutationResponse
  """
  delete data from the table: "permissions"
  """
  bulkDeletePermissions(
    """filter the rows which have to be deleted"""
    where: permissionsBoolExp!
  ): permissionsMutationResponse
  """
  delete data from the table: "resources"
  """
  bulkDeleteResources(
    """filter the rows which have to be deleted"""
    where: resourcesBoolExp!
  ): resourcesMutationResponse
  """
  delete data from the table: "role_permissions"
  """
  bulkDeleteRolePermissions(
    """filter the rows which have to be deleted"""
    where: rolePermissionsBoolExp!
  ): rolePermissionsMutationResponse
  """
  delete data from the table: "roles"
  """
  bulkDeleteRoles(
    """filter the rows which have to be deleted"""
    where: rolesBoolExp!
  ): rolesMutationResponse
  """
  delete data from the table: "audit.slow_queries"
  """
  bulkDeleteSlowQueries(
    """filter the rows which have to be deleted"""
    where: slowQueriesBoolExp!
  ): slowQueriesMutationResponse
  """
  delete data from the table: "audit.user_access_summary"
  """
  bulkDeleteUserAccessSummaries(
    """filter the rows which have to be deleted"""
    where: userAccessSummariesBoolExp!
  ): userAccessSummariesMutationResponse
  """
  delete data from the table: "user_invitations"
  """
  bulkDeleteUserInvitations(
    """filter the rows which have to be deleted"""
    where: userInvitationsBoolExp!
  ): userInvitationsMutationResponse
  """
  delete data from the table: "user_roles"
  """
  bulkDeleteUserRoles(
    """filter the rows which have to be deleted"""
    where: userRolesBoolExp!
  ): userRolesMutationResponse
  """
  delete data from the table: "users"
  """
  bulkDeleteUsers(
    """filter the rows which have to be deleted"""
    where: usersBoolExp!
  ): usersMutationResponse
  """
  delete data from the table: "users_role_backup"
  """
  bulkDeleteUsersRoleBackups(
    """filter the rows which have to be deleted"""
    where: usersRoleBackupBoolExp!
  ): usersRoleBackupMutationResponse
  """
  delete data from the table: "neon_auth.users_sync"
  """
  bulkDeleteUsersSync(
    """filter the rows which have to be deleted"""
    where: authUsersSyncBoolExp!
  ): authUsersSyncMutationResponse
  """
  delete data from the table: "work_schedule"
  """
  bulkDeleteWorkSchedules(
    """filter the rows which have to be deleted"""
    where: workSchedulesBoolExp!
  ): workSchedulesMutationResponse
  """
  insert data into the table: "adjustment_rules"
  """
  bulkInsertAdjustmentRules(
    """the rows to be inserted"""
    objects: [adjustmentRulesInsertInput!]!
    """upsert condition"""
    onConflict: adjustmentRulesOnConflict
  ): adjustmentRulesMutationResponse
  """
  insert data into the table: "app_settings"
  """
  bulkInsertAppSettings(
    """the rows to be inserted"""
    objects: [appSettingsInsertInput!]!
    """upsert condition"""
    onConflict: appSettingsOnConflict
  ): appSettingsMutationResponse
  """
  insert data into the table: "audit.audit_log"
  """
  bulkInsertAuditLogs(
    """the rows to be inserted"""
    objects: [auditLogsInsertInput!]!
    """upsert condition"""
    onConflict: auditLogsOnConflict
  ): auditLogsMutationResponse
  """
  insert data into the table: "audit.auth_events"
  """
  bulkInsertAuthEvents(
    """the rows to be inserted"""
    objects: [authEventsInsertInput!]!
    """upsert condition"""
    onConflict: authEventsOnConflict
  ): authEventsMutationResponse
  """
  insert data into the table: "billing_event_log"
  """
  bulkInsertBillingEventLogs(
    """the rows to be inserted"""
    objects: [billingEventLogsInsertInput!]!
    """upsert condition"""
    onConflict: billingEventLogsOnConflict
  ): billingEventLogsMutationResponse
  """
  insert data into the table: "billing_invoice"
  """
  bulkInsertBillingInvoice(
    """the rows to be inserted"""
    objects: [billingInvoiceInsertInput!]!
    """upsert condition"""
    onConflict: billingInvoiceOnConflict
  ): billingInvoiceMutationResponse
  """
  insert data into the table: "billing_invoices"
  """
  bulkInsertBillingInvoices(
    """the rows to be inserted"""
    objects: [billingInvoicesInsertInput!]!
    """upsert condition"""
    onConflict: billingInvoicesOnConflict
  ): billingInvoicesMutationResponse
  """
  insert data into the table: "billing_items"
  """
  bulkInsertBillingItems(
    """the rows to be inserted"""
    objects: [billingItemsInsertInput!]!
    """upsert condition"""
    onConflict: billingItemsOnConflict
  ): billingItemsMutationResponse
  """
  insert data into the table: "billing_plan"
  """
  bulkInsertBillingPlans(
    """the rows to be inserted"""
    objects: [billingPlansInsertInput!]!
    """upsert condition"""
    onConflict: billingPlansOnConflict
  ): billingPlansMutationResponse
  """
  insert data into the table: "client_billing_assignment"
  """
  bulkInsertClientBillingAssignments(
    """the rows to be inserted"""
    objects: [clientBillingAssignmentsInsertInput!]!
    """upsert condition"""
    onConflict: clientBillingAssignmentsOnConflict
  ): clientBillingAssignmentsMutationResponse
  """
  insert data into the table: "client_external_systems"
  """
  bulkInsertClientExternalSystems(
    """the rows to be inserted"""
    objects: [clientExternalSystemsInsertInput!]!
    """upsert condition"""
    onConflict: clientExternalSystemsOnConflict
  ): clientExternalSystemsMutationResponse
  """
  insert data into the table: "clients"
  """
  bulkInsertClients(
    """the rows to be inserted"""
    objects: [clientsInsertInput!]!
    """upsert condition"""
    onConflict: clientsOnConflict
  ): clientsMutationResponse
  """
  insert data into the table: "audit.data_access_log"
  """
  bulkInsertDataAccessLogs(
    """the rows to be inserted"""
    objects: [dataAccessLogsInsertInput!]!
    """upsert condition"""
    onConflict: dataAccessLogsOnConflict
  ): dataAccessLogsMutationResponse
  """
  insert data into the table: "external_systems"
  """
  bulkInsertExternalSystems(
    """the rows to be inserted"""
    objects: [externalSystemsInsertInput!]!
    """upsert condition"""
    onConflict: externalSystemsOnConflict
  ): externalSystemsMutationResponse
  """
  insert data into the table: "feature_flags"
  """
  bulkInsertFeatureFlags(
    """the rows to be inserted"""
    objects: [featureFlagsInsertInput!]!
    """upsert condition"""
    onConflict: featureFlagsOnConflict
  ): featureFlagsMutationResponse
  """
  insert data into the table: "holidays"
  """
  bulkInsertHolidays(
    """the rows to be inserted"""
    objects: [holidaysInsertInput!]!
    """upsert condition"""
    onConflict: holidaysOnConflict
  ): holidaysMutationResponse
  """
  insert data into the table: "latest_payroll_version_results"
  """
  bulkInsertLatestPayrollVersionResults(
    """the rows to be inserted"""
    objects: [latestPayrollVersionResultsInsertInput!]!
    """upsert condition"""
    onConflict: latestPayrollVersionResultsOnConflict
  ): latestPayrollVersionResultsMutationResponse
  """
  insert data into the table: "leave"
  """
  bulkInsertLeave(
    """the rows to be inserted"""
    objects: [leaveInsertInput!]!
    """upsert condition"""
    onConflict: leaveOnConflict
  ): leaveMutationResponse
  """
  insert data into the table: "notes"
  """
  bulkInsertNotes(
    """the rows to be inserted"""
    objects: [notesInsertInput!]!
    """upsert condition"""
    onConflict: notesOnConflict
  ): notesMutationResponse
  """
  insert data into the table: "payroll_activation_results"
  """
  bulkInsertPayrollActivationResults(
    """the rows to be inserted"""
    objects: [payrollActivationResultsInsertInput!]!
    """upsert condition"""
    onConflict: payrollActivationResultsOnConflict
  ): payrollActivationResultsMutationResponse
  """
  insert data into the table: "payroll_assignment_audit"
  """
  bulkInsertPayrollAssignmentAudits(
    """the rows to be inserted"""
    objects: [payrollAssignmentAuditsInsertInput!]!
    """upsert condition"""
    onConflict: payrollAssignmentAuditsOnConflict
  ): payrollAssignmentAuditsMutationResponse
  """
  insert data into the table: "payroll_assignments"
  """
  bulkInsertPayrollAssignments(
    """the rows to be inserted"""
    objects: [payrollAssignmentsInsertInput!]!
    """upsert condition"""
    onConflict: payrollAssignmentsOnConflict
  ): payrollAssignmentsMutationResponse
  """
  insert data into the table: "payroll_cycles"
  """
  bulkInsertPayrollCycles(
    """the rows to be inserted"""
    objects: [payrollCyclesInsertInput!]!
    """upsert condition"""
    onConflict: payrollCyclesOnConflict
  ): payrollCyclesMutationResponse
  """
  insert data into the table: "payroll_date_types"
  """
  bulkInsertPayrollDateTypes(
    """the rows to be inserted"""
    objects: [payrollDateTypesInsertInput!]!
    """upsert condition"""
    onConflict: payrollDateTypesOnConflict
  ): payrollDateTypesMutationResponse
  """
  insert data into the table: "payroll_dates"
  """
  bulkInsertPayrollDates(
    """the rows to be inserted"""
    objects: [payrollDatesInsertInput!]!
    """upsert condition"""
    onConflict: payrollDatesOnConflict
  ): payrollDatesMutationResponse
  """
  insert data into the table: "payroll_version_history_results"
  """
  bulkInsertPayrollVersionHistoryResults(
    """the rows to be inserted"""
    objects: [payrollVersionHistoryResultsInsertInput!]!
    """upsert condition"""
    onConflict: payrollVersionHistoryResultsOnConflict
  ): payrollVersionHistoryResultsMutationResponse
  """
  insert data into the table: "payroll_version_results"
  """
  bulkInsertPayrollVersionResults(
    """the rows to be inserted"""
    objects: [payrollVersionResultsInsertInput!]!
    """upsert condition"""
    onConflict: payrollVersionResultsOnConflict
  ): payrollVersionResultsMutationResponse
  """
  insert data into the table: "payrolls"
  """
  bulkInsertPayrolls(
    """the rows to be inserted"""
    objects: [payrollsInsertInput!]!
    """upsert condition"""
    onConflict: payrollsOnConflict
  ): payrollsMutationResponse
  """
  insert data into the table: "permission_audit_log"
  """
  bulkInsertPermissionAuditLogs(
    """the rows to be inserted"""
    objects: [permissionAuditLogsInsertInput!]!
    """upsert condition"""
    onConflict: permissionAuditLogsOnConflict
  ): permissionAuditLogsMutationResponse
  """
  insert data into the table: "audit.permission_changes"
  """
  bulkInsertPermissionChanges(
    """the rows to be inserted"""
    objects: [permissionChangesInsertInput!]!
    """upsert condition"""
    onConflict: permissionChangesOnConflict
  ): permissionChangesMutationResponse
  """
  insert data into the table: "permission_overrides"
  """
  bulkInsertPermissionOverrides(
    """the rows to be inserted"""
    objects: [permissionOverridesInsertInput!]!
    """upsert condition"""
    onConflict: permissionOverridesOnConflict
  ): permissionOverridesMutationResponse
  """
  insert data into the table: "permissions"
  """
  bulkInsertPermissions(
    """the rows to be inserted"""
    objects: [permissionsInsertInput!]!
    """upsert condition"""
    onConflict: permissionsOnConflict
  ): permissionsMutationResponse
  """
  insert data into the table: "resources"
  """
  bulkInsertResources(
    """the rows to be inserted"""
    objects: [resourcesInsertInput!]!
    """upsert condition"""
    onConflict: resourcesOnConflict
  ): resourcesMutationResponse
  """
  insert data into the table: "role_permissions"
  """
  bulkInsertRolePermissions(
    """the rows to be inserted"""
    objects: [rolePermissionsInsertInput!]!
    """upsert condition"""
    onConflict: rolePermissionsOnConflict
  ): rolePermissionsMutationResponse
  """
  insert data into the table: "roles"
  """
  bulkInsertRoles(
    """the rows to be inserted"""
    objects: [rolesInsertInput!]!
    """upsert condition"""
    onConflict: rolesOnConflict
  ): rolesMutationResponse
  """
  insert data into the table: "audit.slow_queries"
  """
  bulkInsertSlowQueries(
    """the rows to be inserted"""
    objects: [slowQueriesInsertInput!]!
    """upsert condition"""
    onConflict: slowQueriesOnConflict
  ): slowQueriesMutationResponse
  """
  insert data into the table: "audit.user_access_summary"
  """
  bulkInsertUserAccessSummaries(
    """the rows to be inserted"""
    objects: [userAccessSummariesInsertInput!]!
  ): userAccessSummariesMutationResponse
  """
  insert data into the table: "user_invitations"
  """
  bulkInsertUserInvitations(
    """the rows to be inserted"""
    objects: [userInvitationsInsertInput!]!
    """upsert condition"""
    onConflict: userInvitationsOnConflict
  ): userInvitationsMutationResponse
  """
  insert data into the table: "user_roles"
  """
  bulkInsertUserRoles(
    """the rows to be inserted"""
    objects: [userRolesInsertInput!]!
    """upsert condition"""
    onConflict: userRolesOnConflict
  ): userRolesMutationResponse
  """
  insert data into the table: "users"
  """
  bulkInsertUsers(
    """the rows to be inserted"""
    objects: [usersInsertInput!]!
    """upsert condition"""
    onConflict: usersOnConflict
  ): usersMutationResponse
  """
  insert data into the table: "users_role_backup"
  """
  bulkInsertUsersRoleBackups(
    """the rows to be inserted"""
    objects: [usersRoleBackupInsertInput!]!
  ): usersRoleBackupMutationResponse
  """
  insert data into the table: "neon_auth.users_sync"
  """
  bulkInsertUsersSync(
    """the rows to be inserted"""
    objects: [authUsersSyncInsertInput!]!
    """upsert condition"""
    onConflict: authUsersSyncOnConflict
  ): authUsersSyncMutationResponse
  """
  insert data into the table: "work_schedule"
  """
  bulkInsertWorkSchedules(
    """the rows to be inserted"""
    objects: [workSchedulesInsertInput!]!
    """upsert condition"""
    onConflict: workSchedulesOnConflict
  ): workSchedulesMutationResponse
  """
  update data of the table: "adjustment_rules"
  """
  bulkUpdateAdjustmentRules(
    """sets the columns of the filtered rows to the given values"""
    _set: adjustmentRulesSetInput
    """filter the rows which have to be updated"""
    where: adjustmentRulesBoolExp!
  ): adjustmentRulesMutationResponse
  """
  update data of the table: "app_settings"
  """
  bulkUpdateAppSettings(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: appSettingsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: appSettingsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: appSettingsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: appSettingsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: appSettingsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: appSettingsSetInput
    """filter the rows which have to be updated"""
    where: appSettingsBoolExp!
  ): appSettingsMutationResponse
  """
  update data of the table: "audit.audit_log"
  """
  bulkUpdateAuditLogs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auditLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: auditLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: auditLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: auditLogsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auditLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: auditLogsSetInput
    """filter the rows which have to be updated"""
    where: auditLogsBoolExp!
  ): auditLogsMutationResponse
  """
  update data of the table: "audit.auth_events"
  """
  bulkUpdateAuthEvents(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authEventsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: authEventsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: authEventsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: authEventsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authEventsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: authEventsSetInput
    """filter the rows which have to be updated"""
    where: authEventsBoolExp!
  ): authEventsMutationResponse
  """
  update data of the table: "billing_event_log"
  """
  bulkUpdateBillingEventLogs(
    """sets the columns of the filtered rows to the given values"""
    _set: billingEventLogsSetInput
    """filter the rows which have to be updated"""
    where: billingEventLogsBoolExp!
  ): billingEventLogsMutationResponse
  """
  update data of the table: "billing_invoice"
  """
  bulkUpdateBillingInvoice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingInvoiceIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingInvoiceSetInput
    """filter the rows which have to be updated"""
    where: billingInvoiceBoolExp!
  ): billingInvoiceMutationResponse
  """
  update data of the table: "billing_invoices"
  """
  bulkUpdateBillingInvoices(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingInvoicesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingInvoicesSetInput
    """filter the rows which have to be updated"""
    where: billingInvoicesBoolExp!
  ): billingInvoicesMutationResponse
  """
  update data of the table: "billing_items"
  """
  bulkUpdateBillingItems(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingItemsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingItemsSetInput
    """filter the rows which have to be updated"""
    where: billingItemsBoolExp!
  ): billingItemsMutationResponse
  """
  update data of the table: "billing_plan"
  """
  bulkUpdateBillingPlans(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingPlansIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingPlansSetInput
    """filter the rows which have to be updated"""
    where: billingPlansBoolExp!
  ): billingPlansMutationResponse
  """
  update data of the table: "client_billing_assignment"
  """
  bulkUpdateClientBillingAssignments(
    """sets the columns of the filtered rows to the given values"""
    _set: clientBillingAssignmentsSetInput
    """filter the rows which have to be updated"""
    where: clientBillingAssignmentsBoolExp!
  ): clientBillingAssignmentsMutationResponse
  """
  update data of the table: "client_external_systems"
  """
  bulkUpdateClientExternalSystems(
    """sets the columns of the filtered rows to the given values"""
    _set: clientExternalSystemsSetInput
    """filter the rows which have to be updated"""
    where: clientExternalSystemsBoolExp!
  ): clientExternalSystemsMutationResponse
  """
  update data of the table: "clients"
  """
  bulkUpdateClients(
    """sets the columns of the filtered rows to the given values"""
    _set: clientsSetInput
    """filter the rows which have to be updated"""
    where: clientsBoolExp!
  ): clientsMutationResponse
  """
  update data of the table: "audit.data_access_log"
  """
  bulkUpdateDataAccessLogs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: dataAccessLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: dataAccessLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: dataAccessLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: dataAccessLogsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: dataAccessLogsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: dataAccessLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: dataAccessLogsSetInput
    """filter the rows which have to be updated"""
    where: dataAccessLogsBoolExp!
  ): dataAccessLogsMutationResponse
  """
  update data of the table: "external_systems"
  """
  bulkUpdateExternalSystems(
    """sets the columns of the filtered rows to the given values"""
    _set: externalSystemsSetInput
    """filter the rows which have to be updated"""
    where: externalSystemsBoolExp!
  ): externalSystemsMutationResponse
  """
  update data of the table: "feature_flags"
  """
  bulkUpdateFeatureFlags(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: featureFlagsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: featureFlagsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: featureFlagsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: featureFlagsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: featureFlagsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: featureFlagsSetInput
    """filter the rows which have to be updated"""
    where: featureFlagsBoolExp!
  ): featureFlagsMutationResponse
  """
  update data of the table: "holidays"
  """
  bulkUpdateHolidays(
    """increments the numeric columns with given value of the filtered values"""
    _inc: holidaysIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: holidaysSetInput
    """filter the rows which have to be updated"""
    where: holidaysBoolExp!
  ): holidaysMutationResponse
  """
  update data of the table: "latest_payroll_version_results"
  """
  bulkUpdateLatestPayrollVersionResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: latestPayrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: latestPayrollVersionResultsSetInput
    """filter the rows which have to be updated"""
    where: latestPayrollVersionResultsBoolExp!
  ): latestPayrollVersionResultsMutationResponse
  """
  update data of the table: "leave"
  """
  bulkUpdateLeave(
    """sets the columns of the filtered rows to the given values"""
    _set: leaveSetInput
    """filter the rows which have to be updated"""
    where: leaveBoolExp!
  ): leaveMutationResponse
  """
  update data of the table: "notes"
  """
  bulkUpdateNotes(
    """sets the columns of the filtered rows to the given values"""
    _set: notesSetInput
    """filter the rows which have to be updated"""
    where: notesBoolExp!
  ): notesMutationResponse
  """
  update data of the table: "payroll_activation_results"
  """
  bulkUpdatePayrollActivationResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollActivationResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollActivationResultsSetInput
    """filter the rows which have to be updated"""
    where: payrollActivationResultsBoolExp!
  ): payrollActivationResultsMutationResponse
  """
  update data of the table: "payroll_assignment_audit"
  """
  bulkUpdatePayrollAssignmentAudits(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollAssignmentAuditsSetInput
    """filter the rows which have to be updated"""
    where: payrollAssignmentAuditsBoolExp!
  ): payrollAssignmentAuditsMutationResponse
  """
  update data of the table: "payroll_assignments"
  """
  bulkUpdatePayrollAssignments(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollAssignmentsSetInput
    """filter the rows which have to be updated"""
    where: payrollAssignmentsBoolExp!
  ): payrollAssignmentsMutationResponse
  """
  update data of the table: "payroll_cycles"
  """
  bulkUpdatePayrollCycles(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollCyclesSetInput
    """filter the rows which have to be updated"""
    where: payrollCyclesBoolExp!
  ): payrollCyclesMutationResponse
  """
  update data of the table: "payroll_date_types"
  """
  bulkUpdatePayrollDateTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollDateTypesSetInput
    """filter the rows which have to be updated"""
    where: payrollDateTypesBoolExp!
  ): payrollDateTypesMutationResponse
  """
  update data of the table: "payroll_dates"
  """
  bulkUpdatePayrollDates(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollDatesSetInput
    """filter the rows which have to be updated"""
    where: payrollDatesBoolExp!
  ): payrollDatesMutationResponse
  """
  update data of the table: "payroll_version_history_results"
  """
  bulkUpdatePayrollVersionHistoryResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollVersionHistoryResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollVersionHistoryResultsSetInput
    """filter the rows which have to be updated"""
    where: payrollVersionHistoryResultsBoolExp!
  ): payrollVersionHistoryResultsMutationResponse
  """
  update data of the table: "payroll_version_results"
  """
  bulkUpdatePayrollVersionResults(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollVersionResultsSetInput
    """filter the rows which have to be updated"""
    where: payrollVersionResultsBoolExp!
  ): payrollVersionResultsMutationResponse
  """
  update data of the table: "payrolls"
  """
  bulkUpdatePayrolls(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollsSetInput
    """filter the rows which have to be updated"""
    where: payrollsBoolExp!
  ): payrollsMutationResponse
  """
  update data of the table: "permission_audit_log"
  """
  bulkUpdatePermissionAuditLogs(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permissionAuditLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: permissionAuditLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: permissionAuditLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: permissionAuditLogsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permissionAuditLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: permissionAuditLogsSetInput
    """filter the rows which have to be updated"""
    where: permissionAuditLogsBoolExp!
  ): permissionAuditLogsMutationResponse
  """
  update data of the table: "audit.permission_changes"
  """
  bulkUpdatePermissionChanges(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permissionChangesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: permissionChangesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: permissionChangesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: permissionChangesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permissionChangesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: permissionChangesSetInput
    """filter the rows which have to be updated"""
    where: permissionChangesBoolExp!
  ): permissionChangesMutationResponse
  """
  update data of the table: "permission_overrides"
  """
  bulkUpdatePermissionOverrides(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permissionOverridesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: permissionOverridesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: permissionOverridesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: permissionOverridesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permissionOverridesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: permissionOverridesSetInput
    """filter the rows which have to be updated"""
    where: permissionOverridesBoolExp!
  ): permissionOverridesMutationResponse
  """
  update data of the table: "permissions"
  """
  bulkUpdatePermissions(
    """sets the columns of the filtered rows to the given values"""
    _set: permissionsSetInput
    """filter the rows which have to be updated"""
    where: permissionsBoolExp!
  ): permissionsMutationResponse
  """
  update data of the table: "resources"
  """
  bulkUpdateResources(
    """sets the columns of the filtered rows to the given values"""
    _set: resourcesSetInput
    """filter the rows which have to be updated"""
    where: resourcesBoolExp!
  ): resourcesMutationResponse
  """
  update data of the table: "role_permissions"
  """
  bulkUpdateRolePermissions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rolePermissionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: rolePermissionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: rolePermissionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: rolePermissionsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rolePermissionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: rolePermissionsSetInput
    """filter the rows which have to be updated"""
    where: rolePermissionsBoolExp!
  ): rolePermissionsMutationResponse
  """
  update data of the table: "roles"
  """
  bulkUpdateRoles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rolesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: rolesSetInput
    """filter the rows which have to be updated"""
    where: rolesBoolExp!
  ): rolesMutationResponse
  """
  update data of the table: "audit.slow_queries"
  """
  bulkUpdateSlowQueries(
    """sets the columns of the filtered rows to the given values"""
    _set: slowQueriesSetInput
    """filter the rows which have to be updated"""
    where: slowQueriesBoolExp!
  ): slowQueriesMutationResponse
  """
  update data of the table: "audit.user_access_summary"
  """
  bulkUpdateUserAccessSummaries(
    """sets the columns of the filtered rows to the given values"""
    _set: userAccessSummariesSetInput
    """filter the rows which have to be updated"""
    where: userAccessSummariesBoolExp!
  ): userAccessSummariesMutationResponse
  """
  update data of the table: "user_invitations"
  """
  bulkUpdateUserInvitations(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: userInvitationsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: userInvitationsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: userInvitationsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: userInvitationsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: userInvitationsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: userInvitationsSetInput
    """filter the rows which have to be updated"""
    where: userInvitationsBoolExp!
  ): userInvitationsMutationResponse
  """
  update data of the table: "user_roles"
  """
  bulkUpdateUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: userRolesSetInput
    """filter the rows which have to be updated"""
    where: userRolesBoolExp!
  ): userRolesMutationResponse
  """
  update data of the table: "users"
  """
  bulkUpdateUsers(
    """sets the columns of the filtered rows to the given values"""
    _set: usersSetInput
    """filter the rows which have to be updated"""
    where: usersBoolExp!
  ): usersMutationResponse
  """
  update data of the table: "users_role_backup"
  """
  bulkUpdateUsersRoleBackups(
    """sets the columns of the filtered rows to the given values"""
    _set: usersRoleBackupSetInput
    """filter the rows which have to be updated"""
    where: usersRoleBackupBoolExp!
  ): usersRoleBackupMutationResponse
  """
  update data of the table: "neon_auth.users_sync"
  """
  bulkUpdateUsersSync(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authUsersSyncAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: authUsersSyncDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: authUsersSyncDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: authUsersSyncDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authUsersSyncPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: authUsersSyncSetInput
    """filter the rows which have to be updated"""
    where: authUsersSyncBoolExp!
  ): authUsersSyncMutationResponse
  """
  update data of the table: "work_schedule"
  """
  bulkUpdateWorkSchedules(
    """increments the numeric columns with given value of the filtered values"""
    _inc: workSchedulesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: workSchedulesSetInput
    """filter the rows which have to be updated"""
    where: workSchedulesBoolExp!
  ): workSchedulesMutationResponse
  """Check for suspicious activity patterns"""
  checkSuspiciousActivity(timeWindow: Int, userId: String): SuspiciousActivityResponse
  commitPayrollAssignments(changes: [PayrollAssignmentInput!]!): CommitPayrollAssignmentsOutput
  """
  delete single row from the table: "adjustment_rules"
  """
  deleteAdjustmentRuleById(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustmentRules
  """
  delete single row from the table: "app_settings"
  """
  deleteAppSettingById(
    """Unique identifier for application setting"""
    id: String!
  ): appSettings
  """
  delete single row from the table: "audit.audit_log"
  """
  deleteAuditLogById(id: uuid!): auditLogs
  """
  delete single row from the table: "audit.auth_events"
  """
  deleteAuthEventById(id: uuid!): authEvents
  """
  delete single row from the table: "billing_event_log"
  """
  deleteBillingEventLogById(id: uuid!): billingEventLogs
  """
  delete single row from the table: "billing_invoice"
  """
  deleteBillingInvoiceById(id: uuid!): billingInvoice
  """
  delete single row from the table: "billing_invoices"
  """
  deleteBillingInvoicesById(id: uuid!): billingInvoices
  """
  delete single row from the table: "billing_items"
  """
  deleteBillingItemById(id: uuid!): billingItems
  """
  delete single row from the table: "billing_plan"
  """
  deleteBillingPlanById(id: uuid!): billingPlans
  """
  delete single row from the table: "client_billing_assignment"
  """
  deleteClientBillingAssignmentById(id: uuid!): clientBillingAssignments
  """
  delete single row from the table: "clients"
  """
  deleteClientById(
    """Unique identifier for the client"""
    id: uuid!
  ): clients
  """
  delete single row from the table: "client_external_systems"
  """
  deleteClientExternalSystemById(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): clientExternalSystems
  """
  delete single row from the table: "audit.data_access_log"
  """
  deleteDataAccessLogById(id: uuid!): dataAccessLogs
  """
  delete single row from the table: "external_systems"
  """
  deleteExternalSystemById(
    """Unique identifier for the external system"""
    id: uuid!
  ): externalSystems
  """
  delete single row from the table: "feature_flags"
  """
  deleteFeatureFlagById(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): featureFlags
  """
  delete single row from the table: "holidays"
  """
  deleteHolidayById(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays
  """
  delete single row from the table: "latest_payroll_version_results"
  """
  deleteLatestPayrollVersionResultById(id: uuid!): latestPayrollVersionResults
  """
  delete single row from the table: "leave"
  """
  deleteLeaveById(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave
  """
  delete single row from the table: "notes"
  """
  deleteNoteById(
    """Unique identifier for the note"""
    id: uuid!
  ): notes
  """
  delete single row from the table: "payroll_activation_results"
  """
  deletePayrollActivationResultById(id: uuid!): payrollActivationResults
  """
  delete single row from the table: "payroll_assignment_audit"
  """
  deletePayrollAssignmentAuditById(id: uuid!): payrollAssignmentAudits
  """
  delete single row from the table: "payroll_assignments"
  """
  deletePayrollAssignmentById(id: uuid!): payrollAssignments
  """
  delete single row from the table: "payrolls"
  """
  deletePayrollById(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls
  """
  delete single row from the table: "payroll_cycles"
  """
  deletePayrollCycleById(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payrollCycles
  """
  delete single row from the table: "payroll_dates"
  """
  deletePayrollDateById(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payrollDates
  """
  delete single row from the table: "payroll_date_types"
  """
  deletePayrollDateTypeById(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payrollDateTypes
  """
  delete single row from the table: "payroll_version_history_results"
  """
  deletePayrollVersionHistoryResultById(id: uuid!): payrollVersionHistoryResults
  """
  delete single row from the table: "payroll_version_results"
  """
  deletePayrollVersionResultById(id: uuid!): payrollVersionResults
  """
  delete single row from the table: "permission_audit_log"
  """
  deletePermissionAuditLogById(id: uuid!): permissionAuditLogs
  """
  delete single row from the table: "permissions"
  """
  deletePermissionById(id: uuid!): permissions
  """
  delete single row from the table: "audit.permission_changes"
  """
  deletePermissionChangeById(id: uuid!): permissionChanges
  """
  delete single row from the table: "permission_overrides"
  """
  deletePermissionOverrideById(id: uuid!): permissionOverrides
  """
  delete single row from the table: "resources"
  """
  deleteResourceById(id: uuid!): resources
  """
  delete single row from the table: "roles"
  """
  deleteRoleById(id: uuid!): roles
  """
  delete single row from the table: "role_permissions"
  """
  deleteRolePermissionById(id: uuid!): rolePermissions
  """
  delete single row from the table: "audit.slow_queries"
  """
  deleteSlowQueryById(id: uuid!): slowQueries
  """
  delete single row from the table: "users"
  """
  deleteUserById(
    """Unique identifier for the user"""
    id: uuid!
  ): users
  """
  delete single row from the table: "user_invitations"
  """
  deleteUserInvitationById(id: uuid!): userInvitations
  """
  delete single row from the table: "user_roles"
  """
  deleteUserRoleById(id: uuid!): userRoles
  """
  delete single row from the table: "neon_auth.users_sync"
  """
  deleteUserSyncById(
    """Unique identifier from the authentication provider"""
    id: String!
  ): authUsersSync
  """
  delete single row from the table: "work_schedule"
  """
  deleteWorkScheduleById(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): workSchedules
  """Generate SOC2 compliance reports"""
  generateComplianceReport(input: ComplianceReportInput!): ComplianceReportResponse
  """
  insert a single row into the table: "adjustment_rules"
  """
  insertAdjustmentRule(
    """the row to be inserted"""
    object: adjustmentRulesInsertInput!
    """upsert condition"""
    onConflict: adjustmentRulesOnConflict
  ): adjustmentRules
  """
  insert a single row into the table: "app_settings"
  """
  insertAppSetting(
    """the row to be inserted"""
    object: appSettingsInsertInput!
    """upsert condition"""
    onConflict: appSettingsOnConflict
  ): appSettings
  """
  insert a single row into the table: "audit.audit_log"
  """
  insertAuditLog(
    """the row to be inserted"""
    object: auditLogsInsertInput!
    """upsert condition"""
    onConflict: auditLogsOnConflict
  ): auditLogs
  """
  insert a single row into the table: "audit.auth_events"
  """
  insertAuthEvent(
    """the row to be inserted"""
    object: authEventsInsertInput!
    """upsert condition"""
    onConflict: authEventsOnConflict
  ): authEvents
  """
  insert a single row into the table: "billing_event_log"
  """
  insertBillingEventLog(
    """the row to be inserted"""
    object: billingEventLogsInsertInput!
    """upsert condition"""
    onConflict: billingEventLogsOnConflict
  ): billingEventLogs
  """
  insert a single row into the table: "billing_invoice"
  """
  insertBillingInvoice(
    """the row to be inserted"""
    object: billingInvoiceInsertInput!
    """upsert condition"""
    onConflict: billingInvoiceOnConflict
  ): billingInvoice
  """
  insert a single row into the table: "billing_invoices"
  """
  insertBillingInvoices(
    """the row to be inserted"""
    object: billingInvoicesInsertInput!
    """upsert condition"""
    onConflict: billingInvoicesOnConflict
  ): billingInvoices
  """
  insert a single row into the table: "billing_items"
  """
  insertBillingItem(
    """the row to be inserted"""
    object: billingItemsInsertInput!
    """upsert condition"""
    onConflict: billingItemsOnConflict
  ): billingItems
  """
  insert a single row into the table: "billing_plan"
  """
  insertBillingPlan(
    """the row to be inserted"""
    object: billingPlansInsertInput!
    """upsert condition"""
    onConflict: billingPlansOnConflict
  ): billingPlans
  """
  insert a single row into the table: "clients"
  """
  insertClient(
    """the row to be inserted"""
    object: clientsInsertInput!
    """upsert condition"""
    onConflict: clientsOnConflict
  ): clients
  """
  insert a single row into the table: "client_billing_assignment"
  """
  insertClientBillingAssignment(
    """the row to be inserted"""
    object: clientBillingAssignmentsInsertInput!
    """upsert condition"""
    onConflict: clientBillingAssignmentsOnConflict
  ): clientBillingAssignments
  """
  insert a single row into the table: "client_external_systems"
  """
  insertClientExternalSystem(
    """the row to be inserted"""
    object: clientExternalSystemsInsertInput!
    """upsert condition"""
    onConflict: clientExternalSystemsOnConflict
  ): clientExternalSystems
  """
  insert a single row into the table: "audit.data_access_log"
  """
  insertDataAccessLog(
    """the row to be inserted"""
    object: dataAccessLogsInsertInput!
    """upsert condition"""
    onConflict: dataAccessLogsOnConflict
  ): dataAccessLogs
  """
  insert a single row into the table: "external_systems"
  """
  insertExternalSystem(
    """the row to be inserted"""
    object: externalSystemsInsertInput!
    """upsert condition"""
    onConflict: externalSystemsOnConflict
  ): externalSystems
  """
  insert a single row into the table: "feature_flags"
  """
  insertFeatureFlag(
    """the row to be inserted"""
    object: featureFlagsInsertInput!
    """upsert condition"""
    onConflict: featureFlagsOnConflict
  ): featureFlags
  """
  insert a single row into the table: "holidays"
  """
  insertHoliday(
    """the row to be inserted"""
    object: holidaysInsertInput!
    """upsert condition"""
    onConflict: holidaysOnConflict
  ): holidays
  """
  insert a single row into the table: "latest_payroll_version_results"
  """
  insertLatestPayrollVersionResult(
    """the row to be inserted"""
    object: latestPayrollVersionResultsInsertInput!
    """upsert condition"""
    onConflict: latestPayrollVersionResultsOnConflict
  ): latestPayrollVersionResults
  """
  insert a single row into the table: "leave"
  """
  insertLeave(
    """the row to be inserted"""
    object: leaveInsertInput!
    """upsert condition"""
    onConflict: leaveOnConflict
  ): leave
  """
  insert a single row into the table: "notes"
  """
  insertNote(
    """the row to be inserted"""
    object: notesInsertInput!
    """upsert condition"""
    onConflict: notesOnConflict
  ): notes
  """
  insert a single row into the table: "payrolls"
  """
  insertPayroll(
    """the row to be inserted"""
    object: payrollsInsertInput!
    """upsert condition"""
    onConflict: payrollsOnConflict
  ): payrolls
  """
  insert a single row into the table: "payroll_activation_results"
  """
  insertPayrollActivationResult(
    """the row to be inserted"""
    object: payrollActivationResultsInsertInput!
    """upsert condition"""
    onConflict: payrollActivationResultsOnConflict
  ): payrollActivationResults
  """
  insert a single row into the table: "payroll_assignments"
  """
  insertPayrollAssignment(
    """the row to be inserted"""
    object: payrollAssignmentsInsertInput!
    """upsert condition"""
    onConflict: payrollAssignmentsOnConflict
  ): payrollAssignments
  """
  insert a single row into the table: "payroll_assignment_audit"
  """
  insertPayrollAssignmentAudit(
    """the row to be inserted"""
    object: payrollAssignmentAuditsInsertInput!
    """upsert condition"""
    onConflict: payrollAssignmentAuditsOnConflict
  ): payrollAssignmentAudits
  """
  insert a single row into the table: "payroll_cycles"
  """
  insertPayrollCycle(
    """the row to be inserted"""
    object: payrollCyclesInsertInput!
    """upsert condition"""
    onConflict: payrollCyclesOnConflict
  ): payrollCycles
  """
  insert a single row into the table: "payroll_dates"
  """
  insertPayrollDate(
    """the row to be inserted"""
    object: payrollDatesInsertInput!
    """upsert condition"""
    onConflict: payrollDatesOnConflict
  ): payrollDates
  """
  insert a single row into the table: "payroll_date_types"
  """
  insertPayrollDateType(
    """the row to be inserted"""
    object: payrollDateTypesInsertInput!
    """upsert condition"""
    onConflict: payrollDateTypesOnConflict
  ): payrollDateTypes
  """
  insert a single row into the table: "payroll_version_history_results"
  """
  insertPayrollVersionHistoryResult(
    """the row to be inserted"""
    object: payrollVersionHistoryResultsInsertInput!
    """upsert condition"""
    onConflict: payrollVersionHistoryResultsOnConflict
  ): payrollVersionHistoryResults
  """
  insert a single row into the table: "payroll_version_results"
  """
  insertPayrollVersionResult(
    """the row to be inserted"""
    object: payrollVersionResultsInsertInput!
    """upsert condition"""
    onConflict: payrollVersionResultsOnConflict
  ): payrollVersionResults
  """
  insert a single row into the table: "permissions"
  """
  insertPermission(
    """the row to be inserted"""
    object: permissionsInsertInput!
    """upsert condition"""
    onConflict: permissionsOnConflict
  ): permissions
  """
  insert a single row into the table: "permission_audit_log"
  """
  insertPermissionAuditLog(
    """the row to be inserted"""
    object: permissionAuditLogsInsertInput!
    """upsert condition"""
    onConflict: permissionAuditLogsOnConflict
  ): permissionAuditLogs
  """
  insert a single row into the table: "audit.permission_changes"
  """
  insertPermissionChange(
    """the row to be inserted"""
    object: permissionChangesInsertInput!
    """upsert condition"""
    onConflict: permissionChangesOnConflict
  ): permissionChanges
  """
  insert a single row into the table: "permission_overrides"
  """
  insertPermissionOverride(
    """the row to be inserted"""
    object: permissionOverridesInsertInput!
    """upsert condition"""
    onConflict: permissionOverridesOnConflict
  ): permissionOverrides
  """
  insert a single row into the table: "resources"
  """
  insertResource(
    """the row to be inserted"""
    object: resourcesInsertInput!
    """upsert condition"""
    onConflict: resourcesOnConflict
  ): resources
  """
  insert a single row into the table: "roles"
  """
  insertRole(
    """the row to be inserted"""
    object: rolesInsertInput!
    """upsert condition"""
    onConflict: rolesOnConflict
  ): roles
  """
  insert a single row into the table: "role_permissions"
  """
  insertRolePermission(
    """the row to be inserted"""
    object: rolePermissionsInsertInput!
    """upsert condition"""
    onConflict: rolePermissionsOnConflict
  ): rolePermissions
  """
  insert a single row into the table: "audit.slow_queries"
  """
  insertSlowQuery(
    """the row to be inserted"""
    object: slowQueriesInsertInput!
    """upsert condition"""
    onConflict: slowQueriesOnConflict
  ): slowQueries
  """
  insert a single row into the table: "users"
  """
  insertUser(
    """the row to be inserted"""
    object: usersInsertInput!
    """upsert condition"""
    onConflict: usersOnConflict
  ): users
  """
  insert a single row into the table: "audit.user_access_summary"
  """
  insertUserAccessSummary(
    """the row to be inserted"""
    object: userAccessSummariesInsertInput!
  ): userAccessSummaries
  """
  insert a single row into the table: "user_invitations"
  """
  insertUserInvitation(
    """the row to be inserted"""
    object: userInvitationsInsertInput!
    """upsert condition"""
    onConflict: userInvitationsOnConflict
  ): userInvitations
  """
  insert a single row into the table: "user_roles"
  """
  insertUserRole(
    """the row to be inserted"""
    object: userRolesInsertInput!
    """upsert condition"""
    onConflict: userRolesOnConflict
  ): userRoles
  """
  insert a single row into the table: "neon_auth.users_sync"
  """
  insertUserSync(
    """the row to be inserted"""
    object: authUsersSyncInsertInput!
    """upsert condition"""
    onConflict: authUsersSyncOnConflict
  ): authUsersSync
  """
  insert a single row into the table: "users_role_backup"
  """
  insertUsersRoleBackup(
    """the row to be inserted"""
    object: usersRoleBackupInsertInput!
  ): usersRoleBackup
  """
  insert a single row into the table: "work_schedule"
  """
  insertWorkSchedule(
    """the row to be inserted"""
    object: workSchedulesInsertInput!
    """upsert condition"""
    onConflict: workSchedulesOnConflict
  ): workSchedules
  """Log audit events for SOC2 compliance"""
  logAuditEvent(event: AuditEventInput!): AuditEventResponse
  """
  update single row of the table: "adjustment_rules"
  """
  updateAdjustmentRuleById(
    """sets the columns of the filtered rows to the given values"""
    _set: adjustmentRulesSetInput
    pkColumns: adjustmentRulesPkColumnsInput!
  ): adjustmentRules
  """
  update multiples rows of table: "adjustment_rules"
  """
  updateAdjustmentRulesMany(
    """updates to execute, in order"""
    updates: [adjustmentRulesUpdates!]!
  ): [adjustmentRulesMutationResponse]
  """
  update single row of the table: "app_settings"
  """
  updateAppSettingById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: appSettingsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: appSettingsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: appSettingsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: appSettingsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: appSettingsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: appSettingsSetInput
    pkColumns: appSettingsPkColumnsInput!
  ): appSettings
  """
  update multiples rows of table: "app_settings"
  """
  updateAppSettingsMany(
    """updates to execute, in order"""
    updates: [appSettingsUpdates!]!
  ): [appSettingsMutationResponse]
  """
  update single row of the table: "audit.audit_log"
  """
  updateAuditLogById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auditLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: auditLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: auditLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: auditLogsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auditLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: auditLogsSetInput
    pkColumns: auditLogsPkColumnsInput!
  ): auditLogs
  """
  update multiples rows of table: "audit.audit_log"
  """
  updateAuditLogsMany(
    """updates to execute, in order"""
    updates: [auditLogsUpdates!]!
  ): [auditLogsMutationResponse]
  """
  update single row of the table: "audit.auth_events"
  """
  updateAuthEventById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authEventsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: authEventsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: authEventsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: authEventsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authEventsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: authEventsSetInput
    pkColumns: authEventsPkColumnsInput!
  ): authEvents
  """
  update multiples rows of table: "audit.auth_events"
  """
  updateAuthEventsMany(
    """updates to execute, in order"""
    updates: [authEventsUpdates!]!
  ): [authEventsMutationResponse]
  """
  update multiples rows of table: "neon_auth.users_sync"
  """
  updateAuthUsersSyncMany(
    """updates to execute, in order"""
    updates: [authUsersSyncUpdates!]!
  ): [authUsersSyncMutationResponse]
  """
  update single row of the table: "billing_event_log"
  """
  updateBillingEventLogById(
    """sets the columns of the filtered rows to the given values"""
    _set: billingEventLogsSetInput
    pkColumns: billingEventLogsPkColumnsInput!
  ): billingEventLogs
  """
  update multiples rows of table: "billing_event_log"
  """
  updateBillingEventLogsMany(
    """updates to execute, in order"""
    updates: [billingEventLogsUpdates!]!
  ): [billingEventLogsMutationResponse]
  """
  update single row of the table: "billing_invoice"
  """
  updateBillingInvoiceById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingInvoiceIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingInvoiceSetInput
    pkColumns: billingInvoicePkColumnsInput!
  ): billingInvoice
  """
  update multiples rows of table: "billing_invoice"
  """
  updateBillingInvoiceMany(
    """updates to execute, in order"""
    updates: [billingInvoiceUpdates!]!
  ): [billingInvoiceMutationResponse]
  """
  update single row of the table: "billing_invoices"
  """
  updateBillingInvoicesById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingInvoicesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingInvoicesSetInput
    pkColumns: billingInvoicesPkColumnsInput!
  ): billingInvoices
  """
  update multiples rows of table: "billing_invoices"
  """
  updateBillingInvoicesMany(
    """updates to execute, in order"""
    updates: [billingInvoicesUpdates!]!
  ): [billingInvoicesMutationResponse]
  """
  update single row of the table: "billing_items"
  """
  updateBillingItemById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingItemsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingItemsSetInput
    pkColumns: billingItemsPkColumnsInput!
  ): billingItems
  """
  update multiples rows of table: "billing_items"
  """
  updateBillingItemsMany(
    """updates to execute, in order"""
    updates: [billingItemsUpdates!]!
  ): [billingItemsMutationResponse]
  """
  update single row of the table: "billing_plan"
  """
  updateBillingPlanById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: billingPlansIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: billingPlansSetInput
    pkColumns: billingPlansPkColumnsInput!
  ): billingPlans
  """
  update multiples rows of table: "billing_plan"
  """
  updateBillingPlansMany(
    """updates to execute, in order"""
    updates: [billingPlansUpdates!]!
  ): [billingPlansMutationResponse]
  """
  update single row of the table: "client_billing_assignment"
  """
  updateClientBillingAssignmentById(
    """sets the columns of the filtered rows to the given values"""
    _set: clientBillingAssignmentsSetInput
    pkColumns: clientBillingAssignmentsPkColumnsInput!
  ): clientBillingAssignments
  """
  update multiples rows of table: "client_billing_assignment"
  """
  updateClientBillingAssignmentsMany(
    """updates to execute, in order"""
    updates: [clientBillingAssignmentsUpdates!]!
  ): [clientBillingAssignmentsMutationResponse]
  """
  update single row of the table: "clients"
  """
  updateClientById(
    """sets the columns of the filtered rows to the given values"""
    _set: clientsSetInput
    pkColumns: clientsPkColumnsInput!
  ): clients
  """
  update single row of the table: "client_external_systems"
  """
  updateClientExternalSystemById(
    """sets the columns of the filtered rows to the given values"""
    _set: clientExternalSystemsSetInput
    pkColumns: clientExternalSystemsPkColumnsInput!
  ): clientExternalSystems
  """
  update multiples rows of table: "client_external_systems"
  """
  updateClientExternalSystemsMany(
    """updates to execute, in order"""
    updates: [clientExternalSystemsUpdates!]!
  ): [clientExternalSystemsMutationResponse]
  """
  update multiples rows of table: "clients"
  """
  updateClientsMany(
    """updates to execute, in order"""
    updates: [clientsUpdates!]!
  ): [clientsMutationResponse]
  """
  update single row of the table: "audit.data_access_log"
  """
  updateDataAccessLogById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: dataAccessLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: dataAccessLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: dataAccessLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: dataAccessLogsDeleteKeyInput
    """increments the numeric columns with given value of the filtered values"""
    _inc: dataAccessLogsIncInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: dataAccessLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: dataAccessLogsSetInput
    pkColumns: dataAccessLogsPkColumnsInput!
  ): dataAccessLogs
  """
  update multiples rows of table: "audit.data_access_log"
  """
  updateDataAccessLogsMany(
    """updates to execute, in order"""
    updates: [dataAccessLogsUpdates!]!
  ): [dataAccessLogsMutationResponse]
  """
  update single row of the table: "external_systems"
  """
  updateExternalSystemById(
    """sets the columns of the filtered rows to the given values"""
    _set: externalSystemsSetInput
    pkColumns: externalSystemsPkColumnsInput!
  ): externalSystems
  """
  update multiples rows of table: "external_systems"
  """
  updateExternalSystemsMany(
    """updates to execute, in order"""
    updates: [externalSystemsUpdates!]!
  ): [externalSystemsMutationResponse]
  """
  update single row of the table: "feature_flags"
  """
  updateFeatureFlagById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: featureFlagsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: featureFlagsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: featureFlagsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: featureFlagsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: featureFlagsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: featureFlagsSetInput
    pkColumns: featureFlagsPkColumnsInput!
  ): featureFlags
  """
  update multiples rows of table: "feature_flags"
  """
  updateFeatureFlagsMany(
    """updates to execute, in order"""
    updates: [featureFlagsUpdates!]!
  ): [featureFlagsMutationResponse]
  """
  update single row of the table: "holidays"
  """
  updateHolidayById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: holidaysIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: holidaysSetInput
    pkColumns: holidaysPkColumnsInput!
  ): holidays
  """
  update multiples rows of table: "holidays"
  """
  updateHolidaysMany(
    """updates to execute, in order"""
    updates: [holidaysUpdates!]!
  ): [holidaysMutationResponse]
  """
  update single row of the table: "latest_payroll_version_results"
  """
  updateLatestPayrollVersionResultById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: latestPayrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: latestPayrollVersionResultsSetInput
    pkColumns: latestPayrollVersionResultsPkColumnsInput!
  ): latestPayrollVersionResults
  """
  update multiples rows of table: "latest_payroll_version_results"
  """
  updateLatestPayrollVersionResultsMany(
    """updates to execute, in order"""
    updates: [latestPayrollVersionResultsUpdates!]!
  ): [latestPayrollVersionResultsMutationResponse]
  """
  update single row of the table: "leave"
  """
  updateLeaveById(
    """sets the columns of the filtered rows to the given values"""
    _set: leaveSetInput
    pkColumns: leavePkColumnsInput!
  ): leave
  """
  update multiples rows of table: "leave"
  """
  updateLeaveMany(
    """updates to execute, in order"""
    updates: [leaveUpdates!]!
  ): [leaveMutationResponse]
  """
  update single row of the table: "notes"
  """
  updateNoteById(
    """sets the columns of the filtered rows to the given values"""
    _set: notesSetInput
    pkColumns: notesPkColumnsInput!
  ): notes
  """
  update multiples rows of table: "notes"
  """
  updateNotesMany(
    """updates to execute, in order"""
    updates: [notesUpdates!]!
  ): [notesMutationResponse]
  """
  update single row of the table: "payroll_activation_results"
  """
  updatePayrollActivationResultById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollActivationResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollActivationResultsSetInput
    pkColumns: payrollActivationResultsPkColumnsInput!
  ): payrollActivationResults
  """
  update multiples rows of table: "payroll_activation_results"
  """
  updatePayrollActivationResultsMany(
    """updates to execute, in order"""
    updates: [payrollActivationResultsUpdates!]!
  ): [payrollActivationResultsMutationResponse]
  """
  update single row of the table: "payroll_assignment_audit"
  """
  updatePayrollAssignmentAuditById(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollAssignmentAuditsSetInput
    pkColumns: payrollAssignmentAuditsPkColumnsInput!
  ): payrollAssignmentAudits
  """
  update multiples rows of table: "payroll_assignment_audit"
  """
  updatePayrollAssignmentAuditsMany(
    """updates to execute, in order"""
    updates: [payrollAssignmentAuditsUpdates!]!
  ): [payrollAssignmentAuditsMutationResponse]
  """
  update single row of the table: "payroll_assignments"
  """
  updatePayrollAssignmentById(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollAssignmentsSetInput
    pkColumns: payrollAssignmentsPkColumnsInput!
  ): payrollAssignments
  """
  update multiples rows of table: "payroll_assignments"
  """
  updatePayrollAssignmentsMany(
    """updates to execute, in order"""
    updates: [payrollAssignmentsUpdates!]!
  ): [payrollAssignmentsMutationResponse]
  """
  update single row of the table: "payrolls"
  """
  updatePayrollById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollsSetInput
    pkColumns: payrollsPkColumnsInput!
  ): payrolls
  """
  update single row of the table: "payroll_cycles"
  """
  updatePayrollCycleById(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollCyclesSetInput
    pkColumns: payrollCyclesPkColumnsInput!
  ): payrollCycles
  """
  update multiples rows of table: "payroll_cycles"
  """
  updatePayrollCyclesMany(
    """updates to execute, in order"""
    updates: [payrollCyclesUpdates!]!
  ): [payrollCyclesMutationResponse]
  """
  update single row of the table: "payroll_dates"
  """
  updatePayrollDateById(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollDatesSetInput
    pkColumns: payrollDatesPkColumnsInput!
  ): payrollDates
  """
  update single row of the table: "payroll_date_types"
  """
  updatePayrollDateTypeById(
    """sets the columns of the filtered rows to the given values"""
    _set: payrollDateTypesSetInput
    pkColumns: payrollDateTypesPkColumnsInput!
  ): payrollDateTypes
  """
  update multiples rows of table: "payroll_date_types"
  """
  updatePayrollDateTypesMany(
    """updates to execute, in order"""
    updates: [payrollDateTypesUpdates!]!
  ): [payrollDateTypesMutationResponse]
  """
  update multiples rows of table: "payroll_dates"
  """
  updatePayrollDatesMany(
    """updates to execute, in order"""
    updates: [payrollDatesUpdates!]!
  ): [payrollDatesMutationResponse]
  """
  update single row of the table: "payroll_version_history_results"
  """
  updatePayrollVersionHistoryResultById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollVersionHistoryResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollVersionHistoryResultsSetInput
    pkColumns: payrollVersionHistoryResultsPkColumnsInput!
  ): payrollVersionHistoryResults
  """
  update multiples rows of table: "payroll_version_history_results"
  """
  updatePayrollVersionHistoryResultsMany(
    """updates to execute, in order"""
    updates: [payrollVersionHistoryResultsUpdates!]!
  ): [payrollVersionHistoryResultsMutationResponse]
  """
  update single row of the table: "payroll_version_results"
  """
  updatePayrollVersionResultById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: payrollVersionResultsIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: payrollVersionResultsSetInput
    pkColumns: payrollVersionResultsPkColumnsInput!
  ): payrollVersionResults
  """
  update multiples rows of table: "payroll_version_results"
  """
  updatePayrollVersionResultsMany(
    """updates to execute, in order"""
    updates: [payrollVersionResultsUpdates!]!
  ): [payrollVersionResultsMutationResponse]
  """
  update multiples rows of table: "payrolls"
  """
  updatePayrollsMany(
    """updates to execute, in order"""
    updates: [payrollsUpdates!]!
  ): [payrollsMutationResponse]
  """
  update single row of the table: "permission_audit_log"
  """
  updatePermissionAuditLogById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permissionAuditLogsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: permissionAuditLogsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: permissionAuditLogsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: permissionAuditLogsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permissionAuditLogsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: permissionAuditLogsSetInput
    pkColumns: permissionAuditLogsPkColumnsInput!
  ): permissionAuditLogs
  """
  update multiples rows of table: "permission_audit_log"
  """
  updatePermissionAuditLogsMany(
    """updates to execute, in order"""
    updates: [permissionAuditLogsUpdates!]!
  ): [permissionAuditLogsMutationResponse]
  """
  update single row of the table: "permissions"
  """
  updatePermissionById(
    """sets the columns of the filtered rows to the given values"""
    _set: permissionsSetInput
    pkColumns: permissionsPkColumnsInput!
  ): permissions
  """
  update single row of the table: "audit.permission_changes"
  """
  updatePermissionChangeById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permissionChangesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: permissionChangesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: permissionChangesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: permissionChangesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permissionChangesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: permissionChangesSetInput
    pkColumns: permissionChangesPkColumnsInput!
  ): permissionChanges
  """
  update multiples rows of table: "audit.permission_changes"
  """
  updatePermissionChangesMany(
    """updates to execute, in order"""
    updates: [permissionChangesUpdates!]!
  ): [permissionChangesMutationResponse]
  """
  update single row of the table: "permission_overrides"
  """
  updatePermissionOverrideById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: permissionOverridesAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: permissionOverridesDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: permissionOverridesDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: permissionOverridesDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: permissionOverridesPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: permissionOverridesSetInput
    pkColumns: permissionOverridesPkColumnsInput!
  ): permissionOverrides
  """
  update multiples rows of table: "permission_overrides"
  """
  updatePermissionOverridesMany(
    """updates to execute, in order"""
    updates: [permissionOverridesUpdates!]!
  ): [permissionOverridesMutationResponse]
  """
  update multiples rows of table: "permissions"
  """
  updatePermissionsMany(
    """updates to execute, in order"""
    updates: [permissionsUpdates!]!
  ): [permissionsMutationResponse]
  """
  update single row of the table: "resources"
  """
  updateResourceById(
    """sets the columns of the filtered rows to the given values"""
    _set: resourcesSetInput
    pkColumns: resourcesPkColumnsInput!
  ): resources
  """
  update multiples rows of table: "resources"
  """
  updateResourcesMany(
    """updates to execute, in order"""
    updates: [resourcesUpdates!]!
  ): [resourcesMutationResponse]
  """
  update single row of the table: "roles"
  """
  updateRoleById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rolesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: rolesSetInput
    pkColumns: rolesPkColumnsInput!
  ): roles
  """
  update single row of the table: "role_permissions"
  """
  updateRolePermissionById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: rolePermissionsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: rolePermissionsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: rolePermissionsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: rolePermissionsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: rolePermissionsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: rolePermissionsSetInput
    pkColumns: rolePermissionsPkColumnsInput!
  ): rolePermissions
  """
  update multiples rows of table: "role_permissions"
  """
  updateRolePermissionsMany(
    """updates to execute, in order"""
    updates: [rolePermissionsUpdates!]!
  ): [rolePermissionsMutationResponse]
  """
  update multiples rows of table: "roles"
  """
  updateRolesMany(
    """updates to execute, in order"""
    updates: [rolesUpdates!]!
  ): [rolesMutationResponse]
  """
  update multiples rows of table: "audit.slow_queries"
  """
  updateSlowQueriesMany(
    """updates to execute, in order"""
    updates: [slowQueriesUpdates!]!
  ): [slowQueriesMutationResponse]
  """
  update single row of the table: "audit.slow_queries"
  """
  updateSlowQueryById(
    """sets the columns of the filtered rows to the given values"""
    _set: slowQueriesSetInput
    pkColumns: slowQueriesPkColumnsInput!
  ): slowQueries
  """
  update multiples rows of table: "audit.user_access_summary"
  """
  updateUserAccessSummariesMany(
    """updates to execute, in order"""
    updates: [userAccessSummariesUpdates!]!
  ): [userAccessSummariesMutationResponse]
  """
  update single row of the table: "users"
  """
  updateUserById(
    """sets the columns of the filtered rows to the given values"""
    _set: usersSetInput
    pkColumns: usersPkColumnsInput!
  ): users
  """
  update single row of the table: "user_invitations"
  """
  updateUserInvitationById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: userInvitationsAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: userInvitationsDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: userInvitationsDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: userInvitationsDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: userInvitationsPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: userInvitationsSetInput
    pkColumns: userInvitationsPkColumnsInput!
  ): userInvitations
  """
  update multiples rows of table: "user_invitations"
  """
  updateUserInvitationsMany(
    """updates to execute, in order"""
    updates: [userInvitationsUpdates!]!
  ): [userInvitationsMutationResponse]
  """
  update single row of the table: "user_roles"
  """
  updateUserRoleById(
    """sets the columns of the filtered rows to the given values"""
    _set: userRolesSetInput
    pkColumns: userRolesPkColumnsInput!
  ): userRoles
  """
  update multiples rows of table: "user_roles"
  """
  updateUserRolesMany(
    """updates to execute, in order"""
    updates: [userRolesUpdates!]!
  ): [userRolesMutationResponse]
  """
  update single row of the table: "neon_auth.users_sync"
  """
  updateUserSyncById(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authUsersSyncAppendInput
    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: authUsersSyncDeleteAtPathInput
    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: authUsersSyncDeleteElemInput
    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: authUsersSyncDeleteKeyInput
    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authUsersSyncPrependInput
    """sets the columns of the filtered rows to the given values"""
    _set: authUsersSyncSetInput
    pkColumns: authUsersSyncPkColumnsInput!
  ): authUsersSync
  """
  update multiples rows of table: "users"
  """
  updateUsersMany(
    """updates to execute, in order"""
    updates: [usersUpdates!]!
  ): [usersMutationResponse]
  """
  update multiples rows of table: "users_role_backup"
  """
  updateUsersRoleBackupMany(
    """updates to execute, in order"""
    updates: [usersRoleBackupUpdates!]!
  ): [usersRoleBackupMutationResponse]
  """
  update single row of the table: "work_schedule"
  """
  updateWorkScheduleById(
    """increments the numeric columns with given value of the filtered values"""
    _inc: workSchedulesIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: workSchedulesSetInput
    pkColumns: workSchedulesPkColumnsInput!
  ): workSchedules
  """
  update multiples rows of table: "work_schedule"
  """
  updateWorkSchedulesMany(
    """updates to execute, in order"""
    updates: [workSchedulesUpdates!]!
  ): [workSchedulesMutationResponse]
}

scalar name

"""
columns and relationships of "notes"
"""
type notes {
  """An object relationship"""
  authorUser: users
  """Content of the note"""
  content: String!
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid!
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String!
  """Unique identifier for the note"""
  id: uuid!
  """Whether the note is flagged as important"""
  isImportant: Boolean
  """An array relationship"""
  notesByClient(
    """distinct select on columns"""
    distinctOn: [clientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientsOrderBy!]
    """filter the rows returned"""
    where: clientsBoolExp
  ): [clients!]!
  """An aggregate relationship"""
  notesByClientAggregate(
    """distinct select on columns"""
    distinctOn: [clientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientsOrderBy!]
    """filter the rows returned"""
    where: clientsBoolExp
  ): clientsAggregate!
  """An array relationship"""
  notesByPayroll(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  notesByPayrollAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
aggregated selection of "notes"
"""
type notesAggregate {
  aggregate: notesAggregateFields
  nodes: [notes!]!
}

input notesAggregateBoolExp {
  bool_and: notesAggregateBoolExpBool_and
  bool_or: notesAggregateBoolExpBool_or
  count: notesAggregateBoolExpCount
}

input notesAggregateBoolExpBool_and {
  arguments: notesSelectColumnNotesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: notesBoolExp
  predicate: BooleanComparisonExp!
}

input notesAggregateBoolExpBool_or {
  arguments: notesSelectColumnNotesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: notesBoolExp
  predicate: BooleanComparisonExp!
}

input notesAggregateBoolExpCount {
  arguments: [notesSelectColumn!]
  distinct: Boolean
  filter: notesBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "notes"
"""
type notesAggregateFields {
  count(columns: [notesSelectColumn!], distinct: Boolean): Int!
  max: notesMaxFields
  min: notesMinFields
}

"""
order by aggregate values of table "notes"
"""
input notesAggregateOrderBy {
  count: OrderBy
  max: notesMaxOrderBy
  min: notesMinOrderBy
}

"""
input type for inserting array relation for remote table "notes"
"""
input notesArrRelInsertInput {
  data: [notesInsertInput!]!
  """upsert condition"""
  onConflict: notesOnConflict
}

"""
Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'.
"""
input notesBoolExp {
  _and: [notesBoolExp!]
  _not: notesBoolExp
  _or: [notesBoolExp!]
  authorUser: usersBoolExp
  content: StringComparisonExp
  createdAt: TimestampComparisonExp
  entityId: UuidComparisonExp
  entityType: StringComparisonExp
  id: UuidComparisonExp
  isImportant: BooleanComparisonExp
  notesByClient: clientsBoolExp
  notesByClientAggregate: clientsAggregateBoolExp
  notesByPayroll: payrollsBoolExp
  notesByPayrollAggregate: payrollsAggregateBoolExp
  updatedAt: TimestampComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "notes"
"""
enum notesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  notes_pkey
}

"""
input type for inserting data into table "notes"
"""
input notesInsertInput {
  authorUser: usersObjRelInsertInput
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Whether the note is flagged as important"""
  isImportant: Boolean
  notesByClient: clientsArrRelInsertInput
  notesByPayroll: payrollsArrRelInsertInput
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""aggregate max on columns"""
type notesMaxFields {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
order by max() on columns of table "notes"
"""
input notesMaxOrderBy {
  """Content of the note"""
  content: OrderBy
  """Timestamp when the note was created"""
  createdAt: OrderBy
  """Identifier of the entity this note is attached to"""
  entityId: OrderBy
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: OrderBy
  """Unique identifier for the note"""
  id: OrderBy
  """Timestamp when the note was last updated"""
  updatedAt: OrderBy
  """User who created the note"""
  userId: OrderBy
}

"""aggregate min on columns"""
type notesMinFields {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
order by min() on columns of table "notes"
"""
input notesMinOrderBy {
  """Content of the note"""
  content: OrderBy
  """Timestamp when the note was created"""
  createdAt: OrderBy
  """Identifier of the entity this note is attached to"""
  entityId: OrderBy
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: OrderBy
  """Unique identifier for the note"""
  id: OrderBy
  """Timestamp when the note was last updated"""
  updatedAt: OrderBy
  """User who created the note"""
  userId: OrderBy
}

"""
response of any mutation on the table "notes"
"""
type notesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [notes!]!
}

"""
on_conflict condition type for table "notes"
"""
input notesOnConflict {
  constraint: notesConstraint!
  updateColumns: [notesUpdateColumn!]! = []
  where: notesBoolExp
}

"""Ordering options when selecting data from "notes"."""
input notesOrderBy {
  authorUser: usersOrderBy
  content: OrderBy
  createdAt: OrderBy
  entityId: OrderBy
  entityType: OrderBy
  id: OrderBy
  isImportant: OrderBy
  notesByClientAggregate: clientsAggregateOrderBy
  notesByPayrollAggregate: payrollsAggregateOrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: notes"""
input notesPkColumnsInput {
  """Unique identifier for the note"""
  id: uuid!
}

"""
select columns of table "notes"
"""
enum notesSelectColumn {
  """column name"""
  content
  """column name"""
  createdAt
  """column name"""
  entityId
  """column name"""
  entityType
  """column name"""
  id
  """column name"""
  isImportant
  """column name"""
  updatedAt
  """column name"""
  userId
}

"""
select "notesAggregateBoolExpBool_andArgumentsColumns" columns of table "notes"
"""
enum notesSelectColumnNotesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isImportant
}

"""
select "notesAggregateBoolExpBool_orArgumentsColumns" columns of table "notes"
"""
enum notesSelectColumnNotesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isImportant
}

"""
input type for updating data in table "notes"
"""
input notesSetInput {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Whether the note is flagged as important"""
  isImportant: Boolean
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
Streaming cursor of the table "notes"
"""
input notesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: notesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input notesStreamCursorValueInput {
  """Content of the note"""
  content: String
  """Timestamp when the note was created"""
  createdAt: timestamp
  """Identifier of the entity this note is attached to"""
  entityId: uuid
  """Type of entity this note is attached to (client, payroll, etc.)"""
  entityType: String
  """Unique identifier for the note"""
  id: uuid
  """Whether the note is flagged as important"""
  isImportant: Boolean
  """Timestamp when the note was last updated"""
  updatedAt: timestamp
  """User who created the note"""
  userId: uuid
}

"""
update columns of table "notes"
"""
enum notesUpdateColumn {
  """column name"""
  content
  """column name"""
  createdAt
  """column name"""
  entityId
  """column name"""
  entityType
  """column name"""
  id
  """column name"""
  isImportant
  """column name"""
  updatedAt
  """column name"""
  userId
}

input notesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: notesSetInput
  """filter the rows which have to be updated"""
  where: notesBoolExp!
}

scalar numeric

"""
columns and relationships of "payroll_activation_results"
"""
type payrollActivationResults {
  actionTaken: String!
  executedAt: timestamptz
  id: uuid!
  payrollId: uuid!
  versionNumber: Int!
}

type payrollActivationResultsAggregate {
  aggregate: payrollActivationResultsAggregateFields
  nodes: [payrollActivationResults!]!
}

"""
aggregate fields of "payroll_activation_results"
"""
type payrollActivationResultsAggregateFields {
  avg: payrollActivationResultsAvgFields
  count(columns: [payrollActivationResultsSelectColumn!], distinct: Boolean): Int!
  max: payrollActivationResultsMaxFields
  min: payrollActivationResultsMinFields
  stddev: payrollActivationResultsStddevFields
  stddevPop: payrollActivationResultsStddevPopFields
  stddevSamp: payrollActivationResultsStddevSampFields
  sum: payrollActivationResultsSumFields
  varPop: payrollActivationResultsVarPopFields
  varSamp: payrollActivationResultsVarSampFields
  variance: payrollActivationResultsVarianceFields
}

"""aggregate avg on columns"""
type payrollActivationResultsAvgFields {
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "payroll_activation_results". All fields are combined with a logical 'AND'.
"""
input payrollActivationResultsBoolExp {
  _and: [payrollActivationResultsBoolExp!]
  _not: payrollActivationResultsBoolExp
  _or: [payrollActivationResultsBoolExp!]
  actionTaken: StringComparisonExp
  executedAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  payrollId: UuidComparisonExp
  versionNumber: IntComparisonExp
}

"""
unique or primary key constraints on table "payroll_activation_results"
"""
enum payrollActivationResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_activation_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_activation_results"
"""
input payrollActivationResultsIncInput {
  versionNumber: Int
}

"""
input type for inserting data into table "payroll_activation_results"
"""
input payrollActivationResultsInsertInput {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate max on columns"""
type payrollActivationResultsMaxFields {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate min on columns"""
type payrollActivationResultsMinFields {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""
response of any mutation on the table "payroll_activation_results"
"""
type payrollActivationResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollActivationResults!]!
}

"""
on_conflict condition type for table "payroll_activation_results"
"""
input payrollActivationResultsOnConflict {
  constraint: payrollActivationResultsConstraint!
  updateColumns: [payrollActivationResultsUpdateColumn!]! = []
  where: payrollActivationResultsBoolExp
}

"""
Ordering options when selecting data from "payroll_activation_results".
"""
input payrollActivationResultsOrderBy {
  actionTaken: OrderBy
  executedAt: OrderBy
  id: OrderBy
  payrollId: OrderBy
  versionNumber: OrderBy
}

"""primary key columns input for table: payroll_activation_results"""
input payrollActivationResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_activation_results"
"""
enum payrollActivationResultsSelectColumn {
  """column name"""
  actionTaken
  """column name"""
  executedAt
  """column name"""
  id
  """column name"""
  payrollId
  """column name"""
  versionNumber
}

"""
input type for updating data in table "payroll_activation_results"
"""
input payrollActivationResultsSetInput {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate stddev on columns"""
type payrollActivationResultsStddevFields {
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type payrollActivationResultsStddevPopFields {
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type payrollActivationResultsStddevSampFields {
  versionNumber: Float
}

"""
Streaming cursor of the table "payrollActivationResults"
"""
input payrollActivationResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollActivationResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollActivationResultsStreamCursorValueInput {
  actionTaken: String
  executedAt: timestamptz
  id: uuid
  payrollId: uuid
  versionNumber: Int
}

"""aggregate sum on columns"""
type payrollActivationResultsSumFields {
  versionNumber: Int
}

"""
update columns of table "payroll_activation_results"
"""
enum payrollActivationResultsUpdateColumn {
  """column name"""
  actionTaken
  """column name"""
  executedAt
  """column name"""
  id
  """column name"""
  payrollId
  """column name"""
  versionNumber
}

input payrollActivationResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payrollActivationResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: payrollActivationResultsSetInput
  """filter the rows which have to be updated"""
  where: payrollActivationResultsBoolExp!
}

"""aggregate varPop on columns"""
type payrollActivationResultsVarPopFields {
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type payrollActivationResultsVarSampFields {
  versionNumber: Float
}

"""aggregate variance on columns"""
type payrollActivationResultsVarianceFields {
  versionNumber: Float
}

"""
columns and relationships of "payroll_assignment_audit"
"""
type payrollAssignmentAudits {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  """An object relationship"""
  changedByUser: users
  createdAt: timestamptz
  """An object relationship"""
  fromConsultant: users
  fromConsultantId: uuid
  id: uuid!
  """An object relationship"""
  payrollAssignment: payrollAssignments
  """An object relationship"""
  payrollDate: payrollDates!
  payrollDateId: uuid!
  """An object relationship"""
  toConsultant: users!
  toConsultantId: uuid!
}

"""
aggregated selection of "payroll_assignment_audit"
"""
type payrollAssignmentAuditsAggregate {
  aggregate: payrollAssignmentAuditsAggregateFields
  nodes: [payrollAssignmentAudits!]!
}

input payrollAssignmentAuditsAggregateBoolExp {
  count: payrollAssignmentAuditsAggregateBoolExpCount
}

input payrollAssignmentAuditsAggregateBoolExpCount {
  arguments: [payrollAssignmentAuditsSelectColumn!]
  distinct: Boolean
  filter: payrollAssignmentAuditsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "payroll_assignment_audit"
"""
type payrollAssignmentAuditsAggregateFields {
  count(columns: [payrollAssignmentAuditsSelectColumn!], distinct: Boolean): Int!
  max: payrollAssignmentAuditsMaxFields
  min: payrollAssignmentAuditsMinFields
}

"""
order by aggregate values of table "payroll_assignment_audit"
"""
input payrollAssignmentAuditsAggregateOrderBy {
  count: OrderBy
  max: payrollAssignmentAuditsMaxOrderBy
  min: payrollAssignmentAuditsMinOrderBy
}

"""
input type for inserting array relation for remote table "payroll_assignment_audit"
"""
input payrollAssignmentAuditsArrRelInsertInput {
  data: [payrollAssignmentAuditsInsertInput!]!
  """upsert condition"""
  onConflict: payrollAssignmentAuditsOnConflict
}

"""
Boolean expression to filter rows from the table "payroll_assignment_audit". All fields are combined with a logical 'AND'.
"""
input payrollAssignmentAuditsBoolExp {
  _and: [payrollAssignmentAuditsBoolExp!]
  _not: payrollAssignmentAuditsBoolExp
  _or: [payrollAssignmentAuditsBoolExp!]
  assignmentId: UuidComparisonExp
  changeReason: StringComparisonExp
  changedBy: UuidComparisonExp
  changedByUser: usersBoolExp
  createdAt: TimestamptzComparisonExp
  fromConsultant: usersBoolExp
  fromConsultantId: UuidComparisonExp
  id: UuidComparisonExp
  payrollAssignment: payrollAssignmentsBoolExp
  payrollDate: payrollDatesBoolExp
  payrollDateId: UuidComparisonExp
  toConsultant: usersBoolExp
  toConsultantId: UuidComparisonExp
}

"""
unique or primary key constraints on table "payroll_assignment_audit"
"""
enum payrollAssignmentAuditsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_assignment_audit_pkey
}

"""
input type for inserting data into table "payroll_assignment_audit"
"""
input payrollAssignmentAuditsInsertInput {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  changedByUser: usersObjRelInsertInput
  createdAt: timestamptz
  fromConsultant: usersObjRelInsertInput
  fromConsultantId: uuid
  id: uuid
  payrollAssignment: payrollAssignmentsObjRelInsertInput
  payrollDate: payrollDatesObjRelInsertInput
  payrollDateId: uuid
  toConsultant: usersObjRelInsertInput
  toConsultantId: uuid
}

"""aggregate max on columns"""
type payrollAssignmentAuditsMaxFields {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
order by max() on columns of table "payroll_assignment_audit"
"""
input payrollAssignmentAuditsMaxOrderBy {
  assignmentId: OrderBy
  changeReason: OrderBy
  changedBy: OrderBy
  createdAt: OrderBy
  fromConsultantId: OrderBy
  id: OrderBy
  payrollDateId: OrderBy
  toConsultantId: OrderBy
}

"""aggregate min on columns"""
type payrollAssignmentAuditsMinFields {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
order by min() on columns of table "payroll_assignment_audit"
"""
input payrollAssignmentAuditsMinOrderBy {
  assignmentId: OrderBy
  changeReason: OrderBy
  changedBy: OrderBy
  createdAt: OrderBy
  fromConsultantId: OrderBy
  id: OrderBy
  payrollDateId: OrderBy
  toConsultantId: OrderBy
}

"""
response of any mutation on the table "payroll_assignment_audit"
"""
type payrollAssignmentAuditsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollAssignmentAudits!]!
}

"""
on_conflict condition type for table "payroll_assignment_audit"
"""
input payrollAssignmentAuditsOnConflict {
  constraint: payrollAssignmentAuditsConstraint!
  updateColumns: [payrollAssignmentAuditsUpdateColumn!]! = []
  where: payrollAssignmentAuditsBoolExp
}

"""Ordering options when selecting data from "payroll_assignment_audit"."""
input payrollAssignmentAuditsOrderBy {
  assignmentId: OrderBy
  changeReason: OrderBy
  changedBy: OrderBy
  changedByUser: usersOrderBy
  createdAt: OrderBy
  fromConsultant: usersOrderBy
  fromConsultantId: OrderBy
  id: OrderBy
  payrollAssignment: payrollAssignmentsOrderBy
  payrollDate: payrollDatesOrderBy
  payrollDateId: OrderBy
  toConsultant: usersOrderBy
  toConsultantId: OrderBy
}

"""primary key columns input for table: payroll_assignment_audit"""
input payrollAssignmentAuditsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_assignment_audit"
"""
enum payrollAssignmentAuditsSelectColumn {
  """column name"""
  assignmentId
  """column name"""
  changeReason
  """column name"""
  changedBy
  """column name"""
  createdAt
  """column name"""
  fromConsultantId
  """column name"""
  id
  """column name"""
  payrollDateId
  """column name"""
  toConsultantId
}

"""
input type for updating data in table "payroll_assignment_audit"
"""
input payrollAssignmentAuditsSetInput {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
Streaming cursor of the table "payrollAssignmentAudits"
"""
input payrollAssignmentAuditsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollAssignmentAuditsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollAssignmentAuditsStreamCursorValueInput {
  assignmentId: uuid
  changeReason: String
  changedBy: uuid
  createdAt: timestamptz
  fromConsultantId: uuid
  id: uuid
  payrollDateId: uuid
  toConsultantId: uuid
}

"""
update columns of table "payroll_assignment_audit"
"""
enum payrollAssignmentAuditsUpdateColumn {
  """column name"""
  assignmentId
  """column name"""
  changeReason
  """column name"""
  changedBy
  """column name"""
  createdAt
  """column name"""
  fromConsultantId
  """column name"""
  id
  """column name"""
  payrollDateId
  """column name"""
  toConsultantId
}

input payrollAssignmentAuditsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: payrollAssignmentAuditsSetInput
  """filter the rows which have to be updated"""
  where: payrollAssignmentAuditsBoolExp!
}

"""
columns and relationships of "payroll_assignments"
"""
type payrollAssignments {
  assignedBy: uuid
  """An object relationship"""
  assignedByUser: users
  """An object relationship"""
  assignedConsultant: users!
  assignedDate: timestamptz
  consultantId: uuid!
  createdAt: timestamptz
  id: uuid!
  isBackup: Boolean
  """An object relationship"""
  originalConsultant: users
  originalConsultantId: uuid
  """An array relationship"""
  payrollAssignmentAudits(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """An aggregate relationship"""
  payrollAssignmentAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): payrollAssignmentAuditsAggregate!
  """An object relationship"""
  payrollDate: payrollDates!
  payrollDateId: uuid!
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_assignments"
"""
type payrollAssignmentsAggregate {
  aggregate: payrollAssignmentsAggregateFields
  nodes: [payrollAssignments!]!
}

input payrollAssignmentsAggregateBoolExp {
  bool_and: payrollAssignmentsAggregateBoolExpBool_and
  bool_or: payrollAssignmentsAggregateBoolExpBool_or
  count: payrollAssignmentsAggregateBoolExpCount
}

input payrollAssignmentsAggregateBoolExpBool_and {
  arguments: payrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: payrollAssignmentsBoolExp
  predicate: BooleanComparisonExp!
}

input payrollAssignmentsAggregateBoolExpBool_or {
  arguments: payrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: payrollAssignmentsBoolExp
  predicate: BooleanComparisonExp!
}

input payrollAssignmentsAggregateBoolExpCount {
  arguments: [payrollAssignmentsSelectColumn!]
  distinct: Boolean
  filter: payrollAssignmentsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "payroll_assignments"
"""
type payrollAssignmentsAggregateFields {
  count(columns: [payrollAssignmentsSelectColumn!], distinct: Boolean): Int!
  max: payrollAssignmentsMaxFields
  min: payrollAssignmentsMinFields
}

"""
order by aggregate values of table "payroll_assignments"
"""
input payrollAssignmentsAggregateOrderBy {
  count: OrderBy
  max: payrollAssignmentsMaxOrderBy
  min: payrollAssignmentsMinOrderBy
}

"""
input type for inserting array relation for remote table "payroll_assignments"
"""
input payrollAssignmentsArrRelInsertInput {
  data: [payrollAssignmentsInsertInput!]!
  """upsert condition"""
  onConflict: payrollAssignmentsOnConflict
}

"""
Boolean expression to filter rows from the table "payroll_assignments". All fields are combined with a logical 'AND'.
"""
input payrollAssignmentsBoolExp {
  _and: [payrollAssignmentsBoolExp!]
  _not: payrollAssignmentsBoolExp
  _or: [payrollAssignmentsBoolExp!]
  assignedBy: UuidComparisonExp
  assignedByUser: usersBoolExp
  assignedConsultant: usersBoolExp
  assignedDate: TimestamptzComparisonExp
  consultantId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isBackup: BooleanComparisonExp
  originalConsultant: usersBoolExp
  originalConsultantId: UuidComparisonExp
  payrollAssignmentAudits: payrollAssignmentAuditsBoolExp
  payrollAssignmentAuditsAggregate: payrollAssignmentAuditsAggregateBoolExp
  payrollDate: payrollDatesBoolExp
  payrollDateId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_assignments"
"""
enum payrollAssignmentsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_assignments_pkey
  """
  unique or primary key constraint on columns "payroll_date_id"
  """
  uq_payroll_assignment_payroll_date
}

"""
input type for inserting data into table "payroll_assignments"
"""
input payrollAssignmentsInsertInput {
  assignedBy: uuid
  assignedByUser: usersObjRelInsertInput
  assignedConsultant: usersObjRelInsertInput
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultant: usersObjRelInsertInput
  originalConsultantId: uuid
  payrollAssignmentAudits: payrollAssignmentAuditsArrRelInsertInput
  payrollDate: payrollDatesObjRelInsertInput
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type payrollAssignmentsMaxFields {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "payroll_assignments"
"""
input payrollAssignmentsMaxOrderBy {
  assignedBy: OrderBy
  assignedDate: OrderBy
  consultantId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  originalConsultantId: OrderBy
  payrollDateId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type payrollAssignmentsMinFields {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "payroll_assignments"
"""
input payrollAssignmentsMinOrderBy {
  assignedBy: OrderBy
  assignedDate: OrderBy
  consultantId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  originalConsultantId: OrderBy
  payrollDateId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "payroll_assignments"
"""
type payrollAssignmentsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollAssignments!]!
}

"""
input type for inserting object relation for remote table "payroll_assignments"
"""
input payrollAssignmentsObjRelInsertInput {
  data: payrollAssignmentsInsertInput!
  """upsert condition"""
  onConflict: payrollAssignmentsOnConflict
}

"""
on_conflict condition type for table "payroll_assignments"
"""
input payrollAssignmentsOnConflict {
  constraint: payrollAssignmentsConstraint!
  updateColumns: [payrollAssignmentsUpdateColumn!]! = []
  where: payrollAssignmentsBoolExp
}

"""Ordering options when selecting data from "payroll_assignments"."""
input payrollAssignmentsOrderBy {
  assignedBy: OrderBy
  assignedByUser: usersOrderBy
  assignedConsultant: usersOrderBy
  assignedDate: OrderBy
  consultantId: OrderBy
  createdAt: OrderBy
  id: OrderBy
  isBackup: OrderBy
  originalConsultant: usersOrderBy
  originalConsultantId: OrderBy
  payrollAssignmentAuditsAggregate: payrollAssignmentAuditsAggregateOrderBy
  payrollDate: payrollDatesOrderBy
  payrollDateId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_assignments"""
input payrollAssignmentsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_assignments"
"""
enum payrollAssignmentsSelectColumn {
  """column name"""
  assignedBy
  """column name"""
  assignedDate
  """column name"""
  consultantId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  isBackup
  """column name"""
  originalConsultantId
  """column name"""
  payrollDateId
  """column name"""
  updatedAt
}

"""
select "payrollAssignmentsAggregateBoolExpBool_andArgumentsColumns" columns of table "payroll_assignments"
"""
enum payrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isBackup
}

"""
select "payrollAssignmentsAggregateBoolExpBool_orArgumentsColumns" columns of table "payroll_assignments"
"""
enum payrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isBackup
}

"""
input type for updating data in table "payroll_assignments"
"""
input payrollAssignmentsSetInput {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payrollAssignments"
"""
input payrollAssignmentsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollAssignmentsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollAssignmentsStreamCursorValueInput {
  assignedBy: uuid
  assignedDate: timestamptz
  consultantId: uuid
  createdAt: timestamptz
  id: uuid
  isBackup: Boolean
  originalConsultantId: uuid
  payrollDateId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "payroll_assignments"
"""
enum payrollAssignmentsUpdateColumn {
  """column name"""
  assignedBy
  """column name"""
  assignedDate
  """column name"""
  consultantId
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  isBackup
  """column name"""
  originalConsultantId
  """column name"""
  payrollDateId
  """column name"""
  updatedAt
}

input payrollAssignmentsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: payrollAssignmentsSetInput
  """filter the rows which have to be updated"""
  where: payrollAssignmentsBoolExp!
}

"""
columns and relationships of "payroll_cycles"
"""
type payrollCycles {
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): [adjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): adjustmentRulesAggregate!
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid!
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_cycles"
"""
type payrollCyclesAggregate {
  aggregate: payrollCyclesAggregateFields
  nodes: [payrollCycles!]!
}

"""
aggregate fields of "payroll_cycles"
"""
type payrollCyclesAggregateFields {
  count(columns: [payrollCyclesSelectColumn!], distinct: Boolean): Int!
  max: payrollCyclesMaxFields
  min: payrollCyclesMinFields
}

"""
Boolean expression to filter rows from the table "payroll_cycles". All fields are combined with a logical 'AND'.
"""
input payrollCyclesBoolExp {
  _and: [payrollCyclesBoolExp!]
  _not: payrollCyclesBoolExp
  _or: [payrollCyclesBoolExp!]
  adjustmentRules: adjustmentRulesBoolExp
  adjustmentRulesAggregate: adjustmentRulesAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: PayrollCycleTypeComparisonExp
  payrolls: payrollsBoolExp
  payrollsAggregate: payrollsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_cycles"
"""
enum payrollCyclesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_cycles_name_key
  """
  unique or primary key constraint on columns "id"
  """
  payroll_cycles_pkey
}

"""
input type for inserting data into table "payroll_cycles"
"""
input payrollCyclesInsertInput {
  adjustmentRules: adjustmentRulesArrRelInsertInput
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  payrolls: payrollsArrRelInsertInput
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type payrollCyclesMaxFields {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type payrollCyclesMinFields {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "payroll_cycles"
"""
type payrollCyclesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollCycles!]!
}

"""
input type for inserting object relation for remote table "payroll_cycles"
"""
input payrollCyclesObjRelInsertInput {
  data: payrollCyclesInsertInput!
  """upsert condition"""
  onConflict: payrollCyclesOnConflict
}

"""
on_conflict condition type for table "payroll_cycles"
"""
input payrollCyclesOnConflict {
  constraint: payrollCyclesConstraint!
  updateColumns: [payrollCyclesUpdateColumn!]! = []
  where: payrollCyclesBoolExp
}

"""Ordering options when selecting data from "payroll_cycles"."""
input payrollCyclesOrderBy {
  adjustmentRulesAggregate: adjustmentRulesAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  payrollsAggregate: payrollsAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_cycles"""
input payrollCyclesPkColumnsInput {
  """Unique identifier for the payroll cycle"""
  id: uuid!
}

"""
select columns of table "payroll_cycles"
"""
enum payrollCyclesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
input type for updating data in table "payroll_cycles"
"""
input payrollCyclesSetInput {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payrollCycles"
"""
input payrollCyclesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollCyclesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollCyclesStreamCursorValueInput {
  """Timestamp when the cycle was created"""
  createdAt: timestamptz
  """Detailed description of the payroll cycle"""
  description: String
  """Unique identifier for the payroll cycle"""
  id: uuid
  """Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.)"""
  name: payroll_cycle_type
  """Timestamp when the cycle was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "payroll_cycles"
"""
enum payrollCyclesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input payrollCyclesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: payrollCyclesSetInput
  """filter the rows which have to be updated"""
  where: payrollCyclesBoolExp!
}

"""
columns and relationships of "payroll_dashboard_stats"
"""
type payrollDashboardStats {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""
aggregated selection of "payroll_dashboard_stats"
"""
type payrollDashboardStatsAggregate {
  aggregate: payrollDashboardStatsAggregateFields
  nodes: [payrollDashboardStats!]!
}

"""
aggregate fields of "payroll_dashboard_stats"
"""
type payrollDashboardStatsAggregateFields {
  avg: payrollDashboardStatsAvgFields
  count(columns: [payrollDashboardStatsSelectColumn!], distinct: Boolean): Int!
  max: payrollDashboardStatsMaxFields
  min: payrollDashboardStatsMinFields
  stddev: payrollDashboardStatsStddevFields
  stddevPop: payrollDashboardStatsStddevPopFields
  stddevSamp: payrollDashboardStatsStddevSampFields
  sum: payrollDashboardStatsSumFields
  varPop: payrollDashboardStatsVarPopFields
  varSamp: payrollDashboardStatsVarSampFields
  variance: payrollDashboardStatsVarianceFields
}

"""aggregate avg on columns"""
type payrollDashboardStatsAvgFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""
Boolean expression to filter rows from the table "payroll_dashboard_stats". All fields are combined with a logical 'AND'.
"""
input payrollDashboardStatsBoolExp {
  _and: [payrollDashboardStatsBoolExp!]
  _not: payrollDashboardStatsBoolExp
  _or: [payrollDashboardStatsBoolExp!]
  backupConsultantUserId: UuidComparisonExp
  clientName: StringComparisonExp
  cycleName: PayrollCycleTypeComparisonExp
  futureDates: BigintComparisonExp
  id: UuidComparisonExp
  managerUserId: UuidComparisonExp
  name: StringComparisonExp
  nextEftDate: DateComparisonExp
  pastDates: BigintComparisonExp
  primaryConsultantUserId: UuidComparisonExp
  status: PayrollStatusComparisonExp
  totalDates: BigintComparisonExp
}

"""aggregate max on columns"""
type payrollDashboardStatsMaxFields {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""aggregate min on columns"""
type payrollDashboardStatsMinFields {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""Ordering options when selecting data from "payroll_dashboard_stats"."""
input payrollDashboardStatsOrderBy {
  backupConsultantUserId: OrderBy
  clientName: OrderBy
  cycleName: OrderBy
  futureDates: OrderBy
  id: OrderBy
  managerUserId: OrderBy
  name: OrderBy
  nextEftDate: OrderBy
  pastDates: OrderBy
  primaryConsultantUserId: OrderBy
  status: OrderBy
  totalDates: OrderBy
}

"""
select columns of table "payroll_dashboard_stats"
"""
enum payrollDashboardStatsSelectColumn {
  """column name"""
  backupConsultantUserId
  """column name"""
  clientName
  """column name"""
  cycleName
  """column name"""
  futureDates
  """column name"""
  id
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  nextEftDate
  """column name"""
  pastDates
  """column name"""
  primaryConsultantUserId
  """column name"""
  status
  """column name"""
  totalDates
}

"""aggregate stddev on columns"""
type payrollDashboardStatsStddevFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate stddevPop on columns"""
type payrollDashboardStatsStddevPopFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate stddevSamp on columns"""
type payrollDashboardStatsStddevSampFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""
Streaming cursor of the table "payrollDashboardStats"
"""
input payrollDashboardStatsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollDashboardStatsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollDashboardStatsStreamCursorValueInput {
  backupConsultantUserId: uuid
  clientName: String
  cycleName: payroll_cycle_type
  futureDates: bigint
  id: uuid
  managerUserId: uuid
  name: String
  nextEftDate: date
  pastDates: bigint
  primaryConsultantUserId: uuid
  status: payroll_status
  totalDates: bigint
}

"""aggregate sum on columns"""
type payrollDashboardStatsSumFields {
  futureDates: bigint
  pastDates: bigint
  totalDates: bigint
}

"""aggregate varPop on columns"""
type payrollDashboardStatsVarPopFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate varSamp on columns"""
type payrollDashboardStatsVarSampFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""aggregate variance on columns"""
type payrollDashboardStatsVarianceFields {
  futureDates: Float
  pastDates: Float
  totalDates: Float
}

"""
columns and relationships of "payroll_date_types"
"""
type payrollDateTypes {
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): [adjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): adjustmentRulesAggregate!
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid!
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_date_types"
"""
type payrollDateTypesAggregate {
  aggregate: payrollDateTypesAggregateFields
  nodes: [payrollDateTypes!]!
}

"""
aggregate fields of "payroll_date_types"
"""
type payrollDateTypesAggregateFields {
  count(columns: [payrollDateTypesSelectColumn!], distinct: Boolean): Int!
  max: payrollDateTypesMaxFields
  min: payrollDateTypesMinFields
}

"""
Boolean expression to filter rows from the table "payroll_date_types". All fields are combined with a logical 'AND'.
"""
input payrollDateTypesBoolExp {
  _and: [payrollDateTypesBoolExp!]
  _not: payrollDateTypesBoolExp
  _or: [payrollDateTypesBoolExp!]
  adjustmentRules: adjustmentRulesBoolExp
  adjustmentRulesAggregate: adjustmentRulesAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: PayrollDateTypeComparisonExp
  payrolls: payrollsBoolExp
  payrollsAggregate: payrollsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_date_types"
"""
enum payrollDateTypesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  payroll_date_types_name_key
  """
  unique or primary key constraint on columns "id"
  """
  payroll_date_types_pkey
}

"""
input type for inserting data into table "payroll_date_types"
"""
input payrollDateTypesInsertInput {
  adjustmentRules: adjustmentRulesArrRelInsertInput
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  payrolls: payrollsArrRelInsertInput
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type payrollDateTypesMaxFields {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type payrollDateTypesMinFields {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
response of any mutation on the table "payroll_date_types"
"""
type payrollDateTypesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollDateTypes!]!
}

"""
input type for inserting object relation for remote table "payroll_date_types"
"""
input payrollDateTypesObjRelInsertInput {
  data: payrollDateTypesInsertInput!
  """upsert condition"""
  onConflict: payrollDateTypesOnConflict
}

"""
on_conflict condition type for table "payroll_date_types"
"""
input payrollDateTypesOnConflict {
  constraint: payrollDateTypesConstraint!
  updateColumns: [payrollDateTypesUpdateColumn!]! = []
  where: payrollDateTypesBoolExp
}

"""Ordering options when selecting data from "payroll_date_types"."""
input payrollDateTypesOrderBy {
  adjustmentRulesAggregate: adjustmentRulesAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  payrollsAggregate: payrollsAggregateOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_date_types"""
input payrollDateTypesPkColumnsInput {
  """Unique identifier for the payroll date type"""
  id: uuid!
}

"""
select columns of table "payroll_date_types"
"""
enum payrollDateTypesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
input type for updating data in table "payroll_date_types"
"""
input payrollDateTypesSetInput {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payrollDateTypes"
"""
input payrollDateTypesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollDateTypesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollDateTypesStreamCursorValueInput {
  """Timestamp when the date type was created"""
  createdAt: timestamptz
  """Detailed description of how this date type works"""
  description: String
  """Unique identifier for the payroll date type"""
  id: uuid
  """Name of the date type (Fixed, Last Working Day, etc.)"""
  name: payroll_date_type
  """Timestamp when the date type was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "payroll_date_types"
"""
enum payrollDateTypesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input payrollDateTypesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: payrollDateTypesSetInput
  """filter the rows which have to be updated"""
  where: payrollDateTypesBoolExp!
}

"""
columns and relationships of "payroll_dates"
"""
type payrollDates {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date!
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid!
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date!
  """An object relationship"""
  payrollAssignment: payrollAssignments
  """An array relationship"""
  payrollAssignmentAudits(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """An aggregate relationship"""
  payrollAssignmentAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): payrollAssignmentAuditsAggregate!
  """Reference to the payroll this date belongs to"""
  payrollId: uuid!
  """Date when payroll processing must be completed"""
  processingDate: date!
  """An object relationship"""
  relatedPayroll: payrolls!
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
aggregated selection of "payroll_dates"
"""
type payrollDatesAggregate {
  aggregate: payrollDatesAggregateFields
  nodes: [payrollDates!]!
}

input payrollDatesAggregateBoolExp {
  count: payrollDatesAggregateBoolExpCount
}

input payrollDatesAggregateBoolExpCount {
  arguments: [payrollDatesSelectColumn!]
  distinct: Boolean
  filter: payrollDatesBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "payroll_dates"
"""
type payrollDatesAggregateFields {
  count(columns: [payrollDatesSelectColumn!], distinct: Boolean): Int!
  max: payrollDatesMaxFields
  min: payrollDatesMinFields
}

"""
order by aggregate values of table "payroll_dates"
"""
input payrollDatesAggregateOrderBy {
  count: OrderBy
  max: payrollDatesMaxOrderBy
  min: payrollDatesMinOrderBy
}

"""
input type for inserting array relation for remote table "payroll_dates"
"""
input payrollDatesArrRelInsertInput {
  data: [payrollDatesInsertInput!]!
  """upsert condition"""
  onConflict: payrollDatesOnConflict
}

"""
Boolean expression to filter rows from the table "payroll_dates". All fields are combined with a logical 'AND'.
"""
input payrollDatesBoolExp {
  _and: [payrollDatesBoolExp!]
  _not: payrollDatesBoolExp
  _or: [payrollDatesBoolExp!]
  adjustedEftDate: DateComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  notes: StringComparisonExp
  originalEftDate: DateComparisonExp
  payrollAssignment: payrollAssignmentsBoolExp
  payrollAssignmentAudits: payrollAssignmentAuditsBoolExp
  payrollAssignmentAuditsAggregate: payrollAssignmentAuditsAggregateBoolExp
  payrollId: UuidComparisonExp
  processingDate: DateComparisonExp
  relatedPayroll: payrollsBoolExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "payroll_dates"
"""
enum payrollDatesConstraint {
  """
  unique or primary key constraint on columns "original_eft_date", "payroll_id"
  """
  idx_unique_payroll_date
  """
  unique or primary key constraint on columns "id"
  """
  payroll_dates_pkey
}

"""
input type for inserting data into table "payroll_dates"
"""
input payrollDatesInsertInput {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  payrollAssignment: payrollAssignmentsObjRelInsertInput
  payrollAssignmentAudits: payrollAssignmentAuditsArrRelInsertInput
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  relatedPayroll: payrollsObjRelInsertInput
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type payrollDatesMaxFields {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
order by max() on columns of table "payroll_dates"
"""
input payrollDatesMaxOrderBy {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: OrderBy
  """Timestamp when the date record was created"""
  createdAt: OrderBy
  """Unique identifier for the payroll date"""
  id: OrderBy
  """Additional notes about this payroll date"""
  notes: OrderBy
  """Originally calculated EFT date before adjustments"""
  originalEftDate: OrderBy
  """Reference to the payroll this date belongs to"""
  payrollId: OrderBy
  """Date when payroll processing must be completed"""
  processingDate: OrderBy
  """Timestamp when the date record was last updated"""
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type payrollDatesMinFields {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
order by min() on columns of table "payroll_dates"
"""
input payrollDatesMinOrderBy {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: OrderBy
  """Timestamp when the date record was created"""
  createdAt: OrderBy
  """Unique identifier for the payroll date"""
  id: OrderBy
  """Additional notes about this payroll date"""
  notes: OrderBy
  """Originally calculated EFT date before adjustments"""
  originalEftDate: OrderBy
  """Reference to the payroll this date belongs to"""
  payrollId: OrderBy
  """Date when payroll processing must be completed"""
  processingDate: OrderBy
  """Timestamp when the date record was last updated"""
  updatedAt: OrderBy
}

"""
response of any mutation on the table "payroll_dates"
"""
type payrollDatesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollDates!]!
}

"""
input type for inserting object relation for remote table "payroll_dates"
"""
input payrollDatesObjRelInsertInput {
  data: payrollDatesInsertInput!
  """upsert condition"""
  onConflict: payrollDatesOnConflict
}

"""
on_conflict condition type for table "payroll_dates"
"""
input payrollDatesOnConflict {
  constraint: payrollDatesConstraint!
  updateColumns: [payrollDatesUpdateColumn!]! = []
  where: payrollDatesBoolExp
}

"""Ordering options when selecting data from "payroll_dates"."""
input payrollDatesOrderBy {
  adjustedEftDate: OrderBy
  createdAt: OrderBy
  id: OrderBy
  notes: OrderBy
  originalEftDate: OrderBy
  payrollAssignment: payrollAssignmentsOrderBy
  payrollAssignmentAuditsAggregate: payrollAssignmentAuditsAggregateOrderBy
  payrollId: OrderBy
  processingDate: OrderBy
  relatedPayroll: payrollsOrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: payroll_dates"""
input payrollDatesPkColumnsInput {
  """Unique identifier for the payroll date"""
  id: uuid!
}

"""
select columns of table "payroll_dates"
"""
enum payrollDatesSelectColumn {
  """column name"""
  adjustedEftDate
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  originalEftDate
  """column name"""
  payrollId
  """column name"""
  processingDate
  """column name"""
  updatedAt
}

"""
input type for updating data in table "payroll_dates"
"""
input payrollDatesSetInput {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "payrollDates"
"""
input payrollDatesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollDatesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollDatesStreamCursorValueInput {
  """Final EFT date after holiday and weekend adjustments"""
  adjustedEftDate: date
  """Timestamp when the date record was created"""
  createdAt: timestamptz
  """Unique identifier for the payroll date"""
  id: uuid
  """Additional notes about this payroll date"""
  notes: String
  """Originally calculated EFT date before adjustments"""
  originalEftDate: date
  """Reference to the payroll this date belongs to"""
  payrollId: uuid
  """Date when payroll processing must be completed"""
  processingDate: date
  """Timestamp when the date record was last updated"""
  updatedAt: timestamptz
}

"""
update columns of table "payroll_dates"
"""
enum payrollDatesUpdateColumn {
  """column name"""
  adjustedEftDate
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  notes
  """column name"""
  originalEftDate
  """column name"""
  payrollId
  """column name"""
  processingDate
  """column name"""
  updatedAt
}

input payrollDatesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: payrollDatesSetInput
  """filter the rows which have to be updated"""
  where: payrollDatesBoolExp!
}

"""
columns and relationships of "payroll_triggers_status"
"""
type payrollTriggersStatus {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
  eventObjectTable: name
  triggerName: name
}

"""
aggregated selection of "payroll_triggers_status"
"""
type payrollTriggersStatusAggregate {
  aggregate: payrollTriggersStatusAggregateFields
  nodes: [payrollTriggersStatus!]!
}

"""
aggregate fields of "payroll_triggers_status"
"""
type payrollTriggersStatusAggregateFields {
  count(columns: [payrollTriggersStatusSelectColumn!], distinct: Boolean): Int!
  max: payrollTriggersStatusMaxFields
  min: payrollTriggersStatusMinFields
}

"""
Boolean expression to filter rows from the table "payroll_triggers_status". All fields are combined with a logical 'AND'.
"""
input payrollTriggersStatusBoolExp {
  _and: [payrollTriggersStatusBoolExp!]
  _not: payrollTriggersStatusBoolExp
  _or: [payrollTriggersStatusBoolExp!]
  actionStatement: StringComparisonExp
  actionTiming: StringComparisonExp
  eventManipulation: StringComparisonExp
  eventObjectTable: NameComparisonExp
  triggerName: NameComparisonExp
}

"""aggregate max on columns"""
type payrollTriggersStatusMaxFields {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
}

"""aggregate min on columns"""
type payrollTriggersStatusMinFields {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
}

"""Ordering options when selecting data from "payroll_triggers_status"."""
input payrollTriggersStatusOrderBy {
  actionStatement: OrderBy
  actionTiming: OrderBy
  eventManipulation: OrderBy
  eventObjectTable: OrderBy
  triggerName: OrderBy
}

"""
select columns of table "payroll_triggers_status"
"""
enum payrollTriggersStatusSelectColumn {
  """column name"""
  actionStatement
  """column name"""
  actionTiming
  """column name"""
  eventManipulation
  """column name"""
  eventObjectTable
  """column name"""
  triggerName
}

"""
Streaming cursor of the table "payrollTriggersStatus"
"""
input payrollTriggersStatusStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollTriggersStatusStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollTriggersStatusStreamCursorValueInput {
  actionStatement: String
  actionTiming: String
  eventManipulation: String
  eventObjectTable: name
  triggerName: name
}

"""
columns and relationships of "payroll_version_history_results"
"""
type payrollVersionHistoryResults {
  active: Boolean!
  goLiveDate: date
  id: uuid!
  isCurrent: Boolean!
  name: String!
  payrollId: uuid!
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int!
  versionReason: String
}

type payrollVersionHistoryResultsAggregate {
  aggregate: payrollVersionHistoryResultsAggregateFields
  nodes: [payrollVersionHistoryResults!]!
}

"""
aggregate fields of "payroll_version_history_results"
"""
type payrollVersionHistoryResultsAggregateFields {
  avg: payrollVersionHistoryResultsAvgFields
  count(columns: [payrollVersionHistoryResultsSelectColumn!], distinct: Boolean): Int!
  max: payrollVersionHistoryResultsMaxFields
  min: payrollVersionHistoryResultsMinFields
  stddev: payrollVersionHistoryResultsStddevFields
  stddevPop: payrollVersionHistoryResultsStddevPopFields
  stddevSamp: payrollVersionHistoryResultsStddevSampFields
  sum: payrollVersionHistoryResultsSumFields
  varPop: payrollVersionHistoryResultsVarPopFields
  varSamp: payrollVersionHistoryResultsVarSampFields
  variance: payrollVersionHistoryResultsVarianceFields
}

"""aggregate avg on columns"""
type payrollVersionHistoryResultsAvgFields {
  versionNumber: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_history_results". All fields are combined with a logical 'AND'.
"""
input payrollVersionHistoryResultsBoolExp {
  _and: [payrollVersionHistoryResultsBoolExp!]
  _not: payrollVersionHistoryResultsBoolExp
  _or: [payrollVersionHistoryResultsBoolExp!]
  active: BooleanComparisonExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  isCurrent: BooleanComparisonExp
  name: StringComparisonExp
  payrollId: UuidComparisonExp
  queriedAt: TimestamptzComparisonExp
  supersededDate: DateComparisonExp
  versionNumber: IntComparisonExp
  versionReason: StringComparisonExp
}

"""
unique or primary key constraints on table "payroll_version_history_results"
"""
enum payrollVersionHistoryResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_history_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_history_results"
"""
input payrollVersionHistoryResultsIncInput {
  versionNumber: Int
}

"""
input type for inserting data into table "payroll_version_history_results"
"""
input payrollVersionHistoryResultsInsertInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  isCurrent: Boolean
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate max on columns"""
type payrollVersionHistoryResultsMaxFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate min on columns"""
type payrollVersionHistoryResultsMinFields {
  goLiveDate: date
  id: uuid
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""
response of any mutation on the table "payroll_version_history_results"
"""
type payrollVersionHistoryResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollVersionHistoryResults!]!
}

"""
on_conflict condition type for table "payroll_version_history_results"
"""
input payrollVersionHistoryResultsOnConflict {
  constraint: payrollVersionHistoryResultsConstraint!
  updateColumns: [payrollVersionHistoryResultsUpdateColumn!]! = []
  where: payrollVersionHistoryResultsBoolExp
}

"""
Ordering options when selecting data from "payroll_version_history_results".
"""
input payrollVersionHistoryResultsOrderBy {
  active: OrderBy
  goLiveDate: OrderBy
  id: OrderBy
  isCurrent: OrderBy
  name: OrderBy
  payrollId: OrderBy
  queriedAt: OrderBy
  supersededDate: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""primary key columns input for table: payroll_version_history_results"""
input payrollVersionHistoryResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_version_history_results"
"""
enum payrollVersionHistoryResultsSelectColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  isCurrent
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  supersededDate
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

"""
input type for updating data in table "payroll_version_history_results"
"""
input payrollVersionHistoryResultsSetInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  isCurrent: Boolean
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate stddev on columns"""
type payrollVersionHistoryResultsStddevFields {
  versionNumber: Float
}

"""aggregate stddevPop on columns"""
type payrollVersionHistoryResultsStddevPopFields {
  versionNumber: Float
}

"""aggregate stddevSamp on columns"""
type payrollVersionHistoryResultsStddevSampFields {
  versionNumber: Float
}

"""
Streaming cursor of the table "payrollVersionHistoryResults"
"""
input payrollVersionHistoryResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollVersionHistoryResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollVersionHistoryResultsStreamCursorValueInput {
  active: Boolean
  goLiveDate: date
  id: uuid
  isCurrent: Boolean
  name: String
  payrollId: uuid
  queriedAt: timestamptz
  supersededDate: date
  versionNumber: Int
  versionReason: String
}

"""aggregate sum on columns"""
type payrollVersionHistoryResultsSumFields {
  versionNumber: Int
}

"""
update columns of table "payroll_version_history_results"
"""
enum payrollVersionHistoryResultsUpdateColumn {
  """column name"""
  active
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  isCurrent
  """column name"""
  name
  """column name"""
  payrollId
  """column name"""
  queriedAt
  """column name"""
  supersededDate
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

input payrollVersionHistoryResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payrollVersionHistoryResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: payrollVersionHistoryResultsSetInput
  """filter the rows which have to be updated"""
  where: payrollVersionHistoryResultsBoolExp!
}

"""aggregate varPop on columns"""
type payrollVersionHistoryResultsVarPopFields {
  versionNumber: Float
}

"""aggregate varSamp on columns"""
type payrollVersionHistoryResultsVarSampFields {
  versionNumber: Float
}

"""aggregate variance on columns"""
type payrollVersionHistoryResultsVarianceFields {
  versionNumber: Float
}

"""
columns and relationships of "payroll_version_results"
"""
type payrollVersionResults {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int!
  id: uuid!
  message: String!
  newPayrollId: uuid!
  newVersionNumber: Int!
  oldPayrollId: uuid!
}

type payrollVersionResultsAggregate {
  aggregate: payrollVersionResultsAggregateFields
  nodes: [payrollVersionResults!]!
}

"""
aggregate fields of "payroll_version_results"
"""
type payrollVersionResultsAggregateFields {
  avg: payrollVersionResultsAvgFields
  count(columns: [payrollVersionResultsSelectColumn!], distinct: Boolean): Int!
  max: payrollVersionResultsMaxFields
  min: payrollVersionResultsMinFields
  stddev: payrollVersionResultsStddevFields
  stddevPop: payrollVersionResultsStddevPopFields
  stddevSamp: payrollVersionResultsStddevSampFields
  sum: payrollVersionResultsSumFields
  varPop: payrollVersionResultsVarPopFields
  varSamp: payrollVersionResultsVarSampFields
  variance: payrollVersionResultsVarianceFields
}

"""aggregate avg on columns"""
type payrollVersionResultsAvgFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""
Boolean expression to filter rows from the table "payroll_version_results". All fields are combined with a logical 'AND'.
"""
input payrollVersionResultsBoolExp {
  _and: [payrollVersionResultsBoolExp!]
  _not: payrollVersionResultsBoolExp
  _or: [payrollVersionResultsBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdByUserId: UuidComparisonExp
  datesDeleted: IntComparisonExp
  id: UuidComparisonExp
  message: StringComparisonExp
  newPayrollId: UuidComparisonExp
  newVersionNumber: IntComparisonExp
  oldPayrollId: UuidComparisonExp
}

"""
unique or primary key constraints on table "payroll_version_results"
"""
enum payrollVersionResultsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  payroll_version_results_pkey
}

"""
input type for incrementing numeric columns in table "payroll_version_results"
"""
input payrollVersionResultsIncInput {
  datesDeleted: Int
  newVersionNumber: Int
}

"""
input type for inserting data into table "payroll_version_results"
"""
input payrollVersionResultsInsertInput {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate max on columns"""
type payrollVersionResultsMaxFields {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate min on columns"""
type payrollVersionResultsMinFields {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""
response of any mutation on the table "payroll_version_results"
"""
type payrollVersionResultsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrollVersionResults!]!
}

"""
on_conflict condition type for table "payroll_version_results"
"""
input payrollVersionResultsOnConflict {
  constraint: payrollVersionResultsConstraint!
  updateColumns: [payrollVersionResultsUpdateColumn!]! = []
  where: payrollVersionResultsBoolExp
}

"""Ordering options when selecting data from "payroll_version_results"."""
input payrollVersionResultsOrderBy {
  createdAt: OrderBy
  createdByUserId: OrderBy
  datesDeleted: OrderBy
  id: OrderBy
  message: OrderBy
  newPayrollId: OrderBy
  newVersionNumber: OrderBy
  oldPayrollId: OrderBy
}

"""primary key columns input for table: payroll_version_results"""
input payrollVersionResultsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "payroll_version_results"
"""
enum payrollVersionResultsSelectColumn {
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  datesDeleted
  """column name"""
  id
  """column name"""
  message
  """column name"""
  newPayrollId
  """column name"""
  newVersionNumber
  """column name"""
  oldPayrollId
}

"""
input type for updating data in table "payroll_version_results"
"""
input payrollVersionResultsSetInput {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate stddev on columns"""
type payrollVersionResultsStddevFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate stddevPop on columns"""
type payrollVersionResultsStddevPopFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate stddevSamp on columns"""
type payrollVersionResultsStddevSampFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""
Streaming cursor of the table "payrollVersionResults"
"""
input payrollVersionResultsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollVersionResultsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollVersionResultsStreamCursorValueInput {
  createdAt: timestamptz
  createdByUserId: uuid
  datesDeleted: Int
  id: uuid
  message: String
  newPayrollId: uuid
  newVersionNumber: Int
  oldPayrollId: uuid
}

"""aggregate sum on columns"""
type payrollVersionResultsSumFields {
  datesDeleted: Int
  newVersionNumber: Int
}

"""
update columns of table "payroll_version_results"
"""
enum payrollVersionResultsUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  datesDeleted
  """column name"""
  id
  """column name"""
  message
  """column name"""
  newPayrollId
  """column name"""
  newVersionNumber
  """column name"""
  oldPayrollId
}

input payrollVersionResultsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payrollVersionResultsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: payrollVersionResultsSetInput
  """filter the rows which have to be updated"""
  where: payrollVersionResultsBoolExp!
}

"""aggregate varPop on columns"""
type payrollVersionResultsVarPopFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate varSamp on columns"""
type payrollVersionResultsVarSampFields {
  datesDeleted: Float
  newVersionNumber: Float
}

"""aggregate variance on columns"""
type payrollVersionResultsVarianceFields {
  datesDeleted: Float
  newVersionNumber: Float
}

scalar payroll_cycle_type

scalar payroll_date_type

scalar payroll_status

"""
columns and relationships of "payrolls"
"""
type payrolls {
  """An object relationship"""
  backupConsultant: users
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): [billingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): billingItemsAggregate!
  """An array relationship"""
  childPayrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  childPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """An object relationship"""
  client: clients!
  """Reference to the client this payroll belongs to"""
  clientId: uuid!
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid!
  """Reference to the payroll date type"""
  dateTypeId: uuid!
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid!
  """An object relationship"""
  manager: users
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String!
  """An object relationship"""
  parentPayroll: payrolls
  parentPayrollId: uuid
  """An object relationship"""
  payrollCycle: payrollCycles!
  """An object relationship"""
  payrollDateType: payrollDateTypes!
  """An array relationship"""
  payrollDates(
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): [payrollDates!]!
  """An aggregate relationship"""
  payrollDatesAggregate(
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): payrollDatesAggregate!
  """External payroll system used for this client"""
  payrollSystem: String
  """An object relationship"""
  primaryConsultant: users
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int!
  """Number of hours required to process this payroll"""
  processingTime: Int!
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status!
  supersededDate: date
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
aggregated selection of "payrolls"
"""
type payrollsAggregate {
  aggregate: payrollsAggregateFields
  nodes: [payrolls!]!
}

input payrollsAggregateBoolExp {
  count: payrollsAggregateBoolExpCount
}

input payrollsAggregateBoolExpCount {
  arguments: [payrollsSelectColumn!]
  distinct: Boolean
  filter: payrollsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "payrolls"
"""
type payrollsAggregateFields {
  avg: payrollsAvgFields
  count(columns: [payrollsSelectColumn!], distinct: Boolean): Int!
  max: payrollsMaxFields
  min: payrollsMinFields
  stddev: payrollsStddevFields
  stddevPop: payrollsStddevPopFields
  stddevSamp: payrollsStddevSampFields
  sum: payrollsSumFields
  varPop: payrollsVarPopFields
  varSamp: payrollsVarSampFields
  variance: payrollsVarianceFields
}

"""
order by aggregate values of table "payrolls"
"""
input payrollsAggregateOrderBy {
  avg: payrollsAvgOrderBy
  count: OrderBy
  max: payrollsMaxOrderBy
  min: payrollsMinOrderBy
  stddev: payrollsStddevOrderBy
  stddevPop: payrollsStddevPopOrderBy
  stddevSamp: payrollsStddevSampOrderBy
  sum: payrollsSumOrderBy
  varPop: payrollsVarPopOrderBy
  varSamp: payrollsVarSampOrderBy
  variance: payrollsVarianceOrderBy
}

"""
input type for inserting array relation for remote table "payrolls"
"""
input payrollsArrRelInsertInput {
  data: [payrollsInsertInput!]!
  """upsert condition"""
  onConflict: payrollsOnConflict
}

"""aggregate avg on columns"""
type payrollsAvgFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  versionNumber: Float
}

"""
order by avg() on columns of table "payrolls"
"""
input payrollsAvgOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""
Boolean expression to filter rows from the table "payrolls". All fields are combined with a logical 'AND'.
"""
input payrollsBoolExp {
  _and: [payrollsBoolExp!]
  _not: payrollsBoolExp
  _or: [payrollsBoolExp!]
  backupConsultant: usersBoolExp
  backupConsultantUserId: UuidComparisonExp
  billingItems: billingItemsBoolExp
  billingItemsAggregate: billingItemsAggregateBoolExp
  childPayrolls: payrollsBoolExp
  childPayrollsAggregate: payrollsAggregateBoolExp
  client: clientsBoolExp
  clientId: UuidComparisonExp
  createdAt: TimestamptzComparisonExp
  createdByUserId: UuidComparisonExp
  cycleId: UuidComparisonExp
  dateTypeId: UuidComparisonExp
  dateValue: IntComparisonExp
  employeeCount: IntComparisonExp
  goLiveDate: DateComparisonExp
  id: UuidComparisonExp
  manager: usersBoolExp
  managerUserId: UuidComparisonExp
  name: StringComparisonExp
  parentPayroll: payrollsBoolExp
  parentPayrollId: UuidComparisonExp
  payrollCycle: payrollCyclesBoolExp
  payrollDateType: payrollDateTypesBoolExp
  payrollDates: payrollDatesBoolExp
  payrollDatesAggregate: payrollDatesAggregateBoolExp
  payrollSystem: StringComparisonExp
  primaryConsultant: usersBoolExp
  primaryConsultantUserId: UuidComparisonExp
  processingDaysBeforeEft: IntComparisonExp
  processingTime: IntComparisonExp
  status: PayrollStatusComparisonExp
  supersededDate: DateComparisonExp
  updatedAt: TimestamptzComparisonExp
  versionNumber: IntComparisonExp
  versionReason: StringComparisonExp
}

"""
unique or primary key constraints on table "payrolls"
"""
enum payrollsConstraint {
  """unique or primary key constraint on columns """
  only_one_current_version_per_family
  """
  unique or primary key constraint on columns "id"
  """
  payrolls_pkey
}

"""
input type for incrementing numeric columns in table "payrolls"
"""
input payrollsIncInput {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  versionNumber: Int
}

"""
input type for inserting data into table "payrolls"
"""
input payrollsInsertInput {
  backupConsultant: usersObjRelInsertInput
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  billingItems: billingItemsArrRelInsertInput
  childPayrolls: payrollsArrRelInsertInput
  client: clientsObjRelInsertInput
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  manager: usersObjRelInsertInput
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  parentPayroll: payrollsObjRelInsertInput
  parentPayrollId: uuid
  payrollCycle: payrollCyclesObjRelInsertInput
  payrollDateType: payrollDateTypesObjRelInsertInput
  payrollDates: payrollDatesArrRelInsertInput
  """External payroll system used for this client"""
  payrollSystem: String
  primaryConsultant: usersObjRelInsertInput
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate max on columns"""
type payrollsMaxFields {
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
order by max() on columns of table "payrolls"
"""
input payrollsMaxOrderBy {
  """Backup consultant for this payroll"""
  backupConsultantUserId: OrderBy
  """Reference to the client this payroll belongs to"""
  clientId: OrderBy
  """Timestamp when the payroll was created"""
  createdAt: OrderBy
  createdByUserId: OrderBy
  """Reference to the payroll cycle"""
  cycleId: OrderBy
  """Reference to the payroll date type"""
  dateTypeId: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """The date when the payroll went live in the system"""
  goLiveDate: OrderBy
  """Unique identifier for the payroll"""
  id: OrderBy
  """Manager overseeing this payroll"""
  managerUserId: OrderBy
  """Name of the payroll"""
  name: OrderBy
  parentPayrollId: OrderBy
  """External payroll system used for this client"""
  payrollSystem: OrderBy
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: OrderBy
  supersededDate: OrderBy
  """Timestamp when the payroll was last updated"""
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""aggregate min on columns"""
type payrollsMinFields {
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""
order by min() on columns of table "payrolls"
"""
input payrollsMinOrderBy {
  """Backup consultant for this payroll"""
  backupConsultantUserId: OrderBy
  """Reference to the client this payroll belongs to"""
  clientId: OrderBy
  """Timestamp when the payroll was created"""
  createdAt: OrderBy
  createdByUserId: OrderBy
  """Reference to the payroll cycle"""
  cycleId: OrderBy
  """Reference to the payroll date type"""
  dateTypeId: OrderBy
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """The date when the payroll went live in the system"""
  goLiveDate: OrderBy
  """Unique identifier for the payroll"""
  id: OrderBy
  """Manager overseeing this payroll"""
  managerUserId: OrderBy
  """Name of the payroll"""
  name: OrderBy
  parentPayrollId: OrderBy
  """External payroll system used for this client"""
  payrollSystem: OrderBy
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: OrderBy
  supersededDate: OrderBy
  """Timestamp when the payroll was last updated"""
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""
response of any mutation on the table "payrolls"
"""
type payrollsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [payrolls!]!
}

"""
input type for inserting object relation for remote table "payrolls"
"""
input payrollsObjRelInsertInput {
  data: payrollsInsertInput!
  """upsert condition"""
  onConflict: payrollsOnConflict
}

"""
on_conflict condition type for table "payrolls"
"""
input payrollsOnConflict {
  constraint: payrollsConstraint!
  updateColumns: [payrollsUpdateColumn!]! = []
  where: payrollsBoolExp
}

"""Ordering options when selecting data from "payrolls"."""
input payrollsOrderBy {
  backupConsultant: usersOrderBy
  backupConsultantUserId: OrderBy
  billingItemsAggregate: billingItemsAggregateOrderBy
  childPayrollsAggregate: payrollsAggregateOrderBy
  client: clientsOrderBy
  clientId: OrderBy
  createdAt: OrderBy
  createdByUserId: OrderBy
  cycleId: OrderBy
  dateTypeId: OrderBy
  dateValue: OrderBy
  employeeCount: OrderBy
  goLiveDate: OrderBy
  id: OrderBy
  manager: usersOrderBy
  managerUserId: OrderBy
  name: OrderBy
  parentPayroll: payrollsOrderBy
  parentPayrollId: OrderBy
  payrollCycle: payrollCyclesOrderBy
  payrollDateType: payrollDateTypesOrderBy
  payrollDatesAggregate: payrollDatesAggregateOrderBy
  payrollSystem: OrderBy
  primaryConsultant: usersOrderBy
  primaryConsultantUserId: OrderBy
  processingDaysBeforeEft: OrderBy
  processingTime: OrderBy
  status: OrderBy
  supersededDate: OrderBy
  updatedAt: OrderBy
  versionNumber: OrderBy
  versionReason: OrderBy
}

"""primary key columns input for table: payrolls"""
input payrollsPkColumnsInput {
  """Unique identifier for the payroll"""
  id: uuid!
}

"""
select columns of table "payrolls"
"""
enum payrollsSelectColumn {
  """column name"""
  backupConsultantUserId
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  dateValue
  """column name"""
  employeeCount
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  parentPayrollId
  """column name"""
  payrollSystem
  """column name"""
  primaryConsultantUserId
  """column name"""
  processingDaysBeforeEft
  """column name"""
  processingTime
  """column name"""
  status
  """column name"""
  supersededDate
  """column name"""
  updatedAt
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

"""
input type for updating data in table "payrolls"
"""
input payrollsSetInput {
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate stddev on columns"""
type payrollsStddevFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  versionNumber: Float
}

"""
order by stddev() on columns of table "payrolls"
"""
input payrollsStddevOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""aggregate stddevPop on columns"""
type payrollsStddevPopFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  versionNumber: Float
}

"""
order by stddevPop() on columns of table "payrolls"
"""
input payrollsStddevPopOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""aggregate stddevSamp on columns"""
type payrollsStddevSampFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  versionNumber: Float
}

"""
order by stddevSamp() on columns of table "payrolls"
"""
input payrollsStddevSampOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""
Streaming cursor of the table "payrolls"
"""
input payrollsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: payrollsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input payrollsStreamCursorValueInput {
  """Backup consultant for this payroll"""
  backupConsultantUserId: uuid
  """Reference to the client this payroll belongs to"""
  clientId: uuid
  """Timestamp when the payroll was created"""
  createdAt: timestamptz
  createdByUserId: uuid
  """Reference to the payroll cycle"""
  cycleId: uuid
  """Reference to the payroll date type"""
  dateTypeId: uuid
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """The date when the payroll went live in the system"""
  goLiveDate: date
  """Unique identifier for the payroll"""
  id: uuid
  """Manager overseeing this payroll"""
  managerUserId: uuid
  """Name of the payroll"""
  name: String
  parentPayrollId: uuid
  """External payroll system used for this client"""
  payrollSystem: String
  """Primary consultant responsible for this payroll"""
  primaryConsultantUserId: uuid
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  """Current status of the payroll (Implementation, Active, Inactive)"""
  status: payroll_status
  supersededDate: date
  """Timestamp when the payroll was last updated"""
  updatedAt: timestamptz
  versionNumber: Int
  versionReason: String
}

"""aggregate sum on columns"""
type payrollsSumFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Int
  """Number of employees in this payroll"""
  employeeCount: Int
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Int
  """Number of hours required to process this payroll"""
  processingTime: Int
  versionNumber: Int
}

"""
order by sum() on columns of table "payrolls"
"""
input payrollsSumOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""
update columns of table "payrolls"
"""
enum payrollsUpdateColumn {
  """column name"""
  backupConsultantUserId
  """column name"""
  clientId
  """column name"""
  createdAt
  """column name"""
  createdByUserId
  """column name"""
  cycleId
  """column name"""
  dateTypeId
  """column name"""
  dateValue
  """column name"""
  employeeCount
  """column name"""
  goLiveDate
  """column name"""
  id
  """column name"""
  managerUserId
  """column name"""
  name
  """column name"""
  parentPayrollId
  """column name"""
  payrollSystem
  """column name"""
  primaryConsultantUserId
  """column name"""
  processingDaysBeforeEft
  """column name"""
  processingTime
  """column name"""
  status
  """column name"""
  supersededDate
  """column name"""
  updatedAt
  """column name"""
  versionNumber
  """column name"""
  versionReason
}

input payrollsUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: payrollsIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: payrollsSetInput
  """filter the rows which have to be updated"""
  where: payrollsBoolExp!
}

"""aggregate varPop on columns"""
type payrollsVarPopFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  versionNumber: Float
}

"""
order by varPop() on columns of table "payrolls"
"""
input payrollsVarPopOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""aggregate varSamp on columns"""
type payrollsVarSampFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  versionNumber: Float
}

"""
order by varSamp() on columns of table "payrolls"
"""
input payrollsVarSampOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""aggregate variance on columns"""
type payrollsVarianceFields {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: Float
  """Number of employees in this payroll"""
  employeeCount: Float
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: Float
  """Number of hours required to process this payroll"""
  processingTime: Float
  versionNumber: Float
}

"""
order by variance() on columns of table "payrolls"
"""
input payrollsVarianceOrderBy {
  """Specific value for date calculation (e.g., day of month)"""
  dateValue: OrderBy
  """Number of employees in this payroll"""
  employeeCount: OrderBy
  """Number of days before EFT that processing must complete"""
  processingDaysBeforeEft: OrderBy
  """Number of hours required to process this payroll"""
  processingTime: OrderBy
  versionNumber: OrderBy
}

"""Audit log for permission changes and access attempts"""
type permissionAuditLogs {
  action: String!
  createdAt: timestamptz!
  id: uuid!
  newValue(
    """JSON select path"""
    path: String
  ): jsonb
  operation: String!
  """An object relationship"""
  performedByUser: users
  previousValue(
    """JSON select path"""
    path: String
  ): jsonb
  reason: String
  resource: String!
  targetRole: String
  """An object relationship"""
  targetUser: users
  targetUserId: uuid
  timestamp: timestamptz!
  userId: uuid
}

"""
aggregated selection of "permission_audit_log"
"""
type permissionAuditLogsAggregate {
  aggregate: permissionAuditLogsAggregateFields
  nodes: [permissionAuditLogs!]!
}

input permissionAuditLogsAggregateBoolExp {
  count: permissionAuditLogsAggregateBoolExpCount
}

input permissionAuditLogsAggregateBoolExpCount {
  arguments: [permissionAuditLogsSelectColumn!]
  distinct: Boolean
  filter: permissionAuditLogsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "permission_audit_log"
"""
type permissionAuditLogsAggregateFields {
  count(columns: [permissionAuditLogsSelectColumn!], distinct: Boolean): Int!
  max: permissionAuditLogsMaxFields
  min: permissionAuditLogsMinFields
}

"""
order by aggregate values of table "permission_audit_log"
"""
input permissionAuditLogsAggregateOrderBy {
  count: OrderBy
  max: permissionAuditLogsMaxOrderBy
  min: permissionAuditLogsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input permissionAuditLogsAppendInput {
  newValue: jsonb
  previousValue: jsonb
}

"""
input type for inserting array relation for remote table "permission_audit_log"
"""
input permissionAuditLogsArrRelInsertInput {
  data: [permissionAuditLogsInsertInput!]!
  """upsert condition"""
  onConflict: permissionAuditLogsOnConflict
}

"""
Boolean expression to filter rows from the table "permission_audit_log". All fields are combined with a logical 'AND'.
"""
input permissionAuditLogsBoolExp {
  _and: [permissionAuditLogsBoolExp!]
  _not: permissionAuditLogsBoolExp
  _or: [permissionAuditLogsBoolExp!]
  action: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  newValue: JsonbComparisonExp
  operation: StringComparisonExp
  performedByUser: usersBoolExp
  previousValue: JsonbComparisonExp
  reason: StringComparisonExp
  resource: StringComparisonExp
  targetRole: StringComparisonExp
  targetUser: usersBoolExp
  targetUserId: UuidComparisonExp
  timestamp: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "permission_audit_log"
"""
enum permissionAuditLogsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_audit_log_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input permissionAuditLogsDeleteAtPathInput {
  newValue: [String!]
  previousValue: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input permissionAuditLogsDeleteElemInput {
  newValue: Int
  previousValue: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input permissionAuditLogsDeleteKeyInput {
  newValue: String
  previousValue: String
}

"""
input type for inserting data into table "permission_audit_log"
"""
input permissionAuditLogsInsertInput {
  action: String
  createdAt: timestamptz
  id: uuid
  newValue: jsonb
  operation: String
  performedByUser: usersObjRelInsertInput
  previousValue: jsonb
  reason: String
  resource: String
  targetRole: String
  targetUser: usersObjRelInsertInput
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type permissionAuditLogsMaxFields {
  action: String
  createdAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "permission_audit_log"
"""
input permissionAuditLogsMaxOrderBy {
  action: OrderBy
  createdAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  targetRole: OrderBy
  targetUserId: OrderBy
  timestamp: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type permissionAuditLogsMinFields {
  action: String
  createdAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "permission_audit_log"
"""
input permissionAuditLogsMinOrderBy {
  action: OrderBy
  createdAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  targetRole: OrderBy
  targetUserId: OrderBy
  timestamp: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "permission_audit_log"
"""
type permissionAuditLogsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [permissionAuditLogs!]!
}

"""
on_conflict condition type for table "permission_audit_log"
"""
input permissionAuditLogsOnConflict {
  constraint: permissionAuditLogsConstraint!
  updateColumns: [permissionAuditLogsUpdateColumn!]! = []
  where: permissionAuditLogsBoolExp
}

"""Ordering options when selecting data from "permission_audit_log"."""
input permissionAuditLogsOrderBy {
  action: OrderBy
  createdAt: OrderBy
  id: OrderBy
  newValue: OrderBy
  operation: OrderBy
  performedByUser: usersOrderBy
  previousValue: OrderBy
  reason: OrderBy
  resource: OrderBy
  targetRole: OrderBy
  targetUser: usersOrderBy
  targetUserId: OrderBy
  timestamp: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: permission_audit_log"""
input permissionAuditLogsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input permissionAuditLogsPrependInput {
  newValue: jsonb
  previousValue: jsonb
}

"""
select columns of table "permission_audit_log"
"""
enum permissionAuditLogsSelectColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  newValue
  """column name"""
  operation
  """column name"""
  previousValue
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  targetRole
  """column name"""
  targetUserId
  """column name"""
  timestamp
  """column name"""
  userId
}

"""
input type for updating data in table "permission_audit_log"
"""
input permissionAuditLogsSetInput {
  action: String
  createdAt: timestamptz
  id: uuid
  newValue: jsonb
  operation: String
  previousValue: jsonb
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "permissionAuditLogs"
"""
input permissionAuditLogsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: permissionAuditLogsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input permissionAuditLogsStreamCursorValueInput {
  action: String
  createdAt: timestamptz
  id: uuid
  newValue: jsonb
  operation: String
  previousValue: jsonb
  reason: String
  resource: String
  targetRole: String
  targetUserId: uuid
  timestamp: timestamptz
  userId: uuid
}

"""
update columns of table "permission_audit_log"
"""
enum permissionAuditLogsUpdateColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  newValue
  """column name"""
  operation
  """column name"""
  previousValue
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  targetRole
  """column name"""
  targetUserId
  """column name"""
  timestamp
  """column name"""
  userId
}

input permissionAuditLogsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: permissionAuditLogsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: permissionAuditLogsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: permissionAuditLogsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: permissionAuditLogsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: permissionAuditLogsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: permissionAuditLogsSetInput
  """filter the rows which have to be updated"""
  where: permissionAuditLogsBoolExp!
}

"""
columns and relationships of "audit.permission_changes"
"""
type permissionChanges {
  approvedByUserId: uuid
  changeType: String!
  changedAt: timestamptz!
  changedByUserId: uuid!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newPermissions(
    """JSON select path"""
    path: String
  ): jsonb
  oldPermissions(
    """JSON select path"""
    path: String
  ): jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
aggregated selection of "audit.permission_changes"
"""
type permissionChangesAggregate {
  aggregate: permissionChangesAggregateFields
  nodes: [permissionChanges!]!
}

"""
aggregate fields of "audit.permission_changes"
"""
type permissionChangesAggregateFields {
  count(columns: [permissionChangesSelectColumn!], distinct: Boolean): Int!
  max: permissionChangesMaxFields
  min: permissionChangesMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input permissionChangesAppendInput {
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
}

"""
Boolean expression to filter rows from the table "audit.permission_changes". All fields are combined with a logical 'AND'.
"""
input permissionChangesBoolExp {
  _and: [permissionChangesBoolExp!]
  _not: permissionChangesBoolExp
  _or: [permissionChangesBoolExp!]
  approvedByUserId: UuidComparisonExp
  changeType: StringComparisonExp
  changedAt: TimestamptzComparisonExp
  changedByUserId: UuidComparisonExp
  id: UuidComparisonExp
  metadata: JsonbComparisonExp
  newPermissions: JsonbComparisonExp
  oldPermissions: JsonbComparisonExp
  permissionType: StringComparisonExp
  reason: StringComparisonExp
  targetRoleId: UuidComparisonExp
  targetUserId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.permission_changes"
"""
enum permissionChangesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_changes_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input permissionChangesDeleteAtPathInput {
  metadata: [String!]
  newPermissions: [String!]
  oldPermissions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input permissionChangesDeleteElemInput {
  metadata: Int
  newPermissions: Int
  oldPermissions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input permissionChangesDeleteKeyInput {
  metadata: String
  newPermissions: String
  oldPermissions: String
}

"""
input type for inserting data into table "audit.permission_changes"
"""
input permissionChangesInsertInput {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""aggregate max on columns"""
type permissionChangesMaxFields {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""aggregate min on columns"""
type permissionChangesMinFields {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
response of any mutation on the table "audit.permission_changes"
"""
type permissionChangesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [permissionChanges!]!
}

"""
on_conflict condition type for table "audit.permission_changes"
"""
input permissionChangesOnConflict {
  constraint: permissionChangesConstraint!
  updateColumns: [permissionChangesUpdateColumn!]! = []
  where: permissionChangesBoolExp
}

"""Ordering options when selecting data from "audit.permission_changes"."""
input permissionChangesOrderBy {
  approvedByUserId: OrderBy
  changeType: OrderBy
  changedAt: OrderBy
  changedByUserId: OrderBy
  id: OrderBy
  metadata: OrderBy
  newPermissions: OrderBy
  oldPermissions: OrderBy
  permissionType: OrderBy
  reason: OrderBy
  targetRoleId: OrderBy
  targetUserId: OrderBy
}

"""primary key columns input for table: audit.permission_changes"""
input permissionChangesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input permissionChangesPrependInput {
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
}

"""
select columns of table "audit.permission_changes"
"""
enum permissionChangesSelectColumn {
  """column name"""
  approvedByUserId
  """column name"""
  changeType
  """column name"""
  changedAt
  """column name"""
  changedByUserId
  """column name"""
  id
  """column name"""
  metadata
  """column name"""
  newPermissions
  """column name"""
  oldPermissions
  """column name"""
  permissionType
  """column name"""
  reason
  """column name"""
  targetRoleId
  """column name"""
  targetUserId
}

"""
input type for updating data in table "audit.permission_changes"
"""
input permissionChangesSetInput {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
Streaming cursor of the table "permissionChanges"
"""
input permissionChangesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: permissionChangesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input permissionChangesStreamCursorValueInput {
  approvedByUserId: uuid
  changeType: String
  changedAt: timestamptz
  changedByUserId: uuid
  id: uuid
  metadata: jsonb
  newPermissions: jsonb
  oldPermissions: jsonb
  permissionType: String
  reason: String
  targetRoleId: uuid
  targetUserId: uuid
}

"""
update columns of table "audit.permission_changes"
"""
enum permissionChangesUpdateColumn {
  """column name"""
  approvedByUserId
  """column name"""
  changeType
  """column name"""
  changedAt
  """column name"""
  changedByUserId
  """column name"""
  id
  """column name"""
  metadata
  """column name"""
  newPermissions
  """column name"""
  oldPermissions
  """column name"""
  permissionType
  """column name"""
  reason
  """column name"""
  targetRoleId
  """column name"""
  targetUserId
}

input permissionChangesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: permissionChangesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: permissionChangesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: permissionChangesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: permissionChangesDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: permissionChangesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: permissionChangesSetInput
  """filter the rows which have to be updated"""
  where: permissionChangesBoolExp!
}

"""User-specific and role-specific permission overrides"""
type permissionOverrides {
  """JSON conditions for conditional permissions"""
  conditions(
    """JSON select path"""
    path: String
  ): jsonb
  createdAt: timestamptz!
  createdBy: uuid
  """An object relationship"""
  createdByUser: users
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean!
  id: uuid!
  operation: String!
  reason: String
  resource: String!
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  """An object relationship"""
  targetUser: users
  updatedAt: timestamptz!
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
aggregated selection of "permission_overrides"
"""
type permissionOverridesAggregate {
  aggregate: permissionOverridesAggregateFields
  nodes: [permissionOverrides!]!
}

input permissionOverridesAggregateBoolExp {
  bool_and: permissionOverridesAggregateBoolExpBool_and
  bool_or: permissionOverridesAggregateBoolExpBool_or
  count: permissionOverridesAggregateBoolExpCount
}

input permissionOverridesAggregateBoolExpBool_and {
  arguments: permissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: permissionOverridesBoolExp
  predicate: BooleanComparisonExp!
}

input permissionOverridesAggregateBoolExpBool_or {
  arguments: permissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: permissionOverridesBoolExp
  predicate: BooleanComparisonExp!
}

input permissionOverridesAggregateBoolExpCount {
  arguments: [permissionOverridesSelectColumn!]
  distinct: Boolean
  filter: permissionOverridesBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "permission_overrides"
"""
type permissionOverridesAggregateFields {
  count(columns: [permissionOverridesSelectColumn!], distinct: Boolean): Int!
  max: permissionOverridesMaxFields
  min: permissionOverridesMinFields
}

"""
order by aggregate values of table "permission_overrides"
"""
input permissionOverridesAggregateOrderBy {
  count: OrderBy
  max: permissionOverridesMaxOrderBy
  min: permissionOverridesMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input permissionOverridesAppendInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
}

"""
input type for inserting array relation for remote table "permission_overrides"
"""
input permissionOverridesArrRelInsertInput {
  data: [permissionOverridesInsertInput!]!
  """upsert condition"""
  onConflict: permissionOverridesOnConflict
}

"""
Boolean expression to filter rows from the table "permission_overrides". All fields are combined with a logical 'AND'.
"""
input permissionOverridesBoolExp {
  _and: [permissionOverridesBoolExp!]
  _not: permissionOverridesBoolExp
  _or: [permissionOverridesBoolExp!]
  conditions: JsonbComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UuidComparisonExp
  createdByUser: usersBoolExp
  expiresAt: TimestamptzComparisonExp
  granted: BooleanComparisonExp
  id: UuidComparisonExp
  operation: StringComparisonExp
  reason: StringComparisonExp
  resource: StringComparisonExp
  role: StringComparisonExp
  targetUser: usersBoolExp
  updatedAt: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "permission_overrides"
"""
enum permissionOverridesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permission_overrides_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input permissionOverridesDeleteAtPathInput {
  """JSON conditions for conditional permissions"""
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input permissionOverridesDeleteElemInput {
  """JSON conditions for conditional permissions"""
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input permissionOverridesDeleteKeyInput {
  """JSON conditions for conditional permissions"""
  conditions: String
}

"""
input type for inserting data into table "permission_overrides"
"""
input permissionOverridesInsertInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  createdByUser: usersObjRelInsertInput
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  targetUser: usersObjRelInsertInput
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""aggregate max on columns"""
type permissionOverridesMaxFields {
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
order by max() on columns of table "permission_overrides"
"""
input permissionOverridesMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  """When this override expires (NULL for permanent)"""
  expiresAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: OrderBy
  updatedAt: OrderBy
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: OrderBy
}

"""aggregate min on columns"""
type permissionOverridesMinFields {
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
order by min() on columns of table "permission_overrides"
"""
input permissionOverridesMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  """When this override expires (NULL for permanent)"""
  expiresAt: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: OrderBy
  updatedAt: OrderBy
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: OrderBy
}

"""
response of any mutation on the table "permission_overrides"
"""
type permissionOverridesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [permissionOverrides!]!
}

"""
on_conflict condition type for table "permission_overrides"
"""
input permissionOverridesOnConflict {
  constraint: permissionOverridesConstraint!
  updateColumns: [permissionOverridesUpdateColumn!]! = []
  where: permissionOverridesBoolExp
}

"""Ordering options when selecting data from "permission_overrides"."""
input permissionOverridesOrderBy {
  conditions: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  createdByUser: usersOrderBy
  expiresAt: OrderBy
  granted: OrderBy
  id: OrderBy
  operation: OrderBy
  reason: OrderBy
  resource: OrderBy
  role: OrderBy
  targetUser: usersOrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: permission_overrides"""
input permissionOverridesPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input permissionOverridesPrependInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
}

"""
select columns of table "permission_overrides"
"""
enum permissionOverridesSelectColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  expiresAt
  """column name"""
  granted
  """column name"""
  id
  """column name"""
  operation
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  role
  """column name"""
  updatedAt
  """column name"""
  userId
}

"""
select "permissionOverridesAggregateBoolExpBool_andArgumentsColumns" columns of table "permission_overrides"
"""
enum permissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  granted
}

"""
select "permissionOverridesAggregateBoolExpBool_orArgumentsColumns" columns of table "permission_overrides"
"""
enum permissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  granted
}

"""
input type for updating data in table "permission_overrides"
"""
input permissionOverridesSetInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
Streaming cursor of the table "permissionOverrides"
"""
input permissionOverridesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: permissionOverridesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input permissionOverridesStreamCursorValueInput {
  """JSON conditions for conditional permissions"""
  conditions: jsonb
  createdAt: timestamptz
  createdBy: uuid
  """When this override expires (NULL for permanent)"""
  expiresAt: timestamptz
  """Whether the permission is granted (true) or denied (false)"""
  granted: Boolean
  id: uuid
  operation: String
  reason: String
  resource: String
  """Role name for role-based overrides (mutually exclusive with user_id)"""
  role: String
  updatedAt: timestamptz
  """User ID for user-specific overrides (mutually exclusive with role)"""
  userId: uuid
}

"""
update columns of table "permission_overrides"
"""
enum permissionOverridesUpdateColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  createdBy
  """column name"""
  expiresAt
  """column name"""
  granted
  """column name"""
  id
  """column name"""
  operation
  """column name"""
  reason
  """column name"""
  resource
  """column name"""
  role
  """column name"""
  updatedAt
  """column name"""
  userId
}

input permissionOverridesUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: permissionOverridesAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: permissionOverridesDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: permissionOverridesDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: permissionOverridesDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: permissionOverridesPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: permissionOverridesSetInput
  """filter the rows which have to be updated"""
  where: permissionOverridesBoolExp!
}

"""
columns and relationships of "audit.permission_usage_report"
"""
type permissionUsageReports {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""
aggregated selection of "audit.permission_usage_report"
"""
type permissionUsageReportsAggregate {
  aggregate: permissionUsageReportsAggregateFields
  nodes: [permissionUsageReports!]!
}

"""
aggregate fields of "audit.permission_usage_report"
"""
type permissionUsageReportsAggregateFields {
  avg: permissionUsageReportsAvgFields
  count(columns: [permissionUsageReportsSelectColumn!], distinct: Boolean): Int!
  max: permissionUsageReportsMaxFields
  min: permissionUsageReportsMinFields
  stddev: permissionUsageReportsStddevFields
  stddevPop: permissionUsageReportsStddevPopFields
  stddevSamp: permissionUsageReportsStddevSampFields
  sum: permissionUsageReportsSumFields
  varPop: permissionUsageReportsVarPopFields
  varSamp: permissionUsageReportsVarSampFields
  variance: permissionUsageReportsVarianceFields
}

"""aggregate avg on columns"""
type permissionUsageReportsAvgFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""
Boolean expression to filter rows from the table "audit.permission_usage_report". All fields are combined with a logical 'AND'.
"""
input permissionUsageReportsBoolExp {
  _and: [permissionUsageReportsBoolExp!]
  _not: permissionUsageReportsBoolExp
  _or: [permissionUsageReportsBoolExp!]
  action: PermissionActionComparisonExp
  lastUsed: TimestamptzComparisonExp
  resourceName: StringComparisonExp
  roleName: StringComparisonExp
  totalUsageCount: BigintComparisonExp
  usersWhoUsedPermission: BigintComparisonExp
  usersWithPermission: BigintComparisonExp
}

"""aggregate max on columns"""
type permissionUsageReportsMaxFields {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""aggregate min on columns"""
type permissionUsageReportsMinFields {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""
Ordering options when selecting data from "audit.permission_usage_report".
"""
input permissionUsageReportsOrderBy {
  action: OrderBy
  lastUsed: OrderBy
  resourceName: OrderBy
  roleName: OrderBy
  totalUsageCount: OrderBy
  usersWhoUsedPermission: OrderBy
  usersWithPermission: OrderBy
}

"""
select columns of table "audit.permission_usage_report"
"""
enum permissionUsageReportsSelectColumn {
  """column name"""
  action
  """column name"""
  lastUsed
  """column name"""
  resourceName
  """column name"""
  roleName
  """column name"""
  totalUsageCount
  """column name"""
  usersWhoUsedPermission
  """column name"""
  usersWithPermission
}

"""aggregate stddev on columns"""
type permissionUsageReportsStddevFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate stddevPop on columns"""
type permissionUsageReportsStddevPopFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate stddevSamp on columns"""
type permissionUsageReportsStddevSampFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""
Streaming cursor of the table "permissionUsageReports"
"""
input permissionUsageReportsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: permissionUsageReportsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input permissionUsageReportsStreamCursorValueInput {
  action: permission_action
  lastUsed: timestamptz
  resourceName: String
  roleName: String
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""aggregate sum on columns"""
type permissionUsageReportsSumFields {
  totalUsageCount: bigint
  usersWhoUsedPermission: bigint
  usersWithPermission: bigint
}

"""aggregate varPop on columns"""
type permissionUsageReportsVarPopFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate varSamp on columns"""
type permissionUsageReportsVarSampFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

"""aggregate variance on columns"""
type permissionUsageReportsVarianceFields {
  totalUsageCount: Float
  usersWhoUsedPermission: Float
  usersWithPermission: Float
}

scalar permission_action

"""
columns and relationships of "permissions"
"""
type permissions {
  action: permission_action!
  """An array relationship"""
  assignedToRoles(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): [rolePermissions!]!
  """An aggregate relationship"""
  assignedToRolesAggregate(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): rolePermissionsAggregate!
  createdAt: timestamptz!
  description: String
  id: uuid!
  legacyPermissionName: String
  """An object relationship"""
  relatedResource: resources!
  resourceId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "permissions"
"""
type permissionsAggregate {
  aggregate: permissionsAggregateFields
  nodes: [permissions!]!
}

input permissionsAggregateBoolExp {
  count: permissionsAggregateBoolExpCount
}

input permissionsAggregateBoolExpCount {
  arguments: [permissionsSelectColumn!]
  distinct: Boolean
  filter: permissionsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "permissions"
"""
type permissionsAggregateFields {
  count(columns: [permissionsSelectColumn!], distinct: Boolean): Int!
  max: permissionsMaxFields
  min: permissionsMinFields
}

"""
order by aggregate values of table "permissions"
"""
input permissionsAggregateOrderBy {
  count: OrderBy
  max: permissionsMaxOrderBy
  min: permissionsMinOrderBy
}

"""
input type for inserting array relation for remote table "permissions"
"""
input permissionsArrRelInsertInput {
  data: [permissionsInsertInput!]!
  """upsert condition"""
  onConflict: permissionsOnConflict
}

"""
Boolean expression to filter rows from the table "permissions". All fields are combined with a logical 'AND'.
"""
input permissionsBoolExp {
  _and: [permissionsBoolExp!]
  _not: permissionsBoolExp
  _or: [permissionsBoolExp!]
  action: PermissionActionComparisonExp
  assignedToRoles: rolePermissionsBoolExp
  assignedToRolesAggregate: rolePermissionsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  legacyPermissionName: StringComparisonExp
  relatedResource: resourcesBoolExp
  resourceId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "permissions"
"""
enum permissionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  permissions_pkey
  """
  unique or primary key constraint on columns "action", "resource_id"
  """
  permissions_resource_id_action_key
}

"""
input type for inserting data into table "permissions"
"""
input permissionsInsertInput {
  action: permission_action
  assignedToRoles: rolePermissionsArrRelInsertInput
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  relatedResource: resourcesObjRelInsertInput
  resourceId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type permissionsMaxFields {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "permissions"
"""
input permissionsMaxOrderBy {
  action: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  legacyPermissionName: OrderBy
  resourceId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type permissionsMinFields {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "permissions"
"""
input permissionsMinOrderBy {
  action: OrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  legacyPermissionName: OrderBy
  resourceId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "permissions"
"""
type permissionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [permissions!]!
}

"""
input type for inserting object relation for remote table "permissions"
"""
input permissionsObjRelInsertInput {
  data: permissionsInsertInput!
  """upsert condition"""
  onConflict: permissionsOnConflict
}

"""
on_conflict condition type for table "permissions"
"""
input permissionsOnConflict {
  constraint: permissionsConstraint!
  updateColumns: [permissionsUpdateColumn!]! = []
  where: permissionsBoolExp
}

"""Ordering options when selecting data from "permissions"."""
input permissionsOrderBy {
  action: OrderBy
  assignedToRolesAggregate: rolePermissionsAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  legacyPermissionName: OrderBy
  relatedResource: resourcesOrderBy
  resourceId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: permissions"""
input permissionsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "permissions"
"""
enum permissionsSelectColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  legacyPermissionName
  """column name"""
  resourceId
  """column name"""
  updatedAt
}

"""
input type for updating data in table "permissions"
"""
input permissionsSetInput {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "permissions"
"""
input permissionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: permissionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input permissionsStreamCursorValueInput {
  action: permission_action
  createdAt: timestamptz
  description: String
  id: uuid
  legacyPermissionName: String
  resourceId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "permissions"
"""
enum permissionsUpdateColumn {
  """column name"""
  action
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  legacyPermissionName
  """column name"""
  resourceId
  """column name"""
  updatedAt
}

input permissionsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: permissionsSetInput
  """filter the rows which have to be updated"""
  where: permissionsBoolExp!
}

type query_root {
  """query _Entity union"""
  _entities(representations: [_Any!]!): _Entity
  _service: _Service!
  """
  execute function "activate_payroll_versions" which returns "payroll_activation_results"
  """
  activatePayrollVersions(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): [payrollActivationResults!]!
  """
  execute function "activate_payroll_versions" and query aggregates on result of table type "payroll_activation_results"
  """
  activatePayrollVersionsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): payrollActivationResultsAggregate!
  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustmentRuleById(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustmentRules
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): [adjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): adjustmentRulesAggregate!
  """fetch data from the table: "app_settings" using primary key columns"""
  appSettingById(
    """Unique identifier for application setting"""
    id: String!
  ): appSettings
  """
  fetch data from the table: "app_settings"
  """
  appSettings(
    """distinct select on columns"""
    distinctOn: [appSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [appSettingsOrderBy!]
    """filter the rows returned"""
    where: appSettingsBoolExp
  ): [appSettings!]!
  """
  fetch aggregated fields from the table: "app_settings"
  """
  appSettingsAggregate(
    """distinct select on columns"""
    distinctOn: [appSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [appSettingsOrderBy!]
    """filter the rows returned"""
    where: appSettingsBoolExp
  ): appSettingsAggregate!
  """fetch data from the table: "audit.audit_log" using primary key columns"""
  auditLogById(id: uuid!): auditLogs
  """
  fetch data from the table: "audit.audit_log"
  """
  auditLogs(
    """distinct select on columns"""
    distinctOn: [auditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [auditLogsOrderBy!]
    """filter the rows returned"""
    where: auditLogsBoolExp
  ): [auditLogs!]!
  """
  fetch aggregated fields from the table: "audit.audit_log"
  """
  auditLogsAggregate(
    """distinct select on columns"""
    distinctOn: [auditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [auditLogsOrderBy!]
    """filter the rows returned"""
    where: auditLogsBoolExp
  ): auditLogsAggregate!
  """
  fetch data from the table: "audit.auth_events" using primary key columns
  """
  authEventById(id: uuid!): authEvents
  """
  fetch data from the table: "audit.auth_events"
  """
  authEvents(
    """distinct select on columns"""
    distinctOn: [authEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authEventsOrderBy!]
    """filter the rows returned"""
    where: authEventsBoolExp
  ): [authEvents!]!
  """
  fetch aggregated fields from the table: "audit.auth_events"
  """
  authEventsAggregate(
    """distinct select on columns"""
    distinctOn: [authEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authEventsOrderBy!]
    """filter the rows returned"""
    where: authEventsBoolExp
  ): authEventsAggregate!
  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billingEventLogById(id: uuid!): billingEventLogs
  """An array relationship"""
  billingEventLogs(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): [billingEventLogs!]!
  """An aggregate relationship"""
  billingEventLogsAggregate(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): billingEventLogsAggregate!
  """
  fetch data from the table: "billing_invoice"
  """
  billingInvoice(
    """distinct select on columns"""
    distinctOn: [billingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoiceOrderBy!]
    """filter the rows returned"""
    where: billingInvoiceBoolExp
  ): [billingInvoice!]!
  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billingInvoiceAggregate(
    """distinct select on columns"""
    distinctOn: [billingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoiceOrderBy!]
    """filter the rows returned"""
    where: billingInvoiceBoolExp
  ): billingInvoiceAggregate!
  """fetch data from the table: "billing_invoice" using primary key columns"""
  billingInvoiceById(id: uuid!): billingInvoice
  """An array relationship"""
  billingInvoices(
    """distinct select on columns"""
    distinctOn: [billingInvoicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoicesOrderBy!]
    """filter the rows returned"""
    where: billingInvoicesBoolExp
  ): [billingInvoices!]!
  """An aggregate relationship"""
  billingInvoicesAggregate(
    """distinct select on columns"""
    distinctOn: [billingInvoicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoicesOrderBy!]
    """filter the rows returned"""
    where: billingInvoicesBoolExp
  ): billingInvoicesAggregate!
  """
  fetch data from the table: "billing_invoices" using primary key columns
  """
  billingInvoicesById(id: uuid!): billingInvoices
  """fetch data from the table: "billing_items" using primary key columns"""
  billingItemById(id: uuid!): billingItems
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): [billingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): billingItemsAggregate!
  """fetch data from the table: "billing_plan" using primary key columns"""
  billingPlanById(id: uuid!): billingPlans
  """
  fetch data from the table: "billing_plan"
  """
  billingPlans(
    """distinct select on columns"""
    distinctOn: [billingPlansSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingPlansOrderBy!]
    """filter the rows returned"""
    where: billingPlansBoolExp
  ): [billingPlans!]!
  """
  fetch aggregated fields from the table: "billing_plan"
  """
  billingPlansAggregate(
    """distinct select on columns"""
    distinctOn: [billingPlansSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingPlansOrderBy!]
    """filter the rows returned"""
    where: billingPlansBoolExp
  ): billingPlansAggregate!
  """
  fetch data from the table: "client_billing_assignment" using primary key columns
  """
  clientBillingAssignmentById(id: uuid!): clientBillingAssignments
  """An array relationship"""
  clientBillingAssignments(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): [clientBillingAssignments!]!
  """An aggregate relationship"""
  clientBillingAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): clientBillingAssignmentsAggregate!
  """fetch data from the table: "clients" using primary key columns"""
  clientById(
    """Unique identifier for the client"""
    id: uuid!
  ): clients
  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  clientExternalSystemById(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): clientExternalSystems
  """An array relationship"""
  clientExternalSystems(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): [clientExternalSystems!]!
  """An aggregate relationship"""
  clientExternalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): clientExternalSystemsAggregate!
  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinctOn: [clientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientsOrderBy!]
    """filter the rows returned"""
    where: clientsBoolExp
  ): [clients!]!
  """
  fetch aggregated fields from the table: "clients"
  """
  clientsAggregate(
    """distinct select on columns"""
    distinctOn: [clientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientsOrderBy!]
    """filter the rows returned"""
    where: clientsBoolExp
  ): clientsAggregate!
  """
  execute function "create_payroll_version" which returns "payroll_version_results"
  """
  createPayrollVersion(
    """
    input parameters for function "createPayrollVersion"
    """
    args: createPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): [payrollVersionResults!]!
  """
  execute function "create_payroll_version" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionAggregate(
    """
    input parameters for function "createPayrollVersionAggregate"
    """
    args: createPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): payrollVersionResultsAggregate!
  """
  execute function "create_payroll_version_simple" which returns "payroll_version_results"
  """
  createPayrollVersionSimple(
    """
    input parameters for function "createPayrollVersionSimple"
    """
    args: createPayrollVersionSimpleArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): [payrollVersionResults!]!
  """
  execute function "create_payroll_version_simple" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionSimpleAggregate(
    """
    input parameters for function "createPayrollVersionSimpleAggregate"
    """
    args: createPayrollVersionSimpleArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): payrollVersionResultsAggregate!
  """
  fetch data from the table: "current_payrolls"
  """
  currentPayrolls(
    """distinct select on columns"""
    distinctOn: [currentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [currentPayrollsOrderBy!]
    """filter the rows returned"""
    where: currentPayrollsBoolExp
  ): [currentPayrolls!]!
  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  currentPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [currentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [currentPayrollsOrderBy!]
    """filter the rows returned"""
    where: currentPayrollsBoolExp
  ): currentPayrollsAggregate!
  """
  fetch data from the table: "audit.data_access_log" using primary key columns
  """
  dataAccessLogById(id: uuid!): dataAccessLogs
  """
  fetch data from the table: "audit.data_access_log"
  """
  dataAccessLogs(
    """distinct select on columns"""
    distinctOn: [dataAccessLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [dataAccessLogsOrderBy!]
    """filter the rows returned"""
    where: dataAccessLogsBoolExp
  ): [dataAccessLogs!]!
  """
  fetch aggregated fields from the table: "audit.data_access_log"
  """
  dataAccessLogsAggregate(
    """distinct select on columns"""
    distinctOn: [dataAccessLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [dataAccessLogsOrderBy!]
    """filter the rows returned"""
    where: dataAccessLogsBoolExp
  ): dataAccessLogsAggregate!
  """
  fetch data from the table: "external_systems" using primary key columns
  """
  externalSystemById(
    """Unique identifier for the external system"""
    id: uuid!
  ): externalSystems
  """
  fetch data from the table: "external_systems"
  """
  externalSystems(
    """distinct select on columns"""
    distinctOn: [externalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [externalSystemsOrderBy!]
    """filter the rows returned"""
    where: externalSystemsBoolExp
  ): [externalSystems!]!
  """
  fetch aggregated fields from the table: "external_systems"
  """
  externalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [externalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [externalSystemsOrderBy!]
    """filter the rows returned"""
    where: externalSystemsBoolExp
  ): externalSystemsAggregate!
  """fetch data from the table: "feature_flags" using primary key columns"""
  featureFlagById(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): featureFlags
  """
  fetch data from the table: "feature_flags"
  """
  featureFlags(
    """distinct select on columns"""
    distinctOn: [featureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [featureFlagsOrderBy!]
    """filter the rows returned"""
    where: featureFlagsBoolExp
  ): [featureFlags!]!
  """
  fetch aggregated fields from the table: "feature_flags"
  """
  featureFlagsAggregate(
    """distinct select on columns"""
    distinctOn: [featureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [featureFlagsOrderBy!]
    """filter the rows returned"""
    where: featureFlagsBoolExp
  ): featureFlagsAggregate!
  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generatePayrollDates(
    """
    input parameters for function "generatePayrollDates"
    """
    args: generatePayrollDatesArgs!
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): [payrollDates!]!
  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generatePayrollDatesAggregate(
    """
    input parameters for function "generatePayrollDatesAggregate"
    """
    args: generatePayrollDatesArgs!
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): payrollDatesAggregate!
  """
  execute function "get_latest_payroll_version" which returns "latest_payroll_version_results"
  """
  getLatestPayrollVersion(
    """
    input parameters for function "getLatestPayrollVersion"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): [latestPayrollVersionResults!]!
  """
  execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results"
  """
  getLatestPayrollVersionAggregate(
    """
    input parameters for function "getLatestPayrollVersionAggregate"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): latestPayrollVersionResultsAggregate!
  """
  execute function "get_payroll_version_history" which returns "payroll_version_history_results"
  """
  getPayrollVersionHistory(
    """
    input parameters for function "getPayrollVersionHistory"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): [payrollVersionHistoryResults!]!
  """
  execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results"
  """
  getPayrollVersionHistoryAggregate(
    """
    input parameters for function "getPayrollVersionHistoryAggregate"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): payrollVersionHistoryResultsAggregate!
  """fetch data from the table: "holidays" using primary key columns"""
  holidayById(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays
  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinctOn: [holidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [holidaysOrderBy!]
    """filter the rows returned"""
    where: holidaysBoolExp
  ): [holidays!]!
  """
  fetch aggregated fields from the table: "holidays"
  """
  holidaysAggregate(
    """distinct select on columns"""
    distinctOn: [holidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [holidaysOrderBy!]
    """filter the rows returned"""
    where: holidaysBoolExp
  ): holidaysAggregate!
  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latestPayrollVersionResultById(id: uuid!): latestPayrollVersionResults
  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResults(
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): [latestPayrollVersionResults!]!
  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): latestPayrollVersionResultsAggregate!
  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinctOn: [leaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [leaveOrderBy!]
    """filter the rows returned"""
    where: leaveBoolExp
  ): [leave!]!
  """
  fetch aggregated fields from the table: "leave"
  """
  leaveAggregate(
    """distinct select on columns"""
    distinctOn: [leaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [leaveOrderBy!]
    """filter the rows returned"""
    where: leaveBoolExp
  ): leaveAggregate!
  """fetch data from the table: "leave" using primary key columns"""
  leaveById(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave
  """fetch data from the table: "notes" using primary key columns"""
  noteById(
    """Unique identifier for the note"""
    id: uuid!
  ): notes
  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinctOn: [notesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [notesOrderBy!]
    """filter the rows returned"""
    where: notesBoolExp
  ): [notes!]!
  """
  fetch aggregated fields from the table: "notes"
  """
  notesAggregate(
    """distinct select on columns"""
    distinctOn: [notesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [notesOrderBy!]
    """filter the rows returned"""
    where: notesBoolExp
  ): notesAggregate!
  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payrollActivationResultById(id: uuid!): payrollActivationResults
  """
  fetch data from the table: "payroll_activation_results"
  """
  payrollActivationResults(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): [payrollActivationResults!]!
  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payrollActivationResultsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): payrollActivationResultsAggregate!
  """
  fetch data from the table: "payroll_assignment_audit" using primary key columns
  """
  payrollAssignmentAuditById(id: uuid!): payrollAssignmentAudits
  """An array relationship"""
  payrollAssignmentAudits(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """An aggregate relationship"""
  payrollAssignmentAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): payrollAssignmentAuditsAggregate!
  """
  fetch data from the table: "payroll_assignments" using primary key columns
  """
  payrollAssignmentById(id: uuid!): payrollAssignments
  """
  fetch data from the table: "payroll_assignments"
  """
  payrollAssignments(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): [payrollAssignments!]!
  """
  fetch aggregated fields from the table: "payroll_assignments"
  """
  payrollAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): payrollAssignmentsAggregate!
  """fetch data from the table: "payrolls" using primary key columns"""
  payrollById(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls
  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payrollCycleById(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payrollCycles
  """
  fetch data from the table: "payroll_cycles"
  """
  payrollCycles(
    """distinct select on columns"""
    distinctOn: [payrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollCyclesOrderBy!]
    """filter the rows returned"""
    where: payrollCyclesBoolExp
  ): [payrollCycles!]!
  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payrollCyclesAggregate(
    """distinct select on columns"""
    distinctOn: [payrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollCyclesOrderBy!]
    """filter the rows returned"""
    where: payrollCyclesBoolExp
  ): payrollCyclesAggregate!
  """
  fetch data from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStats(
    """distinct select on columns"""
    distinctOn: [payrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: payrollDashboardStatsBoolExp
  ): [payrollDashboardStats!]!
  """
  fetch aggregated fields from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStatsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: payrollDashboardStatsBoolExp
  ): payrollDashboardStatsAggregate!
  """fetch data from the table: "payroll_dates" using primary key columns"""
  payrollDateById(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payrollDates
  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payrollDateTypeById(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payrollDateTypes
  """
  fetch data from the table: "payroll_date_types"
  """
  payrollDateTypes(
    """distinct select on columns"""
    distinctOn: [payrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: payrollDateTypesBoolExp
  ): [payrollDateTypes!]!
  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payrollDateTypesAggregate(
    """distinct select on columns"""
    distinctOn: [payrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: payrollDateTypesBoolExp
  ): payrollDateTypesAggregate!
  """An array relationship"""
  payrollDates(
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): [payrollDates!]!
  """An aggregate relationship"""
  payrollDatesAggregate(
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): payrollDatesAggregate!
  """
  fetch data from the table: "payroll_triggers_status"
  """
  payrollTriggersStatus(
    """distinct select on columns"""
    distinctOn: [payrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: payrollTriggersStatusBoolExp
  ): [payrollTriggersStatus!]!
  """
  fetch aggregated fields from the table: "payroll_triggers_status"
  """
  payrollTriggersStatusAggregate(
    """distinct select on columns"""
    distinctOn: [payrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: payrollTriggersStatusBoolExp
  ): payrollTriggersStatusAggregate!
  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payrollVersionHistoryResultById(id: uuid!): payrollVersionHistoryResults
  """
  fetch data from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResults(
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): [payrollVersionHistoryResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResultsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): payrollVersionHistoryResultsAggregate!
  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payrollVersionResultById(id: uuid!): payrollVersionResults
  """
  fetch data from the table: "payroll_version_results"
  """
  payrollVersionResults(
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): [payrollVersionResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): payrollVersionResultsAggregate!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permissionAuditLogById(id: uuid!): permissionAuditLogs
  """
  fetch data from the table: "permission_audit_log"
  """
  permissionAuditLogs(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): [permissionAuditLogs!]!
  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permissionAuditLogsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): permissionAuditLogsAggregate!
  """fetch data from the table: "permissions" using primary key columns"""
  permissionById(id: uuid!): permissions
  """
  fetch data from the table: "audit.permission_changes" using primary key columns
  """
  permissionChangeById(id: uuid!): permissionChanges
  """
  fetch data from the table: "audit.permission_changes"
  """
  permissionChanges(
    """distinct select on columns"""
    distinctOn: [permissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionChangesOrderBy!]
    """filter the rows returned"""
    where: permissionChangesBoolExp
  ): [permissionChanges!]!
  """
  fetch aggregated fields from the table: "audit.permission_changes"
  """
  permissionChangesAggregate(
    """distinct select on columns"""
    distinctOn: [permissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionChangesOrderBy!]
    """filter the rows returned"""
    where: permissionChangesBoolExp
  ): permissionChangesAggregate!
  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permissionOverrideById(id: uuid!): permissionOverrides
  """
  fetch data from the table: "permission_overrides"
  """
  permissionOverrides(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): [permissionOverrides!]!
  """
  fetch aggregated fields from the table: "permission_overrides"
  """
  permissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): permissionOverridesAggregate!
  """
  fetch data from the table: "audit.permission_usage_report"
  """
  permissionUsageReports(
    """distinct select on columns"""
    distinctOn: [permissionUsageReportsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionUsageReportsOrderBy!]
    """filter the rows returned"""
    where: permissionUsageReportsBoolExp
  ): [permissionUsageReports!]!
  """
  fetch aggregated fields from the table: "audit.permission_usage_report"
  """
  permissionUsageReportsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionUsageReportsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionUsageReportsOrderBy!]
    """filter the rows returned"""
    where: permissionUsageReportsBoolExp
  ): permissionUsageReportsAggregate!
  """
  fetch data from the table: "permissions"
  """
  permissions(
    """distinct select on columns"""
    distinctOn: [permissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionsOrderBy!]
    """filter the rows returned"""
    where: permissionsBoolExp
  ): [permissions!]!
  """
  fetch aggregated fields from the table: "permissions"
  """
  permissionsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionsOrderBy!]
    """filter the rows returned"""
    where: permissionsBoolExp
  ): permissionsAggregate!
  """fetch data from the table: "resources" using primary key columns"""
  resourceById(id: uuid!): resources
  """
  fetch data from the table: "resources"
  """
  resources(
    """distinct select on columns"""
    distinctOn: [resourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [resourcesOrderBy!]
    """filter the rows returned"""
    where: resourcesBoolExp
  ): [resources!]!
  """
  fetch aggregated fields from the table: "resources"
  """
  resourcesAggregate(
    """distinct select on columns"""
    distinctOn: [resourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [resourcesOrderBy!]
    """filter the rows returned"""
    where: resourcesBoolExp
  ): resourcesAggregate!
  """fetch data from the table: "roles" using primary key columns"""
  roleById(id: uuid!): roles
  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  rolePermissionById(id: uuid!): rolePermissions
  """
  fetch data from the table: "role_permissions"
  """
  rolePermissions(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): [rolePermissions!]!
  """
  fetch aggregated fields from the table: "role_permissions"
  """
  rolePermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): rolePermissionsAggregate!
  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinctOn: [rolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolesOrderBy!]
    """filter the rows returned"""
    where: rolesBoolExp
  ): [roles!]!
  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [rolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolesOrderBy!]
    """filter the rows returned"""
    where: rolesBoolExp
  ): rolesAggregate!
  """
  fetch data from the table: "audit.slow_queries"
  """
  slowQueries(
    """distinct select on columns"""
    distinctOn: [slowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [slowQueriesOrderBy!]
    """filter the rows returned"""
    where: slowQueriesBoolExp
  ): [slowQueries!]!
  """
  fetch aggregated fields from the table: "audit.slow_queries"
  """
  slowQueriesAggregate(
    """distinct select on columns"""
    distinctOn: [slowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [slowQueriesOrderBy!]
    """filter the rows returned"""
    where: slowQueriesBoolExp
  ): slowQueriesAggregate!
  """
  fetch data from the table: "audit.slow_queries" using primary key columns
  """
  slowQueryById(id: uuid!): slowQueries
  """
  fetch data from the table: "audit.user_access_summary"
  """
  userAccessSummaries(
    """distinct select on columns"""
    distinctOn: [userAccessSummariesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userAccessSummariesOrderBy!]
    """filter the rows returned"""
    where: userAccessSummariesBoolExp
  ): [userAccessSummaries!]!
  """
  fetch aggregated fields from the table: "audit.user_access_summary"
  """
  userAccessSummariesAggregate(
    """distinct select on columns"""
    distinctOn: [userAccessSummariesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userAccessSummariesOrderBy!]
    """filter the rows returned"""
    where: userAccessSummariesBoolExp
  ): userAccessSummariesAggregate!
  """fetch data from the table: "users" using primary key columns"""
  userById(
    """Unique identifier for the user"""
    id: uuid!
  ): users
  """
  fetch data from the table: "user_invitations" using primary key columns
  """
  userInvitationById(id: uuid!): userInvitations
  """
  fetch data from the table: "user_invitations"
  """
  userInvitations(
    """distinct select on columns"""
    distinctOn: [userInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userInvitationsOrderBy!]
    """filter the rows returned"""
    where: userInvitationsBoolExp
  ): [userInvitations!]!
  """
  fetch aggregated fields from the table: "user_invitations"
  """
  userInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [userInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userInvitationsOrderBy!]
    """filter the rows returned"""
    where: userInvitationsBoolExp
  ): userInvitationsAggregate!
  """fetch data from the table: "user_roles" using primary key columns"""
  userRoleById(id: uuid!): userRoles
  """
  fetch data from the table: "user_roles"
  """
  userRoles(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): [userRoles!]!
  """
  fetch aggregated fields from the table: "user_roles"
  """
  userRolesAggregate(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): userRolesAggregate!
  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  userSyncById(
    """Unique identifier from the authentication provider"""
    id: String!
  ): authUsersSync
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): usersAggregate!
  """
  fetch data from the table: "users_role_backup"
  """
  usersRoleBackups(
    """distinct select on columns"""
    distinctOn: [usersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: usersRoleBackupBoolExp
  ): [usersRoleBackup!]!
  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  usersRoleBackupsAggregate(
    """distinct select on columns"""
    distinctOn: [usersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: usersRoleBackupBoolExp
  ): usersRoleBackupAggregate!
  """
  fetch data from the table: "neon_auth.users_sync"
  """
  usersSync(
    """distinct select on columns"""
    distinctOn: [authUsersSyncSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authUsersSyncOrderBy!]
    """filter the rows returned"""
    where: authUsersSyncBoolExp
  ): [authUsersSync!]!
  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  usersSyncAggregate(
    """distinct select on columns"""
    distinctOn: [authUsersSyncSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authUsersSyncOrderBy!]
    """filter the rows returned"""
    where: authUsersSyncBoolExp
  ): authUsersSyncAggregate!
  """fetch data from the table: "work_schedule" using primary key columns"""
  workScheduleById(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): workSchedules
  """
  fetch data from the table: "work_schedule"
  """
  workSchedules(
    """distinct select on columns"""
    distinctOn: [workSchedulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [workSchedulesOrderBy!]
    """filter the rows returned"""
    where: workSchedulesBoolExp
  ): [workSchedules!]!
  """
  fetch aggregated fields from the table: "work_schedule"
  """
  workSchedulesAggregate(
    """distinct select on columns"""
    distinctOn: [workSchedulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [workSchedulesOrderBy!]
    """filter the rows returned"""
    where: workSchedulesBoolExp
  ): workSchedulesAggregate!
}

"""
columns and relationships of "resources"
"""
type resources {
  """An array relationship"""
  availablePermissions(
    """distinct select on columns"""
    distinctOn: [permissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionsOrderBy!]
    """filter the rows returned"""
    where: permissionsBoolExp
  ): [permissions!]!
  """An aggregate relationship"""
  availablePermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionsOrderBy!]
    """filter the rows returned"""
    where: permissionsBoolExp
  ): permissionsAggregate!
  createdAt: timestamptz!
  description: String
  displayName: String!
  id: uuid!
  name: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "resources"
"""
type resourcesAggregate {
  aggregate: resourcesAggregateFields
  nodes: [resources!]!
}

"""
aggregate fields of "resources"
"""
type resourcesAggregateFields {
  count(columns: [resourcesSelectColumn!], distinct: Boolean): Int!
  max: resourcesMaxFields
  min: resourcesMinFields
}

"""
Boolean expression to filter rows from the table "resources". All fields are combined with a logical 'AND'.
"""
input resourcesBoolExp {
  _and: [resourcesBoolExp!]
  _not: resourcesBoolExp
  _or: [resourcesBoolExp!]
  availablePermissions: permissionsBoolExp
  availablePermissionsAggregate: permissionsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  displayName: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "resources"
"""
enum resourcesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  resources_name_key
  """
  unique or primary key constraint on columns "id"
  """
  resources_pkey
}

"""
input type for inserting data into table "resources"
"""
input resourcesInsertInput {
  availablePermissions: permissionsArrRelInsertInput
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type resourcesMaxFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type resourcesMinFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "resources"
"""
type resourcesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [resources!]!
}

"""
input type for inserting object relation for remote table "resources"
"""
input resourcesObjRelInsertInput {
  data: resourcesInsertInput!
  """upsert condition"""
  onConflict: resourcesOnConflict
}

"""
on_conflict condition type for table "resources"
"""
input resourcesOnConflict {
  constraint: resourcesConstraint!
  updateColumns: [resourcesUpdateColumn!]! = []
  where: resourcesBoolExp
}

"""Ordering options when selecting data from "resources"."""
input resourcesOrderBy {
  availablePermissionsAggregate: permissionsAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  displayName: OrderBy
  id: OrderBy
  name: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: resources"""
input resourcesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "resources"
"""
enum resourcesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

"""
input type for updating data in table "resources"
"""
input resourcesSetInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "resources"
"""
input resourcesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: resourcesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input resourcesStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  updatedAt: timestamptz
}

"""
update columns of table "resources"
"""
enum resourcesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  name
  """column name"""
  updatedAt
}

input resourcesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: resourcesSetInput
  """filter the rows which have to be updated"""
  where: resourcesBoolExp!
}

"""
columns and relationships of "role_permissions"
"""
type rolePermissions {
  conditions(
    """JSON select path"""
    path: String
  ): jsonb
  createdAt: timestamptz!
  """An object relationship"""
  grantedPermission: permissions!
  """An object relationship"""
  grantedToRole: roles!
  id: uuid!
  permissionId: uuid!
  roleId: uuid!
  updatedAt: timestamptz!
}

"""
aggregated selection of "role_permissions"
"""
type rolePermissionsAggregate {
  aggregate: rolePermissionsAggregateFields
  nodes: [rolePermissions!]!
}

input rolePermissionsAggregateBoolExp {
  count: rolePermissionsAggregateBoolExpCount
}

input rolePermissionsAggregateBoolExpCount {
  arguments: [rolePermissionsSelectColumn!]
  distinct: Boolean
  filter: rolePermissionsBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "role_permissions"
"""
type rolePermissionsAggregateFields {
  count(columns: [rolePermissionsSelectColumn!], distinct: Boolean): Int!
  max: rolePermissionsMaxFields
  min: rolePermissionsMinFields
}

"""
order by aggregate values of table "role_permissions"
"""
input rolePermissionsAggregateOrderBy {
  count: OrderBy
  max: rolePermissionsMaxOrderBy
  min: rolePermissionsMinOrderBy
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input rolePermissionsAppendInput {
  conditions: jsonb
}

"""
input type for inserting array relation for remote table "role_permissions"
"""
input rolePermissionsArrRelInsertInput {
  data: [rolePermissionsInsertInput!]!
  """upsert condition"""
  onConflict: rolePermissionsOnConflict
}

"""
Boolean expression to filter rows from the table "role_permissions". All fields are combined with a logical 'AND'.
"""
input rolePermissionsBoolExp {
  _and: [rolePermissionsBoolExp!]
  _not: rolePermissionsBoolExp
  _or: [rolePermissionsBoolExp!]
  conditions: JsonbComparisonExp
  createdAt: TimestamptzComparisonExp
  grantedPermission: permissionsBoolExp
  grantedToRole: rolesBoolExp
  id: UuidComparisonExp
  permissionId: UuidComparisonExp
  roleId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "role_permissions"
"""
enum rolePermissionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  role_permissions_pkey
  """
  unique or primary key constraint on columns "permission_id", "role_id"
  """
  role_permissions_role_id_permission_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input rolePermissionsDeleteAtPathInput {
  conditions: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input rolePermissionsDeleteElemInput {
  conditions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input rolePermissionsDeleteKeyInput {
  conditions: String
}

"""
input type for inserting data into table "role_permissions"
"""
input rolePermissionsInsertInput {
  conditions: jsonb
  createdAt: timestamptz
  grantedPermission: permissionsObjRelInsertInput
  grantedToRole: rolesObjRelInsertInput
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type rolePermissionsMaxFields {
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "role_permissions"
"""
input rolePermissionsMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  permissionId: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type rolePermissionsMinFields {
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "role_permissions"
"""
input rolePermissionsMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  permissionId: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
}

"""
response of any mutation on the table "role_permissions"
"""
type rolePermissionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [rolePermissions!]!
}

"""
on_conflict condition type for table "role_permissions"
"""
input rolePermissionsOnConflict {
  constraint: rolePermissionsConstraint!
  updateColumns: [rolePermissionsUpdateColumn!]! = []
  where: rolePermissionsBoolExp
}

"""Ordering options when selecting data from "role_permissions"."""
input rolePermissionsOrderBy {
  conditions: OrderBy
  createdAt: OrderBy
  grantedPermission: permissionsOrderBy
  grantedToRole: rolesOrderBy
  id: OrderBy
  permissionId: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: role_permissions"""
input rolePermissionsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input rolePermissionsPrependInput {
  conditions: jsonb
}

"""
select columns of table "role_permissions"
"""
enum rolePermissionsSelectColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  permissionId
  """column name"""
  roleId
  """column name"""
  updatedAt
}

"""
input type for updating data in table "role_permissions"
"""
input rolePermissionsSetInput {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "rolePermissions"
"""
input rolePermissionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: rolePermissionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input rolePermissionsStreamCursorValueInput {
  conditions: jsonb
  createdAt: timestamptz
  id: uuid
  permissionId: uuid
  roleId: uuid
  updatedAt: timestamptz
}

"""
update columns of table "role_permissions"
"""
enum rolePermissionsUpdateColumn {
  """column name"""
  conditions
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  permissionId
  """column name"""
  roleId
  """column name"""
  updatedAt
}

input rolePermissionsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: rolePermissionsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: rolePermissionsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: rolePermissionsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: rolePermissionsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: rolePermissionsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: rolePermissionsSetInput
  """filter the rows which have to be updated"""
  where: rolePermissionsBoolExp!
}

"""
columns and relationships of "roles"
"""
type roles {
  """An array relationship"""
  assignedPermissions(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): [rolePermissions!]!
  """An aggregate relationship"""
  assignedPermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): rolePermissionsAggregate!
  """An array relationship"""
  assignedToUsers(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): [userRoles!]!
  """An aggregate relationship"""
  assignedToUsersAggregate(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): userRolesAggregate!
  createdAt: timestamptz!
  description: String
  displayName: String!
  id: uuid!
  isSystemRole: Boolean!
  name: String!
  priority: Int!
  updatedAt: timestamptz!
}

"""
aggregated selection of "roles"
"""
type rolesAggregate {
  aggregate: rolesAggregateFields
  nodes: [roles!]!
}

"""
aggregate fields of "roles"
"""
type rolesAggregateFields {
  avg: rolesAvgFields
  count(columns: [rolesSelectColumn!], distinct: Boolean): Int!
  max: rolesMaxFields
  min: rolesMinFields
  stddev: rolesStddevFields
  stddevPop: rolesStddevPopFields
  stddevSamp: rolesStddevSampFields
  sum: rolesSumFields
  varPop: rolesVarPopFields
  varSamp: rolesVarSampFields
  variance: rolesVarianceFields
}

"""aggregate avg on columns"""
type rolesAvgFields {
  priority: Float
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input rolesBoolExp {
  _and: [rolesBoolExp!]
  _not: rolesBoolExp
  _or: [rolesBoolExp!]
  assignedPermissions: rolePermissionsBoolExp
  assignedPermissionsAggregate: rolePermissionsAggregateBoolExp
  assignedToUsers: userRolesBoolExp
  assignedToUsersAggregate: userRolesAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  displayName: StringComparisonExp
  id: UuidComparisonExp
  isSystemRole: BooleanComparisonExp
  name: StringComparisonExp
  priority: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "roles"
"""
enum rolesConstraint {
  """
  unique or primary key constraint on columns "name"
  """
  roles_name_key
  """
  unique or primary key constraint on columns "id"
  """
  roles_pkey
}

"""
input type for incrementing numeric columns in table "roles"
"""
input rolesIncInput {
  priority: Int
}

"""
input type for inserting data into table "roles"
"""
input rolesInsertInput {
  assignedPermissions: rolePermissionsArrRelInsertInput
  assignedToUsers: userRolesArrRelInsertInput
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type rolesMaxFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type rolesMinFields {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "roles"
"""
type rolesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [roles!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input rolesObjRelInsertInput {
  data: rolesInsertInput!
  """upsert condition"""
  onConflict: rolesOnConflict
}

"""
on_conflict condition type for table "roles"
"""
input rolesOnConflict {
  constraint: rolesConstraint!
  updateColumns: [rolesUpdateColumn!]! = []
  where: rolesBoolExp
}

"""Ordering options when selecting data from "roles"."""
input rolesOrderBy {
  assignedPermissionsAggregate: rolePermissionsAggregateOrderBy
  assignedToUsersAggregate: userRolesAggregateOrderBy
  createdAt: OrderBy
  description: OrderBy
  displayName: OrderBy
  id: OrderBy
  isSystemRole: OrderBy
  name: OrderBy
  priority: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: roles"""
input rolesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "roles"
"""
enum rolesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  isSystemRole
  """column name"""
  name
  """column name"""
  priority
  """column name"""
  updatedAt
}

"""
input type for updating data in table "roles"
"""
input rolesSetInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type rolesStddevFields {
  priority: Float
}

"""aggregate stddevPop on columns"""
type rolesStddevPopFields {
  priority: Float
}

"""aggregate stddevSamp on columns"""
type rolesStddevSampFields {
  priority: Float
}

"""
Streaming cursor of the table "roles"
"""
input rolesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: rolesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input rolesStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  displayName: String
  id: uuid
  isSystemRole: Boolean
  name: String
  priority: Int
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type rolesSumFields {
  priority: Int
}

"""
update columns of table "roles"
"""
enum rolesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  displayName
  """column name"""
  id
  """column name"""
  isSystemRole
  """column name"""
  name
  """column name"""
  priority
  """column name"""
  updatedAt
}

input rolesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: rolesIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: rolesSetInput
  """filter the rows which have to be updated"""
  where: rolesBoolExp!
}

"""aggregate varPop on columns"""
type rolesVarPopFields {
  priority: Float
}

"""aggregate varSamp on columns"""
type rolesVarSampFields {
  priority: Float
}

"""aggregate variance on columns"""
type rolesVarianceFields {
  priority: Float
}

"""
columns and relationships of "audit.slow_queries"
"""
type slowQueries {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid!
  query: String!
  queryDuration: interval!
  queryStart: timestamptz!
  userId: uuid
}

"""
aggregated selection of "audit.slow_queries"
"""
type slowQueriesAggregate {
  aggregate: slowQueriesAggregateFields
  nodes: [slowQueries!]!
}

"""
aggregate fields of "audit.slow_queries"
"""
type slowQueriesAggregateFields {
  count(columns: [slowQueriesSelectColumn!], distinct: Boolean): Int!
  max: slowQueriesMaxFields
  min: slowQueriesMinFields
}

"""
Boolean expression to filter rows from the table "audit.slow_queries". All fields are combined with a logical 'AND'.
"""
input slowQueriesBoolExp {
  _and: [slowQueriesBoolExp!]
  _not: slowQueriesBoolExp
  _or: [slowQueriesBoolExp!]
  applicationName: StringComparisonExp
  clientAddr: InetComparisonExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  query: StringComparisonExp
  queryDuration: IntervalComparisonExp
  queryStart: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "audit.slow_queries"
"""
enum slowQueriesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  slow_queries_pkey
}

"""
input type for inserting data into table "audit.slow_queries"
"""
input slowQueriesInsertInput {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid
  query: String
  queryDuration: interval
  queryStart: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type slowQueriesMaxFields {
  applicationName: String
  createdAt: timestamptz
  id: uuid
  query: String
  queryStart: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type slowQueriesMinFields {
  applicationName: String
  createdAt: timestamptz
  id: uuid
  query: String
  queryStart: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "audit.slow_queries"
"""
type slowQueriesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [slowQueries!]!
}

"""
on_conflict condition type for table "audit.slow_queries"
"""
input slowQueriesOnConflict {
  constraint: slowQueriesConstraint!
  updateColumns: [slowQueriesUpdateColumn!]! = []
  where: slowQueriesBoolExp
}

"""Ordering options when selecting data from "audit.slow_queries"."""
input slowQueriesOrderBy {
  applicationName: OrderBy
  clientAddr: OrderBy
  createdAt: OrderBy
  id: OrderBy
  query: OrderBy
  queryDuration: OrderBy
  queryStart: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: audit.slow_queries"""
input slowQueriesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "audit.slow_queries"
"""
enum slowQueriesSelectColumn {
  """column name"""
  applicationName
  """column name"""
  clientAddr
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  query
  """column name"""
  queryDuration
  """column name"""
  queryStart
  """column name"""
  userId
}

"""
input type for updating data in table "audit.slow_queries"
"""
input slowQueriesSetInput {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid
  query: String
  queryDuration: interval
  queryStart: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "slowQueries"
"""
input slowQueriesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: slowQueriesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input slowQueriesStreamCursorValueInput {
  applicationName: String
  clientAddr: inet
  createdAt: timestamptz
  id: uuid
  query: String
  queryDuration: interval
  queryStart: timestamptz
  userId: uuid
}

"""
update columns of table "audit.slow_queries"
"""
enum slowQueriesUpdateColumn {
  """column name"""
  applicationName
  """column name"""
  clientAddr
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  query
  """column name"""
  queryDuration
  """column name"""
  queryStart
  """column name"""
  userId
}

input slowQueriesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: slowQueriesSetInput
  """filter the rows which have to be updated"""
  where: slowQueriesBoolExp!
}

type subscription_root {
  """
  execute function "activate_payroll_versions" which returns "payroll_activation_results"
  """
  activatePayrollVersions(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): [payrollActivationResults!]!
  """
  execute function "activate_payroll_versions" and query aggregates on result of table type "payroll_activation_results"
  """
  activatePayrollVersionsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): payrollActivationResultsAggregate!
  """
  fetch data from the table: "adjustment_rules" using primary key columns
  """
  adjustmentRuleById(
    """Unique identifier for the adjustment rule"""
    id: uuid!
  ): adjustmentRules
  """An array relationship"""
  adjustmentRules(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): [adjustmentRules!]!
  """An aggregate relationship"""
  adjustmentRulesAggregate(
    """distinct select on columns"""
    distinctOn: [adjustmentRulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [adjustmentRulesOrderBy!]
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): adjustmentRulesAggregate!
  """
  fetch data from the table in a streaming manner: "adjustment_rules"
  """
  adjustmentRulesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [adjustmentRulesStreamCursorInput]!
    """filter the rows returned"""
    where: adjustmentRulesBoolExp
  ): [adjustmentRules!]!
  """fetch data from the table: "app_settings" using primary key columns"""
  appSettingById(
    """Unique identifier for application setting"""
    id: String!
  ): appSettings
  """
  fetch data from the table: "app_settings"
  """
  appSettings(
    """distinct select on columns"""
    distinctOn: [appSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [appSettingsOrderBy!]
    """filter the rows returned"""
    where: appSettingsBoolExp
  ): [appSettings!]!
  """
  fetch aggregated fields from the table: "app_settings"
  """
  appSettingsAggregate(
    """distinct select on columns"""
    distinctOn: [appSettingsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [appSettingsOrderBy!]
    """filter the rows returned"""
    where: appSettingsBoolExp
  ): appSettingsAggregate!
  """
  fetch data from the table in a streaming manner: "app_settings"
  """
  appSettingsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [appSettingsStreamCursorInput]!
    """filter the rows returned"""
    where: appSettingsBoolExp
  ): [appSettings!]!
  """fetch data from the table: "audit.audit_log" using primary key columns"""
  auditLogById(id: uuid!): auditLogs
  """
  fetch data from the table: "audit.audit_log"
  """
  auditLogs(
    """distinct select on columns"""
    distinctOn: [auditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [auditLogsOrderBy!]
    """filter the rows returned"""
    where: auditLogsBoolExp
  ): [auditLogs!]!
  """
  fetch aggregated fields from the table: "audit.audit_log"
  """
  auditLogsAggregate(
    """distinct select on columns"""
    distinctOn: [auditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [auditLogsOrderBy!]
    """filter the rows returned"""
    where: auditLogsBoolExp
  ): auditLogsAggregate!
  """
  fetch data from the table in a streaming manner: "audit.audit_log"
  """
  auditLogsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [auditLogsStreamCursorInput]!
    """filter the rows returned"""
    where: auditLogsBoolExp
  ): [auditLogs!]!
  """
  fetch data from the table: "audit.auth_events" using primary key columns
  """
  authEventById(id: uuid!): authEvents
  """
  fetch data from the table: "audit.auth_events"
  """
  authEvents(
    """distinct select on columns"""
    distinctOn: [authEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authEventsOrderBy!]
    """filter the rows returned"""
    where: authEventsBoolExp
  ): [authEvents!]!
  """
  fetch aggregated fields from the table: "audit.auth_events"
  """
  authEventsAggregate(
    """distinct select on columns"""
    distinctOn: [authEventsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authEventsOrderBy!]
    """filter the rows returned"""
    where: authEventsBoolExp
  ): authEventsAggregate!
  """
  fetch data from the table in a streaming manner: "audit.auth_events"
  """
  authEventsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [authEventsStreamCursorInput]!
    """filter the rows returned"""
    where: authEventsBoolExp
  ): [authEvents!]!
  """
  fetch data from the table in a streaming manner: "neon_auth.users_sync"
  """
  authUsersSyncStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [authUsersSyncStreamCursorInput]!
    """filter the rows returned"""
    where: authUsersSyncBoolExp
  ): [authUsersSync!]!
  """
  fetch data from the table: "billing_event_log" using primary key columns
  """
  billingEventLogById(id: uuid!): billingEventLogs
  """An array relationship"""
  billingEventLogs(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): [billingEventLogs!]!
  """An aggregate relationship"""
  billingEventLogsAggregate(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): billingEventLogsAggregate!
  """
  fetch data from the table in a streaming manner: "billing_event_log"
  """
  billingEventLogsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [billingEventLogsStreamCursorInput]!
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): [billingEventLogs!]!
  """
  fetch data from the table: "billing_invoice"
  """
  billingInvoice(
    """distinct select on columns"""
    distinctOn: [billingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoiceOrderBy!]
    """filter the rows returned"""
    where: billingInvoiceBoolExp
  ): [billingInvoice!]!
  """
  fetch aggregated fields from the table: "billing_invoice"
  """
  billingInvoiceAggregate(
    """distinct select on columns"""
    distinctOn: [billingInvoiceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoiceOrderBy!]
    """filter the rows returned"""
    where: billingInvoiceBoolExp
  ): billingInvoiceAggregate!
  """fetch data from the table: "billing_invoice" using primary key columns"""
  billingInvoiceById(id: uuid!): billingInvoice
  """
  fetch data from the table in a streaming manner: "billing_invoice"
  """
  billingInvoiceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [billingInvoiceStreamCursorInput]!
    """filter the rows returned"""
    where: billingInvoiceBoolExp
  ): [billingInvoice!]!
  """An array relationship"""
  billingInvoices(
    """distinct select on columns"""
    distinctOn: [billingInvoicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoicesOrderBy!]
    """filter the rows returned"""
    where: billingInvoicesBoolExp
  ): [billingInvoices!]!
  """An aggregate relationship"""
  billingInvoicesAggregate(
    """distinct select on columns"""
    distinctOn: [billingInvoicesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingInvoicesOrderBy!]
    """filter the rows returned"""
    where: billingInvoicesBoolExp
  ): billingInvoicesAggregate!
  """
  fetch data from the table: "billing_invoices" using primary key columns
  """
  billingInvoicesById(id: uuid!): billingInvoices
  """
  fetch data from the table in a streaming manner: "billing_invoices"
  """
  billingInvoicesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [billingInvoicesStreamCursorInput]!
    """filter the rows returned"""
    where: billingInvoicesBoolExp
  ): [billingInvoices!]!
  """fetch data from the table: "billing_items" using primary key columns"""
  billingItemById(id: uuid!): billingItems
  """An array relationship"""
  billingItems(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): [billingItems!]!
  """An aggregate relationship"""
  billingItemsAggregate(
    """distinct select on columns"""
    distinctOn: [billingItemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingItemsOrderBy!]
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): billingItemsAggregate!
  """
  fetch data from the table in a streaming manner: "billing_items"
  """
  billingItemsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [billingItemsStreamCursorInput]!
    """filter the rows returned"""
    where: billingItemsBoolExp
  ): [billingItems!]!
  """fetch data from the table: "billing_plan" using primary key columns"""
  billingPlanById(id: uuid!): billingPlans
  """
  fetch data from the table: "billing_plan"
  """
  billingPlans(
    """distinct select on columns"""
    distinctOn: [billingPlansSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingPlansOrderBy!]
    """filter the rows returned"""
    where: billingPlansBoolExp
  ): [billingPlans!]!
  """
  fetch aggregated fields from the table: "billing_plan"
  """
  billingPlansAggregate(
    """distinct select on columns"""
    distinctOn: [billingPlansSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingPlansOrderBy!]
    """filter the rows returned"""
    where: billingPlansBoolExp
  ): billingPlansAggregate!
  """
  fetch data from the table in a streaming manner: "billing_plan"
  """
  billingPlansStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [billingPlansStreamCursorInput]!
    """filter the rows returned"""
    where: billingPlansBoolExp
  ): [billingPlans!]!
  """
  fetch data from the table: "client_billing_assignment" using primary key columns
  """
  clientBillingAssignmentById(id: uuid!): clientBillingAssignments
  """An array relationship"""
  clientBillingAssignments(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): [clientBillingAssignments!]!
  """An aggregate relationship"""
  clientBillingAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [clientBillingAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientBillingAssignmentsOrderBy!]
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): clientBillingAssignmentsAggregate!
  """
  fetch data from the table in a streaming manner: "client_billing_assignment"
  """
  clientBillingAssignmentsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [clientBillingAssignmentsStreamCursorInput]!
    """filter the rows returned"""
    where: clientBillingAssignmentsBoolExp
  ): [clientBillingAssignments!]!
  """fetch data from the table: "clients" using primary key columns"""
  clientById(
    """Unique identifier for the client"""
    id: uuid!
  ): clients
  """
  fetch data from the table: "client_external_systems" using primary key columns
  """
  clientExternalSystemById(
    """Unique identifier for the client-system mapping"""
    id: uuid!
  ): clientExternalSystems
  """An array relationship"""
  clientExternalSystems(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): [clientExternalSystems!]!
  """An aggregate relationship"""
  clientExternalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [clientExternalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientExternalSystemsOrderBy!]
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): clientExternalSystemsAggregate!
  """
  fetch data from the table in a streaming manner: "client_external_systems"
  """
  clientExternalSystemsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [clientExternalSystemsStreamCursorInput]!
    """filter the rows returned"""
    where: clientExternalSystemsBoolExp
  ): [clientExternalSystems!]!
  """
  fetch data from the table: "clients"
  """
  clients(
    """distinct select on columns"""
    distinctOn: [clientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientsOrderBy!]
    """filter the rows returned"""
    where: clientsBoolExp
  ): [clients!]!
  """
  fetch aggregated fields from the table: "clients"
  """
  clientsAggregate(
    """distinct select on columns"""
    distinctOn: [clientsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [clientsOrderBy!]
    """filter the rows returned"""
    where: clientsBoolExp
  ): clientsAggregate!
  """
  fetch data from the table in a streaming manner: "clients"
  """
  clientsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [clientsStreamCursorInput]!
    """filter the rows returned"""
    where: clientsBoolExp
  ): [clients!]!
  """
  execute function "create_payroll_version" which returns "payroll_version_results"
  """
  createPayrollVersion(
    """
    input parameters for function "createPayrollVersion"
    """
    args: createPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): [payrollVersionResults!]!
  """
  execute function "create_payroll_version" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionAggregate(
    """
    input parameters for function "createPayrollVersionAggregate"
    """
    args: createPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): payrollVersionResultsAggregate!
  """
  execute function "create_payroll_version_simple" which returns "payroll_version_results"
  """
  createPayrollVersionSimple(
    """
    input parameters for function "createPayrollVersionSimple"
    """
    args: createPayrollVersionSimpleArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): [payrollVersionResults!]!
  """
  execute function "create_payroll_version_simple" and query aggregates on result of table type "payroll_version_results"
  """
  createPayrollVersionSimpleAggregate(
    """
    input parameters for function "createPayrollVersionSimpleAggregate"
    """
    args: createPayrollVersionSimpleArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): payrollVersionResultsAggregate!
  """
  fetch data from the table: "current_payrolls"
  """
  currentPayrolls(
    """distinct select on columns"""
    distinctOn: [currentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [currentPayrollsOrderBy!]
    """filter the rows returned"""
    where: currentPayrollsBoolExp
  ): [currentPayrolls!]!
  """
  fetch aggregated fields from the table: "current_payrolls"
  """
  currentPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [currentPayrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [currentPayrollsOrderBy!]
    """filter the rows returned"""
    where: currentPayrollsBoolExp
  ): currentPayrollsAggregate!
  """
  fetch data from the table in a streaming manner: "current_payrolls"
  """
  currentPayrollsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [currentPayrollsStreamCursorInput]!
    """filter the rows returned"""
    where: currentPayrollsBoolExp
  ): [currentPayrolls!]!
  """
  fetch data from the table: "audit.data_access_log" using primary key columns
  """
  dataAccessLogById(id: uuid!): dataAccessLogs
  """
  fetch data from the table: "audit.data_access_log"
  """
  dataAccessLogs(
    """distinct select on columns"""
    distinctOn: [dataAccessLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [dataAccessLogsOrderBy!]
    """filter the rows returned"""
    where: dataAccessLogsBoolExp
  ): [dataAccessLogs!]!
  """
  fetch aggregated fields from the table: "audit.data_access_log"
  """
  dataAccessLogsAggregate(
    """distinct select on columns"""
    distinctOn: [dataAccessLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [dataAccessLogsOrderBy!]
    """filter the rows returned"""
    where: dataAccessLogsBoolExp
  ): dataAccessLogsAggregate!
  """
  fetch data from the table in a streaming manner: "audit.data_access_log"
  """
  dataAccessLogsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [dataAccessLogsStreamCursorInput]!
    """filter the rows returned"""
    where: dataAccessLogsBoolExp
  ): [dataAccessLogs!]!
  """
  fetch data from the table: "external_systems" using primary key columns
  """
  externalSystemById(
    """Unique identifier for the external system"""
    id: uuid!
  ): externalSystems
  """
  fetch data from the table: "external_systems"
  """
  externalSystems(
    """distinct select on columns"""
    distinctOn: [externalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [externalSystemsOrderBy!]
    """filter the rows returned"""
    where: externalSystemsBoolExp
  ): [externalSystems!]!
  """
  fetch aggregated fields from the table: "external_systems"
  """
  externalSystemsAggregate(
    """distinct select on columns"""
    distinctOn: [externalSystemsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [externalSystemsOrderBy!]
    """filter the rows returned"""
    where: externalSystemsBoolExp
  ): externalSystemsAggregate!
  """
  fetch data from the table in a streaming manner: "external_systems"
  """
  externalSystemsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [externalSystemsStreamCursorInput]!
    """filter the rows returned"""
    where: externalSystemsBoolExp
  ): [externalSystems!]!
  """fetch data from the table: "feature_flags" using primary key columns"""
  featureFlagById(
    """Unique identifier for the feature flag"""
    id: uuid!
  ): featureFlags
  """
  fetch data from the table: "feature_flags"
  """
  featureFlags(
    """distinct select on columns"""
    distinctOn: [featureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [featureFlagsOrderBy!]
    """filter the rows returned"""
    where: featureFlagsBoolExp
  ): [featureFlags!]!
  """
  fetch aggregated fields from the table: "feature_flags"
  """
  featureFlagsAggregate(
    """distinct select on columns"""
    distinctOn: [featureFlagsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [featureFlagsOrderBy!]
    """filter the rows returned"""
    where: featureFlagsBoolExp
  ): featureFlagsAggregate!
  """
  fetch data from the table in a streaming manner: "feature_flags"
  """
  featureFlagsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [featureFlagsStreamCursorInput]!
    """filter the rows returned"""
    where: featureFlagsBoolExp
  ): [featureFlags!]!
  """
  execute function "generate_payroll_dates" which returns "payroll_dates"
  """
  generatePayrollDates(
    """
    input parameters for function "generatePayrollDates"
    """
    args: generatePayrollDatesArgs!
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): [payrollDates!]!
  """
  execute function "generate_payroll_dates" and query aggregates on result of table type "payroll_dates"
  """
  generatePayrollDatesAggregate(
    """
    input parameters for function "generatePayrollDatesAggregate"
    """
    args: generatePayrollDatesArgs!
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): payrollDatesAggregate!
  """
  execute function "get_latest_payroll_version" which returns "latest_payroll_version_results"
  """
  getLatestPayrollVersion(
    """
    input parameters for function "getLatestPayrollVersion"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): [latestPayrollVersionResults!]!
  """
  execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results"
  """
  getLatestPayrollVersionAggregate(
    """
    input parameters for function "getLatestPayrollVersionAggregate"
    """
    args: getLatestPayrollVersionArgs!
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): latestPayrollVersionResultsAggregate!
  """
  execute function "get_payroll_version_history" which returns "payroll_version_history_results"
  """
  getPayrollVersionHistory(
    """
    input parameters for function "getPayrollVersionHistory"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): [payrollVersionHistoryResults!]!
  """
  execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results"
  """
  getPayrollVersionHistoryAggregate(
    """
    input parameters for function "getPayrollVersionHistoryAggregate"
    """
    args: getPayrollVersionHistoryArgs!
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): payrollVersionHistoryResultsAggregate!
  """fetch data from the table: "holidays" using primary key columns"""
  holidayById(
    """Unique identifier for the holiday"""
    id: uuid!
  ): holidays
  """
  fetch data from the table: "holidays"
  """
  holidays(
    """distinct select on columns"""
    distinctOn: [holidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [holidaysOrderBy!]
    """filter the rows returned"""
    where: holidaysBoolExp
  ): [holidays!]!
  """
  fetch aggregated fields from the table: "holidays"
  """
  holidaysAggregate(
    """distinct select on columns"""
    distinctOn: [holidaysSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [holidaysOrderBy!]
    """filter the rows returned"""
    where: holidaysBoolExp
  ): holidaysAggregate!
  """
  fetch data from the table in a streaming manner: "holidays"
  """
  holidaysStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [holidaysStreamCursorInput]!
    """filter the rows returned"""
    where: holidaysBoolExp
  ): [holidays!]!
  """
  fetch data from the table: "latest_payroll_version_results" using primary key columns
  """
  latestPayrollVersionResultById(id: uuid!): latestPayrollVersionResults
  """
  fetch data from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResults(
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): [latestPayrollVersionResults!]!
  """
  fetch aggregated fields from the table: "latest_payroll_version_results"
  """
  latestPayrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [latestPayrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [latestPayrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): latestPayrollVersionResultsAggregate!
  """
  fetch data from the table in a streaming manner: "latest_payroll_version_results"
  """
  latestPayrollVersionResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [latestPayrollVersionResultsStreamCursorInput]!
    """filter the rows returned"""
    where: latestPayrollVersionResultsBoolExp
  ): [latestPayrollVersionResults!]!
  """
  fetch data from the table: "leave"
  """
  leave(
    """distinct select on columns"""
    distinctOn: [leaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [leaveOrderBy!]
    """filter the rows returned"""
    where: leaveBoolExp
  ): [leave!]!
  """
  fetch aggregated fields from the table: "leave"
  """
  leaveAggregate(
    """distinct select on columns"""
    distinctOn: [leaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [leaveOrderBy!]
    """filter the rows returned"""
    where: leaveBoolExp
  ): leaveAggregate!
  """fetch data from the table: "leave" using primary key columns"""
  leaveById(
    """Unique identifier for the leave record"""
    id: uuid!
  ): leave
  """
  fetch data from the table in a streaming manner: "leave"
  """
  leaveStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [leaveStreamCursorInput]!
    """filter the rows returned"""
    where: leaveBoolExp
  ): [leave!]!
  """fetch data from the table: "notes" using primary key columns"""
  noteById(
    """Unique identifier for the note"""
    id: uuid!
  ): notes
  """
  fetch data from the table: "notes"
  """
  notes(
    """distinct select on columns"""
    distinctOn: [notesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [notesOrderBy!]
    """filter the rows returned"""
    where: notesBoolExp
  ): [notes!]!
  """
  fetch aggregated fields from the table: "notes"
  """
  notesAggregate(
    """distinct select on columns"""
    distinctOn: [notesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [notesOrderBy!]
    """filter the rows returned"""
    where: notesBoolExp
  ): notesAggregate!
  """
  fetch data from the table in a streaming manner: "notes"
  """
  notesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [notesStreamCursorInput]!
    """filter the rows returned"""
    where: notesBoolExp
  ): [notes!]!
  """
  fetch data from the table: "payroll_activation_results" using primary key columns
  """
  payrollActivationResultById(id: uuid!): payrollActivationResults
  """
  fetch data from the table: "payroll_activation_results"
  """
  payrollActivationResults(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): [payrollActivationResults!]!
  """
  fetch aggregated fields from the table: "payroll_activation_results"
  """
  payrollActivationResultsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollActivationResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollActivationResultsOrderBy!]
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): payrollActivationResultsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_activation_results"
  """
  payrollActivationResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollActivationResultsStreamCursorInput]!
    """filter the rows returned"""
    where: payrollActivationResultsBoolExp
  ): [payrollActivationResults!]!
  """
  fetch data from the table: "payroll_assignment_audit" using primary key columns
  """
  payrollAssignmentAuditById(id: uuid!): payrollAssignmentAudits
  """An array relationship"""
  payrollAssignmentAudits(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """An aggregate relationship"""
  payrollAssignmentAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): payrollAssignmentAuditsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_assignment_audit"
  """
  payrollAssignmentAuditsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollAssignmentAuditsStreamCursorInput]!
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """
  fetch data from the table: "payroll_assignments" using primary key columns
  """
  payrollAssignmentById(id: uuid!): payrollAssignments
  """
  fetch data from the table: "payroll_assignments"
  """
  payrollAssignments(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): [payrollAssignments!]!
  """
  fetch aggregated fields from the table: "payroll_assignments"
  """
  payrollAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): payrollAssignmentsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_assignments"
  """
  payrollAssignmentsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollAssignmentsStreamCursorInput]!
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): [payrollAssignments!]!
  """fetch data from the table: "payrolls" using primary key columns"""
  payrollById(
    """Unique identifier for the payroll"""
    id: uuid!
  ): payrolls
  """fetch data from the table: "payroll_cycles" using primary key columns"""
  payrollCycleById(
    """Unique identifier for the payroll cycle"""
    id: uuid!
  ): payrollCycles
  """
  fetch data from the table: "payroll_cycles"
  """
  payrollCycles(
    """distinct select on columns"""
    distinctOn: [payrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollCyclesOrderBy!]
    """filter the rows returned"""
    where: payrollCyclesBoolExp
  ): [payrollCycles!]!
  """
  fetch aggregated fields from the table: "payroll_cycles"
  """
  payrollCyclesAggregate(
    """distinct select on columns"""
    distinctOn: [payrollCyclesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollCyclesOrderBy!]
    """filter the rows returned"""
    where: payrollCyclesBoolExp
  ): payrollCyclesAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_cycles"
  """
  payrollCyclesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollCyclesStreamCursorInput]!
    """filter the rows returned"""
    where: payrollCyclesBoolExp
  ): [payrollCycles!]!
  """
  fetch data from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStats(
    """distinct select on columns"""
    distinctOn: [payrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: payrollDashboardStatsBoolExp
  ): [payrollDashboardStats!]!
  """
  fetch aggregated fields from the table: "payroll_dashboard_stats"
  """
  payrollDashboardStatsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollDashboardStatsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDashboardStatsOrderBy!]
    """filter the rows returned"""
    where: payrollDashboardStatsBoolExp
  ): payrollDashboardStatsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_dashboard_stats"
  """
  payrollDashboardStatsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollDashboardStatsStreamCursorInput]!
    """filter the rows returned"""
    where: payrollDashboardStatsBoolExp
  ): [payrollDashboardStats!]!
  """fetch data from the table: "payroll_dates" using primary key columns"""
  payrollDateById(
    """Unique identifier for the payroll date"""
    id: uuid!
  ): payrollDates
  """
  fetch data from the table: "payroll_date_types" using primary key columns
  """
  payrollDateTypeById(
    """Unique identifier for the payroll date type"""
    id: uuid!
  ): payrollDateTypes
  """
  fetch data from the table: "payroll_date_types"
  """
  payrollDateTypes(
    """distinct select on columns"""
    distinctOn: [payrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: payrollDateTypesBoolExp
  ): [payrollDateTypes!]!
  """
  fetch aggregated fields from the table: "payroll_date_types"
  """
  payrollDateTypesAggregate(
    """distinct select on columns"""
    distinctOn: [payrollDateTypesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDateTypesOrderBy!]
    """filter the rows returned"""
    where: payrollDateTypesBoolExp
  ): payrollDateTypesAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_date_types"
  """
  payrollDateTypesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollDateTypesStreamCursorInput]!
    """filter the rows returned"""
    where: payrollDateTypesBoolExp
  ): [payrollDateTypes!]!
  """An array relationship"""
  payrollDates(
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): [payrollDates!]!
  """An aggregate relationship"""
  payrollDatesAggregate(
    """distinct select on columns"""
    distinctOn: [payrollDatesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollDatesOrderBy!]
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): payrollDatesAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_dates"
  """
  payrollDatesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollDatesStreamCursorInput]!
    """filter the rows returned"""
    where: payrollDatesBoolExp
  ): [payrollDates!]!
  """
  fetch data from the table: "payroll_triggers_status"
  """
  payrollTriggersStatus(
    """distinct select on columns"""
    distinctOn: [payrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: payrollTriggersStatusBoolExp
  ): [payrollTriggersStatus!]!
  """
  fetch aggregated fields from the table: "payroll_triggers_status"
  """
  payrollTriggersStatusAggregate(
    """distinct select on columns"""
    distinctOn: [payrollTriggersStatusSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollTriggersStatusOrderBy!]
    """filter the rows returned"""
    where: payrollTriggersStatusBoolExp
  ): payrollTriggersStatusAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_triggers_status"
  """
  payrollTriggersStatusStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollTriggersStatusStreamCursorInput]!
    """filter the rows returned"""
    where: payrollTriggersStatusBoolExp
  ): [payrollTriggersStatus!]!
  """
  fetch data from the table: "payroll_version_history_results" using primary key columns
  """
  payrollVersionHistoryResultById(id: uuid!): payrollVersionHistoryResults
  """
  fetch data from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResults(
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): [payrollVersionHistoryResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_history_results"
  """
  payrollVersionHistoryResultsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollVersionHistoryResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionHistoryResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): payrollVersionHistoryResultsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_version_history_results"
  """
  payrollVersionHistoryResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollVersionHistoryResultsStreamCursorInput]!
    """filter the rows returned"""
    where: payrollVersionHistoryResultsBoolExp
  ): [payrollVersionHistoryResults!]!
  """
  fetch data from the table: "payroll_version_results" using primary key columns
  """
  payrollVersionResultById(id: uuid!): payrollVersionResults
  """
  fetch data from the table: "payroll_version_results"
  """
  payrollVersionResults(
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): [payrollVersionResults!]!
  """
  fetch aggregated fields from the table: "payroll_version_results"
  """
  payrollVersionResultsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollVersionResultsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollVersionResultsOrderBy!]
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): payrollVersionResultsAggregate!
  """
  fetch data from the table in a streaming manner: "payroll_version_results"
  """
  payrollVersionResultsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollVersionResultsStreamCursorInput]!
    """filter the rows returned"""
    where: payrollVersionResultsBoolExp
  ): [payrollVersionResults!]!
  """An array relationship"""
  payrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  payrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """
  fetch data from the table in a streaming manner: "payrolls"
  """
  payrollsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [payrollsStreamCursorInput]!
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """
  fetch data from the table: "permission_audit_log" using primary key columns
  """
  permissionAuditLogById(id: uuid!): permissionAuditLogs
  """
  fetch data from the table: "permission_audit_log"
  """
  permissionAuditLogs(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): [permissionAuditLogs!]!
  """
  fetch aggregated fields from the table: "permission_audit_log"
  """
  permissionAuditLogsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): permissionAuditLogsAggregate!
  """
  fetch data from the table in a streaming manner: "permission_audit_log"
  """
  permissionAuditLogsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [permissionAuditLogsStreamCursorInput]!
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): [permissionAuditLogs!]!
  """fetch data from the table: "permissions" using primary key columns"""
  permissionById(id: uuid!): permissions
  """
  fetch data from the table: "audit.permission_changes" using primary key columns
  """
  permissionChangeById(id: uuid!): permissionChanges
  """
  fetch data from the table: "audit.permission_changes"
  """
  permissionChanges(
    """distinct select on columns"""
    distinctOn: [permissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionChangesOrderBy!]
    """filter the rows returned"""
    where: permissionChangesBoolExp
  ): [permissionChanges!]!
  """
  fetch aggregated fields from the table: "audit.permission_changes"
  """
  permissionChangesAggregate(
    """distinct select on columns"""
    distinctOn: [permissionChangesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionChangesOrderBy!]
    """filter the rows returned"""
    where: permissionChangesBoolExp
  ): permissionChangesAggregate!
  """
  fetch data from the table in a streaming manner: "audit.permission_changes"
  """
  permissionChangesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [permissionChangesStreamCursorInput]!
    """filter the rows returned"""
    where: permissionChangesBoolExp
  ): [permissionChanges!]!
  """
  fetch data from the table: "permission_overrides" using primary key columns
  """
  permissionOverrideById(id: uuid!): permissionOverrides
  """
  fetch data from the table: "permission_overrides"
  """
  permissionOverrides(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): [permissionOverrides!]!
  """
  fetch aggregated fields from the table: "permission_overrides"
  """
  permissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): permissionOverridesAggregate!
  """
  fetch data from the table in a streaming manner: "permission_overrides"
  """
  permissionOverridesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [permissionOverridesStreamCursorInput]!
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): [permissionOverrides!]!
  """
  fetch data from the table: "audit.permission_usage_report"
  """
  permissionUsageReports(
    """distinct select on columns"""
    distinctOn: [permissionUsageReportsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionUsageReportsOrderBy!]
    """filter the rows returned"""
    where: permissionUsageReportsBoolExp
  ): [permissionUsageReports!]!
  """
  fetch aggregated fields from the table: "audit.permission_usage_report"
  """
  permissionUsageReportsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionUsageReportsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionUsageReportsOrderBy!]
    """filter the rows returned"""
    where: permissionUsageReportsBoolExp
  ): permissionUsageReportsAggregate!
  """
  fetch data from the table in a streaming manner: "audit.permission_usage_report"
  """
  permissionUsageReportsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [permissionUsageReportsStreamCursorInput]!
    """filter the rows returned"""
    where: permissionUsageReportsBoolExp
  ): [permissionUsageReports!]!
  """
  fetch data from the table: "permissions"
  """
  permissions(
    """distinct select on columns"""
    distinctOn: [permissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionsOrderBy!]
    """filter the rows returned"""
    where: permissionsBoolExp
  ): [permissions!]!
  """
  fetch aggregated fields from the table: "permissions"
  """
  permissionsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionsOrderBy!]
    """filter the rows returned"""
    where: permissionsBoolExp
  ): permissionsAggregate!
  """
  fetch data from the table in a streaming manner: "permissions"
  """
  permissionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [permissionsStreamCursorInput]!
    """filter the rows returned"""
    where: permissionsBoolExp
  ): [permissions!]!
  """fetch data from the table: "resources" using primary key columns"""
  resourceById(id: uuid!): resources
  """
  fetch data from the table: "resources"
  """
  resources(
    """distinct select on columns"""
    distinctOn: [resourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [resourcesOrderBy!]
    """filter the rows returned"""
    where: resourcesBoolExp
  ): [resources!]!
  """
  fetch aggregated fields from the table: "resources"
  """
  resourcesAggregate(
    """distinct select on columns"""
    distinctOn: [resourcesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [resourcesOrderBy!]
    """filter the rows returned"""
    where: resourcesBoolExp
  ): resourcesAggregate!
  """
  fetch data from the table in a streaming manner: "resources"
  """
  resourcesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [resourcesStreamCursorInput]!
    """filter the rows returned"""
    where: resourcesBoolExp
  ): [resources!]!
  """fetch data from the table: "roles" using primary key columns"""
  roleById(id: uuid!): roles
  """
  fetch data from the table: "role_permissions" using primary key columns
  """
  rolePermissionById(id: uuid!): rolePermissions
  """
  fetch data from the table: "role_permissions"
  """
  rolePermissions(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): [rolePermissions!]!
  """
  fetch aggregated fields from the table: "role_permissions"
  """
  rolePermissionsAggregate(
    """distinct select on columns"""
    distinctOn: [rolePermissionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolePermissionsOrderBy!]
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): rolePermissionsAggregate!
  """
  fetch data from the table in a streaming manner: "role_permissions"
  """
  rolePermissionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [rolePermissionsStreamCursorInput]!
    """filter the rows returned"""
    where: rolePermissionsBoolExp
  ): [rolePermissions!]!
  """
  fetch data from the table: "roles"
  """
  roles(
    """distinct select on columns"""
    distinctOn: [rolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolesOrderBy!]
    """filter the rows returned"""
    where: rolesBoolExp
  ): [roles!]!
  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """distinct select on columns"""
    distinctOn: [rolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [rolesOrderBy!]
    """filter the rows returned"""
    where: rolesBoolExp
  ): rolesAggregate!
  """
  fetch data from the table in a streaming manner: "roles"
  """
  rolesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [rolesStreamCursorInput]!
    """filter the rows returned"""
    where: rolesBoolExp
  ): [roles!]!
  """
  fetch data from the table: "audit.slow_queries"
  """
  slowQueries(
    """distinct select on columns"""
    distinctOn: [slowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [slowQueriesOrderBy!]
    """filter the rows returned"""
    where: slowQueriesBoolExp
  ): [slowQueries!]!
  """
  fetch aggregated fields from the table: "audit.slow_queries"
  """
  slowQueriesAggregate(
    """distinct select on columns"""
    distinctOn: [slowQueriesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [slowQueriesOrderBy!]
    """filter the rows returned"""
    where: slowQueriesBoolExp
  ): slowQueriesAggregate!
  """
  fetch data from the table in a streaming manner: "audit.slow_queries"
  """
  slowQueriesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [slowQueriesStreamCursorInput]!
    """filter the rows returned"""
    where: slowQueriesBoolExp
  ): [slowQueries!]!
  """
  fetch data from the table: "audit.slow_queries" using primary key columns
  """
  slowQueryById(id: uuid!): slowQueries
  """
  fetch data from the table: "audit.user_access_summary"
  """
  userAccessSummaries(
    """distinct select on columns"""
    distinctOn: [userAccessSummariesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userAccessSummariesOrderBy!]
    """filter the rows returned"""
    where: userAccessSummariesBoolExp
  ): [userAccessSummaries!]!
  """
  fetch aggregated fields from the table: "audit.user_access_summary"
  """
  userAccessSummariesAggregate(
    """distinct select on columns"""
    distinctOn: [userAccessSummariesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userAccessSummariesOrderBy!]
    """filter the rows returned"""
    where: userAccessSummariesBoolExp
  ): userAccessSummariesAggregate!
  """
  fetch data from the table in a streaming manner: "audit.user_access_summary"
  """
  userAccessSummariesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [userAccessSummariesStreamCursorInput]!
    """filter the rows returned"""
    where: userAccessSummariesBoolExp
  ): [userAccessSummaries!]!
  """fetch data from the table: "users" using primary key columns"""
  userById(
    """Unique identifier for the user"""
    id: uuid!
  ): users
  """
  fetch data from the table: "user_invitations" using primary key columns
  """
  userInvitationById(id: uuid!): userInvitations
  """
  fetch data from the table: "user_invitations"
  """
  userInvitations(
    """distinct select on columns"""
    distinctOn: [userInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userInvitationsOrderBy!]
    """filter the rows returned"""
    where: userInvitationsBoolExp
  ): [userInvitations!]!
  """
  fetch aggregated fields from the table: "user_invitations"
  """
  userInvitationsAggregate(
    """distinct select on columns"""
    distinctOn: [userInvitationsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userInvitationsOrderBy!]
    """filter the rows returned"""
    where: userInvitationsBoolExp
  ): userInvitationsAggregate!
  """
  fetch data from the table in a streaming manner: "user_invitations"
  """
  userInvitationsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [userInvitationsStreamCursorInput]!
    """filter the rows returned"""
    where: userInvitationsBoolExp
  ): [userInvitations!]!
  """fetch data from the table: "user_roles" using primary key columns"""
  userRoleById(id: uuid!): userRoles
  """
  fetch data from the table: "user_roles"
  """
  userRoles(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): [userRoles!]!
  """
  fetch aggregated fields from the table: "user_roles"
  """
  userRolesAggregate(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): userRolesAggregate!
  """
  fetch data from the table in a streaming manner: "user_roles"
  """
  userRolesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [userRolesStreamCursorInput]!
    """filter the rows returned"""
    where: userRolesBoolExp
  ): [userRoles!]!
  """
  fetch data from the table: "neon_auth.users_sync" using primary key columns
  """
  userSyncById(
    """Unique identifier from the authentication provider"""
    id: String!
  ): authUsersSync
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): usersAggregate!
  """
  fetch data from the table in a streaming manner: "users_role_backup"
  """
  usersRoleBackupStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [usersRoleBackupStreamCursorInput]!
    """filter the rows returned"""
    where: usersRoleBackupBoolExp
  ): [usersRoleBackup!]!
  """
  fetch data from the table: "users_role_backup"
  """
  usersRoleBackups(
    """distinct select on columns"""
    distinctOn: [usersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: usersRoleBackupBoolExp
  ): [usersRoleBackup!]!
  """
  fetch aggregated fields from the table: "users_role_backup"
  """
  usersRoleBackupsAggregate(
    """distinct select on columns"""
    distinctOn: [usersRoleBackupSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersRoleBackupOrderBy!]
    """filter the rows returned"""
    where: usersRoleBackupBoolExp
  ): usersRoleBackupAggregate!
  """
  fetch data from the table in a streaming manner: "users"
  """
  usersStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [usersStreamCursorInput]!
    """filter the rows returned"""
    where: usersBoolExp
  ): [users!]!
  """
  fetch data from the table: "neon_auth.users_sync"
  """
  usersSync(
    """distinct select on columns"""
    distinctOn: [authUsersSyncSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authUsersSyncOrderBy!]
    """filter the rows returned"""
    where: authUsersSyncBoolExp
  ): [authUsersSync!]!
  """
  fetch aggregated fields from the table: "neon_auth.users_sync"
  """
  usersSyncAggregate(
    """distinct select on columns"""
    distinctOn: [authUsersSyncSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [authUsersSyncOrderBy!]
    """filter the rows returned"""
    where: authUsersSyncBoolExp
  ): authUsersSyncAggregate!
  """fetch data from the table: "work_schedule" using primary key columns"""
  workScheduleById(
    """Unique identifier for the work schedule entry"""
    id: uuid!
  ): workSchedules
  """
  fetch data from the table: "work_schedule"
  """
  workSchedules(
    """distinct select on columns"""
    distinctOn: [workSchedulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [workSchedulesOrderBy!]
    """filter the rows returned"""
    where: workSchedulesBoolExp
  ): [workSchedules!]!
  """
  fetch aggregated fields from the table: "work_schedule"
  """
  workSchedulesAggregate(
    """distinct select on columns"""
    distinctOn: [workSchedulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [workSchedulesOrderBy!]
    """filter the rows returned"""
    where: workSchedulesBoolExp
  ): workSchedulesAggregate!
  """
  fetch data from the table in a streaming manner: "work_schedule"
  """
  workSchedulesStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [workSchedulesStreamCursorInput]!
    """filter the rows returned"""
    where: workSchedulesBoolExp
  ): [workSchedules!]!
}

scalar timestamp

scalar timestamptz

"""
columns and relationships of "audit.user_access_summary"
"""
type userAccessSummaries {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""
aggregated selection of "audit.user_access_summary"
"""
type userAccessSummariesAggregate {
  aggregate: userAccessSummariesAggregateFields
  nodes: [userAccessSummaries!]!
}

"""
aggregate fields of "audit.user_access_summary"
"""
type userAccessSummariesAggregateFields {
  count(columns: [userAccessSummariesSelectColumn!], distinct: Boolean): Int!
  max: userAccessSummariesMaxFields
  min: userAccessSummariesMinFields
}

"""
Boolean expression to filter rows from the table "audit.user_access_summary". All fields are combined with a logical 'AND'.
"""
input userAccessSummariesBoolExp {
  _and: [userAccessSummariesBoolExp!]
  _not: userAccessSummariesBoolExp
  _or: [userAccessSummariesBoolExp!]
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  isStaff: BooleanComparisonExp
  name: StringComparisonExp
  role: UserRoleComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
input type for inserting data into table "audit.user_access_summary"
"""
input userAccessSummariesInsertInput {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type userAccessSummariesMaxFields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type userAccessSummariesMinFields {
  createdAt: timestamptz
  email: String
  id: uuid
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""
response of any mutation on the table "audit.user_access_summary"
"""
type userAccessSummariesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [userAccessSummaries!]!
}

"""Ordering options when selecting data from "audit.user_access_summary"."""
input userAccessSummariesOrderBy {
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  isActive: OrderBy
  isStaff: OrderBy
  name: OrderBy
  role: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "audit.user_access_summary"
"""
enum userAccessSummariesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  id
  """column name"""
  isActive
  """column name"""
  isStaff
  """column name"""
  name
  """column name"""
  role
  """column name"""
  updatedAt
}

"""
input type for updating data in table "audit.user_access_summary"
"""
input userAccessSummariesSetInput {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "userAccessSummaries"
"""
input userAccessSummariesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: userAccessSummariesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input userAccessSummariesStreamCursorValueInput {
  createdAt: timestamptz
  email: String
  id: uuid
  isActive: Boolean
  isStaff: Boolean
  name: String
  role: user_role
  updatedAt: timestamptz
}

input userAccessSummariesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: userAccessSummariesSetInput
  """filter the rows which have to be updated"""
  where: userAccessSummariesBoolExp!
}

"""
Stores invitation metadata for two-stage user invitation flow with role-based access control
"""
type userInvitations {
  acceptedAt: timestamptz
  acceptedBy: uuid
  """An object relationship"""
  acceptedByUser: users
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz!
  email: String!
  expiresAt: timestamptz!
  firstName: String!
  id: uuid!
  invitationMetadata(
    """JSON select path"""
    path: String
  ): jsonb
  invitedAt: timestamptz!
  invitedBy: uuid!
  """An object relationship"""
  invitedByUser: users
  invitedRole: String!
  lastName: String!
  managerId: uuid
  """An object relationship"""
  managerUser: users
  status: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "user_invitations"
"""
type userInvitationsAggregate {
  aggregate: userInvitationsAggregateFields
  nodes: [userInvitations!]!
}

"""
aggregate fields of "user_invitations"
"""
type userInvitationsAggregateFields {
  count(columns: [userInvitationsSelectColumn!], distinct: Boolean): Int!
  max: userInvitationsMaxFields
  min: userInvitationsMinFields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input userInvitationsAppendInput {
  invitationMetadata: jsonb
}

"""
Boolean expression to filter rows from the table "user_invitations". All fields are combined with a logical 'AND'.
"""
input userInvitationsBoolExp {
  _and: [userInvitationsBoolExp!]
  _not: userInvitationsBoolExp
  _or: [userInvitationsBoolExp!]
  acceptedAt: TimestamptzComparisonExp
  acceptedBy: UuidComparisonExp
  acceptedByUser: usersBoolExp
  clerkInvitationId: StringComparisonExp
  clerkTicket: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  firstName: StringComparisonExp
  id: UuidComparisonExp
  invitationMetadata: JsonbComparisonExp
  invitedAt: TimestamptzComparisonExp
  invitedBy: UuidComparisonExp
  invitedByUser: usersBoolExp
  invitedRole: StringComparisonExp
  lastName: StringComparisonExp
  managerId: UuidComparisonExp
  managerUser: usersBoolExp
  status: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
unique or primary key constraints on table "user_invitations"
"""
enum userInvitationsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_invitations_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input userInvitationsDeleteAtPathInput {
  invitationMetadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input userInvitationsDeleteElemInput {
  invitationMetadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input userInvitationsDeleteKeyInput {
  invitationMetadata: String
}

"""
input type for inserting data into table "user_invitations"
"""
input userInvitationsInsertInput {
  acceptedAt: timestamptz
  acceptedBy: uuid
  acceptedByUser: usersObjRelInsertInput
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationMetadata: jsonb
  invitedAt: timestamptz
  invitedBy: uuid
  invitedByUser: usersObjRelInsertInput
  invitedRole: String
  lastName: String
  managerId: uuid
  managerUser: usersObjRelInsertInput
  status: String
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type userInvitationsMaxFields {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  status: String
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type userInvitationsMinFields {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  status: String
  updatedAt: timestamptz
}

"""
response of any mutation on the table "user_invitations"
"""
type userInvitationsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [userInvitations!]!
}

"""
on_conflict condition type for table "user_invitations"
"""
input userInvitationsOnConflict {
  constraint: userInvitationsConstraint!
  updateColumns: [userInvitationsUpdateColumn!]! = []
  where: userInvitationsBoolExp
}

"""Ordering options when selecting data from "user_invitations"."""
input userInvitationsOrderBy {
  acceptedAt: OrderBy
  acceptedBy: OrderBy
  acceptedByUser: usersOrderBy
  clerkInvitationId: OrderBy
  clerkTicket: OrderBy
  createdAt: OrderBy
  email: OrderBy
  expiresAt: OrderBy
  firstName: OrderBy
  id: OrderBy
  invitationMetadata: OrderBy
  invitedAt: OrderBy
  invitedBy: OrderBy
  invitedByUser: usersOrderBy
  invitedRole: OrderBy
  lastName: OrderBy
  managerId: OrderBy
  managerUser: usersOrderBy
  status: OrderBy
  updatedAt: OrderBy
}

"""primary key columns input for table: user_invitations"""
input userInvitationsPkColumnsInput {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input userInvitationsPrependInput {
  invitationMetadata: jsonb
}

"""
select columns of table "user_invitations"
"""
enum userInvitationsSelectColumn {
  """column name"""
  acceptedAt
  """column name"""
  acceptedBy
  """column name"""
  clerkInvitationId
  """column name"""
  clerkTicket
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  expiresAt
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  invitationMetadata
  """column name"""
  invitedAt
  """column name"""
  invitedBy
  """column name"""
  invitedRole
  """column name"""
  lastName
  """column name"""
  managerId
  """column name"""
  status
  """column name"""
  updatedAt
}

"""
input type for updating data in table "user_invitations"
"""
input userInvitationsSetInput {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationMetadata: jsonb
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  status: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "userInvitations"
"""
input userInvitationsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: userInvitationsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input userInvitationsStreamCursorValueInput {
  acceptedAt: timestamptz
  acceptedBy: uuid
  clerkInvitationId: String
  clerkTicket: String
  createdAt: timestamptz
  email: String
  expiresAt: timestamptz
  firstName: String
  id: uuid
  invitationMetadata: jsonb
  invitedAt: timestamptz
  invitedBy: uuid
  invitedRole: String
  lastName: String
  managerId: uuid
  status: String
  updatedAt: timestamptz
}

"""
update columns of table "user_invitations"
"""
enum userInvitationsUpdateColumn {
  """column name"""
  acceptedAt
  """column name"""
  acceptedBy
  """column name"""
  clerkInvitationId
  """column name"""
  clerkTicket
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  expiresAt
  """column name"""
  firstName
  """column name"""
  id
  """column name"""
  invitationMetadata
  """column name"""
  invitedAt
  """column name"""
  invitedBy
  """column name"""
  invitedRole
  """column name"""
  lastName
  """column name"""
  managerId
  """column name"""
  status
  """column name"""
  updatedAt
}

input userInvitationsUpdates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: userInvitationsAppendInput
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: userInvitationsDeleteAtPathInput
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: userInvitationsDeleteElemInput
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: userInvitationsDeleteKeyInput
  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: userInvitationsPrependInput
  """sets the columns of the filtered rows to the given values"""
  _set: userInvitationsSetInput
  """filter the rows which have to be updated"""
  where: userInvitationsBoolExp!
}

"""
columns and relationships of "user_roles"
"""
type userRoles {
  """An object relationship"""
  assignedRole: roles!
  createdAt: timestamptz!
  id: uuid!
  roleId: uuid!
  """An object relationship"""
  roleUser: users!
  updatedAt: timestamptz!
  userId: uuid!
}

"""
aggregated selection of "user_roles"
"""
type userRolesAggregate {
  aggregate: userRolesAggregateFields
  nodes: [userRoles!]!
}

input userRolesAggregateBoolExp {
  count: userRolesAggregateBoolExpCount
}

input userRolesAggregateBoolExpCount {
  arguments: [userRolesSelectColumn!]
  distinct: Boolean
  filter: userRolesBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "user_roles"
"""
type userRolesAggregateFields {
  count(columns: [userRolesSelectColumn!], distinct: Boolean): Int!
  max: userRolesMaxFields
  min: userRolesMinFields
}

"""
order by aggregate values of table "user_roles"
"""
input userRolesAggregateOrderBy {
  count: OrderBy
  max: userRolesMaxOrderBy
  min: userRolesMinOrderBy
}

"""
input type for inserting array relation for remote table "user_roles"
"""
input userRolesArrRelInsertInput {
  data: [userRolesInsertInput!]!
  """upsert condition"""
  onConflict: userRolesOnConflict
}

"""
Boolean expression to filter rows from the table "user_roles". All fields are combined with a logical 'AND'.
"""
input userRolesBoolExp {
  _and: [userRolesBoolExp!]
  _not: userRolesBoolExp
  _or: [userRolesBoolExp!]
  assignedRole: rolesBoolExp
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  roleId: UuidComparisonExp
  roleUser: usersBoolExp
  updatedAt: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_roles"
"""
enum userRolesConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey
  """
  unique or primary key constraint on columns "user_id", "role_id"
  """
  user_roles_user_id_role_id_key
}

"""
input type for inserting data into table "user_roles"
"""
input userRolesInsertInput {
  assignedRole: rolesObjRelInsertInput
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  roleUser: usersObjRelInsertInput
  updatedAt: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type userRolesMaxFields {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "user_roles"
"""
input userRolesMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type userRolesMinFields {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "user_roles"
"""
input userRolesMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  roleId: OrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_roles"
"""
type userRolesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [userRoles!]!
}

"""
on_conflict condition type for table "user_roles"
"""
input userRolesOnConflict {
  constraint: userRolesConstraint!
  updateColumns: [userRolesUpdateColumn!]! = []
  where: userRolesBoolExp
}

"""Ordering options when selecting data from "user_roles"."""
input userRolesOrderBy {
  assignedRole: rolesOrderBy
  createdAt: OrderBy
  id: OrderBy
  roleId: OrderBy
  roleUser: usersOrderBy
  updatedAt: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_roles"""
input userRolesPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user_roles"
"""
enum userRolesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  roleId
  """column name"""
  updatedAt
  """column name"""
  userId
}

"""
input type for updating data in table "user_roles"
"""
input userRolesSetInput {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "userRoles"
"""
input userRolesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: userRolesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input userRolesStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  roleId: uuid
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "user_roles"
"""
enum userRolesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  roleId
  """column name"""
  updatedAt
  """column name"""
  userId
}

input userRolesUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: userRolesSetInput
  """filter the rows which have to be updated"""
  where: userRolesBoolExp!
}

scalar user_role

"""
columns and relationships of "users"
"""
type users {
  """An array relationship"""
  assignedRoles(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): [userRoles!]!
  """An aggregate relationship"""
  assignedRolesAggregate(
    """distinct select on columns"""
    distinctOn: [userRolesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [userRolesOrderBy!]
    """filter the rows returned"""
    where: userRolesBoolExp
  ): userRolesAggregate!
  """An array relationship"""
  authoredNotes(
    """distinct select on columns"""
    distinctOn: [notesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [notesOrderBy!]
    """filter the rows returned"""
    where: notesBoolExp
  ): [notes!]!
  """An aggregate relationship"""
  authoredNotesAggregate(
    """distinct select on columns"""
    distinctOn: [notesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [notesOrderBy!]
    """filter the rows returned"""
    where: notesBoolExp
  ): notesAggregate!
  """An array relationship"""
  backupConsultantPayrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  backupConsultantPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  """An array relationship"""
  consultantAssignments(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): [payrollAssignments!]!
  """An aggregate relationship"""
  consultantAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): payrollAssignmentsAggregate!
  """An array relationship"""
  createdAssignmentAudits(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """An aggregate relationship"""
  createdAssignmentAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): payrollAssignmentAuditsAggregate!
  """An array relationship"""
  createdAssignments(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): [payrollAssignments!]!
  """An aggregate relationship"""
  createdAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): payrollAssignmentsAggregate!
  """Timestamp when the user was created"""
  createdAt: timestamptz
  """An array relationship"""
  createdBillingEvents(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): [billingEventLogs!]!
  """An aggregate relationship"""
  createdBillingEventsAggregate(
    """distinct select on columns"""
    distinctOn: [billingEventLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [billingEventLogsOrderBy!]
    """filter the rows returned"""
    where: billingEventLogsBoolExp
  ): billingEventLogsAggregate!
  """An array relationship"""
  createdPermissionOverrides(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): [permissionOverrides!]!
  """An aggregate relationship"""
  createdPermissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): permissionOverridesAggregate!
  deactivatedAt: timestamptz
  deactivatedBy: String
  """User's email address (unique)"""
  email: String!
  """Unique identifier for the user"""
  id: uuid!
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  """An array relationship"""
  managedPayrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  managedPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """An array relationship"""
  managedTeamMembers(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): [users!]!
  """An aggregate relationship"""
  managedTeamMembersAggregate(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): usersAggregate!
  """An array relationship"""
  managedUsers(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): [users!]!
  """An aggregate relationship"""
  managedUsersAggregate(
    """distinct select on columns"""
    distinctOn: [usersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [usersOrderBy!]
    """filter the rows returned"""
    where: usersBoolExp
  ): usersAggregate!
  """Reference to the user's manager"""
  managerId: uuid
  """An object relationship"""
  managerUser: users
  """User's full name"""
  name: String!
  """An array relationship"""
  newConsultantAuditTrail(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """An aggregate relationship"""
  newConsultantAuditTrailAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): payrollAssignmentAuditsAggregate!
  """An array relationship"""
  originalConsultantAssignments(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): [payrollAssignments!]!
  """An aggregate relationship"""
  originalConsultantAssignmentsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentsBoolExp
  ): payrollAssignmentsAggregate!
  """An array relationship"""
  originalConsultantAuditTrail(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): [payrollAssignmentAudits!]!
  """An aggregate relationship"""
  originalConsultantAuditTrailAggregate(
    """distinct select on columns"""
    distinctOn: [payrollAssignmentAuditsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollAssignmentAuditsOrderBy!]
    """filter the rows returned"""
    where: payrollAssignmentAuditsBoolExp
  ): payrollAssignmentAuditsAggregate!
  """An array relationship"""
  primaryConsultantPayrolls(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): [payrolls!]!
  """An aggregate relationship"""
  primaryConsultantPayrollsAggregate(
    """distinct select on columns"""
    distinctOn: [payrollsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [payrollsOrderBy!]
    """filter the rows returned"""
    where: payrollsBoolExp
  ): payrollsAggregate!
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role!
  """An array relationship"""
  targetedPermissionAudits(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): [permissionAuditLogs!]!
  """An aggregate relationship"""
  targetedPermissionAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): permissionAuditLogsAggregate!
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """An array relationship"""
  userLeaveRecords(
    """distinct select on columns"""
    distinctOn: [leaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [leaveOrderBy!]
    """filter the rows returned"""
    where: leaveBoolExp
  ): [leave!]!
  """An aggregate relationship"""
  userLeaveRecordsAggregate(
    """distinct select on columns"""
    distinctOn: [leaveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [leaveOrderBy!]
    """filter the rows returned"""
    where: leaveBoolExp
  ): leaveAggregate!
  """An array relationship"""
  userPermissionAudits(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): [permissionAuditLogs!]!
  """An aggregate relationship"""
  userPermissionAuditsAggregate(
    """distinct select on columns"""
    distinctOn: [permissionAuditLogsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionAuditLogsOrderBy!]
    """filter the rows returned"""
    where: permissionAuditLogsBoolExp
  ): permissionAuditLogsAggregate!
  """An array relationship"""
  userPermissionOverrides(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): [permissionOverrides!]!
  """An aggregate relationship"""
  userPermissionOverridesAggregate(
    """distinct select on columns"""
    distinctOn: [permissionOverridesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [permissionOverridesOrderBy!]
    """filter the rows returned"""
    where: permissionOverridesBoolExp
  ): permissionOverridesAggregate!
  """An array relationship"""
  userWorkSchedules(
    """distinct select on columns"""
    distinctOn: [workSchedulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [workSchedulesOrderBy!]
    """filter the rows returned"""
    where: workSchedulesBoolExp
  ): [workSchedules!]!
  """An aggregate relationship"""
  userWorkSchedulesAggregate(
    """distinct select on columns"""
    distinctOn: [workSchedulesSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [workSchedulesOrderBy!]
    """filter the rows returned"""
    where: workSchedulesBoolExp
  ): workSchedulesAggregate!
  """User's unique username for login"""
  username: String
}

"""
aggregated selection of "users"
"""
type usersAggregate {
  aggregate: usersAggregateFields
  nodes: [users!]!
}

input usersAggregateBoolExp {
  bool_and: usersAggregateBoolExpBool_and
  bool_or: usersAggregateBoolExpBool_or
  count: usersAggregateBoolExpCount
}

input usersAggregateBoolExpBool_and {
  arguments: usersSelectColumnUsersAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: usersBoolExp
  predicate: BooleanComparisonExp!
}

input usersAggregateBoolExpBool_or {
  arguments: usersSelectColumnUsersAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: usersBoolExp
  predicate: BooleanComparisonExp!
}

input usersAggregateBoolExpCount {
  arguments: [usersSelectColumn!]
  distinct: Boolean
  filter: usersBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "users"
"""
type usersAggregateFields {
  count(columns: [usersSelectColumn!], distinct: Boolean): Int!
  max: usersMaxFields
  min: usersMinFields
}

"""
order by aggregate values of table "users"
"""
input usersAggregateOrderBy {
  count: OrderBy
  max: usersMaxOrderBy
  min: usersMinOrderBy
}

"""
input type for inserting array relation for remote table "users"
"""
input usersArrRelInsertInput {
  data: [usersInsertInput!]!
  """upsert condition"""
  onConflict: usersOnConflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input usersBoolExp {
  _and: [usersBoolExp!]
  _not: usersBoolExp
  _or: [usersBoolExp!]
  assignedRoles: userRolesBoolExp
  assignedRolesAggregate: userRolesAggregateBoolExp
  authoredNotes: notesBoolExp
  authoredNotesAggregate: notesAggregateBoolExp
  backupConsultantPayrolls: payrollsBoolExp
  backupConsultantPayrollsAggregate: payrollsAggregateBoolExp
  clerkUserId: StringComparisonExp
  consultantAssignments: payrollAssignmentsBoolExp
  consultantAssignmentsAggregate: payrollAssignmentsAggregateBoolExp
  createdAssignmentAudits: payrollAssignmentAuditsBoolExp
  createdAssignmentAuditsAggregate: payrollAssignmentAuditsAggregateBoolExp
  createdAssignments: payrollAssignmentsBoolExp
  createdAssignmentsAggregate: payrollAssignmentsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBillingEvents: billingEventLogsBoolExp
  createdBillingEventsAggregate: billingEventLogsAggregateBoolExp
  createdPermissionOverrides: permissionOverridesBoolExp
  createdPermissionOverridesAggregate: permissionOverridesAggregateBoolExp
  deactivatedAt: TimestamptzComparisonExp
  deactivatedBy: StringComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  image: StringComparisonExp
  isActive: BooleanComparisonExp
  isStaff: BooleanComparisonExp
  managedPayrolls: payrollsBoolExp
  managedPayrollsAggregate: payrollsAggregateBoolExp
  managedTeamMembers: usersBoolExp
  managedTeamMembersAggregate: usersAggregateBoolExp
  managedUsers: usersBoolExp
  managedUsersAggregate: usersAggregateBoolExp
  managerId: UuidComparisonExp
  managerUser: usersBoolExp
  name: StringComparisonExp
  newConsultantAuditTrail: payrollAssignmentAuditsBoolExp
  newConsultantAuditTrailAggregate: payrollAssignmentAuditsAggregateBoolExp
  originalConsultantAssignments: payrollAssignmentsBoolExp
  originalConsultantAssignmentsAggregate: payrollAssignmentsAggregateBoolExp
  originalConsultantAuditTrail: payrollAssignmentAuditsBoolExp
  originalConsultantAuditTrailAggregate: payrollAssignmentAuditsAggregateBoolExp
  primaryConsultantPayrolls: payrollsBoolExp
  primaryConsultantPayrollsAggregate: payrollsAggregateBoolExp
  role: UserRoleComparisonExp
  targetedPermissionAudits: permissionAuditLogsBoolExp
  targetedPermissionAuditsAggregate: permissionAuditLogsAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  userLeaveRecords: leaveBoolExp
  userLeaveRecordsAggregate: leaveAggregateBoolExp
  userPermissionAudits: permissionAuditLogsBoolExp
  userPermissionAuditsAggregate: permissionAuditLogsAggregateBoolExp
  userPermissionOverrides: permissionOverridesBoolExp
  userPermissionOverridesAggregate: permissionOverridesAggregateBoolExp
  userWorkSchedules: workSchedulesBoolExp
  userWorkSchedulesAggregate: workSchedulesAggregateBoolExp
  username: StringComparisonExp
}

"""
unique or primary key constraints on table "users"
"""
enum usersConstraint {
  """
  unique or primary key constraint on columns "clerk_user_id"
  """
  users_clerk_user_id_key
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
  """
  unique or primary key constraint on columns "username"
  """
  users_username_key
}

"""
input type for inserting data into table "users"
"""
input usersInsertInput {
  assignedRoles: userRolesArrRelInsertInput
  authoredNotes: notesArrRelInsertInput
  backupConsultantPayrolls: payrollsArrRelInsertInput
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  consultantAssignments: payrollAssignmentsArrRelInsertInput
  createdAssignmentAudits: payrollAssignmentAuditsArrRelInsertInput
  createdAssignments: payrollAssignmentsArrRelInsertInput
  """Timestamp when the user was created"""
  createdAt: timestamptz
  createdBillingEvents: billingEventLogsArrRelInsertInput
  createdPermissionOverrides: permissionOverridesArrRelInsertInput
  deactivatedAt: timestamptz
  deactivatedBy: String
  """User's email address (unique)"""
  email: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  managedPayrolls: payrollsArrRelInsertInput
  managedTeamMembers: usersArrRelInsertInput
  managedUsers: usersArrRelInsertInput
  """Reference to the user's manager"""
  managerId: uuid
  managerUser: usersObjRelInsertInput
  """User's full name"""
  name: String
  newConsultantAuditTrail: payrollAssignmentAuditsArrRelInsertInput
  originalConsultantAssignments: payrollAssignmentsArrRelInsertInput
  originalConsultantAuditTrail: payrollAssignmentAuditsArrRelInsertInput
  primaryConsultantPayrolls: payrollsArrRelInsertInput
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  targetedPermissionAudits: permissionAuditLogsArrRelInsertInput
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  userLeaveRecords: leaveArrRelInsertInput
  userPermissionAudits: permissionAuditLogsArrRelInsertInput
  userPermissionOverrides: permissionOverridesArrRelInsertInput
  userWorkSchedules: workSchedulesArrRelInsertInput
  """User's unique username for login"""
  username: String
}

"""aggregate max on columns"""
type usersMaxFields {
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """User's email address (unique)"""
  email: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  """Reference to the user's manager"""
  managerId: uuid
  """User's full name"""
  name: String
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""
order by max() on columns of table "users"
"""
input usersMaxOrderBy {
  """External identifier from Clerk authentication service"""
  clerkUserId: OrderBy
  """Timestamp when the user was created"""
  createdAt: OrderBy
  deactivatedAt: OrderBy
  deactivatedBy: OrderBy
  """User's email address (unique)"""
  email: OrderBy
  """Unique identifier for the user"""
  id: OrderBy
  """URL to the user's profile image"""
  image: OrderBy
  """Reference to the user's manager"""
  managerId: OrderBy
  """User's full name"""
  name: OrderBy
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: OrderBy
  """Timestamp when the user was last updated"""
  updatedAt: OrderBy
  """User's unique username for login"""
  username: OrderBy
}

"""aggregate min on columns"""
type usersMinFields {
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """User's email address (unique)"""
  email: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  """Reference to the user's manager"""
  managerId: uuid
  """User's full name"""
  name: String
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""
order by min() on columns of table "users"
"""
input usersMinOrderBy {
  """External identifier from Clerk authentication service"""
  clerkUserId: OrderBy
  """Timestamp when the user was created"""
  createdAt: OrderBy
  deactivatedAt: OrderBy
  deactivatedBy: OrderBy
  """User's email address (unique)"""
  email: OrderBy
  """Unique identifier for the user"""
  id: OrderBy
  """URL to the user's profile image"""
  image: OrderBy
  """Reference to the user's manager"""
  managerId: OrderBy
  """User's full name"""
  name: OrderBy
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: OrderBy
  """Timestamp when the user was last updated"""
  updatedAt: OrderBy
  """User's unique username for login"""
  username: OrderBy
}

"""
response of any mutation on the table "users"
"""
type usersMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input usersObjRelInsertInput {
  data: usersInsertInput!
  """upsert condition"""
  onConflict: usersOnConflict
}

"""
on_conflict condition type for table "users"
"""
input usersOnConflict {
  constraint: usersConstraint!
  updateColumns: [usersUpdateColumn!]! = []
  where: usersBoolExp
}

"""Ordering options when selecting data from "users"."""
input usersOrderBy {
  assignedRolesAggregate: userRolesAggregateOrderBy
  authoredNotesAggregate: notesAggregateOrderBy
  backupConsultantPayrollsAggregate: payrollsAggregateOrderBy
  clerkUserId: OrderBy
  consultantAssignmentsAggregate: payrollAssignmentsAggregateOrderBy
  createdAssignmentAuditsAggregate: payrollAssignmentAuditsAggregateOrderBy
  createdAssignmentsAggregate: payrollAssignmentsAggregateOrderBy
  createdAt: OrderBy
  createdBillingEventsAggregate: billingEventLogsAggregateOrderBy
  createdPermissionOverridesAggregate: permissionOverridesAggregateOrderBy
  deactivatedAt: OrderBy
  deactivatedBy: OrderBy
  email: OrderBy
  id: OrderBy
  image: OrderBy
  isActive: OrderBy
  isStaff: OrderBy
  managedPayrollsAggregate: payrollsAggregateOrderBy
  managedTeamMembersAggregate: usersAggregateOrderBy
  managedUsersAggregate: usersAggregateOrderBy
  managerId: OrderBy
  managerUser: usersOrderBy
  name: OrderBy
  newConsultantAuditTrailAggregate: payrollAssignmentAuditsAggregateOrderBy
  originalConsultantAssignmentsAggregate: payrollAssignmentsAggregateOrderBy
  originalConsultantAuditTrailAggregate: payrollAssignmentAuditsAggregateOrderBy
  primaryConsultantPayrollsAggregate: payrollsAggregateOrderBy
  role: OrderBy
  targetedPermissionAuditsAggregate: permissionAuditLogsAggregateOrderBy
  updatedAt: OrderBy
  userLeaveRecordsAggregate: leaveAggregateOrderBy
  userPermissionAuditsAggregate: permissionAuditLogsAggregateOrderBy
  userPermissionOverridesAggregate: permissionOverridesAggregateOrderBy
  userWorkSchedulesAggregate: workSchedulesAggregateOrderBy
  username: OrderBy
}

"""primary key columns input for table: users"""
input usersPkColumnsInput {
  """Unique identifier for the user"""
  id: uuid!
}

"""
columns and relationships of "users_role_backup"
"""
type usersRoleBackup {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
aggregated selection of "users_role_backup"
"""
type usersRoleBackupAggregate {
  aggregate: usersRoleBackupAggregateFields
  nodes: [usersRoleBackup!]!
}

"""
aggregate fields of "users_role_backup"
"""
type usersRoleBackupAggregateFields {
  count(columns: [usersRoleBackupSelectColumn!], distinct: Boolean): Int!
  max: usersRoleBackupMaxFields
  min: usersRoleBackupMinFields
}

"""
Boolean expression to filter rows from the table "users_role_backup". All fields are combined with a logical 'AND'.
"""
input usersRoleBackupBoolExp {
  _and: [usersRoleBackupBoolExp!]
  _not: usersRoleBackupBoolExp
  _or: [usersRoleBackupBoolExp!]
  createdAt: TimestamptzComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  role: UserRoleComparisonExp
}

"""
input type for inserting data into table "users_role_backup"
"""
input usersRoleBackupInsertInput {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""aggregate max on columns"""
type usersRoleBackupMaxFields {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""aggregate min on columns"""
type usersRoleBackupMinFields {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
response of any mutation on the table "users_role_backup"
"""
type usersRoleBackupMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [usersRoleBackup!]!
}

"""Ordering options when selecting data from "users_role_backup"."""
input usersRoleBackupOrderBy {
  createdAt: OrderBy
  email: OrderBy
  id: OrderBy
  role: OrderBy
}

"""
select columns of table "users_role_backup"
"""
enum usersRoleBackupSelectColumn {
  """column name"""
  createdAt
  """column name"""
  email
  """column name"""
  id
  """column name"""
  role
}

"""
input type for updating data in table "users_role_backup"
"""
input usersRoleBackupSetInput {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

"""
Streaming cursor of the table "usersRoleBackup"
"""
input usersRoleBackupStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: usersRoleBackupStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input usersRoleBackupStreamCursorValueInput {
  createdAt: timestamptz
  email: String
  id: uuid
  role: user_role
}

input usersRoleBackupUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: usersRoleBackupSetInput
  """filter the rows which have to be updated"""
  where: usersRoleBackupBoolExp!
}

"""
select columns of table "users"
"""
enum usersSelectColumn {
  """column name"""
  clerkUserId
  """column name"""
  createdAt
  """column name"""
  deactivatedAt
  """column name"""
  deactivatedBy
  """column name"""
  email
  """column name"""
  id
  """column name"""
  image
  """column name"""
  isActive
  """column name"""
  isStaff
  """column name"""
  managerId
  """column name"""
  name
  """column name"""
  role
  """column name"""
  updatedAt
  """column name"""
  username
}

"""
select "usersAggregateBoolExpBool_andArgumentsColumns" columns of table "users"
"""
enum usersSelectColumnUsersAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isStaff
}

"""
select "usersAggregateBoolExpBool_orArgumentsColumns" columns of table "users"
"""
enum usersSelectColumnUsersAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isActive
  """column name"""
  isStaff
}

"""
input type for updating data in table "users"
"""
input usersSetInput {
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """User's email address (unique)"""
  email: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  """Reference to the user's manager"""
  managerId: uuid
  """User's full name"""
  name: String
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""
Streaming cursor of the table "users"
"""
input usersStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: usersStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input usersStreamCursorValueInput {
  """External identifier from Clerk authentication service"""
  clerkUserId: String
  """Timestamp when the user was created"""
  createdAt: timestamptz
  deactivatedAt: timestamptz
  deactivatedBy: String
  """User's email address (unique)"""
  email: String
  """Unique identifier for the user"""
  id: uuid
  """URL to the user's profile image"""
  image: String
  isActive: Boolean
  """Whether the user is a staff member (vs. external user)"""
  isStaff: Boolean
  """Reference to the user's manager"""
  managerId: uuid
  """User's full name"""
  name: String
  """User's system role (viewer, consultant, manager, org_admin)"""
  role: user_role
  """Timestamp when the user was last updated"""
  updatedAt: timestamptz
  """User's unique username for login"""
  username: String
}

"""
update columns of table "users"
"""
enum usersUpdateColumn {
  """column name"""
  clerkUserId
  """column name"""
  createdAt
  """column name"""
  deactivatedAt
  """column name"""
  deactivatedBy
  """column name"""
  email
  """column name"""
  id
  """column name"""
  image
  """column name"""
  isActive
  """column name"""
  isStaff
  """column name"""
  managerId
  """column name"""
  name
  """column name"""
  role
  """column name"""
  updatedAt
  """column name"""
  username
}

input usersUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: usersSetInput
  """filter the rows which have to be updated"""
  where: usersBoolExp!
}

scalar uuid

"""
columns and relationships of "work_schedule"
"""
type workSchedules {
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid!
  """An object relationship"""
  scheduleOwner: users!
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid!
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String!
  """Number of hours worked on this day"""
  workHours: numeric!
  """An object relationship"""
  workScheduleUser: users!
}

"""
aggregated selection of "work_schedule"
"""
type workSchedulesAggregate {
  aggregate: workSchedulesAggregateFields
  nodes: [workSchedules!]!
}

input workSchedulesAggregateBoolExp {
  count: workSchedulesAggregateBoolExpCount
}

input workSchedulesAggregateBoolExpCount {
  arguments: [workSchedulesSelectColumn!]
  distinct: Boolean
  filter: workSchedulesBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "work_schedule"
"""
type workSchedulesAggregateFields {
  avg: workSchedulesAvgFields
  count(columns: [workSchedulesSelectColumn!], distinct: Boolean): Int!
  max: workSchedulesMaxFields
  min: workSchedulesMinFields
  stddev: workSchedulesStddevFields
  stddevPop: workSchedulesStddevPopFields
  stddevSamp: workSchedulesStddevSampFields
  sum: workSchedulesSumFields
  varPop: workSchedulesVarPopFields
  varSamp: workSchedulesVarSampFields
  variance: workSchedulesVarianceFields
}

"""
order by aggregate values of table "work_schedule"
"""
input workSchedulesAggregateOrderBy {
  avg: workSchedulesAvgOrderBy
  count: OrderBy
  max: workSchedulesMaxOrderBy
  min: workSchedulesMinOrderBy
  stddev: workSchedulesStddevOrderBy
  stddevPop: workSchedulesStddevPopOrderBy
  stddevSamp: workSchedulesStddevSampOrderBy
  sum: workSchedulesSumOrderBy
  varPop: workSchedulesVarPopOrderBy
  varSamp: workSchedulesVarSampOrderBy
  variance: workSchedulesVarianceOrderBy
}

"""
input type for inserting array relation for remote table "work_schedule"
"""
input workSchedulesArrRelInsertInput {
  data: [workSchedulesInsertInput!]!
  """upsert condition"""
  onConflict: workSchedulesOnConflict
}

"""aggregate avg on columns"""
type workSchedulesAvgFields {
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by avg() on columns of table "work_schedule"
"""
input workSchedulesAvgOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
Boolean expression to filter rows from the table "work_schedule". All fields are combined with a logical 'AND'.
"""
input workSchedulesBoolExp {
  _and: [workSchedulesBoolExp!]
  _not: workSchedulesBoolExp
  _or: [workSchedulesBoolExp!]
  createdAt: TimestampComparisonExp
  id: UuidComparisonExp
  scheduleOwner: usersBoolExp
  updatedAt: TimestampComparisonExp
  userId: UuidComparisonExp
  workDay: StringComparisonExp
  workHours: NumericComparisonExp
  workScheduleUser: usersBoolExp
}

"""
unique or primary key constraints on table "work_schedule"
"""
enum workSchedulesConstraint {
  """
  unique or primary key constraint on columns "user_id", "work_day"
  """
  unique_user_work_day
  """
  unique or primary key constraint on columns "id"
  """
  work_schedule_pkey
}

"""
input type for incrementing numeric columns in table "work_schedule"
"""
input workSchedulesIncInput {
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
input type for inserting data into table "work_schedule"
"""
input workSchedulesInsertInput {
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  scheduleOwner: usersObjRelInsertInput
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
  workScheduleUser: usersObjRelInsertInput
}

"""aggregate max on columns"""
type workSchedulesMaxFields {
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
order by max() on columns of table "work_schedule"
"""
input workSchedulesMaxOrderBy {
  """Timestamp when the schedule entry was created"""
  createdAt: OrderBy
  """Unique identifier for the work schedule entry"""
  id: OrderBy
  """Timestamp when the schedule entry was last updated"""
  updatedAt: OrderBy
  """Reference to the user this schedule belongs to"""
  userId: OrderBy
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate min on columns"""
type workSchedulesMinFields {
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
order by min() on columns of table "work_schedule"
"""
input workSchedulesMinOrderBy {
  """Timestamp when the schedule entry was created"""
  createdAt: OrderBy
  """Unique identifier for the work schedule entry"""
  id: OrderBy
  """Timestamp when the schedule entry was last updated"""
  updatedAt: OrderBy
  """Reference to the user this schedule belongs to"""
  userId: OrderBy
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: OrderBy
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
response of any mutation on the table "work_schedule"
"""
type workSchedulesMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [workSchedules!]!
}

"""
on_conflict condition type for table "work_schedule"
"""
input workSchedulesOnConflict {
  constraint: workSchedulesConstraint!
  updateColumns: [workSchedulesUpdateColumn!]! = []
  where: workSchedulesBoolExp
}

"""Ordering options when selecting data from "work_schedule"."""
input workSchedulesOrderBy {
  createdAt: OrderBy
  id: OrderBy
  scheduleOwner: usersOrderBy
  updatedAt: OrderBy
  userId: OrderBy
  workDay: OrderBy
  workHours: OrderBy
  workScheduleUser: usersOrderBy
}

"""primary key columns input for table: work_schedule"""
input workSchedulesPkColumnsInput {
  """Unique identifier for the work schedule entry"""
  id: uuid!
}

"""
select columns of table "work_schedule"
"""
enum workSchedulesSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  updatedAt
  """column name"""
  userId
  """column name"""
  workDay
  """column name"""
  workHours
}

"""
input type for updating data in table "work_schedule"
"""
input workSchedulesSetInput {
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""aggregate stddev on columns"""
type workSchedulesStddevFields {
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by stddev() on columns of table "work_schedule"
"""
input workSchedulesStddevOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate stddevPop on columns"""
type workSchedulesStddevPopFields {
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by stddevPop() on columns of table "work_schedule"
"""
input workSchedulesStddevPopOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate stddevSamp on columns"""
type workSchedulesStddevSampFields {
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by stddevSamp() on columns of table "work_schedule"
"""
input workSchedulesStddevSampOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
Streaming cursor of the table "workSchedules"
"""
input workSchedulesStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: workSchedulesStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input workSchedulesStreamCursorValueInput {
  """Timestamp when the schedule entry was created"""
  createdAt: timestamp
  """Unique identifier for the work schedule entry"""
  id: uuid
  """Timestamp when the schedule entry was last updated"""
  updatedAt: timestamp
  """Reference to the user this schedule belongs to"""
  userId: uuid
  """Day of the week (Monday, Tuesday, etc.)"""
  workDay: String
  """Number of hours worked on this day"""
  workHours: numeric
}

"""aggregate sum on columns"""
type workSchedulesSumFields {
  """Number of hours worked on this day"""
  workHours: numeric
}

"""
order by sum() on columns of table "work_schedule"
"""
input workSchedulesSumOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""
update columns of table "work_schedule"
"""
enum workSchedulesUpdateColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  updatedAt
  """column name"""
  userId
  """column name"""
  workDay
  """column name"""
  workHours
}

input workSchedulesUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: workSchedulesIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: workSchedulesSetInput
  """filter the rows which have to be updated"""
  where: workSchedulesBoolExp!
}

"""aggregate varPop on columns"""
type workSchedulesVarPopFields {
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by varPop() on columns of table "work_schedule"
"""
input workSchedulesVarPopOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate varSamp on columns"""
type workSchedulesVarSampFields {
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by varSamp() on columns of table "work_schedule"
"""
input workSchedulesVarSampOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}

"""aggregate variance on columns"""
type workSchedulesVarianceFields {
  """Number of hours worked on this day"""
  workHours: Float
}

"""
order by variance() on columns of table "work_schedule"
"""
input workSchedulesVarianceOrderBy {
  """Number of hours worked on this day"""
  workHours: OrderBy
}