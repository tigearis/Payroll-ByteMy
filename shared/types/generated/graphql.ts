/* eslint-disable */
/**
 * THIS FILE IS AUTO-GENERATED - DO NOT EDIT MANUALLY
 * 
 * SOC2 Compliant GraphQL Operations
 * Security Classifications Applied:
 * - CRITICAL: Auth, user roles, financial data - Requires admin access + MFA
 * - HIGH: PII, client data, employee info - Requires role-based access
 * - MEDIUM: Internal business data - Requires authentication
 * - LOW: Public/aggregate data - Basic access control
 * 
 * Compliance Features:
 * ✓ Role-based access control (RBAC)
 * ✓ Audit logging integration
 * ✓ Data classification enforcement
 * ✓ Permission boundary validation
 * ✓ Automatic domain isolation and exports
 * ✓ Client Preset v4.8+ for optimal type safety
 * ✓ Zero type conflicts with modern codegen
 * 
 * Generated: 2025-08-04T05:58:23.889Z
 * Schema Version: Latest from Hasura
 * CodeGen Version: Client Preset v4.0
 */

import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  bigint: { input: string; output: string; }
  billing_tier_level: { input: any; output: any; }
  bpchar: { input: any; output: any; }
  date: { input: string; output: string; }
  inet: { input: any; output: any; }
  interval: { input: any; output: any; }
  invitation_status_enum: { input: any; output: any; }
  json: { input: any; output: any; }
  jsonb: { input: any; output: any; }
  leave_status_enum: { input: any; output: any; }
  monthly_billing_status: { input: any; output: any; }
  name: { input: any; output: any; }
  numeric: { input: number; output: number; }
  payroll_cycle_type: { input: any; output: any; }
  payroll_date_type: { input: any; output: any; }
  payroll_status: { input: any; output: any; }
  permission_action: { input: any; output: any; }
  timestamp: { input: any; output: any; }
  timestamptz: { input: string; output: string; }
  user_position: { input: any; output: any; }
  user_role: { input: any; output: any; }
  user_status_enum: { input: any; output: any; }
  uuid: { input: string; output: string; }
};

/** columns and relationships of "adjustment_rules" */
export type AdjustmentRules = {
  __typename?: 'AdjustmentRules';
  /** Timestamp when the rule was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId: Scalars['uuid']['output'];
  /** Reference to the payroll date type this rule affects */
  dateTypeId: Scalars['uuid']['output'];
  /** Unique identifier for the adjustment rule */
  id: Scalars['uuid']['output'];
  /** An object relationship */
  payrollCycle: PayrollCycles;
  /** An object relationship */
  payrollDateType: PayrollDateTypes;
  /** Code/formula used to calculate date adjustments */
  ruleCode: Scalars['String']['output'];
  /** Human-readable description of the adjustment rule */
  ruleDescription: Scalars['String']['output'];
  /** Timestamp when the rule was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "adjustment_rules" */
export type AdjustmentRulesAggregate = {
  __typename?: 'AdjustmentRulesAggregate';
  aggregate?: Maybe<AdjustmentRulesAggregateFields>;
  nodes: Array<AdjustmentRules>;
};

export type AdjustmentRulesAggregateBoolExp = {
  count?: InputMaybe<AdjustmentRulesAggregateBoolExpCount>;
};

/** aggregate fields of "adjustment_rules" */
export type AdjustmentRulesAggregateFields = {
  __typename?: 'AdjustmentRulesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AdjustmentRulesMaxFields>;
  min?: Maybe<AdjustmentRulesMinFields>;
};


/** aggregate fields of "adjustment_rules" */
export type AdjustmentRulesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "adjustment_rules" */
export type AdjustmentRulesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<AdjustmentRulesMaxOrderBy>;
  min?: InputMaybe<AdjustmentRulesMinOrderBy>;
};

/** input type for inserting array relation for remote table "adjustment_rules" */
export type AdjustmentRulesArrRelInsertInput = {
  data: Array<AdjustmentRulesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<AdjustmentRulesOnConflict>;
};

/** Boolean expression to filter rows from the table "adjustment_rules". All fields are combined with a logical 'AND'. */
export type AdjustmentRulesBoolExp = {
  _and?: InputMaybe<Array<AdjustmentRulesBoolExp>>;
  _not?: InputMaybe<AdjustmentRulesBoolExp>;
  _or?: InputMaybe<Array<AdjustmentRulesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  cycleId?: InputMaybe<UuidComparisonExp>;
  dateTypeId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  payrollCycle?: InputMaybe<PayrollCyclesBoolExp>;
  payrollDateType?: InputMaybe<PayrollDateTypesBoolExp>;
  ruleCode?: InputMaybe<StringComparisonExp>;
  ruleDescription?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "adjustment_rules" */
export type AdjustmentRulesConstraint =
  /** unique or primary key constraint on columns "date_type_id", "cycle_id" */
  | 'adjustment_rules_cycle_id_date_type_id_key'
  /** unique or primary key constraint on columns "id" */
  | 'adjustment_rules_pkey'
  | '%future added value';

/** input type for inserting data into table "adjustment_rules" */
export type AdjustmentRulesInsertInput = {
  /** Timestamp when the rule was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll date type this rule affects */
  dateTypeId?: InputMaybe<Scalars['uuid']['input']>;
  /** Unique identifier for the adjustment rule */
  id?: InputMaybe<Scalars['uuid']['input']>;
  payrollCycle?: InputMaybe<PayrollCyclesObjRelInsertInput>;
  payrollDateType?: InputMaybe<PayrollDateTypesObjRelInsertInput>;
  /** Code/formula used to calculate date adjustments */
  ruleCode?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable description of the adjustment rule */
  ruleDescription?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the rule was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type AdjustmentRulesMaxFields = {
  __typename?: 'AdjustmentRulesMaxFields';
  /** Timestamp when the rule was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the payroll date type this rule affects */
  dateTypeId?: Maybe<Scalars['uuid']['output']>;
  /** Unique identifier for the adjustment rule */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Code/formula used to calculate date adjustments */
  ruleCode?: Maybe<Scalars['String']['output']>;
  /** Human-readable description of the adjustment rule */
  ruleDescription?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the rule was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "adjustment_rules" */
export type AdjustmentRulesMaxOrderBy = {
  /** Timestamp when the rule was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId?: InputMaybe<OrderBy>;
  /** Reference to the payroll date type this rule affects */
  dateTypeId?: InputMaybe<OrderBy>;
  /** Unique identifier for the adjustment rule */
  id?: InputMaybe<OrderBy>;
  /** Code/formula used to calculate date adjustments */
  ruleCode?: InputMaybe<OrderBy>;
  /** Human-readable description of the adjustment rule */
  ruleDescription?: InputMaybe<OrderBy>;
  /** Timestamp when the rule was last updated */
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type AdjustmentRulesMinFields = {
  __typename?: 'AdjustmentRulesMinFields';
  /** Timestamp when the rule was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the payroll date type this rule affects */
  dateTypeId?: Maybe<Scalars['uuid']['output']>;
  /** Unique identifier for the adjustment rule */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Code/formula used to calculate date adjustments */
  ruleCode?: Maybe<Scalars['String']['output']>;
  /** Human-readable description of the adjustment rule */
  ruleDescription?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the rule was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "adjustment_rules" */
export type AdjustmentRulesMinOrderBy = {
  /** Timestamp when the rule was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId?: InputMaybe<OrderBy>;
  /** Reference to the payroll date type this rule affects */
  dateTypeId?: InputMaybe<OrderBy>;
  /** Unique identifier for the adjustment rule */
  id?: InputMaybe<OrderBy>;
  /** Code/formula used to calculate date adjustments */
  ruleCode?: InputMaybe<OrderBy>;
  /** Human-readable description of the adjustment rule */
  ruleDescription?: InputMaybe<OrderBy>;
  /** Timestamp when the rule was last updated */
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "adjustment_rules" */
export type AdjustmentRulesMutationResponse = {
  __typename?: 'AdjustmentRulesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AdjustmentRules>;
};

/** on_conflict condition type for table "adjustment_rules" */
export type AdjustmentRulesOnConflict = {
  constraint: AdjustmentRulesConstraint;
  updateColumns?: Array<AdjustmentRulesUpdateColumn>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};

/** Ordering options when selecting data from "adjustment_rules". */
export type AdjustmentRulesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  cycleId?: InputMaybe<OrderBy>;
  dateTypeId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollCycle?: InputMaybe<PayrollCyclesOrderBy>;
  payrollDateType?: InputMaybe<PayrollDateTypesOrderBy>;
  ruleCode?: InputMaybe<OrderBy>;
  ruleDescription?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: adjustment_rules */
export type AdjustmentRulesPkColumnsInput = {
  /** Unique identifier for the adjustment rule */
  id: Scalars['uuid']['input'];
};

/** select columns of table "adjustment_rules" */
export type AdjustmentRulesSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'cycleId'
  /** column name */
  | 'dateTypeId'
  /** column name */
  | 'id'
  /** column name */
  | 'ruleCode'
  /** column name */
  | 'ruleDescription'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "adjustment_rules" */
export type AdjustmentRulesSetInput = {
  /** Timestamp when the rule was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll date type this rule affects */
  dateTypeId?: InputMaybe<Scalars['uuid']['input']>;
  /** Unique identifier for the adjustment rule */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Code/formula used to calculate date adjustments */
  ruleCode?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable description of the adjustment rule */
  ruleDescription?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the rule was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "adjustment_rules" */
export type AdjustmentRulesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AdjustmentRulesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AdjustmentRulesStreamCursorValueInput = {
  /** Timestamp when the rule was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Reference to the payroll cycle this rule applies to */
  cycleId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll date type this rule affects */
  dateTypeId?: InputMaybe<Scalars['uuid']['input']>;
  /** Unique identifier for the adjustment rule */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Code/formula used to calculate date adjustments */
  ruleCode?: InputMaybe<Scalars['String']['input']>;
  /** Human-readable description of the adjustment rule */
  ruleDescription?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the rule was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "adjustment_rules" */
export type AdjustmentRulesUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'cycleId'
  /** column name */
  | 'dateTypeId'
  /** column name */
  | 'id'
  /** column name */
  | 'ruleCode'
  /** column name */
  | 'ruleDescription'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type AdjustmentRulesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AdjustmentRulesSetInput>;
  /** filter the rows which have to be updated */
  where: AdjustmentRulesBoolExp;
};

/** columns and relationships of "app_settings" */
export type AppSettings = {
  __typename?: 'AppSettings';
  /** Unique identifier for application setting */
  id: Scalars['String']['output'];
  /** JSON structure containing application permission configurations */
  permissions?: Maybe<Scalars['jsonb']['output']>;
};


/** columns and relationships of "app_settings" */
export type AppSettingsPermissionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "app_settings" */
export type AppSettingsAggregate = {
  __typename?: 'AppSettingsAggregate';
  aggregate?: Maybe<AppSettingsAggregateFields>;
  nodes: Array<AppSettings>;
};

/** aggregate fields of "app_settings" */
export type AppSettingsAggregateFields = {
  __typename?: 'AppSettingsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AppSettingsMaxFields>;
  min?: Maybe<AppSettingsMinFields>;
};


/** aggregate fields of "app_settings" */
export type AppSettingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AppSettingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AppSettingsAppendInput = {
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "app_settings". All fields are combined with a logical 'AND'. */
export type AppSettingsBoolExp = {
  _and?: InputMaybe<Array<AppSettingsBoolExp>>;
  _not?: InputMaybe<AppSettingsBoolExp>;
  _or?: InputMaybe<Array<AppSettingsBoolExp>>;
  id?: InputMaybe<StringComparisonExp>;
  permissions?: InputMaybe<JsonbComparisonExp>;
};

/** unique or primary key constraints on table "app_settings" */
export type AppSettingsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'app_settings_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AppSettingsDeleteAtPathInput = {
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AppSettingsDeleteElemInput = {
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AppSettingsDeleteKeyInput = {
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "app_settings" */
export type AppSettingsInsertInput = {
  /** Unique identifier for application setting */
  id?: InputMaybe<Scalars['String']['input']>;
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate max on columns */
export type AppSettingsMaxFields = {
  __typename?: 'AppSettingsMaxFields';
  /** Unique identifier for application setting */
  id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type AppSettingsMinFields = {
  __typename?: 'AppSettingsMinFields';
  /** Unique identifier for application setting */
  id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "app_settings" */
export type AppSettingsMutationResponse = {
  __typename?: 'AppSettingsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AppSettings>;
};

/** on_conflict condition type for table "app_settings" */
export type AppSettingsOnConflict = {
  constraint: AppSettingsConstraint;
  updateColumns?: Array<AppSettingsUpdateColumn>;
  where?: InputMaybe<AppSettingsBoolExp>;
};

/** Ordering options when selecting data from "app_settings". */
export type AppSettingsOrderBy = {
  id?: InputMaybe<OrderBy>;
  permissions?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: app_settings */
export type AppSettingsPkColumnsInput = {
  /** Unique identifier for application setting */
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AppSettingsPrependInput = {
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "app_settings" */
export type AppSettingsSelectColumn =
  /** column name */
  | 'id'
  /** column name */
  | 'permissions'
  | '%future added value';

/** input type for updating data in table "app_settings" */
export type AppSettingsSetInput = {
  /** Unique identifier for application setting */
  id?: InputMaybe<Scalars['String']['input']>;
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Streaming cursor of the table "app_settings" */
export type AppSettingsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AppSettingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AppSettingsStreamCursorValueInput = {
  /** Unique identifier for application setting */
  id?: InputMaybe<Scalars['String']['input']>;
  /** JSON structure containing application permission configurations */
  permissions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** update columns of table "app_settings" */
export type AppSettingsUpdateColumn =
  /** column name */
  | 'id'
  /** column name */
  | 'permissions'
  | '%future added value';

export type AppSettingsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AppSettingsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AppSettingsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AppSettingsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AppSettingsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AppSettingsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AppSettingsSetInput>;
  /** filter the rows which have to be updated */
  where: AppSettingsBoolExp;
};

/** columns and relationships of "audit.audit_log" */
export type AuditAuditLog = {
  __typename?: 'AuditAuditLog';
  action: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  eventTime: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  ipAddress?: Maybe<Scalars['inet']['output']>;
  metadata?: Maybe<Scalars['jsonb']['output']>;
  newValues?: Maybe<Scalars['jsonb']['output']>;
  oldValues?: Maybe<Scalars['jsonb']['output']>;
  requestId?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['String']['output']>;
  resourceType: Scalars['String']['output'];
  sessionId?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userEmail?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  userRole?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "audit.audit_log" */
export type AuditAuditLogMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "audit.audit_log" */
export type AuditAuditLogNewValuesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "audit.audit_log" */
export type AuditAuditLogOldValuesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "audit.audit_log" */
export type AuditAuditLogAggregate = {
  __typename?: 'AuditAuditLogAggregate';
  aggregate?: Maybe<AuditAuditLogAggregateFields>;
  nodes: Array<AuditAuditLog>;
};

/** aggregate fields of "audit.audit_log" */
export type AuditAuditLogAggregateFields = {
  __typename?: 'AuditAuditLogAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AuditAuditLogMaxFields>;
  min?: Maybe<AuditAuditLogMinFields>;
};


/** aggregate fields of "audit.audit_log" */
export type AuditAuditLogAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuditAuditLogSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AuditAuditLogAppendInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newValues?: InputMaybe<Scalars['jsonb']['input']>;
  oldValues?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "audit.audit_log". All fields are combined with a logical 'AND'. */
export type AuditAuditLogBoolExp = {
  _and?: InputMaybe<Array<AuditAuditLogBoolExp>>;
  _not?: InputMaybe<AuditAuditLogBoolExp>;
  _or?: InputMaybe<Array<AuditAuditLogBoolExp>>;
  action?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  errorMessage?: InputMaybe<StringComparisonExp>;
  eventTime?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ipAddress?: InputMaybe<InetComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  newValues?: InputMaybe<JsonbComparisonExp>;
  oldValues?: InputMaybe<JsonbComparisonExp>;
  requestId?: InputMaybe<StringComparisonExp>;
  resourceId?: InputMaybe<StringComparisonExp>;
  resourceType?: InputMaybe<StringComparisonExp>;
  sessionId?: InputMaybe<StringComparisonExp>;
  success?: InputMaybe<BooleanComparisonExp>;
  userAgent?: InputMaybe<StringComparisonExp>;
  userEmail?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  userRole?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "audit.audit_log" */
export type AuditAuditLogConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'audit_log_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AuditAuditLogDeleteAtPathInput = {
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
  newValues?: InputMaybe<Array<Scalars['String']['input']>>;
  oldValues?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AuditAuditLogDeleteElemInput = {
  metadata?: InputMaybe<Scalars['Int']['input']>;
  newValues?: InputMaybe<Scalars['Int']['input']>;
  oldValues?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AuditAuditLogDeleteKeyInput = {
  metadata?: InputMaybe<Scalars['String']['input']>;
  newValues?: InputMaybe<Scalars['String']['input']>;
  oldValues?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "audit.audit_log" */
export type AuditAuditLogInsertInput = {
  action?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  eventTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newValues?: InputMaybe<Scalars['jsonb']['input']>;
  oldValues?: InputMaybe<Scalars['jsonb']['input']>;
  requestId?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['String']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userEmail?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  userRole?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type AuditAuditLogMaxFields = {
  __typename?: 'AuditAuditLogMaxFields';
  action?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  eventTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  requestId?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['String']['output']>;
  resourceType?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userEmail?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  userRole?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type AuditAuditLogMinFields = {
  __typename?: 'AuditAuditLogMinFields';
  action?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  eventTime?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  requestId?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['String']['output']>;
  resourceType?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userEmail?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  userRole?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "audit.audit_log" */
export type AuditAuditLogMutationResponse = {
  __typename?: 'AuditAuditLogMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AuditAuditLog>;
};

/** on_conflict condition type for table "audit.audit_log" */
export type AuditAuditLogOnConflict = {
  constraint: AuditAuditLogConstraint;
  updateColumns?: Array<AuditAuditLogUpdateColumn>;
  where?: InputMaybe<AuditAuditLogBoolExp>;
};

/** Ordering options when selecting data from "audit.audit_log". */
export type AuditAuditLogOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  errorMessage?: InputMaybe<OrderBy>;
  eventTime?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ipAddress?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  newValues?: InputMaybe<OrderBy>;
  oldValues?: InputMaybe<OrderBy>;
  requestId?: InputMaybe<OrderBy>;
  resourceId?: InputMaybe<OrderBy>;
  resourceType?: InputMaybe<OrderBy>;
  sessionId?: InputMaybe<OrderBy>;
  success?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userEmail?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  userRole?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: audit.audit_log */
export type AuditAuditLogPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AuditAuditLogPrependInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newValues?: InputMaybe<Scalars['jsonb']['input']>;
  oldValues?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "audit.audit_log" */
export type AuditAuditLogSelectColumn =
  /** column name */
  | 'action'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'errorMessage'
  /** column name */
  | 'eventTime'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'metadata'
  /** column name */
  | 'newValues'
  /** column name */
  | 'oldValues'
  /** column name */
  | 'requestId'
  /** column name */
  | 'resourceId'
  /** column name */
  | 'resourceType'
  /** column name */
  | 'sessionId'
  /** column name */
  | 'success'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userEmail'
  /** column name */
  | 'userId'
  /** column name */
  | 'userRole'
  | '%future added value';

/** input type for updating data in table "audit.audit_log" */
export type AuditAuditLogSetInput = {
  action?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  eventTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newValues?: InputMaybe<Scalars['jsonb']['input']>;
  oldValues?: InputMaybe<Scalars['jsonb']['input']>;
  requestId?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['String']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userEmail?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  userRole?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "audit_audit_log" */
export type AuditAuditLogStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AuditAuditLogStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuditAuditLogStreamCursorValueInput = {
  action?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  eventTime?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newValues?: InputMaybe<Scalars['jsonb']['input']>;
  oldValues?: InputMaybe<Scalars['jsonb']['input']>;
  requestId?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['String']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userEmail?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  userRole?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "audit.audit_log" */
export type AuditAuditLogUpdateColumn =
  /** column name */
  | 'action'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'errorMessage'
  /** column name */
  | 'eventTime'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'metadata'
  /** column name */
  | 'newValues'
  /** column name */
  | 'oldValues'
  /** column name */
  | 'requestId'
  /** column name */
  | 'resourceId'
  /** column name */
  | 'resourceType'
  /** column name */
  | 'sessionId'
  /** column name */
  | 'success'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userEmail'
  /** column name */
  | 'userId'
  /** column name */
  | 'userRole'
  | '%future added value';

export type AuditAuditLogUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AuditAuditLogAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AuditAuditLogDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AuditAuditLogDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AuditAuditLogDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AuditAuditLogPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuditAuditLogSetInput>;
  /** filter the rows which have to be updated */
  where: AuditAuditLogBoolExp;
};

/** columns and relationships of "audit.auth_events" */
export type AuditAuthEvents = {
  __typename?: 'AuditAuthEvents';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  eventTime: Scalars['timestamptz']['output'];
  eventType: Scalars['String']['output'];
  failureReason?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  ipAddress?: Maybe<Scalars['inet']['output']>;
  metadata?: Maybe<Scalars['jsonb']['output']>;
  success?: Maybe<Scalars['Boolean']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userEmail?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "audit.auth_events" */
export type AuditAuthEventsMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "audit.auth_events" */
export type AuditAuthEventsAggregate = {
  __typename?: 'AuditAuthEventsAggregate';
  aggregate?: Maybe<AuditAuthEventsAggregateFields>;
  nodes: Array<AuditAuthEvents>;
};

/** aggregate fields of "audit.auth_events" */
export type AuditAuthEventsAggregateFields = {
  __typename?: 'AuditAuthEventsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AuditAuthEventsMaxFields>;
  min?: Maybe<AuditAuthEventsMinFields>;
};


/** aggregate fields of "audit.auth_events" */
export type AuditAuthEventsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuditAuthEventsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AuditAuthEventsAppendInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "audit.auth_events". All fields are combined with a logical 'AND'. */
export type AuditAuthEventsBoolExp = {
  _and?: InputMaybe<Array<AuditAuthEventsBoolExp>>;
  _not?: InputMaybe<AuditAuthEventsBoolExp>;
  _or?: InputMaybe<Array<AuditAuthEventsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  eventTime?: InputMaybe<TimestamptzComparisonExp>;
  eventType?: InputMaybe<StringComparisonExp>;
  failureReason?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ipAddress?: InputMaybe<InetComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  success?: InputMaybe<BooleanComparisonExp>;
  userAgent?: InputMaybe<StringComparisonExp>;
  userEmail?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "audit.auth_events" */
export type AuditAuthEventsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'auth_events_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AuditAuthEventsDeleteAtPathInput = {
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AuditAuthEventsDeleteElemInput = {
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AuditAuthEventsDeleteKeyInput = {
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "audit.auth_events" */
export type AuditAuthEventsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  eventTime?: InputMaybe<Scalars['timestamptz']['input']>;
  eventType?: InputMaybe<Scalars['String']['input']>;
  failureReason?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userEmail?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type AuditAuthEventsMaxFields = {
  __typename?: 'AuditAuthEventsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  eventTime?: Maybe<Scalars['timestamptz']['output']>;
  eventType?: Maybe<Scalars['String']['output']>;
  failureReason?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userEmail?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type AuditAuthEventsMinFields = {
  __typename?: 'AuditAuthEventsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  eventTime?: Maybe<Scalars['timestamptz']['output']>;
  eventType?: Maybe<Scalars['String']['output']>;
  failureReason?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userEmail?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "audit.auth_events" */
export type AuditAuthEventsMutationResponse = {
  __typename?: 'AuditAuthEventsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AuditAuthEvents>;
};

/** on_conflict condition type for table "audit.auth_events" */
export type AuditAuthEventsOnConflict = {
  constraint: AuditAuthEventsConstraint;
  updateColumns?: Array<AuditAuthEventsUpdateColumn>;
  where?: InputMaybe<AuditAuthEventsBoolExp>;
};

/** Ordering options when selecting data from "audit.auth_events". */
export type AuditAuthEventsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  eventTime?: InputMaybe<OrderBy>;
  eventType?: InputMaybe<OrderBy>;
  failureReason?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ipAddress?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  success?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userEmail?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: audit.auth_events */
export type AuditAuthEventsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AuditAuthEventsPrependInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "audit.auth_events" */
export type AuditAuthEventsSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'eventTime'
  /** column name */
  | 'eventType'
  /** column name */
  | 'failureReason'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'metadata'
  /** column name */
  | 'success'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userEmail'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "audit.auth_events" */
export type AuditAuthEventsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  eventTime?: InputMaybe<Scalars['timestamptz']['input']>;
  eventType?: InputMaybe<Scalars['String']['input']>;
  failureReason?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userEmail?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "audit_auth_events" */
export type AuditAuthEventsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AuditAuthEventsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuditAuthEventsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  eventTime?: InputMaybe<Scalars['timestamptz']['input']>;
  eventType?: InputMaybe<Scalars['String']['input']>;
  failureReason?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  success?: InputMaybe<Scalars['Boolean']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userEmail?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "audit.auth_events" */
export type AuditAuthEventsUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'eventTime'
  /** column name */
  | 'eventType'
  /** column name */
  | 'failureReason'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'metadata'
  /** column name */
  | 'success'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userEmail'
  /** column name */
  | 'userId'
  | '%future added value';

export type AuditAuthEventsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AuditAuthEventsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AuditAuthEventsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AuditAuthEventsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AuditAuthEventsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AuditAuthEventsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuditAuthEventsSetInput>;
  /** filter the rows which have to be updated */
  where: AuditAuthEventsBoolExp;
};

/** columns and relationships of "audit.data_access_log" */
export type AuditDataAccessLog = {
  __typename?: 'AuditDataAccessLog';
  accessType: Scalars['String']['output'];
  accessedAt: Scalars['timestamptz']['output'];
  dataClassification?: Maybe<Scalars['String']['output']>;
  fieldsAccessed?: Maybe<Array<Scalars['String']['output']>>;
  id: Scalars['uuid']['output'];
  ipAddress?: Maybe<Scalars['inet']['output']>;
  metadata?: Maybe<Scalars['jsonb']['output']>;
  queryExecuted?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['String']['output']>;
  resourceType: Scalars['String']['output'];
  rowCount?: Maybe<Scalars['Int']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  userId: Scalars['uuid']['output'];
};


/** columns and relationships of "audit.data_access_log" */
export type AuditDataAccessLogMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "audit.data_access_log" */
export type AuditDataAccessLogAggregate = {
  __typename?: 'AuditDataAccessLogAggregate';
  aggregate?: Maybe<AuditDataAccessLogAggregateFields>;
  nodes: Array<AuditDataAccessLog>;
};

/** aggregate fields of "audit.data_access_log" */
export type AuditDataAccessLogAggregateFields = {
  __typename?: 'AuditDataAccessLogAggregateFields';
  avg?: Maybe<AuditDataAccessLogAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AuditDataAccessLogMaxFields>;
  min?: Maybe<AuditDataAccessLogMinFields>;
  stddev?: Maybe<AuditDataAccessLogStddevFields>;
  stddevPop?: Maybe<AuditDataAccessLogStddevPopFields>;
  stddevSamp?: Maybe<AuditDataAccessLogStddevSampFields>;
  sum?: Maybe<AuditDataAccessLogSumFields>;
  varPop?: Maybe<AuditDataAccessLogVarPopFields>;
  varSamp?: Maybe<AuditDataAccessLogVarSampFields>;
  variance?: Maybe<AuditDataAccessLogVarianceFields>;
};


/** aggregate fields of "audit.data_access_log" */
export type AuditDataAccessLogAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuditDataAccessLogSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AuditDataAccessLogAppendInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type AuditDataAccessLogAvgFields = {
  __typename?: 'AuditDataAccessLogAvgFields';
  rowCount?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "audit.data_access_log". All fields are combined with a logical 'AND'. */
export type AuditDataAccessLogBoolExp = {
  _and?: InputMaybe<Array<AuditDataAccessLogBoolExp>>;
  _not?: InputMaybe<AuditDataAccessLogBoolExp>;
  _or?: InputMaybe<Array<AuditDataAccessLogBoolExp>>;
  accessType?: InputMaybe<StringComparisonExp>;
  accessedAt?: InputMaybe<TimestamptzComparisonExp>;
  dataClassification?: InputMaybe<StringComparisonExp>;
  fieldsAccessed?: InputMaybe<StringArrayComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ipAddress?: InputMaybe<InetComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  queryExecuted?: InputMaybe<StringComparisonExp>;
  resourceId?: InputMaybe<StringComparisonExp>;
  resourceType?: InputMaybe<StringComparisonExp>;
  rowCount?: InputMaybe<IntComparisonExp>;
  sessionId?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "audit.data_access_log" */
export type AuditDataAccessLogConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'data_access_log_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AuditDataAccessLogDeleteAtPathInput = {
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AuditDataAccessLogDeleteElemInput = {
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AuditDataAccessLogDeleteKeyInput = {
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "audit.data_access_log" */
export type AuditDataAccessLogIncInput = {
  rowCount?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "audit.data_access_log" */
export type AuditDataAccessLogInsertInput = {
  accessType?: InputMaybe<Scalars['String']['input']>;
  accessedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  dataClassification?: InputMaybe<Scalars['String']['input']>;
  fieldsAccessed?: InputMaybe<Array<Scalars['String']['input']>>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  queryExecuted?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['String']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
  rowCount?: InputMaybe<Scalars['Int']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type AuditDataAccessLogMaxFields = {
  __typename?: 'AuditDataAccessLogMaxFields';
  accessType?: Maybe<Scalars['String']['output']>;
  accessedAt?: Maybe<Scalars['timestamptz']['output']>;
  dataClassification?: Maybe<Scalars['String']['output']>;
  fieldsAccessed?: Maybe<Array<Scalars['String']['output']>>;
  id?: Maybe<Scalars['uuid']['output']>;
  queryExecuted?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['String']['output']>;
  resourceType?: Maybe<Scalars['String']['output']>;
  rowCount?: Maybe<Scalars['Int']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type AuditDataAccessLogMinFields = {
  __typename?: 'AuditDataAccessLogMinFields';
  accessType?: Maybe<Scalars['String']['output']>;
  accessedAt?: Maybe<Scalars['timestamptz']['output']>;
  dataClassification?: Maybe<Scalars['String']['output']>;
  fieldsAccessed?: Maybe<Array<Scalars['String']['output']>>;
  id?: Maybe<Scalars['uuid']['output']>;
  queryExecuted?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['String']['output']>;
  resourceType?: Maybe<Scalars['String']['output']>;
  rowCount?: Maybe<Scalars['Int']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "audit.data_access_log" */
export type AuditDataAccessLogMutationResponse = {
  __typename?: 'AuditDataAccessLogMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AuditDataAccessLog>;
};

/** on_conflict condition type for table "audit.data_access_log" */
export type AuditDataAccessLogOnConflict = {
  constraint: AuditDataAccessLogConstraint;
  updateColumns?: Array<AuditDataAccessLogUpdateColumn>;
  where?: InputMaybe<AuditDataAccessLogBoolExp>;
};

/** Ordering options when selecting data from "audit.data_access_log". */
export type AuditDataAccessLogOrderBy = {
  accessType?: InputMaybe<OrderBy>;
  accessedAt?: InputMaybe<OrderBy>;
  dataClassification?: InputMaybe<OrderBy>;
  fieldsAccessed?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ipAddress?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  queryExecuted?: InputMaybe<OrderBy>;
  resourceId?: InputMaybe<OrderBy>;
  resourceType?: InputMaybe<OrderBy>;
  rowCount?: InputMaybe<OrderBy>;
  sessionId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: audit.data_access_log */
export type AuditDataAccessLogPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AuditDataAccessLogPrependInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "audit.data_access_log" */
export type AuditDataAccessLogSelectColumn =
  /** column name */
  | 'accessType'
  /** column name */
  | 'accessedAt'
  /** column name */
  | 'dataClassification'
  /** column name */
  | 'fieldsAccessed'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'metadata'
  /** column name */
  | 'queryExecuted'
  /** column name */
  | 'resourceId'
  /** column name */
  | 'resourceType'
  /** column name */
  | 'rowCount'
  /** column name */
  | 'sessionId'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "audit.data_access_log" */
export type AuditDataAccessLogSetInput = {
  accessType?: InputMaybe<Scalars['String']['input']>;
  accessedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  dataClassification?: InputMaybe<Scalars['String']['input']>;
  fieldsAccessed?: InputMaybe<Array<Scalars['String']['input']>>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  queryExecuted?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['String']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
  rowCount?: InputMaybe<Scalars['Int']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type AuditDataAccessLogStddevFields = {
  __typename?: 'AuditDataAccessLogStddevFields';
  rowCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type AuditDataAccessLogStddevPopFields = {
  __typename?: 'AuditDataAccessLogStddevPopFields';
  rowCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type AuditDataAccessLogStddevSampFields = {
  __typename?: 'AuditDataAccessLogStddevSampFields';
  rowCount?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "audit_data_access_log" */
export type AuditDataAccessLogStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AuditDataAccessLogStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuditDataAccessLogStreamCursorValueInput = {
  accessType?: InputMaybe<Scalars['String']['input']>;
  accessedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  dataClassification?: InputMaybe<Scalars['String']['input']>;
  fieldsAccessed?: InputMaybe<Array<Scalars['String']['input']>>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  queryExecuted?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['String']['input']>;
  resourceType?: InputMaybe<Scalars['String']['input']>;
  rowCount?: InputMaybe<Scalars['Int']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type AuditDataAccessLogSumFields = {
  __typename?: 'AuditDataAccessLogSumFields';
  rowCount?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "audit.data_access_log" */
export type AuditDataAccessLogUpdateColumn =
  /** column name */
  | 'accessType'
  /** column name */
  | 'accessedAt'
  /** column name */
  | 'dataClassification'
  /** column name */
  | 'fieldsAccessed'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'metadata'
  /** column name */
  | 'queryExecuted'
  /** column name */
  | 'resourceId'
  /** column name */
  | 'resourceType'
  /** column name */
  | 'rowCount'
  /** column name */
  | 'sessionId'
  /** column name */
  | 'userId'
  | '%future added value';

export type AuditDataAccessLogUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AuditDataAccessLogAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AuditDataAccessLogDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AuditDataAccessLogDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AuditDataAccessLogDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AuditDataAccessLogIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AuditDataAccessLogPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuditDataAccessLogSetInput>;
  /** filter the rows which have to be updated */
  where: AuditDataAccessLogBoolExp;
};

/** aggregate varPop on columns */
export type AuditDataAccessLogVarPopFields = {
  __typename?: 'AuditDataAccessLogVarPopFields';
  rowCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type AuditDataAccessLogVarSampFields = {
  __typename?: 'AuditDataAccessLogVarSampFields';
  rowCount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type AuditDataAccessLogVarianceFields = {
  __typename?: 'AuditDataAccessLogVarianceFields';
  rowCount?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "audit.permission_changes" */
export type AuditPermissionChanges = {
  __typename?: 'AuditPermissionChanges';
  approvedByUserId?: Maybe<Scalars['uuid']['output']>;
  changeType: Scalars['String']['output'];
  changedAt: Scalars['timestamptz']['output'];
  changedByUserId: Scalars['uuid']['output'];
  id: Scalars['uuid']['output'];
  metadata?: Maybe<Scalars['jsonb']['output']>;
  newPermissions?: Maybe<Scalars['jsonb']['output']>;
  oldPermissions?: Maybe<Scalars['jsonb']['output']>;
  permissionType?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  targetRoleId?: Maybe<Scalars['uuid']['output']>;
  targetUserId?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "audit.permission_changes" */
export type AuditPermissionChangesMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "audit.permission_changes" */
export type AuditPermissionChangesNewPermissionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "audit.permission_changes" */
export type AuditPermissionChangesOldPermissionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "audit.permission_changes" */
export type AuditPermissionChangesAggregate = {
  __typename?: 'AuditPermissionChangesAggregate';
  aggregate?: Maybe<AuditPermissionChangesAggregateFields>;
  nodes: Array<AuditPermissionChanges>;
};

/** aggregate fields of "audit.permission_changes" */
export type AuditPermissionChangesAggregateFields = {
  __typename?: 'AuditPermissionChangesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AuditPermissionChangesMaxFields>;
  min?: Maybe<AuditPermissionChangesMinFields>;
};


/** aggregate fields of "audit.permission_changes" */
export type AuditPermissionChangesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuditPermissionChangesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AuditPermissionChangesAppendInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  oldPermissions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "audit.permission_changes". All fields are combined with a logical 'AND'. */
export type AuditPermissionChangesBoolExp = {
  _and?: InputMaybe<Array<AuditPermissionChangesBoolExp>>;
  _not?: InputMaybe<AuditPermissionChangesBoolExp>;
  _or?: InputMaybe<Array<AuditPermissionChangesBoolExp>>;
  approvedByUserId?: InputMaybe<UuidComparisonExp>;
  changeType?: InputMaybe<StringComparisonExp>;
  changedAt?: InputMaybe<TimestamptzComparisonExp>;
  changedByUserId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  newPermissions?: InputMaybe<JsonbComparisonExp>;
  oldPermissions?: InputMaybe<JsonbComparisonExp>;
  permissionType?: InputMaybe<StringComparisonExp>;
  reason?: InputMaybe<StringComparisonExp>;
  targetRoleId?: InputMaybe<UuidComparisonExp>;
  targetUserId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "audit.permission_changes" */
export type AuditPermissionChangesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'permission_changes_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AuditPermissionChangesDeleteAtPathInput = {
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
  newPermissions?: InputMaybe<Array<Scalars['String']['input']>>;
  oldPermissions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AuditPermissionChangesDeleteElemInput = {
  metadata?: InputMaybe<Scalars['Int']['input']>;
  newPermissions?: InputMaybe<Scalars['Int']['input']>;
  oldPermissions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AuditPermissionChangesDeleteKeyInput = {
  metadata?: InputMaybe<Scalars['String']['input']>;
  newPermissions?: InputMaybe<Scalars['String']['input']>;
  oldPermissions?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "audit.permission_changes" */
export type AuditPermissionChangesInsertInput = {
  approvedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  changeType?: InputMaybe<Scalars['String']['input']>;
  changedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  changedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  oldPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  permissionType?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  targetRoleId?: InputMaybe<Scalars['uuid']['input']>;
  targetUserId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type AuditPermissionChangesMaxFields = {
  __typename?: 'AuditPermissionChangesMaxFields';
  approvedByUserId?: Maybe<Scalars['uuid']['output']>;
  changeType?: Maybe<Scalars['String']['output']>;
  changedAt?: Maybe<Scalars['timestamptz']['output']>;
  changedByUserId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  permissionType?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  targetRoleId?: Maybe<Scalars['uuid']['output']>;
  targetUserId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type AuditPermissionChangesMinFields = {
  __typename?: 'AuditPermissionChangesMinFields';
  approvedByUserId?: Maybe<Scalars['uuid']['output']>;
  changeType?: Maybe<Scalars['String']['output']>;
  changedAt?: Maybe<Scalars['timestamptz']['output']>;
  changedByUserId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  permissionType?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  targetRoleId?: Maybe<Scalars['uuid']['output']>;
  targetUserId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "audit.permission_changes" */
export type AuditPermissionChangesMutationResponse = {
  __typename?: 'AuditPermissionChangesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AuditPermissionChanges>;
};

/** on_conflict condition type for table "audit.permission_changes" */
export type AuditPermissionChangesOnConflict = {
  constraint: AuditPermissionChangesConstraint;
  updateColumns?: Array<AuditPermissionChangesUpdateColumn>;
  where?: InputMaybe<AuditPermissionChangesBoolExp>;
};

/** Ordering options when selecting data from "audit.permission_changes". */
export type AuditPermissionChangesOrderBy = {
  approvedByUserId?: InputMaybe<OrderBy>;
  changeType?: InputMaybe<OrderBy>;
  changedAt?: InputMaybe<OrderBy>;
  changedByUserId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  newPermissions?: InputMaybe<OrderBy>;
  oldPermissions?: InputMaybe<OrderBy>;
  permissionType?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  targetRoleId?: InputMaybe<OrderBy>;
  targetUserId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: audit.permission_changes */
export type AuditPermissionChangesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AuditPermissionChangesPrependInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  oldPermissions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "audit.permission_changes" */
export type AuditPermissionChangesSelectColumn =
  /** column name */
  | 'approvedByUserId'
  /** column name */
  | 'changeType'
  /** column name */
  | 'changedAt'
  /** column name */
  | 'changedByUserId'
  /** column name */
  | 'id'
  /** column name */
  | 'metadata'
  /** column name */
  | 'newPermissions'
  /** column name */
  | 'oldPermissions'
  /** column name */
  | 'permissionType'
  /** column name */
  | 'reason'
  /** column name */
  | 'targetRoleId'
  /** column name */
  | 'targetUserId'
  | '%future added value';

/** input type for updating data in table "audit.permission_changes" */
export type AuditPermissionChangesSetInput = {
  approvedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  changeType?: InputMaybe<Scalars['String']['input']>;
  changedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  changedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  oldPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  permissionType?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  targetRoleId?: InputMaybe<Scalars['uuid']['input']>;
  targetUserId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "audit_permission_changes" */
export type AuditPermissionChangesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AuditPermissionChangesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuditPermissionChangesStreamCursorValueInput = {
  approvedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  changeType?: InputMaybe<Scalars['String']['input']>;
  changedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  changedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  newPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  oldPermissions?: InputMaybe<Scalars['jsonb']['input']>;
  permissionType?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  targetRoleId?: InputMaybe<Scalars['uuid']['input']>;
  targetUserId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "audit.permission_changes" */
export type AuditPermissionChangesUpdateColumn =
  /** column name */
  | 'approvedByUserId'
  /** column name */
  | 'changeType'
  /** column name */
  | 'changedAt'
  /** column name */
  | 'changedByUserId'
  /** column name */
  | 'id'
  /** column name */
  | 'metadata'
  /** column name */
  | 'newPermissions'
  /** column name */
  | 'oldPermissions'
  /** column name */
  | 'permissionType'
  /** column name */
  | 'reason'
  /** column name */
  | 'targetRoleId'
  /** column name */
  | 'targetUserId'
  | '%future added value';

export type AuditPermissionChangesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AuditPermissionChangesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<AuditPermissionChangesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<AuditPermissionChangesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<AuditPermissionChangesDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AuditPermissionChangesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuditPermissionChangesSetInput>;
  /** filter the rows which have to be updated */
  where: AuditPermissionChangesBoolExp;
};

/** columns and relationships of "audit.permission_usage_report" */
export type AuditPermissionUsageReport = {
  __typename?: 'AuditPermissionUsageReport';
  action?: Maybe<Scalars['permission_action']['output']>;
  lastUsed?: Maybe<Scalars['timestamptz']['output']>;
  resourceName?: Maybe<Scalars['String']['output']>;
  roleName?: Maybe<Scalars['String']['output']>;
  totalUsageCount?: Maybe<Scalars['bigint']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['bigint']['output']>;
  usersWithPermission?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "audit.permission_usage_report" */
export type AuditPermissionUsageReportAggregate = {
  __typename?: 'AuditPermissionUsageReportAggregate';
  aggregate?: Maybe<AuditPermissionUsageReportAggregateFields>;
  nodes: Array<AuditPermissionUsageReport>;
};

/** aggregate fields of "audit.permission_usage_report" */
export type AuditPermissionUsageReportAggregateFields = {
  __typename?: 'AuditPermissionUsageReportAggregateFields';
  avg?: Maybe<AuditPermissionUsageReportAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<AuditPermissionUsageReportMaxFields>;
  min?: Maybe<AuditPermissionUsageReportMinFields>;
  stddev?: Maybe<AuditPermissionUsageReportStddevFields>;
  stddevPop?: Maybe<AuditPermissionUsageReportStddevPopFields>;
  stddevSamp?: Maybe<AuditPermissionUsageReportStddevSampFields>;
  sum?: Maybe<AuditPermissionUsageReportSumFields>;
  varPop?: Maybe<AuditPermissionUsageReportVarPopFields>;
  varSamp?: Maybe<AuditPermissionUsageReportVarSampFields>;
  variance?: Maybe<AuditPermissionUsageReportVarianceFields>;
};


/** aggregate fields of "audit.permission_usage_report" */
export type AuditPermissionUsageReportAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuditPermissionUsageReportSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type AuditPermissionUsageReportAvgFields = {
  __typename?: 'AuditPermissionUsageReportAvgFields';
  totalUsageCount?: Maybe<Scalars['Float']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['Float']['output']>;
  usersWithPermission?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "audit.permission_usage_report". All fields are combined with a logical 'AND'. */
export type AuditPermissionUsageReportBoolExp = {
  _and?: InputMaybe<Array<AuditPermissionUsageReportBoolExp>>;
  _not?: InputMaybe<AuditPermissionUsageReportBoolExp>;
  _or?: InputMaybe<Array<AuditPermissionUsageReportBoolExp>>;
  action?: InputMaybe<PermissionActionComparisonExp>;
  lastUsed?: InputMaybe<TimestamptzComparisonExp>;
  resourceName?: InputMaybe<StringComparisonExp>;
  roleName?: InputMaybe<StringComparisonExp>;
  totalUsageCount?: InputMaybe<BigintComparisonExp>;
  usersWhoUsedPermission?: InputMaybe<BigintComparisonExp>;
  usersWithPermission?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type AuditPermissionUsageReportMaxFields = {
  __typename?: 'AuditPermissionUsageReportMaxFields';
  action?: Maybe<Scalars['permission_action']['output']>;
  lastUsed?: Maybe<Scalars['timestamptz']['output']>;
  resourceName?: Maybe<Scalars['String']['output']>;
  roleName?: Maybe<Scalars['String']['output']>;
  totalUsageCount?: Maybe<Scalars['bigint']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['bigint']['output']>;
  usersWithPermission?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type AuditPermissionUsageReportMinFields = {
  __typename?: 'AuditPermissionUsageReportMinFields';
  action?: Maybe<Scalars['permission_action']['output']>;
  lastUsed?: Maybe<Scalars['timestamptz']['output']>;
  resourceName?: Maybe<Scalars['String']['output']>;
  roleName?: Maybe<Scalars['String']['output']>;
  totalUsageCount?: Maybe<Scalars['bigint']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['bigint']['output']>;
  usersWithPermission?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "audit.permission_usage_report". */
export type AuditPermissionUsageReportOrderBy = {
  action?: InputMaybe<OrderBy>;
  lastUsed?: InputMaybe<OrderBy>;
  resourceName?: InputMaybe<OrderBy>;
  roleName?: InputMaybe<OrderBy>;
  totalUsageCount?: InputMaybe<OrderBy>;
  usersWhoUsedPermission?: InputMaybe<OrderBy>;
  usersWithPermission?: InputMaybe<OrderBy>;
};

/** select columns of table "audit.permission_usage_report" */
export type AuditPermissionUsageReportSelectColumn =
  /** column name */
  | 'action'
  /** column name */
  | 'lastUsed'
  /** column name */
  | 'resourceName'
  /** column name */
  | 'roleName'
  /** column name */
  | 'totalUsageCount'
  /** column name */
  | 'usersWhoUsedPermission'
  /** column name */
  | 'usersWithPermission'
  | '%future added value';

/** aggregate stddev on columns */
export type AuditPermissionUsageReportStddevFields = {
  __typename?: 'AuditPermissionUsageReportStddevFields';
  totalUsageCount?: Maybe<Scalars['Float']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['Float']['output']>;
  usersWithPermission?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type AuditPermissionUsageReportStddevPopFields = {
  __typename?: 'AuditPermissionUsageReportStddevPopFields';
  totalUsageCount?: Maybe<Scalars['Float']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['Float']['output']>;
  usersWithPermission?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type AuditPermissionUsageReportStddevSampFields = {
  __typename?: 'AuditPermissionUsageReportStddevSampFields';
  totalUsageCount?: Maybe<Scalars['Float']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['Float']['output']>;
  usersWithPermission?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "audit_permission_usage_report" */
export type AuditPermissionUsageReportStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AuditPermissionUsageReportStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuditPermissionUsageReportStreamCursorValueInput = {
  action?: InputMaybe<Scalars['permission_action']['input']>;
  lastUsed?: InputMaybe<Scalars['timestamptz']['input']>;
  resourceName?: InputMaybe<Scalars['String']['input']>;
  roleName?: InputMaybe<Scalars['String']['input']>;
  totalUsageCount?: InputMaybe<Scalars['bigint']['input']>;
  usersWhoUsedPermission?: InputMaybe<Scalars['bigint']['input']>;
  usersWithPermission?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type AuditPermissionUsageReportSumFields = {
  __typename?: 'AuditPermissionUsageReportSumFields';
  totalUsageCount?: Maybe<Scalars['bigint']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['bigint']['output']>;
  usersWithPermission?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate varPop on columns */
export type AuditPermissionUsageReportVarPopFields = {
  __typename?: 'AuditPermissionUsageReportVarPopFields';
  totalUsageCount?: Maybe<Scalars['Float']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['Float']['output']>;
  usersWithPermission?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type AuditPermissionUsageReportVarSampFields = {
  __typename?: 'AuditPermissionUsageReportVarSampFields';
  totalUsageCount?: Maybe<Scalars['Float']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['Float']['output']>;
  usersWithPermission?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type AuditPermissionUsageReportVarianceFields = {
  __typename?: 'AuditPermissionUsageReportVarianceFields';
  totalUsageCount?: Maybe<Scalars['Float']['output']>;
  usersWhoUsedPermission?: Maybe<Scalars['Float']['output']>;
  usersWithPermission?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "audit.slow_queries" */
export type AuditSlowQueries = {
  __typename?: 'AuditSlowQueries';
  applicationName?: Maybe<Scalars['String']['output']>;
  clientAddr?: Maybe<Scalars['inet']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  query: Scalars['String']['output'];
  queryDuration: Scalars['interval']['output'];
  queryStart: Scalars['timestamptz']['output'];
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "audit.slow_queries" */
export type AuditSlowQueriesAggregate = {
  __typename?: 'AuditSlowQueriesAggregate';
  aggregate?: Maybe<AuditSlowQueriesAggregateFields>;
  nodes: Array<AuditSlowQueries>;
};

/** aggregate fields of "audit.slow_queries" */
export type AuditSlowQueriesAggregateFields = {
  __typename?: 'AuditSlowQueriesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AuditSlowQueriesMaxFields>;
  min?: Maybe<AuditSlowQueriesMinFields>;
};


/** aggregate fields of "audit.slow_queries" */
export type AuditSlowQueriesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuditSlowQueriesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "audit.slow_queries". All fields are combined with a logical 'AND'. */
export type AuditSlowQueriesBoolExp = {
  _and?: InputMaybe<Array<AuditSlowQueriesBoolExp>>;
  _not?: InputMaybe<AuditSlowQueriesBoolExp>;
  _or?: InputMaybe<Array<AuditSlowQueriesBoolExp>>;
  applicationName?: InputMaybe<StringComparisonExp>;
  clientAddr?: InputMaybe<InetComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  query?: InputMaybe<StringComparisonExp>;
  queryDuration?: InputMaybe<IntervalComparisonExp>;
  queryStart?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "audit.slow_queries" */
export type AuditSlowQueriesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'slow_queries_pkey'
  | '%future added value';

/** input type for inserting data into table "audit.slow_queries" */
export type AuditSlowQueriesInsertInput = {
  applicationName?: InputMaybe<Scalars['String']['input']>;
  clientAddr?: InputMaybe<Scalars['inet']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  queryDuration?: InputMaybe<Scalars['interval']['input']>;
  queryStart?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type AuditSlowQueriesMaxFields = {
  __typename?: 'AuditSlowQueriesMaxFields';
  applicationName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  query?: Maybe<Scalars['String']['output']>;
  queryStart?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type AuditSlowQueriesMinFields = {
  __typename?: 'AuditSlowQueriesMinFields';
  applicationName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  query?: Maybe<Scalars['String']['output']>;
  queryStart?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "audit.slow_queries" */
export type AuditSlowQueriesMutationResponse = {
  __typename?: 'AuditSlowQueriesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AuditSlowQueries>;
};

/** on_conflict condition type for table "audit.slow_queries" */
export type AuditSlowQueriesOnConflict = {
  constraint: AuditSlowQueriesConstraint;
  updateColumns?: Array<AuditSlowQueriesUpdateColumn>;
  where?: InputMaybe<AuditSlowQueriesBoolExp>;
};

/** Ordering options when selecting data from "audit.slow_queries". */
export type AuditSlowQueriesOrderBy = {
  applicationName?: InputMaybe<OrderBy>;
  clientAddr?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  query?: InputMaybe<OrderBy>;
  queryDuration?: InputMaybe<OrderBy>;
  queryStart?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: audit.slow_queries */
export type AuditSlowQueriesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "audit.slow_queries" */
export type AuditSlowQueriesSelectColumn =
  /** column name */
  | 'applicationName'
  /** column name */
  | 'clientAddr'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'query'
  /** column name */
  | 'queryDuration'
  /** column name */
  | 'queryStart'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "audit.slow_queries" */
export type AuditSlowQueriesSetInput = {
  applicationName?: InputMaybe<Scalars['String']['input']>;
  clientAddr?: InputMaybe<Scalars['inet']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  queryDuration?: InputMaybe<Scalars['interval']['input']>;
  queryStart?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "audit_slow_queries" */
export type AuditSlowQueriesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AuditSlowQueriesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuditSlowQueriesStreamCursorValueInput = {
  applicationName?: InputMaybe<Scalars['String']['input']>;
  clientAddr?: InputMaybe<Scalars['inet']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  queryDuration?: InputMaybe<Scalars['interval']['input']>;
  queryStart?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "audit.slow_queries" */
export type AuditSlowQueriesUpdateColumn =
  /** column name */
  | 'applicationName'
  /** column name */
  | 'clientAddr'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'query'
  /** column name */
  | 'queryDuration'
  /** column name */
  | 'queryStart'
  /** column name */
  | 'userId'
  | '%future added value';

export type AuditSlowQueriesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuditSlowQueriesSetInput>;
  /** filter the rows which have to be updated */
  where: AuditSlowQueriesBoolExp;
};

/** columns and relationships of "audit.user_access_summary" */
export type AuditUserAccessSummary = {
  __typename?: 'AuditUserAccessSummary';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isStaff?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Scalars['user_role']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "audit.user_access_summary" */
export type AuditUserAccessSummaryAggregate = {
  __typename?: 'AuditUserAccessSummaryAggregate';
  aggregate?: Maybe<AuditUserAccessSummaryAggregateFields>;
  nodes: Array<AuditUserAccessSummary>;
};

/** aggregate fields of "audit.user_access_summary" */
export type AuditUserAccessSummaryAggregateFields = {
  __typename?: 'AuditUserAccessSummaryAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<AuditUserAccessSummaryMaxFields>;
  min?: Maybe<AuditUserAccessSummaryMinFields>;
};


/** aggregate fields of "audit.user_access_summary" */
export type AuditUserAccessSummaryAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<AuditUserAccessSummarySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "audit.user_access_summary". All fields are combined with a logical 'AND'. */
export type AuditUserAccessSummaryBoolExp = {
  _and?: InputMaybe<Array<AuditUserAccessSummaryBoolExp>>;
  _not?: InputMaybe<AuditUserAccessSummaryBoolExp>;
  _or?: InputMaybe<Array<AuditUserAccessSummaryBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isStaff?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  role?: InputMaybe<UserRoleComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** input type for inserting data into table "audit.user_access_summary" */
export type AuditUserAccessSummaryInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['user_role']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type AuditUserAccessSummaryMaxFields = {
  __typename?: 'AuditUserAccessSummaryMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Scalars['user_role']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type AuditUserAccessSummaryMinFields = {
  __typename?: 'AuditUserAccessSummaryMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Scalars['user_role']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "audit.user_access_summary" */
export type AuditUserAccessSummaryMutationResponse = {
  __typename?: 'AuditUserAccessSummaryMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<AuditUserAccessSummary>;
};

/** Ordering options when selecting data from "audit.user_access_summary". */
export type AuditUserAccessSummaryOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isStaff?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  role?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** select columns of table "audit.user_access_summary" */
export type AuditUserAccessSummarySelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'email'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isStaff'
  /** column name */
  | 'name'
  /** column name */
  | 'role'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "audit.user_access_summary" */
export type AuditUserAccessSummarySetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['user_role']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "audit_user_access_summary" */
export type AuditUserAccessSummaryStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: AuditUserAccessSummaryStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type AuditUserAccessSummaryStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['user_role']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

export type AuditUserAccessSummaryUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuditUserAccessSummarySetInput>;
  /** filter the rows which have to be updated */
  where: AuditUserAccessSummaryBoolExp;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type BigintComparisonExp = {
  _eq?: InputMaybe<Scalars['bigint']['input']>;
  _gt?: InputMaybe<Scalars['bigint']['input']>;
  _gte?: InputMaybe<Scalars['bigint']['input']>;
  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['bigint']['input']>;
  _lte?: InputMaybe<Scalars['bigint']['input']>;
  _neq?: InputMaybe<Scalars['bigint']['input']>;
  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};

/** Metrics showing automation effectiveness and approval workflows */
export type BillingAutomationMetrics = {
  __typename?: 'BillingAutomationMetrics';
  approvedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['numeric']['output']>;
  avgApprovalDays?: Maybe<Scalars['numeric']['output']>;
  manualItems?: Maybe<Scalars['bigint']['output']>;
  manualRevenue?: Maybe<Scalars['numeric']['output']>;
  pendingApproval?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "billing_automation_metrics" */
export type BillingAutomationMetricsAggregate = {
  __typename?: 'BillingAutomationMetricsAggregate';
  aggregate?: Maybe<BillingAutomationMetricsAggregateFields>;
  nodes: Array<BillingAutomationMetrics>;
};

/** aggregate fields of "billing_automation_metrics" */
export type BillingAutomationMetricsAggregateFields = {
  __typename?: 'BillingAutomationMetricsAggregateFields';
  avg?: Maybe<BillingAutomationMetricsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<BillingAutomationMetricsMaxFields>;
  min?: Maybe<BillingAutomationMetricsMinFields>;
  stddev?: Maybe<BillingAutomationMetricsStddevFields>;
  stddevPop?: Maybe<BillingAutomationMetricsStddevPopFields>;
  stddevSamp?: Maybe<BillingAutomationMetricsStddevSampFields>;
  sum?: Maybe<BillingAutomationMetricsSumFields>;
  varPop?: Maybe<BillingAutomationMetricsVarPopFields>;
  varSamp?: Maybe<BillingAutomationMetricsVarSampFields>;
  variance?: Maybe<BillingAutomationMetricsVarianceFields>;
};


/** aggregate fields of "billing_automation_metrics" */
export type BillingAutomationMetricsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BillingAutomationMetricsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type BillingAutomationMetricsAvgFields = {
  __typename?: 'BillingAutomationMetricsAvgFields';
  approvedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['Float']['output']>;
  avgApprovalDays?: Maybe<Scalars['Float']['output']>;
  manualItems?: Maybe<Scalars['Float']['output']>;
  manualRevenue?: Maybe<Scalars['Float']['output']>;
  pendingApproval?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "billing_automation_metrics". All fields are combined with a logical 'AND'. */
export type BillingAutomationMetricsBoolExp = {
  _and?: InputMaybe<Array<BillingAutomationMetricsBoolExp>>;
  _not?: InputMaybe<BillingAutomationMetricsBoolExp>;
  _or?: InputMaybe<Array<BillingAutomationMetricsBoolExp>>;
  approvedItems?: InputMaybe<BigintComparisonExp>;
  autoGeneratedItems?: InputMaybe<BigintComparisonExp>;
  autoGeneratedRevenue?: InputMaybe<NumericComparisonExp>;
  avgApprovalDays?: InputMaybe<NumericComparisonExp>;
  manualItems?: InputMaybe<BigintComparisonExp>;
  manualRevenue?: InputMaybe<NumericComparisonExp>;
  pendingApproval?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type BillingAutomationMetricsMaxFields = {
  __typename?: 'BillingAutomationMetricsMaxFields';
  approvedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['numeric']['output']>;
  avgApprovalDays?: Maybe<Scalars['numeric']['output']>;
  manualItems?: Maybe<Scalars['bigint']['output']>;
  manualRevenue?: Maybe<Scalars['numeric']['output']>;
  pendingApproval?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type BillingAutomationMetricsMinFields = {
  __typename?: 'BillingAutomationMetricsMinFields';
  approvedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['numeric']['output']>;
  avgApprovalDays?: Maybe<Scalars['numeric']['output']>;
  manualItems?: Maybe<Scalars['bigint']['output']>;
  manualRevenue?: Maybe<Scalars['numeric']['output']>;
  pendingApproval?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "billing_automation_metrics". */
export type BillingAutomationMetricsOrderBy = {
  approvedItems?: InputMaybe<OrderBy>;
  autoGeneratedItems?: InputMaybe<OrderBy>;
  autoGeneratedRevenue?: InputMaybe<OrderBy>;
  avgApprovalDays?: InputMaybe<OrderBy>;
  manualItems?: InputMaybe<OrderBy>;
  manualRevenue?: InputMaybe<OrderBy>;
  pendingApproval?: InputMaybe<OrderBy>;
};

/** select columns of table "billing_automation_metrics" */
export type BillingAutomationMetricsSelectColumn =
  /** column name */
  | 'approvedItems'
  /** column name */
  | 'autoGeneratedItems'
  /** column name */
  | 'autoGeneratedRevenue'
  /** column name */
  | 'avgApprovalDays'
  /** column name */
  | 'manualItems'
  /** column name */
  | 'manualRevenue'
  /** column name */
  | 'pendingApproval'
  | '%future added value';

/** aggregate stddev on columns */
export type BillingAutomationMetricsStddevFields = {
  __typename?: 'BillingAutomationMetricsStddevFields';
  approvedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['Float']['output']>;
  avgApprovalDays?: Maybe<Scalars['Float']['output']>;
  manualItems?: Maybe<Scalars['Float']['output']>;
  manualRevenue?: Maybe<Scalars['Float']['output']>;
  pendingApproval?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type BillingAutomationMetricsStddevPopFields = {
  __typename?: 'BillingAutomationMetricsStddevPopFields';
  approvedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['Float']['output']>;
  avgApprovalDays?: Maybe<Scalars['Float']['output']>;
  manualItems?: Maybe<Scalars['Float']['output']>;
  manualRevenue?: Maybe<Scalars['Float']['output']>;
  pendingApproval?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type BillingAutomationMetricsStddevSampFields = {
  __typename?: 'BillingAutomationMetricsStddevSampFields';
  approvedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['Float']['output']>;
  avgApprovalDays?: Maybe<Scalars['Float']['output']>;
  manualItems?: Maybe<Scalars['Float']['output']>;
  manualRevenue?: Maybe<Scalars['Float']['output']>;
  pendingApproval?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "billing_automation_metrics" */
export type BillingAutomationMetricsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BillingAutomationMetricsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BillingAutomationMetricsStreamCursorValueInput = {
  approvedItems?: InputMaybe<Scalars['bigint']['input']>;
  autoGeneratedItems?: InputMaybe<Scalars['bigint']['input']>;
  autoGeneratedRevenue?: InputMaybe<Scalars['numeric']['input']>;
  avgApprovalDays?: InputMaybe<Scalars['numeric']['input']>;
  manualItems?: InputMaybe<Scalars['bigint']['input']>;
  manualRevenue?: InputMaybe<Scalars['numeric']['input']>;
  pendingApproval?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type BillingAutomationMetricsSumFields = {
  __typename?: 'BillingAutomationMetricsSumFields';
  approvedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedItems?: Maybe<Scalars['bigint']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['numeric']['output']>;
  avgApprovalDays?: Maybe<Scalars['numeric']['output']>;
  manualItems?: Maybe<Scalars['bigint']['output']>;
  manualRevenue?: Maybe<Scalars['numeric']['output']>;
  pendingApproval?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate varPop on columns */
export type BillingAutomationMetricsVarPopFields = {
  __typename?: 'BillingAutomationMetricsVarPopFields';
  approvedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['Float']['output']>;
  avgApprovalDays?: Maybe<Scalars['Float']['output']>;
  manualItems?: Maybe<Scalars['Float']['output']>;
  manualRevenue?: Maybe<Scalars['Float']['output']>;
  pendingApproval?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type BillingAutomationMetricsVarSampFields = {
  __typename?: 'BillingAutomationMetricsVarSampFields';
  approvedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['Float']['output']>;
  avgApprovalDays?: Maybe<Scalars['Float']['output']>;
  manualItems?: Maybe<Scalars['Float']['output']>;
  manualRevenue?: Maybe<Scalars['Float']['output']>;
  pendingApproval?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type BillingAutomationMetricsVarianceFields = {
  __typename?: 'BillingAutomationMetricsVarianceFields';
  approvedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedItems?: Maybe<Scalars['Float']['output']>;
  autoGeneratedRevenue?: Maybe<Scalars['Float']['output']>;
  avgApprovalDays?: Maybe<Scalars['Float']['output']>;
  manualItems?: Maybe<Scalars['Float']['output']>;
  manualRevenue?: Maybe<Scalars['Float']['output']>;
  pendingApproval?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "billing_event_log" */
export type BillingEventLog = {
  __typename?: 'BillingEventLog';
  /** An object relationship */
  billingInvoice?: Maybe<BillingInvoice>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  createdByUser?: Maybe<Users>;
  eventType: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  message?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "billing_event_log" */
export type BillingEventLogAggregate = {
  __typename?: 'BillingEventLogAggregate';
  aggregate?: Maybe<BillingEventLogAggregateFields>;
  nodes: Array<BillingEventLog>;
};

export type BillingEventLogAggregateBoolExp = {
  count?: InputMaybe<BillingEventLogAggregateBoolExpCount>;
};

/** aggregate fields of "billing_event_log" */
export type BillingEventLogAggregateFields = {
  __typename?: 'BillingEventLogAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<BillingEventLogMaxFields>;
  min?: Maybe<BillingEventLogMinFields>;
};


/** aggregate fields of "billing_event_log" */
export type BillingEventLogAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "billing_event_log" */
export type BillingEventLogAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<BillingEventLogMaxOrderBy>;
  min?: InputMaybe<BillingEventLogMinOrderBy>;
};

/** input type for inserting array relation for remote table "billing_event_log" */
export type BillingEventLogArrRelInsertInput = {
  data: Array<BillingEventLogInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<BillingEventLogOnConflict>;
};

/** Boolean expression to filter rows from the table "billing_event_log". All fields are combined with a logical 'AND'. */
export type BillingEventLogBoolExp = {
  _and?: InputMaybe<Array<BillingEventLogBoolExp>>;
  _not?: InputMaybe<BillingEventLogBoolExp>;
  _or?: InputMaybe<Array<BillingEventLogBoolExp>>;
  billingInvoice?: InputMaybe<BillingInvoiceBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  eventType?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invoiceId?: InputMaybe<UuidComparisonExp>;
  message?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "billing_event_log" */
export type BillingEventLogConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'billing_event_log_pkey'
  | '%future added value';

/** input type for inserting data into table "billing_event_log" */
export type BillingEventLogInsertInput = {
  billingInvoice?: InputMaybe<BillingInvoiceObjRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  eventType?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type BillingEventLogMaxFields = {
  __typename?: 'BillingEventLogMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  eventType?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  message?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "billing_event_log" */
export type BillingEventLogMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  eventType?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type BillingEventLogMinFields = {
  __typename?: 'BillingEventLogMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  eventType?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  message?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "billing_event_log" */
export type BillingEventLogMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  eventType?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "billing_event_log" */
export type BillingEventLogMutationResponse = {
  __typename?: 'BillingEventLogMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BillingEventLog>;
};

/** on_conflict condition type for table "billing_event_log" */
export type BillingEventLogOnConflict = {
  constraint: BillingEventLogConstraint;
  updateColumns?: Array<BillingEventLogUpdateColumn>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};

/** Ordering options when selecting data from "billing_event_log". */
export type BillingEventLogOrderBy = {
  billingInvoice?: InputMaybe<BillingInvoiceOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  eventType?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: billing_event_log */
export type BillingEventLogPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "billing_event_log" */
export type BillingEventLogSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'eventType'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceId'
  /** column name */
  | 'message'
  | '%future added value';

/** input type for updating data in table "billing_event_log" */
export type BillingEventLogSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  eventType?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "billing_event_log" */
export type BillingEventLogStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BillingEventLogStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BillingEventLogStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  eventType?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "billing_event_log" */
export type BillingEventLogUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'eventType'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceId'
  /** column name */
  | 'message'
  | '%future added value';

export type BillingEventLogUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BillingEventLogSetInput>;
  /** filter the rows which have to be updated */
  where: BillingEventLogBoolExp;
};

/** columns and relationships of "billing_invoice" */
export type BillingInvoice = {
  __typename?: 'BillingInvoice';
  /** An object relationship */
  billingPeriod?: Maybe<BillingPeriods>;
  billingPeriodEnd: Scalars['date']['output'];
  /** Reference to billing period this invoice covers */
  billingPeriodId?: Maybe<Scalars['uuid']['output']>;
  billingPeriodStart: Scalars['date']['output'];
  /** An object relationship */
  client: Clients;
  clientId: Scalars['uuid']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  dueDate?: Maybe<Scalars['date']['output']>;
  /** An array relationship */
  eventLogs: Array<BillingEventLog>;
  /** An aggregate relationship */
  eventLogsAggregate: BillingEventLogAggregate;
  id: Scalars['uuid']['output'];
  /** An array relationship */
  invoiceItems: Array<BillingInvoiceItem>;
  /** An aggregate relationship */
  invoiceItemsAggregate: BillingInvoiceItemAggregate;
  /** Unique invoice number for client reference */
  invoiceNumber?: Maybe<Scalars['String']['output']>;
  issuedDate?: Maybe<Scalars['date']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Int']['output']>;
  status: Scalars['String']['output'];
  totalAmount: Scalars['numeric']['output'];
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "billing_invoice" */
export type BillingInvoiceEventLogsArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


/** columns and relationships of "billing_invoice" */
export type BillingInvoiceEventLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


/** columns and relationships of "billing_invoice" */
export type BillingInvoiceInvoiceItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


/** columns and relationships of "billing_invoice" */
export type BillingInvoiceInvoiceItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};

/** aggregated selection of "billing_invoice" */
export type BillingInvoiceAggregate = {
  __typename?: 'BillingInvoiceAggregate';
  aggregate?: Maybe<BillingInvoiceAggregateFields>;
  nodes: Array<BillingInvoice>;
};

export type BillingInvoiceAggregateBoolExp = {
  count?: InputMaybe<BillingInvoiceAggregateBoolExpCount>;
};

/** aggregate fields of "billing_invoice" */
export type BillingInvoiceAggregateFields = {
  __typename?: 'BillingInvoiceAggregateFields';
  avg?: Maybe<BillingInvoiceAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<BillingInvoiceMaxFields>;
  min?: Maybe<BillingInvoiceMinFields>;
  stddev?: Maybe<BillingInvoiceStddevFields>;
  stddevPop?: Maybe<BillingInvoiceStddevPopFields>;
  stddevSamp?: Maybe<BillingInvoiceStddevSampFields>;
  sum?: Maybe<BillingInvoiceSumFields>;
  varPop?: Maybe<BillingInvoiceVarPopFields>;
  varSamp?: Maybe<BillingInvoiceVarSampFields>;
  variance?: Maybe<BillingInvoiceVarianceFields>;
};


/** aggregate fields of "billing_invoice" */
export type BillingInvoiceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "billing_invoice" */
export type BillingInvoiceAggregateOrderBy = {
  avg?: InputMaybe<BillingInvoiceAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<BillingInvoiceMaxOrderBy>;
  min?: InputMaybe<BillingInvoiceMinOrderBy>;
  stddev?: InputMaybe<BillingInvoiceStddevOrderBy>;
  stddevPop?: InputMaybe<BillingInvoiceStddevPopOrderBy>;
  stddevSamp?: InputMaybe<BillingInvoiceStddevSampOrderBy>;
  sum?: InputMaybe<BillingInvoiceSumOrderBy>;
  varPop?: InputMaybe<BillingInvoiceVarPopOrderBy>;
  varSamp?: InputMaybe<BillingInvoiceVarSampOrderBy>;
  variance?: InputMaybe<BillingInvoiceVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "billing_invoice" */
export type BillingInvoiceArrRelInsertInput = {
  data: Array<BillingInvoiceInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<BillingInvoiceOnConflict>;
};

/** aggregate avg on columns */
export type BillingInvoiceAvgFields = {
  __typename?: 'BillingInvoiceAvgFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "billing_invoice" */
export type BillingInvoiceAvgOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "billing_invoice". All fields are combined with a logical 'AND'. */
export type BillingInvoiceBoolExp = {
  _and?: InputMaybe<Array<BillingInvoiceBoolExp>>;
  _not?: InputMaybe<BillingInvoiceBoolExp>;
  _or?: InputMaybe<Array<BillingInvoiceBoolExp>>;
  billingPeriod?: InputMaybe<BillingPeriodsBoolExp>;
  billingPeriodEnd?: InputMaybe<DateComparisonExp>;
  billingPeriodId?: InputMaybe<UuidComparisonExp>;
  billingPeriodStart?: InputMaybe<DateComparisonExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  currency?: InputMaybe<StringComparisonExp>;
  dueDate?: InputMaybe<DateComparisonExp>;
  eventLogs?: InputMaybe<BillingEventLogBoolExp>;
  eventLogsAggregate?: InputMaybe<BillingEventLogAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invoiceItems?: InputMaybe<BillingInvoiceItemBoolExp>;
  invoiceItemsAggregate?: InputMaybe<BillingInvoiceItemAggregateBoolExp>;
  invoiceNumber?: InputMaybe<StringComparisonExp>;
  issuedDate?: InputMaybe<DateComparisonExp>;
  notes?: InputMaybe<StringComparisonExp>;
  payrollCount?: InputMaybe<IntComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  totalAmount?: InputMaybe<NumericComparisonExp>;
  totalHours?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "billing_invoice" */
export type BillingInvoiceConstraint =
  /** unique or primary key constraint on columns "invoice_number" */
  | 'billing_invoice_invoice_number_key'
  /** unique or primary key constraint on columns "id" */
  | 'billing_invoice_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "billing_invoice" */
export type BillingInvoiceIncInput = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<Scalars['Int']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "billing_invoice" */
export type BillingInvoiceInsertInput = {
  billingPeriod?: InputMaybe<BillingPeriodsObjRelInsertInput>;
  billingPeriodEnd?: InputMaybe<Scalars['date']['input']>;
  /** Reference to billing period this invoice covers */
  billingPeriodId?: InputMaybe<Scalars['uuid']['input']>;
  billingPeriodStart?: InputMaybe<Scalars['date']['input']>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  dueDate?: InputMaybe<Scalars['date']['input']>;
  eventLogs?: InputMaybe<BillingEventLogArrRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceItems?: InputMaybe<BillingInvoiceItemArrRelInsertInput>;
  /** Unique invoice number for client reference */
  invoiceNumber?: InputMaybe<Scalars['String']['input']>;
  issuedDate?: InputMaybe<Scalars['date']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "billing_invoice_item" */
export type BillingInvoiceItem = {
  __typename?: 'BillingInvoiceItem';
  /** An object relationship */
  billingInvoice: BillingInvoice;
  /** An object relationship */
  billingItem?: Maybe<BillingItems>;
  billingPeriodEnd: Scalars['date']['output'];
  billingPeriodStart: Scalars['date']['output'];
  createdAt: Scalars['timestamptz']['output'];
  descriptionOverride?: Maybe<Scalars['String']['output']>;
  hourlyRate: Scalars['numeric']['output'];
  id: Scalars['uuid']['output'];
  invoiceId: Scalars['uuid']['output'];
  itemId?: Maybe<Scalars['uuid']['output']>;
  lineItemType?: Maybe<Scalars['String']['output']>;
  netAmount?: Maybe<Scalars['numeric']['output']>;
  quantityHours: Scalars['numeric']['output'];
  taxAmount: Scalars['numeric']['output'];
  totalAmount: Scalars['numeric']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};

/** aggregated selection of "billing_invoice_item" */
export type BillingInvoiceItemAggregate = {
  __typename?: 'BillingInvoiceItemAggregate';
  aggregate?: Maybe<BillingInvoiceItemAggregateFields>;
  nodes: Array<BillingInvoiceItem>;
};

export type BillingInvoiceItemAggregateBoolExp = {
  count?: InputMaybe<BillingInvoiceItemAggregateBoolExpCount>;
};

/** aggregate fields of "billing_invoice_item" */
export type BillingInvoiceItemAggregateFields = {
  __typename?: 'BillingInvoiceItemAggregateFields';
  avg?: Maybe<BillingInvoiceItemAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<BillingInvoiceItemMaxFields>;
  min?: Maybe<BillingInvoiceItemMinFields>;
  stddev?: Maybe<BillingInvoiceItemStddevFields>;
  stddevPop?: Maybe<BillingInvoiceItemStddevPopFields>;
  stddevSamp?: Maybe<BillingInvoiceItemStddevSampFields>;
  sum?: Maybe<BillingInvoiceItemSumFields>;
  varPop?: Maybe<BillingInvoiceItemVarPopFields>;
  varSamp?: Maybe<BillingInvoiceItemVarSampFields>;
  variance?: Maybe<BillingInvoiceItemVarianceFields>;
};


/** aggregate fields of "billing_invoice_item" */
export type BillingInvoiceItemAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "billing_invoice_item" */
export type BillingInvoiceItemAggregateOrderBy = {
  avg?: InputMaybe<BillingInvoiceItemAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<BillingInvoiceItemMaxOrderBy>;
  min?: InputMaybe<BillingInvoiceItemMinOrderBy>;
  stddev?: InputMaybe<BillingInvoiceItemStddevOrderBy>;
  stddevPop?: InputMaybe<BillingInvoiceItemStddevPopOrderBy>;
  stddevSamp?: InputMaybe<BillingInvoiceItemStddevSampOrderBy>;
  sum?: InputMaybe<BillingInvoiceItemSumOrderBy>;
  varPop?: InputMaybe<BillingInvoiceItemVarPopOrderBy>;
  varSamp?: InputMaybe<BillingInvoiceItemVarSampOrderBy>;
  variance?: InputMaybe<BillingInvoiceItemVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "billing_invoice_item" */
export type BillingInvoiceItemArrRelInsertInput = {
  data: Array<BillingInvoiceItemInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<BillingInvoiceItemOnConflict>;
};

/** aggregate avg on columns */
export type BillingInvoiceItemAvgFields = {
  __typename?: 'BillingInvoiceItemAvgFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  quantityHours?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemAvgOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "billing_invoice_item". All fields are combined with a logical 'AND'. */
export type BillingInvoiceItemBoolExp = {
  _and?: InputMaybe<Array<BillingInvoiceItemBoolExp>>;
  _not?: InputMaybe<BillingInvoiceItemBoolExp>;
  _or?: InputMaybe<Array<BillingInvoiceItemBoolExp>>;
  billingInvoice?: InputMaybe<BillingInvoiceBoolExp>;
  billingItem?: InputMaybe<BillingItemsBoolExp>;
  billingPeriodEnd?: InputMaybe<DateComparisonExp>;
  billingPeriodStart?: InputMaybe<DateComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  descriptionOverride?: InputMaybe<StringComparisonExp>;
  hourlyRate?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invoiceId?: InputMaybe<UuidComparisonExp>;
  itemId?: InputMaybe<UuidComparisonExp>;
  lineItemType?: InputMaybe<StringComparisonExp>;
  netAmount?: InputMaybe<NumericComparisonExp>;
  quantityHours?: InputMaybe<NumericComparisonExp>;
  taxAmount?: InputMaybe<NumericComparisonExp>;
  totalAmount?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "billing_invoice_item" */
export type BillingInvoiceItemConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'billing_invoice_item_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "billing_invoice_item" */
export type BillingInvoiceItemIncInput = {
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  quantityHours?: InputMaybe<Scalars['numeric']['input']>;
  taxAmount?: InputMaybe<Scalars['numeric']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "billing_invoice_item" */
export type BillingInvoiceItemInsertInput = {
  billingInvoice?: InputMaybe<BillingInvoiceObjRelInsertInput>;
  billingItem?: InputMaybe<BillingItemsObjRelInsertInput>;
  billingPeriodEnd?: InputMaybe<Scalars['date']['input']>;
  billingPeriodStart?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  descriptionOverride?: InputMaybe<Scalars['String']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  itemId?: InputMaybe<Scalars['uuid']['input']>;
  lineItemType?: InputMaybe<Scalars['String']['input']>;
  quantityHours?: InputMaybe<Scalars['numeric']['input']>;
  taxAmount?: InputMaybe<Scalars['numeric']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type BillingInvoiceItemMaxFields = {
  __typename?: 'BillingInvoiceItemMaxFields';
  billingPeriodEnd?: Maybe<Scalars['date']['output']>;
  billingPeriodStart?: Maybe<Scalars['date']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  descriptionOverride?: Maybe<Scalars['String']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  itemId?: Maybe<Scalars['uuid']['output']>;
  lineItemType?: Maybe<Scalars['String']['output']>;
  netAmount?: Maybe<Scalars['numeric']['output']>;
  quantityHours?: Maybe<Scalars['numeric']['output']>;
  taxAmount?: Maybe<Scalars['numeric']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemMaxOrderBy = {
  billingPeriodEnd?: InputMaybe<OrderBy>;
  billingPeriodStart?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  descriptionOverride?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  itemId?: InputMaybe<OrderBy>;
  lineItemType?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type BillingInvoiceItemMinFields = {
  __typename?: 'BillingInvoiceItemMinFields';
  billingPeriodEnd?: Maybe<Scalars['date']['output']>;
  billingPeriodStart?: Maybe<Scalars['date']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  descriptionOverride?: Maybe<Scalars['String']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  itemId?: Maybe<Scalars['uuid']['output']>;
  lineItemType?: Maybe<Scalars['String']['output']>;
  netAmount?: Maybe<Scalars['numeric']['output']>;
  quantityHours?: Maybe<Scalars['numeric']['output']>;
  taxAmount?: Maybe<Scalars['numeric']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemMinOrderBy = {
  billingPeriodEnd?: InputMaybe<OrderBy>;
  billingPeriodStart?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  descriptionOverride?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  itemId?: InputMaybe<OrderBy>;
  lineItemType?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "billing_invoice_item" */
export type BillingInvoiceItemMutationResponse = {
  __typename?: 'BillingInvoiceItemMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BillingInvoiceItem>;
};

/** on_conflict condition type for table "billing_invoice_item" */
export type BillingInvoiceItemOnConflict = {
  constraint: BillingInvoiceItemConstraint;
  updateColumns?: Array<BillingInvoiceItemUpdateColumn>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};

/** Ordering options when selecting data from "billing_invoice_item". */
export type BillingInvoiceItemOrderBy = {
  billingInvoice?: InputMaybe<BillingInvoiceOrderBy>;
  billingItem?: InputMaybe<BillingItemsOrderBy>;
  billingPeriodEnd?: InputMaybe<OrderBy>;
  billingPeriodStart?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  descriptionOverride?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  itemId?: InputMaybe<OrderBy>;
  lineItemType?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: billing_invoice_item */
export type BillingInvoiceItemPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "billing_invoice_item" */
export type BillingInvoiceItemSelectColumn =
  /** column name */
  | 'billingPeriodEnd'
  /** column name */
  | 'billingPeriodStart'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'descriptionOverride'
  /** column name */
  | 'hourlyRate'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceId'
  /** column name */
  | 'itemId'
  /** column name */
  | 'lineItemType'
  /** column name */
  | 'netAmount'
  /** column name */
  | 'quantityHours'
  /** column name */
  | 'taxAmount'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "billing_invoice_item" */
export type BillingInvoiceItemSetInput = {
  billingPeriodEnd?: InputMaybe<Scalars['date']['input']>;
  billingPeriodStart?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  descriptionOverride?: InputMaybe<Scalars['String']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  itemId?: InputMaybe<Scalars['uuid']['input']>;
  lineItemType?: InputMaybe<Scalars['String']['input']>;
  quantityHours?: InputMaybe<Scalars['numeric']['input']>;
  taxAmount?: InputMaybe<Scalars['numeric']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type BillingInvoiceItemStddevFields = {
  __typename?: 'BillingInvoiceItemStddevFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  quantityHours?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemStddevOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type BillingInvoiceItemStddevPopFields = {
  __typename?: 'BillingInvoiceItemStddevPopFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  quantityHours?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemStddevPopOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type BillingInvoiceItemStddevSampFields = {
  __typename?: 'BillingInvoiceItemStddevSampFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  quantityHours?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemStddevSampOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "billing_invoice_item" */
export type BillingInvoiceItemStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BillingInvoiceItemStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BillingInvoiceItemStreamCursorValueInput = {
  billingPeriodEnd?: InputMaybe<Scalars['date']['input']>;
  billingPeriodStart?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  descriptionOverride?: InputMaybe<Scalars['String']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  itemId?: InputMaybe<Scalars['uuid']['input']>;
  lineItemType?: InputMaybe<Scalars['String']['input']>;
  netAmount?: InputMaybe<Scalars['numeric']['input']>;
  quantityHours?: InputMaybe<Scalars['numeric']['input']>;
  taxAmount?: InputMaybe<Scalars['numeric']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type BillingInvoiceItemSumFields = {
  __typename?: 'BillingInvoiceItemSumFields';
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  netAmount?: Maybe<Scalars['numeric']['output']>;
  quantityHours?: Maybe<Scalars['numeric']['output']>;
  taxAmount?: Maybe<Scalars['numeric']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemSumOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "billing_invoice_item" */
export type BillingInvoiceItemUpdateColumn =
  /** column name */
  | 'billingPeriodEnd'
  /** column name */
  | 'billingPeriodStart'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'descriptionOverride'
  /** column name */
  | 'hourlyRate'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceId'
  /** column name */
  | 'itemId'
  /** column name */
  | 'lineItemType'
  /** column name */
  | 'quantityHours'
  /** column name */
  | 'taxAmount'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type BillingInvoiceItemUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<BillingInvoiceItemIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BillingInvoiceItemSetInput>;
  /** filter the rows which have to be updated */
  where: BillingInvoiceItemBoolExp;
};

/** aggregate varPop on columns */
export type BillingInvoiceItemVarPopFields = {
  __typename?: 'BillingInvoiceItemVarPopFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  quantityHours?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemVarPopOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type BillingInvoiceItemVarSampFields = {
  __typename?: 'BillingInvoiceItemVarSampFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  quantityHours?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemVarSampOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type BillingInvoiceItemVarianceFields = {
  __typename?: 'BillingInvoiceItemVarianceFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  netAmount?: Maybe<Scalars['Float']['output']>;
  quantityHours?: Maybe<Scalars['Float']['output']>;
  taxAmount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "billing_invoice_item" */
export type BillingInvoiceItemVarianceOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
  netAmount?: InputMaybe<OrderBy>;
  quantityHours?: InputMaybe<OrderBy>;
  taxAmount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate max on columns */
export type BillingInvoiceMaxFields = {
  __typename?: 'BillingInvoiceMaxFields';
  billingPeriodEnd?: Maybe<Scalars['date']['output']>;
  /** Reference to billing period this invoice covers */
  billingPeriodId?: Maybe<Scalars['uuid']['output']>;
  billingPeriodStart?: Maybe<Scalars['date']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  dueDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Unique invoice number for client reference */
  invoiceNumber?: Maybe<Scalars['String']['output']>;
  issuedDate?: Maybe<Scalars['date']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "billing_invoice" */
export type BillingInvoiceMaxOrderBy = {
  billingPeriodEnd?: InputMaybe<OrderBy>;
  /** Reference to billing period this invoice covers */
  billingPeriodId?: InputMaybe<OrderBy>;
  billingPeriodStart?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  dueDate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Unique invoice number for client reference */
  invoiceNumber?: InputMaybe<OrderBy>;
  issuedDate?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type BillingInvoiceMinFields = {
  __typename?: 'BillingInvoiceMinFields';
  billingPeriodEnd?: Maybe<Scalars['date']['output']>;
  /** Reference to billing period this invoice covers */
  billingPeriodId?: Maybe<Scalars['uuid']['output']>;
  billingPeriodStart?: Maybe<Scalars['date']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  dueDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Unique invoice number for client reference */
  invoiceNumber?: Maybe<Scalars['String']['output']>;
  issuedDate?: Maybe<Scalars['date']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "billing_invoice" */
export type BillingInvoiceMinOrderBy = {
  billingPeriodEnd?: InputMaybe<OrderBy>;
  /** Reference to billing period this invoice covers */
  billingPeriodId?: InputMaybe<OrderBy>;
  billingPeriodStart?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  dueDate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Unique invoice number for client reference */
  invoiceNumber?: InputMaybe<OrderBy>;
  issuedDate?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "billing_invoice" */
export type BillingInvoiceMutationResponse = {
  __typename?: 'BillingInvoiceMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BillingInvoice>;
};

/** input type for inserting object relation for remote table "billing_invoice" */
export type BillingInvoiceObjRelInsertInput = {
  data: BillingInvoiceInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<BillingInvoiceOnConflict>;
};

/** on_conflict condition type for table "billing_invoice" */
export type BillingInvoiceOnConflict = {
  constraint: BillingInvoiceConstraint;
  updateColumns?: Array<BillingInvoiceUpdateColumn>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};

/** Ordering options when selecting data from "billing_invoice". */
export type BillingInvoiceOrderBy = {
  billingPeriod?: InputMaybe<BillingPeriodsOrderBy>;
  billingPeriodEnd?: InputMaybe<OrderBy>;
  billingPeriodId?: InputMaybe<OrderBy>;
  billingPeriodStart?: InputMaybe<OrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  dueDate?: InputMaybe<OrderBy>;
  eventLogsAggregate?: InputMaybe<BillingEventLogAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceItemsAggregate?: InputMaybe<BillingInvoiceItemAggregateOrderBy>;
  invoiceNumber?: InputMaybe<OrderBy>;
  issuedDate?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  payrollCount?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  totalHours?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: billing_invoice */
export type BillingInvoicePkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "billing_invoice" */
export type BillingInvoiceSelectColumn =
  /** column name */
  | 'billingPeriodEnd'
  /** column name */
  | 'billingPeriodId'
  /** column name */
  | 'billingPeriodStart'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'currency'
  /** column name */
  | 'dueDate'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceNumber'
  /** column name */
  | 'issuedDate'
  /** column name */
  | 'notes'
  /** column name */
  | 'payrollCount'
  /** column name */
  | 'status'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'totalHours'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "billing_invoice" */
export type BillingInvoiceSetInput = {
  billingPeriodEnd?: InputMaybe<Scalars['date']['input']>;
  /** Reference to billing period this invoice covers */
  billingPeriodId?: InputMaybe<Scalars['uuid']['input']>;
  billingPeriodStart?: InputMaybe<Scalars['date']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  dueDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Unique invoice number for client reference */
  invoiceNumber?: InputMaybe<Scalars['String']['input']>;
  issuedDate?: InputMaybe<Scalars['date']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type BillingInvoiceStddevFields = {
  __typename?: 'BillingInvoiceStddevFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "billing_invoice" */
export type BillingInvoiceStddevOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type BillingInvoiceStddevPopFields = {
  __typename?: 'BillingInvoiceStddevPopFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "billing_invoice" */
export type BillingInvoiceStddevPopOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type BillingInvoiceStddevSampFields = {
  __typename?: 'BillingInvoiceStddevSampFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "billing_invoice" */
export type BillingInvoiceStddevSampOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "billing_invoice" */
export type BillingInvoiceStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BillingInvoiceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BillingInvoiceStreamCursorValueInput = {
  billingPeriodEnd?: InputMaybe<Scalars['date']['input']>;
  /** Reference to billing period this invoice covers */
  billingPeriodId?: InputMaybe<Scalars['uuid']['input']>;
  billingPeriodStart?: InputMaybe<Scalars['date']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  dueDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Unique invoice number for client reference */
  invoiceNumber?: InputMaybe<Scalars['String']['input']>;
  issuedDate?: InputMaybe<Scalars['date']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type BillingInvoiceSumFields = {
  __typename?: 'BillingInvoiceSumFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Int']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "billing_invoice" */
export type BillingInvoiceSumOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** update columns of table "billing_invoice" */
export type BillingInvoiceUpdateColumn =
  /** column name */
  | 'billingPeriodEnd'
  /** column name */
  | 'billingPeriodId'
  /** column name */
  | 'billingPeriodStart'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'currency'
  /** column name */
  | 'dueDate'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceNumber'
  /** column name */
  | 'issuedDate'
  /** column name */
  | 'notes'
  /** column name */
  | 'payrollCount'
  /** column name */
  | 'status'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'totalHours'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type BillingInvoiceUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<BillingInvoiceIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BillingInvoiceSetInput>;
  /** filter the rows which have to be updated */
  where: BillingInvoiceBoolExp;
};

/** aggregate varPop on columns */
export type BillingInvoiceVarPopFields = {
  __typename?: 'BillingInvoiceVarPopFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "billing_invoice" */
export type BillingInvoiceVarPopOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type BillingInvoiceVarSampFields = {
  __typename?: 'BillingInvoiceVarSampFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "billing_invoice" */
export type BillingInvoiceVarSampOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type BillingInvoiceVarianceFields = {
  __typename?: 'BillingInvoiceVarianceFields';
  /** Number of payroll jobs included in this invoice */
  payrollCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  /** Total hours spent on services in this invoice */
  totalHours?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "billing_invoice" */
export type BillingInvoiceVarianceOrderBy = {
  /** Number of payroll jobs included in this invoice */
  payrollCount?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  /** Total hours spent on services in this invoice */
  totalHours?: InputMaybe<OrderBy>;
};

/** columns and relationships of "billing_items" */
export type BillingItems = {
  __typename?: 'BillingItems';
  amount?: Maybe<Scalars['numeric']['output']>;
  approvalDate?: Maybe<Scalars['timestamptz']['output']>;
  approvedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  approvedByUser?: Maybe<Users>;
  billingPlanId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  client?: Maybe<Clients>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  /** When this item was confirmed by manager */
  confirmedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Manager who confirmed this item */
  confirmedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  confirmedByUser?: Maybe<Users>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['uuid']['output'];
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  invoiceItems: Array<BillingInvoiceItem>;
  /** An aggregate relationship */
  invoiceItemsAggregate: BillingInvoiceItemAggregate;
  isApproved?: Maybe<Scalars['Boolean']['output']>;
  isAutoGenerated?: Maybe<Scalars['Boolean']['output']>;
  /** Additional notes about this billing item */
  notes?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  payroll?: Maybe<Payrolls>;
  /** An object relationship */
  payrollDate?: Maybe<PayrollDates>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  quantity: Scalars['Int']['output'];
  /** An object relationship */
  quote?: Maybe<Quotes>;
  quoteId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  service?: Maybe<Services>;
  /** Reference to the service from service catalog */
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  staffUser?: Maybe<Users>;
  /** Staff member who performed the service */
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  /** Status: draft, confirmed, billed */
  status?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  timeEntries: Array<TimeEntries>;
  /** An aggregate relationship */
  timeEntriesAggregate: TimeEntriesAggregate;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitPrice: Scalars['numeric']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "billing_items" */
export type BillingItemsInvoiceItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


/** columns and relationships of "billing_items" */
export type BillingItemsInvoiceItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


/** columns and relationships of "billing_items" */
export type BillingItemsTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


/** columns and relationships of "billing_items" */
export type BillingItemsTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};

/** aggregated selection of "billing_items" */
export type BillingItemsAggregate = {
  __typename?: 'BillingItemsAggregate';
  aggregate?: Maybe<BillingItemsAggregateFields>;
  nodes: Array<BillingItems>;
};

export type BillingItemsAggregateBoolExp = {
  bool_and?: InputMaybe<BillingItemsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<BillingItemsAggregateBoolExpBool_Or>;
  count?: InputMaybe<BillingItemsAggregateBoolExpCount>;
};

/** aggregate fields of "billing_items" */
export type BillingItemsAggregateFields = {
  __typename?: 'BillingItemsAggregateFields';
  avg?: Maybe<BillingItemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<BillingItemsMaxFields>;
  min?: Maybe<BillingItemsMinFields>;
  stddev?: Maybe<BillingItemsStddevFields>;
  stddevPop?: Maybe<BillingItemsStddevPopFields>;
  stddevSamp?: Maybe<BillingItemsStddevSampFields>;
  sum?: Maybe<BillingItemsSumFields>;
  varPop?: Maybe<BillingItemsVarPopFields>;
  varSamp?: Maybe<BillingItemsVarSampFields>;
  variance?: Maybe<BillingItemsVarianceFields>;
};


/** aggregate fields of "billing_items" */
export type BillingItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BillingItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "billing_items" */
export type BillingItemsAggregateOrderBy = {
  avg?: InputMaybe<BillingItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<BillingItemsMaxOrderBy>;
  min?: InputMaybe<BillingItemsMinOrderBy>;
  stddev?: InputMaybe<BillingItemsStddevOrderBy>;
  stddevPop?: InputMaybe<BillingItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<BillingItemsStddevSampOrderBy>;
  sum?: InputMaybe<BillingItemsSumOrderBy>;
  varPop?: InputMaybe<BillingItemsVarPopOrderBy>;
  varSamp?: InputMaybe<BillingItemsVarSampOrderBy>;
  variance?: InputMaybe<BillingItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "billing_items" */
export type BillingItemsArrRelInsertInput = {
  data: Array<BillingItemsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<BillingItemsOnConflict>;
};

/** aggregate avg on columns */
export type BillingItemsAvgFields = {
  __typename?: 'BillingItemsAvgFields';
  amount?: Maybe<Scalars['Float']['output']>;
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "billing_items" */
export type BillingItemsAvgOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "billing_items". All fields are combined with a logical 'AND'. */
export type BillingItemsBoolExp = {
  _and?: InputMaybe<Array<BillingItemsBoolExp>>;
  _not?: InputMaybe<BillingItemsBoolExp>;
  _or?: InputMaybe<Array<BillingItemsBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  approvalDate?: InputMaybe<TimestamptzComparisonExp>;
  approvedBy?: InputMaybe<UuidComparisonExp>;
  approvedByUser?: InputMaybe<UsersBoolExp>;
  billingPlanId?: InputMaybe<UuidComparisonExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  confirmedAt?: InputMaybe<TimestamptzComparisonExp>;
  confirmedBy?: InputMaybe<UuidComparisonExp>;
  confirmedByUser?: InputMaybe<UsersBoolExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  hourlyRate?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invoiceId?: InputMaybe<UuidComparisonExp>;
  invoiceItems?: InputMaybe<BillingInvoiceItemBoolExp>;
  invoiceItemsAggregate?: InputMaybe<BillingInvoiceItemAggregateBoolExp>;
  isApproved?: InputMaybe<BooleanComparisonExp>;
  isAutoGenerated?: InputMaybe<BooleanComparisonExp>;
  notes?: InputMaybe<StringComparisonExp>;
  payroll?: InputMaybe<PayrollsBoolExp>;
  payrollDate?: InputMaybe<PayrollDatesBoolExp>;
  payrollDateId?: InputMaybe<UuidComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  quantity?: InputMaybe<IntComparisonExp>;
  quote?: InputMaybe<QuotesBoolExp>;
  quoteId?: InputMaybe<UuidComparisonExp>;
  service?: InputMaybe<ServicesBoolExp>;
  serviceId?: InputMaybe<UuidComparisonExp>;
  serviceName?: InputMaybe<StringComparisonExp>;
  staffUser?: InputMaybe<UsersBoolExp>;
  staffUserId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  timeEntries?: InputMaybe<TimeEntriesBoolExp>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateBoolExp>;
  totalAmount?: InputMaybe<NumericComparisonExp>;
  unitPrice?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "billing_items" */
export type BillingItemsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'billing_items_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "billing_items" */
export type BillingItemsIncInput = {
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitPrice?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "billing_items" */
export type BillingItemsInsertInput = {
  approvalDate?: InputMaybe<Scalars['timestamptz']['input']>;
  approvedBy?: InputMaybe<Scalars['uuid']['input']>;
  approvedByUser?: InputMaybe<UsersObjRelInsertInput>;
  billingPlanId?: InputMaybe<Scalars['uuid']['input']>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** When this item was confirmed by manager */
  confirmedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Manager who confirmed this item */
  confirmedBy?: InputMaybe<Scalars['uuid']['input']>;
  confirmedByUser?: InputMaybe<UsersObjRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  invoiceItems?: InputMaybe<BillingInvoiceItemArrRelInsertInput>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isAutoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional notes about this billing item */
  notes?: InputMaybe<Scalars['String']['input']>;
  payroll?: InputMaybe<PayrollsObjRelInsertInput>;
  payrollDate?: InputMaybe<PayrollDatesObjRelInsertInput>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quote?: InputMaybe<QuotesObjRelInsertInput>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  service?: InputMaybe<ServicesObjRelInsertInput>;
  /** Reference to the service from service catalog */
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  serviceName?: InputMaybe<Scalars['String']['input']>;
  staffUser?: InputMaybe<UsersObjRelInsertInput>;
  /** Staff member who performed the service */
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Status: draft, confirmed, billed */
  status?: InputMaybe<Scalars['String']['input']>;
  timeEntries?: InputMaybe<TimeEntriesArrRelInsertInput>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitPrice?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type BillingItemsMaxFields = {
  __typename?: 'BillingItemsMaxFields';
  amount?: Maybe<Scalars['numeric']['output']>;
  approvalDate?: Maybe<Scalars['timestamptz']['output']>;
  approvedBy?: Maybe<Scalars['uuid']['output']>;
  billingPlanId?: Maybe<Scalars['uuid']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  /** When this item was confirmed by manager */
  confirmedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Manager who confirmed this item */
  confirmedBy?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  /** Additional notes about this billing item */
  notes?: Maybe<Scalars['String']['output']>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  quoteId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the service from service catalog */
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  /** Staff member who performed the service */
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  /** Status: draft, confirmed, billed */
  status?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitPrice?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "billing_items" */
export type BillingItemsMaxOrderBy = {
  amount?: InputMaybe<OrderBy>;
  approvalDate?: InputMaybe<OrderBy>;
  approvedBy?: InputMaybe<OrderBy>;
  billingPlanId?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  /** When this item was confirmed by manager */
  confirmedAt?: InputMaybe<OrderBy>;
  /** Manager who confirmed this item */
  confirmedBy?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  /** Additional notes about this billing item */
  notes?: InputMaybe<OrderBy>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  /** Reference to the service from service catalog */
  serviceId?: InputMaybe<OrderBy>;
  serviceName?: InputMaybe<OrderBy>;
  /** Staff member who performed the service */
  staffUserId?: InputMaybe<OrderBy>;
  /** Status: draft, confirmed, billed */
  status?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type BillingItemsMinFields = {
  __typename?: 'BillingItemsMinFields';
  amount?: Maybe<Scalars['numeric']['output']>;
  approvalDate?: Maybe<Scalars['timestamptz']['output']>;
  approvedBy?: Maybe<Scalars['uuid']['output']>;
  billingPlanId?: Maybe<Scalars['uuid']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  /** When this item was confirmed by manager */
  confirmedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Manager who confirmed this item */
  confirmedBy?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invoiceId?: Maybe<Scalars['uuid']['output']>;
  /** Additional notes about this billing item */
  notes?: Maybe<Scalars['String']['output']>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  quoteId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the service from service catalog */
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  /** Staff member who performed the service */
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  /** Status: draft, confirmed, billed */
  status?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitPrice?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "billing_items" */
export type BillingItemsMinOrderBy = {
  amount?: InputMaybe<OrderBy>;
  approvalDate?: InputMaybe<OrderBy>;
  approvedBy?: InputMaybe<OrderBy>;
  billingPlanId?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  /** When this item was confirmed by manager */
  confirmedAt?: InputMaybe<OrderBy>;
  /** Manager who confirmed this item */
  confirmedBy?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  /** Additional notes about this billing item */
  notes?: InputMaybe<OrderBy>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  /** Reference to the service from service catalog */
  serviceId?: InputMaybe<OrderBy>;
  serviceName?: InputMaybe<OrderBy>;
  /** Staff member who performed the service */
  staffUserId?: InputMaybe<OrderBy>;
  /** Status: draft, confirmed, billed */
  status?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "billing_items" */
export type BillingItemsMutationResponse = {
  __typename?: 'BillingItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BillingItems>;
};

/** input type for inserting object relation for remote table "billing_items" */
export type BillingItemsObjRelInsertInput = {
  data: BillingItemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<BillingItemsOnConflict>;
};

/** on_conflict condition type for table "billing_items" */
export type BillingItemsOnConflict = {
  constraint: BillingItemsConstraint;
  updateColumns?: Array<BillingItemsUpdateColumn>;
  where?: InputMaybe<BillingItemsBoolExp>;
};

/** Ordering options when selecting data from "billing_items". */
export type BillingItemsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  approvalDate?: InputMaybe<OrderBy>;
  approvedBy?: InputMaybe<OrderBy>;
  approvedByUser?: InputMaybe<UsersOrderBy>;
  billingPlanId?: InputMaybe<OrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  confirmedAt?: InputMaybe<OrderBy>;
  confirmedBy?: InputMaybe<OrderBy>;
  confirmedByUser?: InputMaybe<UsersOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invoiceId?: InputMaybe<OrderBy>;
  invoiceItemsAggregate?: InputMaybe<BillingInvoiceItemAggregateOrderBy>;
  isApproved?: InputMaybe<OrderBy>;
  isAutoGenerated?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  payroll?: InputMaybe<PayrollsOrderBy>;
  payrollDate?: InputMaybe<PayrollDatesOrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  quote?: InputMaybe<QuotesOrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  service?: InputMaybe<ServicesOrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  serviceName?: InputMaybe<OrderBy>;
  staffUser?: InputMaybe<UsersOrderBy>;
  staffUserId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateOrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: billing_items */
export type BillingItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "billing_items" */
export type BillingItemsSelectColumn =
  /** column name */
  | 'amount'
  /** column name */
  | 'approvalDate'
  /** column name */
  | 'approvedBy'
  /** column name */
  | 'billingPlanId'
  /** column name */
  | 'clientId'
  /** column name */
  | 'confirmedAt'
  /** column name */
  | 'confirmedBy'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'hourlyRate'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceId'
  /** column name */
  | 'isApproved'
  /** column name */
  | 'isAutoGenerated'
  /** column name */
  | 'notes'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'quantity'
  /** column name */
  | 'quoteId'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'serviceName'
  /** column name */
  | 'staffUserId'
  /** column name */
  | 'status'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'unitPrice'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "billingItemsAggregateBoolExpBool_andArgumentsColumns" columns of table "billing_items" */
export type BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isApproved'
  /** column name */
  | 'isAutoGenerated'
  | '%future added value';

/** select "billingItemsAggregateBoolExpBool_orArgumentsColumns" columns of table "billing_items" */
export type BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isApproved'
  /** column name */
  | 'isAutoGenerated'
  | '%future added value';

/** input type for updating data in table "billing_items" */
export type BillingItemsSetInput = {
  approvalDate?: InputMaybe<Scalars['timestamptz']['input']>;
  approvedBy?: InputMaybe<Scalars['uuid']['input']>;
  billingPlanId?: InputMaybe<Scalars['uuid']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** When this item was confirmed by manager */
  confirmedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Manager who confirmed this item */
  confirmedBy?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isAutoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional notes about this billing item */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the service from service catalog */
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  serviceName?: InputMaybe<Scalars['String']['input']>;
  /** Staff member who performed the service */
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Status: draft, confirmed, billed */
  status?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitPrice?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type BillingItemsStddevFields = {
  __typename?: 'BillingItemsStddevFields';
  amount?: Maybe<Scalars['Float']['output']>;
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "billing_items" */
export type BillingItemsStddevOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type BillingItemsStddevPopFields = {
  __typename?: 'BillingItemsStddevPopFields';
  amount?: Maybe<Scalars['Float']['output']>;
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "billing_items" */
export type BillingItemsStddevPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type BillingItemsStddevSampFields = {
  __typename?: 'BillingItemsStddevSampFields';
  amount?: Maybe<Scalars['Float']['output']>;
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "billing_items" */
export type BillingItemsStddevSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "billing_items" */
export type BillingItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BillingItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BillingItemsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['numeric']['input']>;
  approvalDate?: InputMaybe<Scalars['timestamptz']['input']>;
  approvedBy?: InputMaybe<Scalars['uuid']['input']>;
  billingPlanId?: InputMaybe<Scalars['uuid']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** When this item was confirmed by manager */
  confirmedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Manager who confirmed this item */
  confirmedBy?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invoiceId?: InputMaybe<Scalars['uuid']['input']>;
  isApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isAutoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional notes about this billing item */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Links billing item to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific billing tracking. */
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the service from service catalog */
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  serviceName?: InputMaybe<Scalars['String']['input']>;
  /** Staff member who performed the service */
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Status: draft, confirmed, billed */
  status?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitPrice?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type BillingItemsSumFields = {
  __typename?: 'BillingItemsSumFields';
  amount?: Maybe<Scalars['numeric']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitPrice?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "billing_items" */
export type BillingItemsSumOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** update columns of table "billing_items" */
export type BillingItemsUpdateColumn =
  /** column name */
  | 'approvalDate'
  /** column name */
  | 'approvedBy'
  /** column name */
  | 'billingPlanId'
  /** column name */
  | 'clientId'
  /** column name */
  | 'confirmedAt'
  /** column name */
  | 'confirmedBy'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'hourlyRate'
  /** column name */
  | 'id'
  /** column name */
  | 'invoiceId'
  /** column name */
  | 'isApproved'
  /** column name */
  | 'isAutoGenerated'
  /** column name */
  | 'notes'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'quantity'
  /** column name */
  | 'quoteId'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'serviceName'
  /** column name */
  | 'staffUserId'
  /** column name */
  | 'status'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'unitPrice'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type BillingItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<BillingItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BillingItemsSetInput>;
  /** filter the rows which have to be updated */
  where: BillingItemsBoolExp;
};

/** aggregate varPop on columns */
export type BillingItemsVarPopFields = {
  __typename?: 'BillingItemsVarPopFields';
  amount?: Maybe<Scalars['Float']['output']>;
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "billing_items" */
export type BillingItemsVarPopOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type BillingItemsVarSampFields = {
  __typename?: 'BillingItemsVarSampFields';
  amount?: Maybe<Scalars['Float']['output']>;
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "billing_items" */
export type BillingItemsVarSampOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type BillingItemsVarianceFields = {
  __typename?: 'BillingItemsVarianceFields';
  amount?: Maybe<Scalars['Float']['output']>;
  hourlyRate?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "billing_items" */
export type BillingItemsVarianceOrderBy = {
  amount?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** Billing periods for consolidating multiple payroll jobs into client invoices */
export type BillingPeriods = {
  __typename?: 'BillingPeriods';
  autoBillingEnabled?: Maybe<Scalars['Boolean']['output']>;
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  billingInvoices: Array<BillingInvoice>;
  /** An aggregate relationship */
  billingInvoicesAggregate: BillingInvoiceAggregate;
  /** First day of the billing month for easy grouping */
  billingMonth?: Maybe<Scalars['date']['output']>;
  /** An object relationship */
  client: Clients;
  /** Client this billing period is for */
  clientId: Scalars['uuid']['output'];
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  lastCheckedAt?: Maybe<Scalars['timestamptz']['output']>;
  metadata?: Maybe<Scalars['jsonb']['output']>;
  /** An array relationship */
  monthlyBillingCompletions: Array<MonthlyBillingCompletion>;
  /** An aggregate relationship */
  monthlyBillingCompletionsAggregate: MonthlyBillingCompletionAggregate;
  /** Current status of monthly billing cycle */
  monthlyStatus?: Maybe<Scalars['monthly_billing_status']['output']>;
  /** End date of billing period */
  periodEnd: Scalars['date']['output'];
  /** Start date of billing period */
  periodStart: Scalars['date']['output'];
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: Maybe<Scalars['String']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** Billing periods for consolidating multiple payroll jobs into client invoices */
export type BillingPeriodsBillingInvoicesArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


/** Billing periods for consolidating multiple payroll jobs into client invoices */
export type BillingPeriodsBillingInvoicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


/** Billing periods for consolidating multiple payroll jobs into client invoices */
export type BillingPeriodsMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Billing periods for consolidating multiple payroll jobs into client invoices */
export type BillingPeriodsMonthlyBillingCompletionsArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


/** Billing periods for consolidating multiple payroll jobs into client invoices */
export type BillingPeriodsMonthlyBillingCompletionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};

/** aggregated selection of "billing_periods" */
export type BillingPeriodsAggregate = {
  __typename?: 'BillingPeriodsAggregate';
  aggregate?: Maybe<BillingPeriodsAggregateFields>;
  nodes: Array<BillingPeriods>;
};

export type BillingPeriodsAggregateBoolExp = {
  bool_and?: InputMaybe<BillingPeriodsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<BillingPeriodsAggregateBoolExpBool_Or>;
  count?: InputMaybe<BillingPeriodsAggregateBoolExpCount>;
};

/** aggregate fields of "billing_periods" */
export type BillingPeriodsAggregateFields = {
  __typename?: 'BillingPeriodsAggregateFields';
  avg?: Maybe<BillingPeriodsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<BillingPeriodsMaxFields>;
  min?: Maybe<BillingPeriodsMinFields>;
  stddev?: Maybe<BillingPeriodsStddevFields>;
  stddevPop?: Maybe<BillingPeriodsStddevPopFields>;
  stddevSamp?: Maybe<BillingPeriodsStddevSampFields>;
  sum?: Maybe<BillingPeriodsSumFields>;
  varPop?: Maybe<BillingPeriodsVarPopFields>;
  varSamp?: Maybe<BillingPeriodsVarSampFields>;
  variance?: Maybe<BillingPeriodsVarianceFields>;
};


/** aggregate fields of "billing_periods" */
export type BillingPeriodsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "billing_periods" */
export type BillingPeriodsAggregateOrderBy = {
  avg?: InputMaybe<BillingPeriodsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<BillingPeriodsMaxOrderBy>;
  min?: InputMaybe<BillingPeriodsMinOrderBy>;
  stddev?: InputMaybe<BillingPeriodsStddevOrderBy>;
  stddevPop?: InputMaybe<BillingPeriodsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<BillingPeriodsStddevSampOrderBy>;
  sum?: InputMaybe<BillingPeriodsSumOrderBy>;
  varPop?: InputMaybe<BillingPeriodsVarPopOrderBy>;
  varSamp?: InputMaybe<BillingPeriodsVarSampOrderBy>;
  variance?: InputMaybe<BillingPeriodsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type BillingPeriodsAppendInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "billing_periods" */
export type BillingPeriodsArrRelInsertInput = {
  data: Array<BillingPeriodsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<BillingPeriodsOnConflict>;
};

/** aggregate avg on columns */
export type BillingPeriodsAvgFields = {
  __typename?: 'BillingPeriodsAvgFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "billing_periods" */
export type BillingPeriodsAvgOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "billing_periods". All fields are combined with a logical 'AND'. */
export type BillingPeriodsBoolExp = {
  _and?: InputMaybe<Array<BillingPeriodsBoolExp>>;
  _not?: InputMaybe<BillingPeriodsBoolExp>;
  _or?: InputMaybe<Array<BillingPeriodsBoolExp>>;
  autoBillingEnabled?: InputMaybe<BooleanComparisonExp>;
  billingGeneratedAt?: InputMaybe<TimestamptzComparisonExp>;
  billingInvoices?: InputMaybe<BillingInvoiceBoolExp>;
  billingInvoicesAggregate?: InputMaybe<BillingInvoiceAggregateBoolExp>;
  billingMonth?: InputMaybe<DateComparisonExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  completedPayrollDates?: InputMaybe<IntComparisonExp>;
  completedPayrolls?: InputMaybe<IntComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastCheckedAt?: InputMaybe<TimestamptzComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  monthlyBillingCompletions?: InputMaybe<MonthlyBillingCompletionBoolExp>;
  monthlyBillingCompletionsAggregate?: InputMaybe<MonthlyBillingCompletionAggregateBoolExp>;
  monthlyStatus?: InputMaybe<MonthlyBillingStatusComparisonExp>;
  periodEnd?: InputMaybe<DateComparisonExp>;
  periodStart?: InputMaybe<DateComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  totalPayrollDates?: InputMaybe<IntComparisonExp>;
  totalPayrolls?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "billing_periods" */
export type BillingPeriodsConstraint =
  /** unique or primary key constraint on columns "client_id", "period_start", "period_end" */
  | 'billing_periods_client_id_period_start_period_end_key'
  /** unique or primary key constraint on columns "id" */
  | 'billing_periods_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type BillingPeriodsDeleteAtPathInput = {
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type BillingPeriodsDeleteElemInput = {
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type BillingPeriodsDeleteKeyInput = {
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "billing_periods" */
export type BillingPeriodsIncInput = {
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "billing_periods" */
export type BillingPeriodsInsertInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingGeneratedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  billingInvoices?: InputMaybe<BillingInvoiceArrRelInsertInput>;
  /** First day of the billing month for easy grouping */
  billingMonth?: InputMaybe<Scalars['date']['input']>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  /** Client this billing period is for */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastCheckedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  monthlyBillingCompletions?: InputMaybe<MonthlyBillingCompletionArrRelInsertInput>;
  /** Current status of monthly billing cycle */
  monthlyStatus?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  /** End date of billing period */
  periodEnd?: InputMaybe<Scalars['date']['input']>;
  /** Start date of billing period */
  periodStart?: InputMaybe<Scalars['date']['input']>;
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: InputMaybe<Scalars['String']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type BillingPeriodsMaxFields = {
  __typename?: 'BillingPeriodsMaxFields';
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** First day of the billing month for easy grouping */
  billingMonth?: Maybe<Scalars['date']['output']>;
  /** Client this billing period is for */
  clientId?: Maybe<Scalars['uuid']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastCheckedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Current status of monthly billing cycle */
  monthlyStatus?: Maybe<Scalars['monthly_billing_status']['output']>;
  /** End date of billing period */
  periodEnd?: Maybe<Scalars['date']['output']>;
  /** Start date of billing period */
  periodStart?: Maybe<Scalars['date']['output']>;
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: Maybe<Scalars['String']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "billing_periods" */
export type BillingPeriodsMaxOrderBy = {
  billingGeneratedAt?: InputMaybe<OrderBy>;
  /** First day of the billing month for easy grouping */
  billingMonth?: InputMaybe<OrderBy>;
  /** Client this billing period is for */
  clientId?: InputMaybe<OrderBy>;
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastCheckedAt?: InputMaybe<OrderBy>;
  /** Current status of monthly billing cycle */
  monthlyStatus?: InputMaybe<OrderBy>;
  /** End date of billing period */
  periodEnd?: InputMaybe<OrderBy>;
  /** Start date of billing period */
  periodStart?: InputMaybe<OrderBy>;
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type BillingPeriodsMinFields = {
  __typename?: 'BillingPeriodsMinFields';
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** First day of the billing month for easy grouping */
  billingMonth?: Maybe<Scalars['date']['output']>;
  /** Client this billing period is for */
  clientId?: Maybe<Scalars['uuid']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastCheckedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Current status of monthly billing cycle */
  monthlyStatus?: Maybe<Scalars['monthly_billing_status']['output']>;
  /** End date of billing period */
  periodEnd?: Maybe<Scalars['date']['output']>;
  /** Start date of billing period */
  periodStart?: Maybe<Scalars['date']['output']>;
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: Maybe<Scalars['String']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "billing_periods" */
export type BillingPeriodsMinOrderBy = {
  billingGeneratedAt?: InputMaybe<OrderBy>;
  /** First day of the billing month for easy grouping */
  billingMonth?: InputMaybe<OrderBy>;
  /** Client this billing period is for */
  clientId?: InputMaybe<OrderBy>;
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastCheckedAt?: InputMaybe<OrderBy>;
  /** Current status of monthly billing cycle */
  monthlyStatus?: InputMaybe<OrderBy>;
  /** End date of billing period */
  periodEnd?: InputMaybe<OrderBy>;
  /** Start date of billing period */
  periodStart?: InputMaybe<OrderBy>;
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "billing_periods" */
export type BillingPeriodsMutationResponse = {
  __typename?: 'BillingPeriodsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BillingPeriods>;
};

/** input type for inserting object relation for remote table "billing_periods" */
export type BillingPeriodsObjRelInsertInput = {
  data: BillingPeriodsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<BillingPeriodsOnConflict>;
};

/** on_conflict condition type for table "billing_periods" */
export type BillingPeriodsOnConflict = {
  constraint: BillingPeriodsConstraint;
  updateColumns?: Array<BillingPeriodsUpdateColumn>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};

/** Ordering options when selecting data from "billing_periods". */
export type BillingPeriodsOrderBy = {
  autoBillingEnabled?: InputMaybe<OrderBy>;
  billingGeneratedAt?: InputMaybe<OrderBy>;
  billingInvoicesAggregate?: InputMaybe<BillingInvoiceAggregateOrderBy>;
  billingMonth?: InputMaybe<OrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastCheckedAt?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  monthlyBillingCompletionsAggregate?: InputMaybe<MonthlyBillingCompletionAggregateOrderBy>;
  monthlyStatus?: InputMaybe<OrderBy>;
  periodEnd?: InputMaybe<OrderBy>;
  periodStart?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: billing_periods */
export type BillingPeriodsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type BillingPeriodsPrependInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "billing_periods" */
export type BillingPeriodsSelectColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingGeneratedAt'
  /** column name */
  | 'billingMonth'
  /** column name */
  | 'clientId'
  /** column name */
  | 'completedPayrollDates'
  /** column name */
  | 'completedPayrolls'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'lastCheckedAt'
  /** column name */
  | 'metadata'
  /** column name */
  | 'monthlyStatus'
  /** column name */
  | 'periodEnd'
  /** column name */
  | 'periodStart'
  /** column name */
  | 'status'
  /** column name */
  | 'totalPayrollDates'
  /** column name */
  | 'totalPayrolls'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "billingPeriodsAggregateBoolExpBool_andArgumentsColumns" columns of table "billing_periods" */
export type BillingPeriodsSelectColumnBillingPeriodsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  | '%future added value';

/** select "billingPeriodsAggregateBoolExpBool_orArgumentsColumns" columns of table "billing_periods" */
export type BillingPeriodsSelectColumnBillingPeriodsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  | '%future added value';

/** input type for updating data in table "billing_periods" */
export type BillingPeriodsSetInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingGeneratedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** First day of the billing month for easy grouping */
  billingMonth?: InputMaybe<Scalars['date']['input']>;
  /** Client this billing period is for */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastCheckedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Current status of monthly billing cycle */
  monthlyStatus?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  /** End date of billing period */
  periodEnd?: InputMaybe<Scalars['date']['input']>;
  /** Start date of billing period */
  periodStart?: InputMaybe<Scalars['date']['input']>;
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: InputMaybe<Scalars['String']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type BillingPeriodsStddevFields = {
  __typename?: 'BillingPeriodsStddevFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "billing_periods" */
export type BillingPeriodsStddevOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type BillingPeriodsStddevPopFields = {
  __typename?: 'BillingPeriodsStddevPopFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "billing_periods" */
export type BillingPeriodsStddevPopOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type BillingPeriodsStddevSampFields = {
  __typename?: 'BillingPeriodsStddevSampFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "billing_periods" */
export type BillingPeriodsStddevSampOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "billing_periods" */
export type BillingPeriodsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: BillingPeriodsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type BillingPeriodsStreamCursorValueInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingGeneratedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** First day of the billing month for easy grouping */
  billingMonth?: InputMaybe<Scalars['date']['input']>;
  /** Client this billing period is for */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastCheckedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** Current status of monthly billing cycle */
  monthlyStatus?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  /** End date of billing period */
  periodEnd?: InputMaybe<Scalars['date']['input']>;
  /** Start date of billing period */
  periodStart?: InputMaybe<Scalars['date']['input']>;
  /** Status: open, ready_to_invoice, invoiced, paid */
  status?: InputMaybe<Scalars['String']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type BillingPeriodsSumFields = {
  __typename?: 'BillingPeriodsSumFields';
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "billing_periods" */
export type BillingPeriodsSumOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** update columns of table "billing_periods" */
export type BillingPeriodsUpdateColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingGeneratedAt'
  /** column name */
  | 'billingMonth'
  /** column name */
  | 'clientId'
  /** column name */
  | 'completedPayrollDates'
  /** column name */
  | 'completedPayrolls'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'lastCheckedAt'
  /** column name */
  | 'metadata'
  /** column name */
  | 'monthlyStatus'
  /** column name */
  | 'periodEnd'
  /** column name */
  | 'periodStart'
  /** column name */
  | 'status'
  /** column name */
  | 'totalPayrollDates'
  /** column name */
  | 'totalPayrolls'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type BillingPeriodsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<BillingPeriodsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<BillingPeriodsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<BillingPeriodsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<BillingPeriodsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<BillingPeriodsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<BillingPeriodsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BillingPeriodsSetInput>;
  /** filter the rows which have to be updated */
  where: BillingPeriodsBoolExp;
};

/** aggregate varPop on columns */
export type BillingPeriodsVarPopFields = {
  __typename?: 'BillingPeriodsVarPopFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "billing_periods" */
export type BillingPeriodsVarPopOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type BillingPeriodsVarSampFields = {
  __typename?: 'BillingPeriodsVarSampFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "billing_periods" */
export type BillingPeriodsVarSampOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type BillingPeriodsVarianceFields = {
  __typename?: 'BillingPeriodsVarianceFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "billing_periods" */
export type BillingPeriodsVarianceOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "billing_tier_level". All fields are combined with logical 'AND'. */
export type BillingTierLevelComparisonExp = {
  _eq?: InputMaybe<Scalars['billing_tier_level']['input']>;
  _gt?: InputMaybe<Scalars['billing_tier_level']['input']>;
  _gte?: InputMaybe<Scalars['billing_tier_level']['input']>;
  _in?: InputMaybe<Array<Scalars['billing_tier_level']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['billing_tier_level']['input']>;
  _lte?: InputMaybe<Scalars['billing_tier_level']['input']>;
  _neq?: InputMaybe<Scalars['billing_tier_level']['input']>;
  _nin?: InputMaybe<Array<Scalars['billing_tier_level']['input']>>;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type BooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'. */
export type BpcharComparisonExp = {
  _eq?: InputMaybe<Scalars['bpchar']['input']>;
  _gt?: InputMaybe<Scalars['bpchar']['input']>;
  _gte?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['bpchar']['input']>;
  _in?: InputMaybe<Array<Scalars['bpchar']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['bpchar']['input']>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['bpchar']['input']>;
  _lt?: InputMaybe<Scalars['bpchar']['input']>;
  _lte?: InputMaybe<Scalars['bpchar']['input']>;
  _neq?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['bpchar']['input']>;
  _nin?: InputMaybe<Array<Scalars['bpchar']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['bpchar']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['bpchar']['input']>;
};

/** columns and relationships of "client_external_systems" */
export type ClientExternalSystems = {
  __typename?: 'ClientExternalSystems';
  /** An object relationship */
  client: Clients;
  /** Reference to the client */
  clientId: Scalars['uuid']['output'];
  /** Timestamp when the mapping was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  externalSystem: ExternalSystems;
  /** Unique identifier for the client-system mapping */
  id: Scalars['uuid']['output'];
  /** Client identifier in the external system */
  systemClientId?: Maybe<Scalars['String']['output']>;
  /** Reference to the external system */
  systemId: Scalars['uuid']['output'];
  /** Timestamp when the mapping was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "client_external_systems" */
export type ClientExternalSystemsAggregate = {
  __typename?: 'ClientExternalSystemsAggregate';
  aggregate?: Maybe<ClientExternalSystemsAggregateFields>;
  nodes: Array<ClientExternalSystems>;
};

export type ClientExternalSystemsAggregateBoolExp = {
  count?: InputMaybe<ClientExternalSystemsAggregateBoolExpCount>;
};

/** aggregate fields of "client_external_systems" */
export type ClientExternalSystemsAggregateFields = {
  __typename?: 'ClientExternalSystemsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<ClientExternalSystemsMaxFields>;
  min?: Maybe<ClientExternalSystemsMinFields>;
};


/** aggregate fields of "client_external_systems" */
export type ClientExternalSystemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "client_external_systems" */
export type ClientExternalSystemsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ClientExternalSystemsMaxOrderBy>;
  min?: InputMaybe<ClientExternalSystemsMinOrderBy>;
};

/** input type for inserting array relation for remote table "client_external_systems" */
export type ClientExternalSystemsArrRelInsertInput = {
  data: Array<ClientExternalSystemsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ClientExternalSystemsOnConflict>;
};

/** Boolean expression to filter rows from the table "client_external_systems". All fields are combined with a logical 'AND'. */
export type ClientExternalSystemsBoolExp = {
  _and?: InputMaybe<Array<ClientExternalSystemsBoolExp>>;
  _not?: InputMaybe<ClientExternalSystemsBoolExp>;
  _or?: InputMaybe<Array<ClientExternalSystemsBoolExp>>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  externalSystem?: InputMaybe<ExternalSystemsBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  systemClientId?: InputMaybe<StringComparisonExp>;
  systemId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "client_external_systems" */
export type ClientExternalSystemsConstraint =
  /** unique or primary key constraint on columns "client_id", "system_id" */
  | 'client_external_systems_client_id_system_id_key'
  /** unique or primary key constraint on columns "id" */
  | 'client_external_systems_pkey'
  | '%future added value';

/** input type for inserting data into table "client_external_systems" */
export type ClientExternalSystemsInsertInput = {
  client?: InputMaybe<ClientsObjRelInsertInput>;
  /** Reference to the client */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the mapping was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  externalSystem?: InputMaybe<ExternalSystemsObjRelInsertInput>;
  /** Unique identifier for the client-system mapping */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Client identifier in the external system */
  systemClientId?: InputMaybe<Scalars['String']['input']>;
  /** Reference to the external system */
  systemId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the mapping was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ClientExternalSystemsMaxFields = {
  __typename?: 'ClientExternalSystemsMaxFields';
  /** Reference to the client */
  clientId?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the mapping was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique identifier for the client-system mapping */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Client identifier in the external system */
  systemClientId?: Maybe<Scalars['String']['output']>;
  /** Reference to the external system */
  systemId?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the mapping was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "client_external_systems" */
export type ClientExternalSystemsMaxOrderBy = {
  /** Reference to the client */
  clientId?: InputMaybe<OrderBy>;
  /** Timestamp when the mapping was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Unique identifier for the client-system mapping */
  id?: InputMaybe<OrderBy>;
  /** Client identifier in the external system */
  systemClientId?: InputMaybe<OrderBy>;
  /** Reference to the external system */
  systemId?: InputMaybe<OrderBy>;
  /** Timestamp when the mapping was last updated */
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ClientExternalSystemsMinFields = {
  __typename?: 'ClientExternalSystemsMinFields';
  /** Reference to the client */
  clientId?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the mapping was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique identifier for the client-system mapping */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Client identifier in the external system */
  systemClientId?: Maybe<Scalars['String']['output']>;
  /** Reference to the external system */
  systemId?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the mapping was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "client_external_systems" */
export type ClientExternalSystemsMinOrderBy = {
  /** Reference to the client */
  clientId?: InputMaybe<OrderBy>;
  /** Timestamp when the mapping was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Unique identifier for the client-system mapping */
  id?: InputMaybe<OrderBy>;
  /** Client identifier in the external system */
  systemClientId?: InputMaybe<OrderBy>;
  /** Reference to the external system */
  systemId?: InputMaybe<OrderBy>;
  /** Timestamp when the mapping was last updated */
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "client_external_systems" */
export type ClientExternalSystemsMutationResponse = {
  __typename?: 'ClientExternalSystemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ClientExternalSystems>;
};

/** on_conflict condition type for table "client_external_systems" */
export type ClientExternalSystemsOnConflict = {
  constraint: ClientExternalSystemsConstraint;
  updateColumns?: Array<ClientExternalSystemsUpdateColumn>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};

/** Ordering options when selecting data from "client_external_systems". */
export type ClientExternalSystemsOrderBy = {
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  externalSystem?: InputMaybe<ExternalSystemsOrderBy>;
  id?: InputMaybe<OrderBy>;
  systemClientId?: InputMaybe<OrderBy>;
  systemId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: client_external_systems */
export type ClientExternalSystemsPkColumnsInput = {
  /** Unique identifier for the client-system mapping */
  id: Scalars['uuid']['input'];
};

/** select columns of table "client_external_systems" */
export type ClientExternalSystemsSelectColumn =
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'systemClientId'
  /** column name */
  | 'systemId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "client_external_systems" */
export type ClientExternalSystemsSetInput = {
  /** Reference to the client */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the mapping was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique identifier for the client-system mapping */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Client identifier in the external system */
  systemClientId?: InputMaybe<Scalars['String']['input']>;
  /** Reference to the external system */
  systemId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the mapping was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "client_external_systems" */
export type ClientExternalSystemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ClientExternalSystemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClientExternalSystemsStreamCursorValueInput = {
  /** Reference to the client */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the mapping was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique identifier for the client-system mapping */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Client identifier in the external system */
  systemClientId?: InputMaybe<Scalars['String']['input']>;
  /** Reference to the external system */
  systemId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the mapping was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "client_external_systems" */
export type ClientExternalSystemsUpdateColumn =
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'systemClientId'
  /** column name */
  | 'systemId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type ClientExternalSystemsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClientExternalSystemsSetInput>;
  /** filter the rows which have to be updated */
  where: ClientExternalSystemsBoolExp;
};

/** Client-specific service agreements and configurations */
export type ClientServiceAgreements = {
  __typename?: 'ClientServiceAgreements';
  autoBillingEnabled?: Maybe<Scalars['Boolean']['output']>;
  autoBillingTriggers?: Maybe<Scalars['jsonb']['output']>;
  billingFrequency?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  client: Clients;
  clientId: Scalars['uuid']['output'];
  contractEndDate?: Maybe<Scalars['date']['output']>;
  contractStartDate?: Maybe<Scalars['date']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  createdByUser?: Maybe<Users>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['uuid']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  payrollServiceAgreements: Array<PayrollServiceAgreements>;
  /** An aggregate relationship */
  payrollServiceAgreementsAggregate: PayrollServiceAgreementsAggregate;
  /** An object relationship */
  service: Services;
  serviceConfiguration?: Maybe<Scalars['jsonb']['output']>;
  serviceId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** Client-specific service agreements and configurations */
export type ClientServiceAgreementsAutoBillingTriggersArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Client-specific service agreements and configurations */
export type ClientServiceAgreementsPayrollServiceAgreementsArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** Client-specific service agreements and configurations */
export type ClientServiceAgreementsPayrollServiceAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** Client-specific service agreements and configurations */
export type ClientServiceAgreementsServiceConfigurationArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "client_service_agreements" */
export type ClientServiceAgreementsAggregate = {
  __typename?: 'ClientServiceAgreementsAggregate';
  aggregate?: Maybe<ClientServiceAgreementsAggregateFields>;
  nodes: Array<ClientServiceAgreements>;
};

export type ClientServiceAgreementsAggregateBoolExp = {
  bool_and?: InputMaybe<ClientServiceAgreementsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<ClientServiceAgreementsAggregateBoolExpBool_Or>;
  count?: InputMaybe<ClientServiceAgreementsAggregateBoolExpCount>;
};

/** aggregate fields of "client_service_agreements" */
export type ClientServiceAgreementsAggregateFields = {
  __typename?: 'ClientServiceAgreementsAggregateFields';
  avg?: Maybe<ClientServiceAgreementsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClientServiceAgreementsMaxFields>;
  min?: Maybe<ClientServiceAgreementsMinFields>;
  stddev?: Maybe<ClientServiceAgreementsStddevFields>;
  stddevPop?: Maybe<ClientServiceAgreementsStddevPopFields>;
  stddevSamp?: Maybe<ClientServiceAgreementsStddevSampFields>;
  sum?: Maybe<ClientServiceAgreementsSumFields>;
  varPop?: Maybe<ClientServiceAgreementsVarPopFields>;
  varSamp?: Maybe<ClientServiceAgreementsVarSampFields>;
  variance?: Maybe<ClientServiceAgreementsVarianceFields>;
};


/** aggregate fields of "client_service_agreements" */
export type ClientServiceAgreementsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "client_service_agreements" */
export type ClientServiceAgreementsAggregateOrderBy = {
  avg?: InputMaybe<ClientServiceAgreementsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ClientServiceAgreementsMaxOrderBy>;
  min?: InputMaybe<ClientServiceAgreementsMinOrderBy>;
  stddev?: InputMaybe<ClientServiceAgreementsStddevOrderBy>;
  stddevPop?: InputMaybe<ClientServiceAgreementsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ClientServiceAgreementsStddevSampOrderBy>;
  sum?: InputMaybe<ClientServiceAgreementsSumOrderBy>;
  varPop?: InputMaybe<ClientServiceAgreementsVarPopOrderBy>;
  varSamp?: InputMaybe<ClientServiceAgreementsVarSampOrderBy>;
  variance?: InputMaybe<ClientServiceAgreementsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ClientServiceAgreementsAppendInput = {
  autoBillingTriggers?: InputMaybe<Scalars['jsonb']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "client_service_agreements" */
export type ClientServiceAgreementsArrRelInsertInput = {
  data: Array<ClientServiceAgreementsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ClientServiceAgreementsOnConflict>;
};

/** aggregate avg on columns */
export type ClientServiceAgreementsAvgFields = {
  __typename?: 'ClientServiceAgreementsAvgFields';
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsAvgOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "client_service_agreements". All fields are combined with a logical 'AND'. */
export type ClientServiceAgreementsBoolExp = {
  _and?: InputMaybe<Array<ClientServiceAgreementsBoolExp>>;
  _not?: InputMaybe<ClientServiceAgreementsBoolExp>;
  _or?: InputMaybe<Array<ClientServiceAgreementsBoolExp>>;
  autoBillingEnabled?: InputMaybe<BooleanComparisonExp>;
  autoBillingTriggers?: InputMaybe<JsonbComparisonExp>;
  billingFrequency?: InputMaybe<StringComparisonExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  contractEndDate?: InputMaybe<DateComparisonExp>;
  contractStartDate?: InputMaybe<DateComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  customRate?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isEnabled?: InputMaybe<BooleanComparisonExp>;
  payrollServiceAgreements?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  payrollServiceAgreementsAggregate?: InputMaybe<PayrollServiceAgreementsAggregateBoolExp>;
  service?: InputMaybe<ServicesBoolExp>;
  serviceConfiguration?: InputMaybe<JsonbComparisonExp>;
  serviceId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "client_service_agreements" */
export type ClientServiceAgreementsConstraint =
  /** unique or primary key constraint on columns "client_id", "service_id" */
  | 'client_service_agreements_client_id_service_id_key'
  /** unique or primary key constraint on columns "id" */
  | 'client_service_agreements_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ClientServiceAgreementsDeleteAtPathInput = {
  autoBillingTriggers?: InputMaybe<Array<Scalars['String']['input']>>;
  serviceConfiguration?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ClientServiceAgreementsDeleteElemInput = {
  autoBillingTriggers?: InputMaybe<Scalars['Int']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ClientServiceAgreementsDeleteKeyInput = {
  autoBillingTriggers?: InputMaybe<Scalars['String']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "client_service_agreements" */
export type ClientServiceAgreementsIncInput = {
  customRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "client_service_agreements" */
export type ClientServiceAgreementsInsertInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  autoBillingTriggers?: InputMaybe<Scalars['jsonb']['input']>;
  billingFrequency?: InputMaybe<Scalars['String']['input']>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  contractEndDate?: InputMaybe<Scalars['date']['input']>;
  contractStartDate?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  payrollServiceAgreements?: InputMaybe<PayrollServiceAgreementsArrRelInsertInput>;
  service?: InputMaybe<ServicesObjRelInsertInput>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ClientServiceAgreementsMaxFields = {
  __typename?: 'ClientServiceAgreementsMaxFields';
  billingFrequency?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  contractEndDate?: Maybe<Scalars['date']['output']>;
  contractStartDate?: Maybe<Scalars['date']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsMaxOrderBy = {
  billingFrequency?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  contractEndDate?: InputMaybe<OrderBy>;
  contractStartDate?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ClientServiceAgreementsMinFields = {
  __typename?: 'ClientServiceAgreementsMinFields';
  billingFrequency?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  contractEndDate?: Maybe<Scalars['date']['output']>;
  contractStartDate?: Maybe<Scalars['date']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsMinOrderBy = {
  billingFrequency?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  contractEndDate?: InputMaybe<OrderBy>;
  contractStartDate?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "client_service_agreements" */
export type ClientServiceAgreementsMutationResponse = {
  __typename?: 'ClientServiceAgreementsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ClientServiceAgreements>;
};

/** input type for inserting object relation for remote table "client_service_agreements" */
export type ClientServiceAgreementsObjRelInsertInput = {
  data: ClientServiceAgreementsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<ClientServiceAgreementsOnConflict>;
};

/** on_conflict condition type for table "client_service_agreements" */
export type ClientServiceAgreementsOnConflict = {
  constraint: ClientServiceAgreementsConstraint;
  updateColumns?: Array<ClientServiceAgreementsUpdateColumn>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};

/** Ordering options when selecting data from "client_service_agreements". */
export type ClientServiceAgreementsOrderBy = {
  autoBillingEnabled?: InputMaybe<OrderBy>;
  autoBillingTriggers?: InputMaybe<OrderBy>;
  billingFrequency?: InputMaybe<OrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  contractEndDate?: InputMaybe<OrderBy>;
  contractStartDate?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  customRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isEnabled?: InputMaybe<OrderBy>;
  payrollServiceAgreementsAggregate?: InputMaybe<PayrollServiceAgreementsAggregateOrderBy>;
  service?: InputMaybe<ServicesOrderBy>;
  serviceConfiguration?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: client_service_agreements */
export type ClientServiceAgreementsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ClientServiceAgreementsPrependInput = {
  autoBillingTriggers?: InputMaybe<Scalars['jsonb']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "client_service_agreements" */
export type ClientServiceAgreementsSelectColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'autoBillingTriggers'
  /** column name */
  | 'billingFrequency'
  /** column name */
  | 'clientId'
  /** column name */
  | 'contractEndDate'
  /** column name */
  | 'contractStartDate'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'customRate'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isEnabled'
  /** column name */
  | 'serviceConfiguration'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "clientServiceAgreementsAggregateBoolExpBool_andArgumentsColumns" columns of table "client_service_agreements" */
export type ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isEnabled'
  | '%future added value';

/** select "clientServiceAgreementsAggregateBoolExpBool_orArgumentsColumns" columns of table "client_service_agreements" */
export type ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isEnabled'
  | '%future added value';

/** input type for updating data in table "client_service_agreements" */
export type ClientServiceAgreementsSetInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  autoBillingTriggers?: InputMaybe<Scalars['jsonb']['input']>;
  billingFrequency?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  contractEndDate?: InputMaybe<Scalars['date']['input']>;
  contractStartDate?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type ClientServiceAgreementsStddevFields = {
  __typename?: 'ClientServiceAgreementsStddevFields';
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsStddevOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ClientServiceAgreementsStddevPopFields = {
  __typename?: 'ClientServiceAgreementsStddevPopFields';
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsStddevPopOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ClientServiceAgreementsStddevSampFields = {
  __typename?: 'ClientServiceAgreementsStddevSampFields';
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsStddevSampOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "client_service_agreements" */
export type ClientServiceAgreementsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ClientServiceAgreementsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClientServiceAgreementsStreamCursorValueInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  autoBillingTriggers?: InputMaybe<Scalars['jsonb']['input']>;
  billingFrequency?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  contractEndDate?: InputMaybe<Scalars['date']['input']>;
  contractStartDate?: InputMaybe<Scalars['date']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type ClientServiceAgreementsSumFields = {
  __typename?: 'ClientServiceAgreementsSumFields';
  customRate?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsSumOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** update columns of table "client_service_agreements" */
export type ClientServiceAgreementsUpdateColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'autoBillingTriggers'
  /** column name */
  | 'billingFrequency'
  /** column name */
  | 'clientId'
  /** column name */
  | 'contractEndDate'
  /** column name */
  | 'contractStartDate'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'customRate'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isEnabled'
  /** column name */
  | 'serviceConfiguration'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type ClientServiceAgreementsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<ClientServiceAgreementsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<ClientServiceAgreementsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<ClientServiceAgreementsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<ClientServiceAgreementsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ClientServiceAgreementsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<ClientServiceAgreementsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClientServiceAgreementsSetInput>;
  /** filter the rows which have to be updated */
  where: ClientServiceAgreementsBoolExp;
};

/** aggregate varPop on columns */
export type ClientServiceAgreementsVarPopFields = {
  __typename?: 'ClientServiceAgreementsVarPopFields';
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsVarPopOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ClientServiceAgreementsVarSampFields = {
  __typename?: 'ClientServiceAgreementsVarSampFields';
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsVarSampOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ClientServiceAgreementsVarianceFields = {
  __typename?: 'ClientServiceAgreementsVarianceFields';
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "client_service_agreements" */
export type ClientServiceAgreementsVarianceOrderBy = {
  customRate?: InputMaybe<OrderBy>;
};

/** columns and relationships of "client_services_with_rates" */
export type ClientServicesWithRates = {
  __typename?: 'ClientServicesWithRates';
  agreementId?: Maybe<Scalars['uuid']['output']>;
  billingFrequency?: Maybe<Scalars['String']['output']>;
  billingUnit?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  effectiveDate?: Maybe<Scalars['date']['output']>;
  effectiveRate?: Maybe<Scalars['numeric']['output']>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isEnabled?: Maybe<Scalars['Boolean']['output']>;
  serviceDescription?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  standardRate?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "client_services_with_rates" */
export type ClientServicesWithRatesAggregate = {
  __typename?: 'ClientServicesWithRatesAggregate';
  aggregate?: Maybe<ClientServicesWithRatesAggregateFields>;
  nodes: Array<ClientServicesWithRates>;
};

/** aggregate fields of "client_services_with_rates" */
export type ClientServicesWithRatesAggregateFields = {
  __typename?: 'ClientServicesWithRatesAggregateFields';
  avg?: Maybe<ClientServicesWithRatesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ClientServicesWithRatesMaxFields>;
  min?: Maybe<ClientServicesWithRatesMinFields>;
  stddev?: Maybe<ClientServicesWithRatesStddevFields>;
  stddevPop?: Maybe<ClientServicesWithRatesStddevPopFields>;
  stddevSamp?: Maybe<ClientServicesWithRatesStddevSampFields>;
  sum?: Maybe<ClientServicesWithRatesSumFields>;
  varPop?: Maybe<ClientServicesWithRatesVarPopFields>;
  varSamp?: Maybe<ClientServicesWithRatesVarSampFields>;
  variance?: Maybe<ClientServicesWithRatesVarianceFields>;
};


/** aggregate fields of "client_services_with_rates" */
export type ClientServicesWithRatesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClientServicesWithRatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ClientServicesWithRatesAvgFields = {
  __typename?: 'ClientServicesWithRatesAvgFields';
  customRate?: Maybe<Scalars['Float']['output']>;
  effectiveRate?: Maybe<Scalars['Float']['output']>;
  standardRate?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "client_services_with_rates". All fields are combined with a logical 'AND'. */
export type ClientServicesWithRatesBoolExp = {
  _and?: InputMaybe<Array<ClientServicesWithRatesBoolExp>>;
  _not?: InputMaybe<ClientServicesWithRatesBoolExp>;
  _or?: InputMaybe<Array<ClientServicesWithRatesBoolExp>>;
  agreementId?: InputMaybe<UuidComparisonExp>;
  billingFrequency?: InputMaybe<StringComparisonExp>;
  billingUnit?: InputMaybe<StringComparisonExp>;
  category?: InputMaybe<StringComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  customRate?: InputMaybe<NumericComparisonExp>;
  effectiveDate?: InputMaybe<DateComparisonExp>;
  effectiveRate?: InputMaybe<NumericComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isEnabled?: InputMaybe<BooleanComparisonExp>;
  serviceDescription?: InputMaybe<StringComparisonExp>;
  serviceId?: InputMaybe<UuidComparisonExp>;
  serviceName?: InputMaybe<StringComparisonExp>;
  standardRate?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type ClientServicesWithRatesMaxFields = {
  __typename?: 'ClientServicesWithRatesMaxFields';
  agreementId?: Maybe<Scalars['uuid']['output']>;
  billingFrequency?: Maybe<Scalars['String']['output']>;
  billingUnit?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  effectiveDate?: Maybe<Scalars['date']['output']>;
  effectiveRate?: Maybe<Scalars['numeric']['output']>;
  serviceDescription?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  standardRate?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type ClientServicesWithRatesMinFields = {
  __typename?: 'ClientServicesWithRatesMinFields';
  agreementId?: Maybe<Scalars['uuid']['output']>;
  billingFrequency?: Maybe<Scalars['String']['output']>;
  billingUnit?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  effectiveDate?: Maybe<Scalars['date']['output']>;
  effectiveRate?: Maybe<Scalars['numeric']['output']>;
  serviceDescription?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  standardRate?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "client_services_with_rates". */
export type ClientServicesWithRatesOrderBy = {
  agreementId?: InputMaybe<OrderBy>;
  billingFrequency?: InputMaybe<OrderBy>;
  billingUnit?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
  effectiveDate?: InputMaybe<OrderBy>;
  effectiveRate?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isEnabled?: InputMaybe<OrderBy>;
  serviceDescription?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  serviceName?: InputMaybe<OrderBy>;
  standardRate?: InputMaybe<OrderBy>;
};

/** select columns of table "client_services_with_rates" */
export type ClientServicesWithRatesSelectColumn =
  /** column name */
  | 'agreementId'
  /** column name */
  | 'billingFrequency'
  /** column name */
  | 'billingUnit'
  /** column name */
  | 'category'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'customRate'
  /** column name */
  | 'effectiveDate'
  /** column name */
  | 'effectiveRate'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isEnabled'
  /** column name */
  | 'serviceDescription'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'serviceName'
  /** column name */
  | 'standardRate'
  | '%future added value';

/** aggregate stddev on columns */
export type ClientServicesWithRatesStddevFields = {
  __typename?: 'ClientServicesWithRatesStddevFields';
  customRate?: Maybe<Scalars['Float']['output']>;
  effectiveRate?: Maybe<Scalars['Float']['output']>;
  standardRate?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type ClientServicesWithRatesStddevPopFields = {
  __typename?: 'ClientServicesWithRatesStddevPopFields';
  customRate?: Maybe<Scalars['Float']['output']>;
  effectiveRate?: Maybe<Scalars['Float']['output']>;
  standardRate?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type ClientServicesWithRatesStddevSampFields = {
  __typename?: 'ClientServicesWithRatesStddevSampFields';
  customRate?: Maybe<Scalars['Float']['output']>;
  effectiveRate?: Maybe<Scalars['Float']['output']>;
  standardRate?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "client_services_with_rates" */
export type ClientServicesWithRatesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ClientServicesWithRatesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClientServicesWithRatesStreamCursorValueInput = {
  agreementId?: InputMaybe<Scalars['uuid']['input']>;
  billingFrequency?: InputMaybe<Scalars['String']['input']>;
  billingUnit?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
  effectiveDate?: InputMaybe<Scalars['date']['input']>;
  effectiveRate?: InputMaybe<Scalars['numeric']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  serviceDescription?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  serviceName?: InputMaybe<Scalars['String']['input']>;
  standardRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type ClientServicesWithRatesSumFields = {
  __typename?: 'ClientServicesWithRatesSumFields';
  customRate?: Maybe<Scalars['numeric']['output']>;
  effectiveRate?: Maybe<Scalars['numeric']['output']>;
  standardRate?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type ClientServicesWithRatesVarPopFields = {
  __typename?: 'ClientServicesWithRatesVarPopFields';
  customRate?: Maybe<Scalars['Float']['output']>;
  effectiveRate?: Maybe<Scalars['Float']['output']>;
  standardRate?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type ClientServicesWithRatesVarSampFields = {
  __typename?: 'ClientServicesWithRatesVarSampFields';
  customRate?: Maybe<Scalars['Float']['output']>;
  effectiveRate?: Maybe<Scalars['Float']['output']>;
  standardRate?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ClientServicesWithRatesVarianceFields = {
  __typename?: 'ClientServicesWithRatesVarianceFields';
  customRate?: Maybe<Scalars['Float']['output']>;
  effectiveRate?: Maybe<Scalars['Float']['output']>;
  standardRate?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "clients" */
export type Clients = {
  __typename?: 'Clients';
  /** Whether the client is currently active */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  billingInvoices: Array<BillingInvoice>;
  /** An aggregate relationship */
  billingInvoicesAggregate: BillingInvoiceAggregate;
  /** An array relationship */
  billingItems: Array<BillingItems>;
  /** An aggregate relationship */
  billingItemsAggregate: BillingItemsAggregate;
  /** An array relationship */
  billingPeriods: Array<BillingPeriods>;
  /** An aggregate relationship */
  billingPeriodsAggregate: BillingPeriodsAggregate;
  /** An array relationship */
  clientQuotes: Array<Quotes>;
  /** An aggregate relationship */
  clientQuotesAggregate: QuotesAggregate;
  /** Email address for the client contact */
  contactEmail?: Maybe<Scalars['String']['output']>;
  /** Primary contact person at the client */
  contactPerson?: Maybe<Scalars['String']['output']>;
  /** Phone number for the client contact */
  contactPhone?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the client was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  externalSystemConnections: Array<ClientExternalSystems>;
  /** An aggregate relationship */
  externalSystemConnectionsAggregate: ClientExternalSystemsAggregate;
  /** An array relationship */
  files: Array<Files>;
  /** An aggregate relationship */
  filesAggregate: FilesAggregate;
  /** Unique identifier for the client */
  id: Scalars['uuid']['output'];
  /** An array relationship */
  monthlyBillingCompletions: Array<MonthlyBillingCompletion>;
  /** An aggregate relationship */
  monthlyBillingCompletionsAggregate: MonthlyBillingCompletionAggregate;
  /** Client company name */
  name: Scalars['String']['output'];
  /** An array relationship */
  payrolls: Array<Payrolls>;
  /** An aggregate relationship */
  payrollsAggregate: PayrollsAggregate;
  /** An array relationship */
  quoteConversions: Array<QuoteConversions>;
  /** An aggregate relationship */
  quoteConversionsAggregate: QuoteConversionsAggregate;
  /** An array relationship */
  quotes: Array<Quotes>;
  /** An aggregate relationship */
  quotesAggregate: QuotesAggregate;
  /** An array relationship */
  serviceAgreements: Array<ClientServiceAgreements>;
  /** An aggregate relationship */
  serviceAgreementsAggregate: ClientServiceAgreementsAggregate;
  /** An array relationship */
  timeEntries: Array<TimeEntries>;
  /** An aggregate relationship */
  timeEntriesAggregate: TimeEntriesAggregate;
  /** Timestamp when the client was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "clients" */
export type ClientsBillingInvoicesArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsBillingInvoicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsBillingPeriodsArgs = {
  distinctOn?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingPeriodsOrderBy>>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsBillingPeriodsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingPeriodsOrderBy>>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsClientQuotesArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsClientQuotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsExternalSystemConnectionsArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsExternalSystemConnectionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsFilesArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsMonthlyBillingCompletionsArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsMonthlyBillingCompletionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsPayrollsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsQuoteConversionsArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsQuoteConversionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsQuotesArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsQuotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsServiceAgreementsArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsServiceAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


/** columns and relationships of "clients" */
export type ClientsTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};

/** aggregated selection of "clients" */
export type ClientsAggregate = {
  __typename?: 'ClientsAggregate';
  aggregate?: Maybe<ClientsAggregateFields>;
  nodes: Array<Clients>;
};

/** aggregate fields of "clients" */
export type ClientsAggregateFields = {
  __typename?: 'ClientsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<ClientsMaxFields>;
  min?: Maybe<ClientsMinFields>;
};


/** aggregate fields of "clients" */
export type ClientsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ClientsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "clients". All fields are combined with a logical 'AND'. */
export type ClientsBoolExp = {
  _and?: InputMaybe<Array<ClientsBoolExp>>;
  _not?: InputMaybe<ClientsBoolExp>;
  _or?: InputMaybe<Array<ClientsBoolExp>>;
  active?: InputMaybe<BooleanComparisonExp>;
  billingInvoices?: InputMaybe<BillingInvoiceBoolExp>;
  billingInvoicesAggregate?: InputMaybe<BillingInvoiceAggregateBoolExp>;
  billingItems?: InputMaybe<BillingItemsBoolExp>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  billingPeriods?: InputMaybe<BillingPeriodsBoolExp>;
  billingPeriodsAggregate?: InputMaybe<BillingPeriodsAggregateBoolExp>;
  clientQuotes?: InputMaybe<QuotesBoolExp>;
  clientQuotesAggregate?: InputMaybe<QuotesAggregateBoolExp>;
  contactEmail?: InputMaybe<StringComparisonExp>;
  contactPerson?: InputMaybe<StringComparisonExp>;
  contactPhone?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  externalSystemConnections?: InputMaybe<ClientExternalSystemsBoolExp>;
  externalSystemConnectionsAggregate?: InputMaybe<ClientExternalSystemsAggregateBoolExp>;
  files?: InputMaybe<FilesBoolExp>;
  filesAggregate?: InputMaybe<FilesAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  monthlyBillingCompletions?: InputMaybe<MonthlyBillingCompletionBoolExp>;
  monthlyBillingCompletionsAggregate?: InputMaybe<MonthlyBillingCompletionAggregateBoolExp>;
  name?: InputMaybe<StringComparisonExp>;
  payrolls?: InputMaybe<PayrollsBoolExp>;
  payrollsAggregate?: InputMaybe<PayrollsAggregateBoolExp>;
  quoteConversions?: InputMaybe<QuoteConversionsBoolExp>;
  quoteConversionsAggregate?: InputMaybe<QuoteConversionsAggregateBoolExp>;
  quotes?: InputMaybe<QuotesBoolExp>;
  quotesAggregate?: InputMaybe<QuotesAggregateBoolExp>;
  serviceAgreements?: InputMaybe<ClientServiceAgreementsBoolExp>;
  serviceAgreementsAggregate?: InputMaybe<ClientServiceAgreementsAggregateBoolExp>;
  timeEntries?: InputMaybe<TimeEntriesBoolExp>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "clients" */
export type ClientsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'clients_pkey'
  | '%future added value';

/** input type for inserting data into table "clients" */
export type ClientsInsertInput = {
  /** Whether the client is currently active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  billingInvoices?: InputMaybe<BillingInvoiceArrRelInsertInput>;
  billingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  billingPeriods?: InputMaybe<BillingPeriodsArrRelInsertInput>;
  clientQuotes?: InputMaybe<QuotesArrRelInsertInput>;
  /** Email address for the client contact */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Primary contact person at the client */
  contactPerson?: InputMaybe<Scalars['String']['input']>;
  /** Phone number for the client contact */
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the client was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  externalSystemConnections?: InputMaybe<ClientExternalSystemsArrRelInsertInput>;
  files?: InputMaybe<FilesArrRelInsertInput>;
  /** Unique identifier for the client */
  id?: InputMaybe<Scalars['uuid']['input']>;
  monthlyBillingCompletions?: InputMaybe<MonthlyBillingCompletionArrRelInsertInput>;
  /** Client company name */
  name?: InputMaybe<Scalars['String']['input']>;
  payrolls?: InputMaybe<PayrollsArrRelInsertInput>;
  quoteConversions?: InputMaybe<QuoteConversionsArrRelInsertInput>;
  quotes?: InputMaybe<QuotesArrRelInsertInput>;
  serviceAgreements?: InputMaybe<ClientServiceAgreementsArrRelInsertInput>;
  timeEntries?: InputMaybe<TimeEntriesArrRelInsertInput>;
  /** Timestamp when the client was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ClientsMaxFields = {
  __typename?: 'ClientsMaxFields';
  /** Email address for the client contact */
  contactEmail?: Maybe<Scalars['String']['output']>;
  /** Primary contact person at the client */
  contactPerson?: Maybe<Scalars['String']['output']>;
  /** Phone number for the client contact */
  contactPhone?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the client was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique identifier for the client */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Client company name */
  name?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the client was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type ClientsMinFields = {
  __typename?: 'ClientsMinFields';
  /** Email address for the client contact */
  contactEmail?: Maybe<Scalars['String']['output']>;
  /** Primary contact person at the client */
  contactPerson?: Maybe<Scalars['String']['output']>;
  /** Phone number for the client contact */
  contactPhone?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the client was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique identifier for the client */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Client company name */
  name?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the client was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "clients" */
export type ClientsMutationResponse = {
  __typename?: 'ClientsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Clients>;
};

/** input type for inserting object relation for remote table "clients" */
export type ClientsObjRelInsertInput = {
  data: ClientsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<ClientsOnConflict>;
};

/** on_conflict condition type for table "clients" */
export type ClientsOnConflict = {
  constraint: ClientsConstraint;
  updateColumns?: Array<ClientsUpdateColumn>;
  where?: InputMaybe<ClientsBoolExp>;
};

/** Ordering options when selecting data from "clients". */
export type ClientsOrderBy = {
  active?: InputMaybe<OrderBy>;
  billingInvoicesAggregate?: InputMaybe<BillingInvoiceAggregateOrderBy>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  billingPeriodsAggregate?: InputMaybe<BillingPeriodsAggregateOrderBy>;
  clientQuotesAggregate?: InputMaybe<QuotesAggregateOrderBy>;
  contactEmail?: InputMaybe<OrderBy>;
  contactPerson?: InputMaybe<OrderBy>;
  contactPhone?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  externalSystemConnectionsAggregate?: InputMaybe<ClientExternalSystemsAggregateOrderBy>;
  filesAggregate?: InputMaybe<FilesAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  monthlyBillingCompletionsAggregate?: InputMaybe<MonthlyBillingCompletionAggregateOrderBy>;
  name?: InputMaybe<OrderBy>;
  payrollsAggregate?: InputMaybe<PayrollsAggregateOrderBy>;
  quoteConversionsAggregate?: InputMaybe<QuoteConversionsAggregateOrderBy>;
  quotesAggregate?: InputMaybe<QuotesAggregateOrderBy>;
  serviceAgreementsAggregate?: InputMaybe<ClientServiceAgreementsAggregateOrderBy>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: clients */
export type ClientsPkColumnsInput = {
  /** Unique identifier for the client */
  id: Scalars['uuid']['input'];
};

/** select columns of table "clients" */
export type ClientsSelectColumn =
  /** column name */
  | 'active'
  /** column name */
  | 'contactEmail'
  /** column name */
  | 'contactPerson'
  /** column name */
  | 'contactPhone'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "clients" */
export type ClientsSetInput = {
  /** Whether the client is currently active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Email address for the client contact */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Primary contact person at the client */
  contactPerson?: InputMaybe<Scalars['String']['input']>;
  /** Phone number for the client contact */
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the client was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique identifier for the client */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Client company name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the client was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "clients" */
export type ClientsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ClientsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ClientsStreamCursorValueInput = {
  /** Whether the client is currently active */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Email address for the client contact */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Primary contact person at the client */
  contactPerson?: InputMaybe<Scalars['String']['input']>;
  /** Phone number for the client contact */
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the client was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique identifier for the client */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Client company name */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the client was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "clients" */
export type ClientsUpdateColumn =
  /** column name */
  | 'active'
  /** column name */
  | 'contactEmail'
  /** column name */
  | 'contactPerson'
  /** column name */
  | 'contactPhone'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type ClientsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ClientsSetInput>;
  /** filter the rows which have to be updated */
  where: ClientsBoolExp;
};

/** columns and relationships of "consultant_capacity_overview" */
export type ConsultantCapacityOverview = {
  __typename?: 'ConsultantCapacityOverview';
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['numeric']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  usesDefaultAdminTime?: Maybe<Scalars['Boolean']['output']>;
  workDay?: Maybe<Scalars['String']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "consultant_capacity_overview" */
export type ConsultantCapacityOverviewAggregate = {
  __typename?: 'ConsultantCapacityOverviewAggregate';
  aggregate?: Maybe<ConsultantCapacityOverviewAggregateFields>;
  nodes: Array<ConsultantCapacityOverview>;
};

/** aggregate fields of "consultant_capacity_overview" */
export type ConsultantCapacityOverviewAggregateFields = {
  __typename?: 'ConsultantCapacityOverviewAggregateFields';
  avg?: Maybe<ConsultantCapacityOverviewAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ConsultantCapacityOverviewMaxFields>;
  min?: Maybe<ConsultantCapacityOverviewMinFields>;
  stddev?: Maybe<ConsultantCapacityOverviewStddevFields>;
  stddevPop?: Maybe<ConsultantCapacityOverviewStddevPopFields>;
  stddevSamp?: Maybe<ConsultantCapacityOverviewStddevSampFields>;
  sum?: Maybe<ConsultantCapacityOverviewSumFields>;
  varPop?: Maybe<ConsultantCapacityOverviewVarPopFields>;
  varSamp?: Maybe<ConsultantCapacityOverviewVarSampFields>;
  variance?: Maybe<ConsultantCapacityOverviewVarianceFields>;
};


/** aggregate fields of "consultant_capacity_overview" */
export type ConsultantCapacityOverviewAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ConsultantCapacityOverviewSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type ConsultantCapacityOverviewAvgFields = {
  __typename?: 'ConsultantCapacityOverviewAvgFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['Float']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "consultant_capacity_overview". All fields are combined with a logical 'AND'. */
export type ConsultantCapacityOverviewBoolExp = {
  _and?: InputMaybe<Array<ConsultantCapacityOverviewBoolExp>>;
  _not?: InputMaybe<ConsultantCapacityOverviewBoolExp>;
  _or?: InputMaybe<Array<ConsultantCapacityOverviewBoolExp>>;
  adminTimeHours?: InputMaybe<NumericComparisonExp>;
  adminTimePercentageActual?: InputMaybe<NumericComparisonExp>;
  defaultAdminTimePercentage?: InputMaybe<NumericComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  payrollCapacityHours?: InputMaybe<NumericComparisonExp>;
  position?: InputMaybe<UserPositionComparisonExp>;
  usesDefaultAdminTime?: InputMaybe<BooleanComparisonExp>;
  workDay?: InputMaybe<StringComparisonExp>;
  workHours?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type ConsultantCapacityOverviewMaxFields = {
  __typename?: 'ConsultantCapacityOverviewMaxFields';
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['numeric']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  workDay?: Maybe<Scalars['String']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type ConsultantCapacityOverviewMinFields = {
  __typename?: 'ConsultantCapacityOverviewMinFields';
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['numeric']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  workDay?: Maybe<Scalars['String']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "consultant_capacity_overview". */
export type ConsultantCapacityOverviewOrderBy = {
  adminTimeHours?: InputMaybe<OrderBy>;
  adminTimePercentageActual?: InputMaybe<OrderBy>;
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payrollCapacityHours?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  usesDefaultAdminTime?: InputMaybe<OrderBy>;
  workDay?: InputMaybe<OrderBy>;
  workHours?: InputMaybe<OrderBy>;
};

/** select columns of table "consultant_capacity_overview" */
export type ConsultantCapacityOverviewSelectColumn =
  /** column name */
  | 'adminTimeHours'
  /** column name */
  | 'adminTimePercentageActual'
  /** column name */
  | 'defaultAdminTimePercentage'
  /** column name */
  | 'email'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'payrollCapacityHours'
  /** column name */
  | 'position'
  /** column name */
  | 'usesDefaultAdminTime'
  /** column name */
  | 'workDay'
  /** column name */
  | 'workHours'
  | '%future added value';

/** aggregate stddev on columns */
export type ConsultantCapacityOverviewStddevFields = {
  __typename?: 'ConsultantCapacityOverviewStddevFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['Float']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type ConsultantCapacityOverviewStddevPopFields = {
  __typename?: 'ConsultantCapacityOverviewStddevPopFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['Float']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type ConsultantCapacityOverviewStddevSampFields = {
  __typename?: 'ConsultantCapacityOverviewStddevSampFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['Float']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "consultant_capacity_overview" */
export type ConsultantCapacityOverviewStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ConsultantCapacityOverviewStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ConsultantCapacityOverviewStreamCursorValueInput = {
  adminTimeHours?: InputMaybe<Scalars['numeric']['input']>;
  adminTimePercentageActual?: InputMaybe<Scalars['numeric']['input']>;
  defaultAdminTimePercentage?: InputMaybe<Scalars['numeric']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollCapacityHours?: InputMaybe<Scalars['numeric']['input']>;
  position?: InputMaybe<Scalars['user_position']['input']>;
  usesDefaultAdminTime?: InputMaybe<Scalars['Boolean']['input']>;
  workDay?: InputMaybe<Scalars['String']['input']>;
  workHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type ConsultantCapacityOverviewSumFields = {
  __typename?: 'ConsultantCapacityOverviewSumFields';
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['numeric']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type ConsultantCapacityOverviewVarPopFields = {
  __typename?: 'ConsultantCapacityOverviewVarPopFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['Float']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type ConsultantCapacityOverviewVarSampFields = {
  __typename?: 'ConsultantCapacityOverviewVarSampFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['Float']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type ConsultantCapacityOverviewVarianceFields = {
  __typename?: 'ConsultantCapacityOverviewVarianceFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  adminTimePercentageActual?: Maybe<Scalars['Float']['output']>;
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "current_payrolls" */
export type CurrentPayrolls = {
  __typename?: 'CurrentPayrolls';
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  cycleId?: Maybe<Scalars['uuid']['output']>;
  dateTypeId?: Maybe<Scalars['uuid']['output']>;
  dateValue?: Maybe<Scalars['Int']['output']>;
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  parentPayrollId?: Maybe<Scalars['uuid']['output']>;
  payrollCycleName?: Maybe<Scalars['payroll_cycle_type']['output']>;
  payrollDateTypeName?: Maybe<Scalars['payroll_date_type']['output']>;
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "current_payrolls" */
export type CurrentPayrollsAggregate = {
  __typename?: 'CurrentPayrollsAggregate';
  aggregate?: Maybe<CurrentPayrollsAggregateFields>;
  nodes: Array<CurrentPayrolls>;
};

/** aggregate fields of "current_payrolls" */
export type CurrentPayrollsAggregateFields = {
  __typename?: 'CurrentPayrollsAggregateFields';
  avg?: Maybe<CurrentPayrollsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<CurrentPayrollsMaxFields>;
  min?: Maybe<CurrentPayrollsMinFields>;
  stddev?: Maybe<CurrentPayrollsStddevFields>;
  stddevPop?: Maybe<CurrentPayrollsStddevPopFields>;
  stddevSamp?: Maybe<CurrentPayrollsStddevSampFields>;
  sum?: Maybe<CurrentPayrollsSumFields>;
  varPop?: Maybe<CurrentPayrollsVarPopFields>;
  varSamp?: Maybe<CurrentPayrollsVarSampFields>;
  variance?: Maybe<CurrentPayrollsVarianceFields>;
};


/** aggregate fields of "current_payrolls" */
export type CurrentPayrollsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<CurrentPayrollsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type CurrentPayrollsAvgFields = {
  __typename?: 'CurrentPayrollsAvgFields';
  dateValue?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "current_payrolls". All fields are combined with a logical 'AND'. */
export type CurrentPayrollsBoolExp = {
  _and?: InputMaybe<Array<CurrentPayrollsBoolExp>>;
  _not?: InputMaybe<CurrentPayrollsBoolExp>;
  _or?: InputMaybe<Array<CurrentPayrollsBoolExp>>;
  backupConsultantUserId?: InputMaybe<UuidComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  cycleId?: InputMaybe<UuidComparisonExp>;
  dateTypeId?: InputMaybe<UuidComparisonExp>;
  dateValue?: InputMaybe<IntComparisonExp>;
  goLiveDate?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  managerUserId?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  parentPayrollId?: InputMaybe<UuidComparisonExp>;
  payrollCycleName?: InputMaybe<PayrollCycleTypeComparisonExp>;
  payrollDateTypeName?: InputMaybe<PayrollDateTypeComparisonExp>;
  primaryConsultantUserId?: InputMaybe<UuidComparisonExp>;
  supersededDate?: InputMaybe<DateComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  versionNumber?: InputMaybe<IntComparisonExp>;
  versionReason?: InputMaybe<StringComparisonExp>;
};

/** aggregate max on columns */
export type CurrentPayrollsMaxFields = {
  __typename?: 'CurrentPayrollsMaxFields';
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  cycleId?: Maybe<Scalars['uuid']['output']>;
  dateTypeId?: Maybe<Scalars['uuid']['output']>;
  dateValue?: Maybe<Scalars['Int']['output']>;
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  parentPayrollId?: Maybe<Scalars['uuid']['output']>;
  payrollCycleName?: Maybe<Scalars['payroll_cycle_type']['output']>;
  payrollDateTypeName?: Maybe<Scalars['payroll_date_type']['output']>;
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type CurrentPayrollsMinFields = {
  __typename?: 'CurrentPayrollsMinFields';
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  cycleId?: Maybe<Scalars['uuid']['output']>;
  dateTypeId?: Maybe<Scalars['uuid']['output']>;
  dateValue?: Maybe<Scalars['Int']['output']>;
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  parentPayrollId?: Maybe<Scalars['uuid']['output']>;
  payrollCycleName?: Maybe<Scalars['payroll_cycle_type']['output']>;
  payrollDateTypeName?: Maybe<Scalars['payroll_date_type']['output']>;
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "current_payrolls". */
export type CurrentPayrollsOrderBy = {
  backupConsultantUserId?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  cycleId?: InputMaybe<OrderBy>;
  dateTypeId?: InputMaybe<OrderBy>;
  dateValue?: InputMaybe<OrderBy>;
  goLiveDate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  managerUserId?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  parentPayrollId?: InputMaybe<OrderBy>;
  payrollCycleName?: InputMaybe<OrderBy>;
  payrollDateTypeName?: InputMaybe<OrderBy>;
  primaryConsultantUserId?: InputMaybe<OrderBy>;
  supersededDate?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
  versionReason?: InputMaybe<OrderBy>;
};

/** select columns of table "current_payrolls" */
export type CurrentPayrollsSelectColumn =
  /** column name */
  | 'backupConsultantUserId'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'cycleId'
  /** column name */
  | 'dateTypeId'
  /** column name */
  | 'dateValue'
  /** column name */
  | 'goLiveDate'
  /** column name */
  | 'id'
  /** column name */
  | 'managerUserId'
  /** column name */
  | 'name'
  /** column name */
  | 'parentPayrollId'
  /** column name */
  | 'payrollCycleName'
  /** column name */
  | 'payrollDateTypeName'
  /** column name */
  | 'primaryConsultantUserId'
  /** column name */
  | 'supersededDate'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'versionNumber'
  /** column name */
  | 'versionReason'
  | '%future added value';

/** aggregate stddev on columns */
export type CurrentPayrollsStddevFields = {
  __typename?: 'CurrentPayrollsStddevFields';
  dateValue?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type CurrentPayrollsStddevPopFields = {
  __typename?: 'CurrentPayrollsStddevPopFields';
  dateValue?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type CurrentPayrollsStddevSampFields = {
  __typename?: 'CurrentPayrollsStddevSampFields';
  dateValue?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "current_payrolls" */
export type CurrentPayrollsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: CurrentPayrollsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type CurrentPayrollsStreamCursorValueInput = {
  backupConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  cycleId?: InputMaybe<Scalars['uuid']['input']>;
  dateTypeId?: InputMaybe<Scalars['uuid']['input']>;
  dateValue?: InputMaybe<Scalars['Int']['input']>;
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  managerUserId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentPayrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollCycleName?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  payrollDateTypeName?: InputMaybe<Scalars['payroll_date_type']['input']>;
  primaryConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  supersededDate?: InputMaybe<Scalars['date']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionReason?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type CurrentPayrollsSumFields = {
  __typename?: 'CurrentPayrollsSumFields';
  dateValue?: Maybe<Scalars['Int']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** aggregate varPop on columns */
export type CurrentPayrollsVarPopFields = {
  __typename?: 'CurrentPayrollsVarPopFields';
  dateValue?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type CurrentPayrollsVarSampFields = {
  __typename?: 'CurrentPayrollsVarSampFields';
  dateValue?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type CurrentPayrollsVarianceFields = {
  __typename?: 'CurrentPayrollsVarianceFields';
  dateValue?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** ordering argument of a cursor */
export type CursorOrdering =
  /** ascending ordering of the cursor */
  | 'ASC'
  /** descending ordering of the cursor */
  | 'DESC'
  | '%future added value';

/** columns and relationships of "data_backups" */
export type DataBackups = {
  __typename?: 'DataBackups';
  backupType?: Maybe<Scalars['String']['output']>;
  checksum?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  compressionType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  encryptionKeyHash?: Maybe<Scalars['String']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  fileSize?: Maybe<Scalars['bigint']['output']>;
  id: Scalars['uuid']['output'];
  metadata?: Maybe<Scalars['jsonb']['output']>;
  retentionDays?: Maybe<Scalars['Int']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  storagePath?: Maybe<Scalars['String']['output']>;
  tablesIncluded?: Maybe<Array<Scalars['String']['output']>>;
  /** An object relationship */
  user?: Maybe<Users>;
  userId?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "data_backups" */
export type DataBackupsMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "data_backups" */
export type DataBackupsAggregate = {
  __typename?: 'DataBackupsAggregate';
  aggregate?: Maybe<DataBackupsAggregateFields>;
  nodes: Array<DataBackups>;
};

export type DataBackupsAggregateBoolExp = {
  count?: InputMaybe<DataBackupsAggregateBoolExpCount>;
};

/** aggregate fields of "data_backups" */
export type DataBackupsAggregateFields = {
  __typename?: 'DataBackupsAggregateFields';
  avg?: Maybe<DataBackupsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<DataBackupsMaxFields>;
  min?: Maybe<DataBackupsMinFields>;
  stddev?: Maybe<DataBackupsStddevFields>;
  stddevPop?: Maybe<DataBackupsStddevPopFields>;
  stddevSamp?: Maybe<DataBackupsStddevSampFields>;
  sum?: Maybe<DataBackupsSumFields>;
  varPop?: Maybe<DataBackupsVarPopFields>;
  varSamp?: Maybe<DataBackupsVarSampFields>;
  variance?: Maybe<DataBackupsVarianceFields>;
};


/** aggregate fields of "data_backups" */
export type DataBackupsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<DataBackupsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "data_backups" */
export type DataBackupsAggregateOrderBy = {
  avg?: InputMaybe<DataBackupsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<DataBackupsMaxOrderBy>;
  min?: InputMaybe<DataBackupsMinOrderBy>;
  stddev?: InputMaybe<DataBackupsStddevOrderBy>;
  stddevPop?: InputMaybe<DataBackupsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<DataBackupsStddevSampOrderBy>;
  sum?: InputMaybe<DataBackupsSumOrderBy>;
  varPop?: InputMaybe<DataBackupsVarPopOrderBy>;
  varSamp?: InputMaybe<DataBackupsVarSampOrderBy>;
  variance?: InputMaybe<DataBackupsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type DataBackupsAppendInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "data_backups" */
export type DataBackupsArrRelInsertInput = {
  data: Array<DataBackupsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<DataBackupsOnConflict>;
};

/** aggregate avg on columns */
export type DataBackupsAvgFields = {
  __typename?: 'DataBackupsAvgFields';
  fileSize?: Maybe<Scalars['Float']['output']>;
  retentionDays?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "data_backups" */
export type DataBackupsAvgOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "data_backups". All fields are combined with a logical 'AND'. */
export type DataBackupsBoolExp = {
  _and?: InputMaybe<Array<DataBackupsBoolExp>>;
  _not?: InputMaybe<DataBackupsBoolExp>;
  _or?: InputMaybe<Array<DataBackupsBoolExp>>;
  backupType?: InputMaybe<StringComparisonExp>;
  checksum?: InputMaybe<StringComparisonExp>;
  completedAt?: InputMaybe<TimestamptzComparisonExp>;
  compressionType?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  encryptionKeyHash?: InputMaybe<StringComparisonExp>;
  errorMessage?: InputMaybe<StringComparisonExp>;
  expiresAt?: InputMaybe<TimestamptzComparisonExp>;
  fileSize?: InputMaybe<BigintComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  retentionDays?: InputMaybe<IntComparisonExp>;
  startedAt?: InputMaybe<TimestamptzComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  storagePath?: InputMaybe<StringComparisonExp>;
  tablesIncluded?: InputMaybe<StringArrayComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "data_backups" */
export type DataBackupsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'data_backups_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type DataBackupsDeleteAtPathInput = {
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type DataBackupsDeleteElemInput = {
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type DataBackupsDeleteKeyInput = {
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "data_backups" */
export type DataBackupsIncInput = {
  fileSize?: InputMaybe<Scalars['bigint']['input']>;
  retentionDays?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "data_backups" */
export type DataBackupsInsertInput = {
  backupType?: InputMaybe<Scalars['String']['input']>;
  checksum?: InputMaybe<Scalars['String']['input']>;
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  compressionType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  encryptionKeyHash?: InputMaybe<Scalars['String']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  fileSize?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  retentionDays?: InputMaybe<Scalars['Int']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  storagePath?: InputMaybe<Scalars['String']['input']>;
  tablesIncluded?: InputMaybe<Array<Scalars['String']['input']>>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type DataBackupsMaxFields = {
  __typename?: 'DataBackupsMaxFields';
  backupType?: Maybe<Scalars['String']['output']>;
  checksum?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  compressionType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  encryptionKeyHash?: Maybe<Scalars['String']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  fileSize?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  retentionDays?: Maybe<Scalars['Int']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  storagePath?: Maybe<Scalars['String']['output']>;
  tablesIncluded?: Maybe<Array<Scalars['String']['output']>>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "data_backups" */
export type DataBackupsMaxOrderBy = {
  backupType?: InputMaybe<OrderBy>;
  checksum?: InputMaybe<OrderBy>;
  completedAt?: InputMaybe<OrderBy>;
  compressionType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  encryptionKeyHash?: InputMaybe<OrderBy>;
  errorMessage?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  fileSize?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  storagePath?: InputMaybe<OrderBy>;
  tablesIncluded?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type DataBackupsMinFields = {
  __typename?: 'DataBackupsMinFields';
  backupType?: Maybe<Scalars['String']['output']>;
  checksum?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  compressionType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  encryptionKeyHash?: Maybe<Scalars['String']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  fileSize?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  retentionDays?: Maybe<Scalars['Int']['output']>;
  startedAt?: Maybe<Scalars['timestamptz']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  storagePath?: Maybe<Scalars['String']['output']>;
  tablesIncluded?: Maybe<Array<Scalars['String']['output']>>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "data_backups" */
export type DataBackupsMinOrderBy = {
  backupType?: InputMaybe<OrderBy>;
  checksum?: InputMaybe<OrderBy>;
  completedAt?: InputMaybe<OrderBy>;
  compressionType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  encryptionKeyHash?: InputMaybe<OrderBy>;
  errorMessage?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  fileSize?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  storagePath?: InputMaybe<OrderBy>;
  tablesIncluded?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "data_backups" */
export type DataBackupsMutationResponse = {
  __typename?: 'DataBackupsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DataBackups>;
};

/** on_conflict condition type for table "data_backups" */
export type DataBackupsOnConflict = {
  constraint: DataBackupsConstraint;
  updateColumns?: Array<DataBackupsUpdateColumn>;
  where?: InputMaybe<DataBackupsBoolExp>;
};

/** Ordering options when selecting data from "data_backups". */
export type DataBackupsOrderBy = {
  backupType?: InputMaybe<OrderBy>;
  checksum?: InputMaybe<OrderBy>;
  completedAt?: InputMaybe<OrderBy>;
  compressionType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  encryptionKeyHash?: InputMaybe<OrderBy>;
  errorMessage?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  fileSize?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
  startedAt?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  storagePath?: InputMaybe<OrderBy>;
  tablesIncluded?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: data_backups */
export type DataBackupsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type DataBackupsPrependInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "data_backups" */
export type DataBackupsSelectColumn =
  /** column name */
  | 'backupType'
  /** column name */
  | 'checksum'
  /** column name */
  | 'completedAt'
  /** column name */
  | 'compressionType'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'encryptionKeyHash'
  /** column name */
  | 'errorMessage'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'fileSize'
  /** column name */
  | 'id'
  /** column name */
  | 'metadata'
  /** column name */
  | 'retentionDays'
  /** column name */
  | 'startedAt'
  /** column name */
  | 'status'
  /** column name */
  | 'storagePath'
  /** column name */
  | 'tablesIncluded'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "data_backups" */
export type DataBackupsSetInput = {
  backupType?: InputMaybe<Scalars['String']['input']>;
  checksum?: InputMaybe<Scalars['String']['input']>;
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  compressionType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  encryptionKeyHash?: InputMaybe<Scalars['String']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  fileSize?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  retentionDays?: InputMaybe<Scalars['Int']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  storagePath?: InputMaybe<Scalars['String']['input']>;
  tablesIncluded?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type DataBackupsStddevFields = {
  __typename?: 'DataBackupsStddevFields';
  fileSize?: Maybe<Scalars['Float']['output']>;
  retentionDays?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "data_backups" */
export type DataBackupsStddevOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type DataBackupsStddevPopFields = {
  __typename?: 'DataBackupsStddevPopFields';
  fileSize?: Maybe<Scalars['Float']['output']>;
  retentionDays?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "data_backups" */
export type DataBackupsStddevPopOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type DataBackupsStddevSampFields = {
  __typename?: 'DataBackupsStddevSampFields';
  fileSize?: Maybe<Scalars['Float']['output']>;
  retentionDays?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "data_backups" */
export type DataBackupsStddevSampOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "data_backups" */
export type DataBackupsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: DataBackupsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type DataBackupsStreamCursorValueInput = {
  backupType?: InputMaybe<Scalars['String']['input']>;
  checksum?: InputMaybe<Scalars['String']['input']>;
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  compressionType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  encryptionKeyHash?: InputMaybe<Scalars['String']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  fileSize?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  retentionDays?: InputMaybe<Scalars['Int']['input']>;
  startedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  storagePath?: InputMaybe<Scalars['String']['input']>;
  tablesIncluded?: InputMaybe<Array<Scalars['String']['input']>>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type DataBackupsSumFields = {
  __typename?: 'DataBackupsSumFields';
  fileSize?: Maybe<Scalars['bigint']['output']>;
  retentionDays?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "data_backups" */
export type DataBackupsSumOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** update columns of table "data_backups" */
export type DataBackupsUpdateColumn =
  /** column name */
  | 'backupType'
  /** column name */
  | 'checksum'
  /** column name */
  | 'completedAt'
  /** column name */
  | 'compressionType'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'encryptionKeyHash'
  /** column name */
  | 'errorMessage'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'fileSize'
  /** column name */
  | 'id'
  /** column name */
  | 'metadata'
  /** column name */
  | 'retentionDays'
  /** column name */
  | 'startedAt'
  /** column name */
  | 'status'
  /** column name */
  | 'storagePath'
  /** column name */
  | 'tablesIncluded'
  /** column name */
  | 'userId'
  | '%future added value';

export type DataBackupsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<DataBackupsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<DataBackupsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<DataBackupsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<DataBackupsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<DataBackupsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<DataBackupsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DataBackupsSetInput>;
  /** filter the rows which have to be updated */
  where: DataBackupsBoolExp;
};

/** aggregate varPop on columns */
export type DataBackupsVarPopFields = {
  __typename?: 'DataBackupsVarPopFields';
  fileSize?: Maybe<Scalars['Float']['output']>;
  retentionDays?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "data_backups" */
export type DataBackupsVarPopOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type DataBackupsVarSampFields = {
  __typename?: 'DataBackupsVarSampFields';
  fileSize?: Maybe<Scalars['Float']['output']>;
  retentionDays?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "data_backups" */
export type DataBackupsVarSampOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type DataBackupsVarianceFields = {
  __typename?: 'DataBackupsVarianceFields';
  fileSize?: Maybe<Scalars['Float']['output']>;
  retentionDays?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "data_backups" */
export type DataBackupsVarianceOrderBy = {
  fileSize?: InputMaybe<OrderBy>;
  retentionDays?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type DateComparisonExp = {
  _eq?: InputMaybe<Scalars['date']['input']>;
  _gt?: InputMaybe<Scalars['date']['input']>;
  _gte?: InputMaybe<Scalars['date']['input']>;
  _in?: InputMaybe<Array<Scalars['date']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['date']['input']>;
  _lte?: InputMaybe<Scalars['date']['input']>;
  _neq?: InputMaybe<Scalars['date']['input']>;
  _nin?: InputMaybe<Array<Scalars['date']['input']>>;
};

/** Draft emails saved for later sending */
export type EmailDrafts = {
  __typename?: 'EmailDrafts';
  businessContext?: Maybe<Scalars['jsonb']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  emailTemplate?: Maybe<EmailTemplates>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  recipientEmails: Array<Scalars['String']['output']>;
  scheduledFor?: Maybe<Scalars['timestamptz']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['uuid']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
  variableValues?: Maybe<Scalars['jsonb']['output']>;
};


/** Draft emails saved for later sending */
export type EmailDraftsBusinessContextArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Draft emails saved for later sending */
export type EmailDraftsVariableValuesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "email_drafts" */
export type EmailDraftsAggregate = {
  __typename?: 'EmailDraftsAggregate';
  aggregate?: Maybe<EmailDraftsAggregateFields>;
  nodes: Array<EmailDrafts>;
};

export type EmailDraftsAggregateBoolExp = {
  count?: InputMaybe<EmailDraftsAggregateBoolExpCount>;
};

/** aggregate fields of "email_drafts" */
export type EmailDraftsAggregateFields = {
  __typename?: 'EmailDraftsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<EmailDraftsMaxFields>;
  min?: Maybe<EmailDraftsMinFields>;
};


/** aggregate fields of "email_drafts" */
export type EmailDraftsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "email_drafts" */
export type EmailDraftsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EmailDraftsMaxOrderBy>;
  min?: InputMaybe<EmailDraftsMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type EmailDraftsAppendInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  variableValues?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "email_drafts" */
export type EmailDraftsArrRelInsertInput = {
  data: Array<EmailDraftsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EmailDraftsOnConflict>;
};

/** Boolean expression to filter rows from the table "email_drafts". All fields are combined with a logical 'AND'. */
export type EmailDraftsBoolExp = {
  _and?: InputMaybe<Array<EmailDraftsBoolExp>>;
  _not?: InputMaybe<EmailDraftsBoolExp>;
  _or?: InputMaybe<Array<EmailDraftsBoolExp>>;
  businessContext?: InputMaybe<JsonbComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  emailTemplate?: InputMaybe<EmailTemplatesBoolExp>;
  htmlContent?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  recipientEmails?: InputMaybe<StringArrayComparisonExp>;
  scheduledFor?: InputMaybe<TimestamptzComparisonExp>;
  subject?: InputMaybe<StringComparisonExp>;
  templateId?: InputMaybe<UuidComparisonExp>;
  textContent?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  variableValues?: InputMaybe<JsonbComparisonExp>;
};

/** unique or primary key constraints on table "email_drafts" */
export type EmailDraftsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'email_drafts_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type EmailDraftsDeleteAtPathInput = {
  businessContext?: InputMaybe<Array<Scalars['String']['input']>>;
  variableValues?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type EmailDraftsDeleteElemInput = {
  businessContext?: InputMaybe<Scalars['Int']['input']>;
  variableValues?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type EmailDraftsDeleteKeyInput = {
  businessContext?: InputMaybe<Scalars['String']['input']>;
  variableValues?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "email_drafts" */
export type EmailDraftsInsertInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  emailTemplate?: InputMaybe<EmailTemplatesObjRelInsertInput>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  recipientEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  scheduledFor?: InputMaybe<Scalars['timestamptz']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  variableValues?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate max on columns */
export type EmailDraftsMaxFields = {
  __typename?: 'EmailDraftsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  recipientEmails?: Maybe<Array<Scalars['String']['output']>>;
  scheduledFor?: Maybe<Scalars['timestamptz']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['uuid']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "email_drafts" */
export type EmailDraftsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  recipientEmails?: InputMaybe<OrderBy>;
  scheduledFor?: InputMaybe<OrderBy>;
  subject?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EmailDraftsMinFields = {
  __typename?: 'EmailDraftsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  recipientEmails?: Maybe<Array<Scalars['String']['output']>>;
  scheduledFor?: Maybe<Scalars['timestamptz']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['uuid']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "email_drafts" */
export type EmailDraftsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  recipientEmails?: InputMaybe<OrderBy>;
  scheduledFor?: InputMaybe<OrderBy>;
  subject?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "email_drafts" */
export type EmailDraftsMutationResponse = {
  __typename?: 'EmailDraftsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<EmailDrafts>;
};

/** on_conflict condition type for table "email_drafts" */
export type EmailDraftsOnConflict = {
  constraint: EmailDraftsConstraint;
  updateColumns?: Array<EmailDraftsUpdateColumn>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};

/** Ordering options when selecting data from "email_drafts". */
export type EmailDraftsOrderBy = {
  businessContext?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  emailTemplate?: InputMaybe<EmailTemplatesOrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  recipientEmails?: InputMaybe<OrderBy>;
  scheduledFor?: InputMaybe<OrderBy>;
  subject?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  variableValues?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: email_drafts */
export type EmailDraftsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type EmailDraftsPrependInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  variableValues?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "email_drafts" */
export type EmailDraftsSelectColumn =
  /** column name */
  | 'businessContext'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'htmlContent'
  /** column name */
  | 'id'
  /** column name */
  | 'recipientEmails'
  /** column name */
  | 'scheduledFor'
  /** column name */
  | 'subject'
  /** column name */
  | 'templateId'
  /** column name */
  | 'textContent'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  /** column name */
  | 'variableValues'
  | '%future added value';

/** input type for updating data in table "email_drafts" */
export type EmailDraftsSetInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  recipientEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  scheduledFor?: InputMaybe<Scalars['timestamptz']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  variableValues?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Streaming cursor of the table "email_drafts" */
export type EmailDraftsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EmailDraftsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EmailDraftsStreamCursorValueInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  recipientEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  scheduledFor?: InputMaybe<Scalars['timestamptz']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  variableValues?: InputMaybe<Scalars['jsonb']['input']>;
};

/** update columns of table "email_drafts" */
export type EmailDraftsUpdateColumn =
  /** column name */
  | 'businessContext'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'htmlContent'
  /** column name */
  | 'id'
  /** column name */
  | 'recipientEmails'
  /** column name */
  | 'scheduledFor'
  /** column name */
  | 'subject'
  /** column name */
  | 'templateId'
  /** column name */
  | 'textContent'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  /** column name */
  | 'variableValues'
  | '%future added value';

export type EmailDraftsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<EmailDraftsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<EmailDraftsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<EmailDraftsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<EmailDraftsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<EmailDraftsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EmailDraftsSetInput>;
  /** filter the rows which have to be updated */
  where: EmailDraftsBoolExp;
};

/** Audit log of all emails sent through the system */
export type EmailSendLogs = {
  __typename?: 'EmailSendLogs';
  businessContext?: Maybe<Scalars['jsonb']['output']>;
  clickedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  deliveredAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  emailTemplate?: Maybe<EmailTemplates>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  openedAt?: Maybe<Scalars['timestamptz']['output']>;
  recipientEmails: Array<Scalars['String']['output']>;
  resendEmailId?: Maybe<Scalars['String']['output']>;
  resendResponse?: Maybe<Scalars['jsonb']['output']>;
  scheduledFor?: Maybe<Scalars['timestamptz']['output']>;
  sendStatus?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  senderUser: Users;
  senderUserId: Scalars['uuid']['output'];
  sentAt?: Maybe<Scalars['timestamptz']['output']>;
  subject: Scalars['String']['output'];
  templateId?: Maybe<Scalars['uuid']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
};


/** Audit log of all emails sent through the system */
export type EmailSendLogsBusinessContextArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Audit log of all emails sent through the system */
export type EmailSendLogsResendResponseArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "email_send_logs" */
export type EmailSendLogsAggregate = {
  __typename?: 'EmailSendLogsAggregate';
  aggregate?: Maybe<EmailSendLogsAggregateFields>;
  nodes: Array<EmailSendLogs>;
};

export type EmailSendLogsAggregateBoolExp = {
  count?: InputMaybe<EmailSendLogsAggregateBoolExpCount>;
};

/** aggregate fields of "email_send_logs" */
export type EmailSendLogsAggregateFields = {
  __typename?: 'EmailSendLogsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<EmailSendLogsMaxFields>;
  min?: Maybe<EmailSendLogsMinFields>;
};


/** aggregate fields of "email_send_logs" */
export type EmailSendLogsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "email_send_logs" */
export type EmailSendLogsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EmailSendLogsMaxOrderBy>;
  min?: InputMaybe<EmailSendLogsMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type EmailSendLogsAppendInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  resendResponse?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "email_send_logs" */
export type EmailSendLogsArrRelInsertInput = {
  data: Array<EmailSendLogsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EmailSendLogsOnConflict>;
};

/** Boolean expression to filter rows from the table "email_send_logs". All fields are combined with a logical 'AND'. */
export type EmailSendLogsBoolExp = {
  _and?: InputMaybe<Array<EmailSendLogsBoolExp>>;
  _not?: InputMaybe<EmailSendLogsBoolExp>;
  _or?: InputMaybe<Array<EmailSendLogsBoolExp>>;
  businessContext?: InputMaybe<JsonbComparisonExp>;
  clickedAt?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  deliveredAt?: InputMaybe<TimestamptzComparisonExp>;
  emailTemplate?: InputMaybe<EmailTemplatesBoolExp>;
  errorMessage?: InputMaybe<StringComparisonExp>;
  htmlContent?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  openedAt?: InputMaybe<TimestamptzComparisonExp>;
  recipientEmails?: InputMaybe<StringArrayComparisonExp>;
  resendEmailId?: InputMaybe<StringComparisonExp>;
  resendResponse?: InputMaybe<JsonbComparisonExp>;
  scheduledFor?: InputMaybe<TimestamptzComparisonExp>;
  sendStatus?: InputMaybe<StringComparisonExp>;
  senderUser?: InputMaybe<UsersBoolExp>;
  senderUserId?: InputMaybe<UuidComparisonExp>;
  sentAt?: InputMaybe<TimestamptzComparisonExp>;
  subject?: InputMaybe<StringComparisonExp>;
  templateId?: InputMaybe<UuidComparisonExp>;
  textContent?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "email_send_logs" */
export type EmailSendLogsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'email_send_logs_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type EmailSendLogsDeleteAtPathInput = {
  businessContext?: InputMaybe<Array<Scalars['String']['input']>>;
  resendResponse?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type EmailSendLogsDeleteElemInput = {
  businessContext?: InputMaybe<Scalars['Int']['input']>;
  resendResponse?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type EmailSendLogsDeleteKeyInput = {
  businessContext?: InputMaybe<Scalars['String']['input']>;
  resendResponse?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "email_send_logs" */
export type EmailSendLogsInsertInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  clickedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deliveredAt?: InputMaybe<Scalars['timestamptz']['input']>;
  emailTemplate?: InputMaybe<EmailTemplatesObjRelInsertInput>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  openedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  recipientEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  resendEmailId?: InputMaybe<Scalars['String']['input']>;
  resendResponse?: InputMaybe<Scalars['jsonb']['input']>;
  scheduledFor?: InputMaybe<Scalars['timestamptz']['input']>;
  sendStatus?: InputMaybe<Scalars['String']['input']>;
  senderUser?: InputMaybe<UsersObjRelInsertInput>;
  senderUserId?: InputMaybe<Scalars['uuid']['input']>;
  sentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type EmailSendLogsMaxFields = {
  __typename?: 'EmailSendLogsMaxFields';
  clickedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  deliveredAt?: Maybe<Scalars['timestamptz']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  openedAt?: Maybe<Scalars['timestamptz']['output']>;
  recipientEmails?: Maybe<Array<Scalars['String']['output']>>;
  resendEmailId?: Maybe<Scalars['String']['output']>;
  scheduledFor?: Maybe<Scalars['timestamptz']['output']>;
  sendStatus?: Maybe<Scalars['String']['output']>;
  senderUserId?: Maybe<Scalars['uuid']['output']>;
  sentAt?: Maybe<Scalars['timestamptz']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['uuid']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "email_send_logs" */
export type EmailSendLogsMaxOrderBy = {
  clickedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deliveredAt?: InputMaybe<OrderBy>;
  errorMessage?: InputMaybe<OrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openedAt?: InputMaybe<OrderBy>;
  recipientEmails?: InputMaybe<OrderBy>;
  resendEmailId?: InputMaybe<OrderBy>;
  scheduledFor?: InputMaybe<OrderBy>;
  sendStatus?: InputMaybe<OrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  sentAt?: InputMaybe<OrderBy>;
  subject?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EmailSendLogsMinFields = {
  __typename?: 'EmailSendLogsMinFields';
  clickedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  deliveredAt?: Maybe<Scalars['timestamptz']['output']>;
  errorMessage?: Maybe<Scalars['String']['output']>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  openedAt?: Maybe<Scalars['timestamptz']['output']>;
  recipientEmails?: Maybe<Array<Scalars['String']['output']>>;
  resendEmailId?: Maybe<Scalars['String']['output']>;
  scheduledFor?: Maybe<Scalars['timestamptz']['output']>;
  sendStatus?: Maybe<Scalars['String']['output']>;
  senderUserId?: Maybe<Scalars['uuid']['output']>;
  sentAt?: Maybe<Scalars['timestamptz']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['uuid']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "email_send_logs" */
export type EmailSendLogsMinOrderBy = {
  clickedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deliveredAt?: InputMaybe<OrderBy>;
  errorMessage?: InputMaybe<OrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openedAt?: InputMaybe<OrderBy>;
  recipientEmails?: InputMaybe<OrderBy>;
  resendEmailId?: InputMaybe<OrderBy>;
  scheduledFor?: InputMaybe<OrderBy>;
  sendStatus?: InputMaybe<OrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  sentAt?: InputMaybe<OrderBy>;
  subject?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "email_send_logs" */
export type EmailSendLogsMutationResponse = {
  __typename?: 'EmailSendLogsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<EmailSendLogs>;
};

/** on_conflict condition type for table "email_send_logs" */
export type EmailSendLogsOnConflict = {
  constraint: EmailSendLogsConstraint;
  updateColumns?: Array<EmailSendLogsUpdateColumn>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};

/** Ordering options when selecting data from "email_send_logs". */
export type EmailSendLogsOrderBy = {
  businessContext?: InputMaybe<OrderBy>;
  clickedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  deliveredAt?: InputMaybe<OrderBy>;
  emailTemplate?: InputMaybe<EmailTemplatesOrderBy>;
  errorMessage?: InputMaybe<OrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  openedAt?: InputMaybe<OrderBy>;
  recipientEmails?: InputMaybe<OrderBy>;
  resendEmailId?: InputMaybe<OrderBy>;
  resendResponse?: InputMaybe<OrderBy>;
  scheduledFor?: InputMaybe<OrderBy>;
  sendStatus?: InputMaybe<OrderBy>;
  senderUser?: InputMaybe<UsersOrderBy>;
  senderUserId?: InputMaybe<OrderBy>;
  sentAt?: InputMaybe<OrderBy>;
  subject?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: email_send_logs */
export type EmailSendLogsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type EmailSendLogsPrependInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  resendResponse?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "email_send_logs" */
export type EmailSendLogsSelectColumn =
  /** column name */
  | 'businessContext'
  /** column name */
  | 'clickedAt'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'deliveredAt'
  /** column name */
  | 'errorMessage'
  /** column name */
  | 'htmlContent'
  /** column name */
  | 'id'
  /** column name */
  | 'openedAt'
  /** column name */
  | 'recipientEmails'
  /** column name */
  | 'resendEmailId'
  /** column name */
  | 'resendResponse'
  /** column name */
  | 'scheduledFor'
  /** column name */
  | 'sendStatus'
  /** column name */
  | 'senderUserId'
  /** column name */
  | 'sentAt'
  /** column name */
  | 'subject'
  /** column name */
  | 'templateId'
  /** column name */
  | 'textContent'
  | '%future added value';

/** input type for updating data in table "email_send_logs" */
export type EmailSendLogsSetInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  clickedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deliveredAt?: InputMaybe<Scalars['timestamptz']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  openedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  recipientEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  resendEmailId?: InputMaybe<Scalars['String']['input']>;
  resendResponse?: InputMaybe<Scalars['jsonb']['input']>;
  scheduledFor?: InputMaybe<Scalars['timestamptz']['input']>;
  sendStatus?: InputMaybe<Scalars['String']['input']>;
  senderUserId?: InputMaybe<Scalars['uuid']['input']>;
  sentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "email_send_logs" */
export type EmailSendLogsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EmailSendLogsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EmailSendLogsStreamCursorValueInput = {
  businessContext?: InputMaybe<Scalars['jsonb']['input']>;
  clickedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deliveredAt?: InputMaybe<Scalars['timestamptz']['input']>;
  errorMessage?: InputMaybe<Scalars['String']['input']>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  openedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  recipientEmails?: InputMaybe<Array<Scalars['String']['input']>>;
  resendEmailId?: InputMaybe<Scalars['String']['input']>;
  resendResponse?: InputMaybe<Scalars['jsonb']['input']>;
  scheduledFor?: InputMaybe<Scalars['timestamptz']['input']>;
  sendStatus?: InputMaybe<Scalars['String']['input']>;
  senderUserId?: InputMaybe<Scalars['uuid']['input']>;
  sentAt?: InputMaybe<Scalars['timestamptz']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "email_send_logs" */
export type EmailSendLogsUpdateColumn =
  /** column name */
  | 'businessContext'
  /** column name */
  | 'clickedAt'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'deliveredAt'
  /** column name */
  | 'errorMessage'
  /** column name */
  | 'htmlContent'
  /** column name */
  | 'id'
  /** column name */
  | 'openedAt'
  /** column name */
  | 'recipientEmails'
  /** column name */
  | 'resendEmailId'
  /** column name */
  | 'resendResponse'
  /** column name */
  | 'scheduledFor'
  /** column name */
  | 'sendStatus'
  /** column name */
  | 'senderUserId'
  /** column name */
  | 'sentAt'
  /** column name */
  | 'subject'
  /** column name */
  | 'templateId'
  /** column name */
  | 'textContent'
  | '%future added value';

export type EmailSendLogsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<EmailSendLogsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<EmailSendLogsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<EmailSendLogsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<EmailSendLogsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<EmailSendLogsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EmailSendLogsSetInput>;
  /** filter the rows which have to be updated */
  where: EmailSendLogsBoolExp;
};

/** Email templates for various business communications */
export type EmailTemplates = {
  __typename?: 'EmailTemplates';
  approvedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  approvedByUser?: Maybe<Users>;
  approvedByUserId?: Maybe<Scalars['uuid']['output']>;
  availableVariables: Scalars['jsonb']['output'];
  category: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  createdByUser: Users;
  createdByUserId: Scalars['uuid']['output'];
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  emailDrafts: Array<EmailDrafts>;
  /** An aggregate relationship */
  emailDraftsAggregate: EmailDraftsAggregate;
  /** An array relationship */
  emailSendLogs: Array<EmailSendLogs>;
  /** An aggregate relationship */
  emailSendLogsAggregate: EmailSendLogsAggregate;
  htmlContent: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isSystemTemplate?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  requiresApproval?: Maybe<Scalars['Boolean']['output']>;
  subjectTemplate: Scalars['String']['output'];
  textContent?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  userFavorites: Array<UserEmailTemplateFavorites>;
  /** An aggregate relationship */
  userFavoritesAggregate: UserEmailTemplateFavoritesAggregate;
};


/** Email templates for various business communications */
export type EmailTemplatesAvailableVariablesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Email templates for various business communications */
export type EmailTemplatesEmailDraftsArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


/** Email templates for various business communications */
export type EmailTemplatesEmailDraftsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


/** Email templates for various business communications */
export type EmailTemplatesEmailSendLogsArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


/** Email templates for various business communications */
export type EmailTemplatesEmailSendLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


/** Email templates for various business communications */
export type EmailTemplatesUserFavoritesArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


/** Email templates for various business communications */
export type EmailTemplatesUserFavoritesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};

/** aggregated selection of "email_templates" */
export type EmailTemplatesAggregate = {
  __typename?: 'EmailTemplatesAggregate';
  aggregate?: Maybe<EmailTemplatesAggregateFields>;
  nodes: Array<EmailTemplates>;
};

export type EmailTemplatesAggregateBoolExp = {
  bool_and?: InputMaybe<EmailTemplatesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<EmailTemplatesAggregateBoolExpBool_Or>;
  count?: InputMaybe<EmailTemplatesAggregateBoolExpCount>;
};

/** aggregate fields of "email_templates" */
export type EmailTemplatesAggregateFields = {
  __typename?: 'EmailTemplatesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<EmailTemplatesMaxFields>;
  min?: Maybe<EmailTemplatesMinFields>;
};


/** aggregate fields of "email_templates" */
export type EmailTemplatesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "email_templates" */
export type EmailTemplatesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<EmailTemplatesMaxOrderBy>;
  min?: InputMaybe<EmailTemplatesMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type EmailTemplatesAppendInput = {
  availableVariables?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "email_templates" */
export type EmailTemplatesArrRelInsertInput = {
  data: Array<EmailTemplatesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<EmailTemplatesOnConflict>;
};

/** Boolean expression to filter rows from the table "email_templates". All fields are combined with a logical 'AND'. */
export type EmailTemplatesBoolExp = {
  _and?: InputMaybe<Array<EmailTemplatesBoolExp>>;
  _not?: InputMaybe<EmailTemplatesBoolExp>;
  _or?: InputMaybe<Array<EmailTemplatesBoolExp>>;
  approvedAt?: InputMaybe<TimestamptzComparisonExp>;
  approvedByUser?: InputMaybe<UsersBoolExp>;
  approvedByUserId?: InputMaybe<UuidComparisonExp>;
  availableVariables?: InputMaybe<JsonbComparisonExp>;
  category?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  createdByUserId?: InputMaybe<UuidComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  emailDrafts?: InputMaybe<EmailDraftsBoolExp>;
  emailDraftsAggregate?: InputMaybe<EmailDraftsAggregateBoolExp>;
  emailSendLogs?: InputMaybe<EmailSendLogsBoolExp>;
  emailSendLogsAggregate?: InputMaybe<EmailSendLogsAggregateBoolExp>;
  htmlContent?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isSystemTemplate?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  requiresApproval?: InputMaybe<BooleanComparisonExp>;
  subjectTemplate?: InputMaybe<StringComparisonExp>;
  textContent?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userFavorites?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
  userFavoritesAggregate?: InputMaybe<UserEmailTemplateFavoritesAggregateBoolExp>;
};

/** unique or primary key constraints on table "email_templates" */
export type EmailTemplatesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'email_templates_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type EmailTemplatesDeleteAtPathInput = {
  availableVariables?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type EmailTemplatesDeleteElemInput = {
  availableVariables?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type EmailTemplatesDeleteKeyInput = {
  availableVariables?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "email_templates" */
export type EmailTemplatesInsertInput = {
  approvedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  approvedByUser?: InputMaybe<UsersObjRelInsertInput>;
  approvedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  availableVariables?: InputMaybe<Scalars['jsonb']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  emailDrafts?: InputMaybe<EmailDraftsArrRelInsertInput>;
  emailSendLogs?: InputMaybe<EmailSendLogsArrRelInsertInput>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  subjectTemplate?: InputMaybe<Scalars['String']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userFavorites?: InputMaybe<UserEmailTemplateFavoritesArrRelInsertInput>;
};

/** aggregate max on columns */
export type EmailTemplatesMaxFields = {
  __typename?: 'EmailTemplatesMaxFields';
  approvedAt?: Maybe<Scalars['timestamptz']['output']>;
  approvedByUserId?: Maybe<Scalars['uuid']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  subjectTemplate?: Maybe<Scalars['String']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "email_templates" */
export type EmailTemplatesMaxOrderBy = {
  approvedAt?: InputMaybe<OrderBy>;
  approvedByUserId?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdByUserId?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  subjectTemplate?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type EmailTemplatesMinFields = {
  __typename?: 'EmailTemplatesMinFields';
  approvedAt?: Maybe<Scalars['timestamptz']['output']>;
  approvedByUserId?: Maybe<Scalars['uuid']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  htmlContent?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  subjectTemplate?: Maybe<Scalars['String']['output']>;
  textContent?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "email_templates" */
export type EmailTemplatesMinOrderBy = {
  approvedAt?: InputMaybe<OrderBy>;
  approvedByUserId?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdByUserId?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  subjectTemplate?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "email_templates" */
export type EmailTemplatesMutationResponse = {
  __typename?: 'EmailTemplatesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<EmailTemplates>;
};

/** input type for inserting object relation for remote table "email_templates" */
export type EmailTemplatesObjRelInsertInput = {
  data: EmailTemplatesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<EmailTemplatesOnConflict>;
};

/** on_conflict condition type for table "email_templates" */
export type EmailTemplatesOnConflict = {
  constraint: EmailTemplatesConstraint;
  updateColumns?: Array<EmailTemplatesUpdateColumn>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};

/** Ordering options when selecting data from "email_templates". */
export type EmailTemplatesOrderBy = {
  approvedAt?: InputMaybe<OrderBy>;
  approvedByUser?: InputMaybe<UsersOrderBy>;
  approvedByUserId?: InputMaybe<OrderBy>;
  availableVariables?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  createdByUserId?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  emailDraftsAggregate?: InputMaybe<EmailDraftsAggregateOrderBy>;
  emailSendLogsAggregate?: InputMaybe<EmailSendLogsAggregateOrderBy>;
  htmlContent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isSystemTemplate?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  requiresApproval?: InputMaybe<OrderBy>;
  subjectTemplate?: InputMaybe<OrderBy>;
  textContent?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userFavoritesAggregate?: InputMaybe<UserEmailTemplateFavoritesAggregateOrderBy>;
};

/** primary key columns input for table: email_templates */
export type EmailTemplatesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type EmailTemplatesPrependInput = {
  availableVariables?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "email_templates" */
export type EmailTemplatesSelectColumn =
  /** column name */
  | 'approvedAt'
  /** column name */
  | 'approvedByUserId'
  /** column name */
  | 'availableVariables'
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdByUserId'
  /** column name */
  | 'description'
  /** column name */
  | 'htmlContent'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isSystemTemplate'
  /** column name */
  | 'name'
  /** column name */
  | 'requiresApproval'
  /** column name */
  | 'subjectTemplate'
  /** column name */
  | 'textContent'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "emailTemplatesAggregateBoolExpBool_andArgumentsColumns" columns of table "email_templates" */
export type EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isSystemTemplate'
  /** column name */
  | 'requiresApproval'
  | '%future added value';

/** select "emailTemplatesAggregateBoolExpBool_orArgumentsColumns" columns of table "email_templates" */
export type EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isSystemTemplate'
  /** column name */
  | 'requiresApproval'
  | '%future added value';

/** input type for updating data in table "email_templates" */
export type EmailTemplatesSetInput = {
  approvedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  approvedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  availableVariables?: InputMaybe<Scalars['jsonb']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  subjectTemplate?: InputMaybe<Scalars['String']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "email_templates" */
export type EmailTemplatesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: EmailTemplatesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type EmailTemplatesStreamCursorValueInput = {
  approvedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  approvedByUserId?: InputMaybe<Scalars['uuid']['input']>;
  availableVariables?: InputMaybe<Scalars['jsonb']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  subjectTemplate?: InputMaybe<Scalars['String']['input']>;
  textContent?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "email_templates" */
export type EmailTemplatesUpdateColumn =
  /** column name */
  | 'approvedAt'
  /** column name */
  | 'approvedByUserId'
  /** column name */
  | 'availableVariables'
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdByUserId'
  /** column name */
  | 'description'
  /** column name */
  | 'htmlContent'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isSystemTemplate'
  /** column name */
  | 'name'
  /** column name */
  | 'requiresApproval'
  /** column name */
  | 'subjectTemplate'
  /** column name */
  | 'textContent'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type EmailTemplatesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<EmailTemplatesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<EmailTemplatesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<EmailTemplatesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<EmailTemplatesDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<EmailTemplatesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EmailTemplatesSetInput>;
  /** filter the rows which have to be updated */
  where: EmailTemplatesBoolExp;
};

/** columns and relationships of "external_systems" */
export type ExternalSystems = {
  __typename?: 'ExternalSystems';
  /** An array relationship */
  clientExternalSystems: Array<ClientExternalSystems>;
  /** An aggregate relationship */
  clientExternalSystemsAggregate: ClientExternalSystemsAggregate;
  /** Timestamp when the system was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of the external system and its purpose */
  description?: Maybe<Scalars['String']['output']>;
  /** Path or reference to the system icon */
  icon?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the external system */
  id: Scalars['uuid']['output'];
  /** Name of the external system */
  name: Scalars['String']['output'];
  /** Timestamp when the system was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** URL endpoint for the external system */
  url: Scalars['String']['output'];
};


/** columns and relationships of "external_systems" */
export type ExternalSystemsClientExternalSystemsArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


/** columns and relationships of "external_systems" */
export type ExternalSystemsClientExternalSystemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};

/** aggregated selection of "external_systems" */
export type ExternalSystemsAggregate = {
  __typename?: 'ExternalSystemsAggregate';
  aggregate?: Maybe<ExternalSystemsAggregateFields>;
  nodes: Array<ExternalSystems>;
};

/** aggregate fields of "external_systems" */
export type ExternalSystemsAggregateFields = {
  __typename?: 'ExternalSystemsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<ExternalSystemsMaxFields>;
  min?: Maybe<ExternalSystemsMinFields>;
};


/** aggregate fields of "external_systems" */
export type ExternalSystemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ExternalSystemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "external_systems". All fields are combined with a logical 'AND'. */
export type ExternalSystemsBoolExp = {
  _and?: InputMaybe<Array<ExternalSystemsBoolExp>>;
  _not?: InputMaybe<ExternalSystemsBoolExp>;
  _or?: InputMaybe<Array<ExternalSystemsBoolExp>>;
  clientExternalSystems?: InputMaybe<ClientExternalSystemsBoolExp>;
  clientExternalSystemsAggregate?: InputMaybe<ClientExternalSystemsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  icon?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  url?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "external_systems" */
export type ExternalSystemsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'external_systems_pkey'
  | '%future added value';

/** input type for inserting data into table "external_systems" */
export type ExternalSystemsInsertInput = {
  clientExternalSystems?: InputMaybe<ClientExternalSystemsArrRelInsertInput>;
  /** Timestamp when the system was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of the external system and its purpose */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Path or reference to the system icon */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the external system */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the external system */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the system was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** URL endpoint for the external system */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type ExternalSystemsMaxFields = {
  __typename?: 'ExternalSystemsMaxFields';
  /** Timestamp when the system was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of the external system and its purpose */
  description?: Maybe<Scalars['String']['output']>;
  /** Path or reference to the system icon */
  icon?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the external system */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Name of the external system */
  name?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the system was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** URL endpoint for the external system */
  url?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type ExternalSystemsMinFields = {
  __typename?: 'ExternalSystemsMinFields';
  /** Timestamp when the system was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of the external system and its purpose */
  description?: Maybe<Scalars['String']['output']>;
  /** Path or reference to the system icon */
  icon?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the external system */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Name of the external system */
  name?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the system was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** URL endpoint for the external system */
  url?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "external_systems" */
export type ExternalSystemsMutationResponse = {
  __typename?: 'ExternalSystemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ExternalSystems>;
};

/** input type for inserting object relation for remote table "external_systems" */
export type ExternalSystemsObjRelInsertInput = {
  data: ExternalSystemsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<ExternalSystemsOnConflict>;
};

/** on_conflict condition type for table "external_systems" */
export type ExternalSystemsOnConflict = {
  constraint: ExternalSystemsConstraint;
  updateColumns?: Array<ExternalSystemsUpdateColumn>;
  where?: InputMaybe<ExternalSystemsBoolExp>;
};

/** Ordering options when selecting data from "external_systems". */
export type ExternalSystemsOrderBy = {
  clientExternalSystemsAggregate?: InputMaybe<ClientExternalSystemsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  icon?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: external_systems */
export type ExternalSystemsPkColumnsInput = {
  /** Unique identifier for the external system */
  id: Scalars['uuid']['input'];
};

/** select columns of table "external_systems" */
export type ExternalSystemsSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'icon'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'url'
  | '%future added value';

/** input type for updating data in table "external_systems" */
export type ExternalSystemsSetInput = {
  /** Timestamp when the system was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of the external system and its purpose */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Path or reference to the system icon */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the external system */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the external system */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the system was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** URL endpoint for the external system */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "external_systems" */
export type ExternalSystemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ExternalSystemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ExternalSystemsStreamCursorValueInput = {
  /** Timestamp when the system was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of the external system and its purpose */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Path or reference to the system icon */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the external system */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the external system */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the system was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** URL endpoint for the external system */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "external_systems" */
export type ExternalSystemsUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'icon'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'url'
  | '%future added value';

export type ExternalSystemsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ExternalSystemsSetInput>;
  /** filter the rows which have to be updated */
  where: ExternalSystemsBoolExp;
};

/** columns and relationships of "feature_flags" */
export type FeatureFlags = {
  __typename?: 'FeatureFlags';
  /** JSON array of roles that can access this feature */
  allowedRoles: Scalars['jsonb']['output'];
  /** Name of the feature controlled by this flag */
  featureName: Scalars['String']['output'];
  /** Unique identifier for the feature flag */
  id: Scalars['uuid']['output'];
  /** Whether the feature is currently enabled */
  isEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the feature flag was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "feature_flags" */
export type FeatureFlagsAllowedRolesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "feature_flags" */
export type FeatureFlagsAggregate = {
  __typename?: 'FeatureFlagsAggregate';
  aggregate?: Maybe<FeatureFlagsAggregateFields>;
  nodes: Array<FeatureFlags>;
};

/** aggregate fields of "feature_flags" */
export type FeatureFlagsAggregateFields = {
  __typename?: 'FeatureFlagsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<FeatureFlagsMaxFields>;
  min?: Maybe<FeatureFlagsMinFields>;
};


/** aggregate fields of "feature_flags" */
export type FeatureFlagsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FeatureFlagsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type FeatureFlagsAppendInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'. */
export type FeatureFlagsBoolExp = {
  _and?: InputMaybe<Array<FeatureFlagsBoolExp>>;
  _not?: InputMaybe<FeatureFlagsBoolExp>;
  _or?: InputMaybe<Array<FeatureFlagsBoolExp>>;
  allowedRoles?: InputMaybe<JsonbComparisonExp>;
  featureName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isEnabled?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "feature_flags" */
export type FeatureFlagsConstraint =
  /** unique or primary key constraint on columns "feature_name" */
  | 'feature_flags_feature_name_key'
  /** unique or primary key constraint on columns "id" */
  | 'feature_flags_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type FeatureFlagsDeleteAtPathInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type FeatureFlagsDeleteElemInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type FeatureFlagsDeleteKeyInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "feature_flags" */
export type FeatureFlagsInsertInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Scalars['jsonb']['input']>;
  /** Name of the feature controlled by this flag */
  featureName?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the feature flag */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the feature is currently enabled */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp when the feature flag was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type FeatureFlagsMaxFields = {
  __typename?: 'FeatureFlagsMaxFields';
  /** Name of the feature controlled by this flag */
  featureName?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the feature flag */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the feature flag was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type FeatureFlagsMinFields = {
  __typename?: 'FeatureFlagsMinFields';
  /** Name of the feature controlled by this flag */
  featureName?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the feature flag */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the feature flag was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "feature_flags" */
export type FeatureFlagsMutationResponse = {
  __typename?: 'FeatureFlagsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<FeatureFlags>;
};

/** on_conflict condition type for table "feature_flags" */
export type FeatureFlagsOnConflict = {
  constraint: FeatureFlagsConstraint;
  updateColumns?: Array<FeatureFlagsUpdateColumn>;
  where?: InputMaybe<FeatureFlagsBoolExp>;
};

/** Ordering options when selecting data from "feature_flags". */
export type FeatureFlagsOrderBy = {
  allowedRoles?: InputMaybe<OrderBy>;
  featureName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isEnabled?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: feature_flags */
export type FeatureFlagsPkColumnsInput = {
  /** Unique identifier for the feature flag */
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type FeatureFlagsPrependInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "feature_flags" */
export type FeatureFlagsSelectColumn =
  /** column name */
  | 'allowedRoles'
  /** column name */
  | 'featureName'
  /** column name */
  | 'id'
  /** column name */
  | 'isEnabled'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "feature_flags" */
export type FeatureFlagsSetInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Scalars['jsonb']['input']>;
  /** Name of the feature controlled by this flag */
  featureName?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the feature flag */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the feature is currently enabled */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp when the feature flag was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "feature_flags" */
export type FeatureFlagsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: FeatureFlagsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FeatureFlagsStreamCursorValueInput = {
  /** JSON array of roles that can access this feature */
  allowedRoles?: InputMaybe<Scalars['jsonb']['input']>;
  /** Name of the feature controlled by this flag */
  featureName?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the feature flag */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the feature is currently enabled */
  isEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp when the feature flag was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "feature_flags" */
export type FeatureFlagsUpdateColumn =
  /** column name */
  | 'allowedRoles'
  /** column name */
  | 'featureName'
  /** column name */
  | 'id'
  /** column name */
  | 'isEnabled'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type FeatureFlagsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<FeatureFlagsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<FeatureFlagsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<FeatureFlagsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<FeatureFlagsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<FeatureFlagsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FeatureFlagsSetInput>;
  /** filter the rows which have to be updated */
  where: FeatureFlagsBoolExp;
};

/** columns and relationships of "files" */
export type Files = {
  __typename?: 'Files';
  bucket: Scalars['String']['output'];
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  client?: Maybe<Clients>;
  /** Links document to a specific client */
  clientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: Maybe<Scalars['String']['output']>;
  filename: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  /** Whether document is publicly accessible within permissions */
  isPublic?: Maybe<Scalars['Boolean']['output']>;
  /** Additional document metadata as JSON */
  metadata?: Maybe<Scalars['jsonb']['output']>;
  mimetype?: Maybe<Scalars['String']['output']>;
  objectKey: Scalars['String']['output'];
  /** An object relationship */
  payroll?: Maybe<Payrolls>;
  /** Links document to a specific payroll */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  /** User who uploaded the document */
  uploadedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  uploadedByUser?: Maybe<Users>;
  url?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "files" */
export type FilesMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "files" */
export type FilesAggregate = {
  __typename?: 'FilesAggregate';
  aggregate?: Maybe<FilesAggregateFields>;
  nodes: Array<Files>;
};

export type FilesAggregateBoolExp = {
  bool_and?: InputMaybe<FilesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<FilesAggregateBoolExpBool_Or>;
  count?: InputMaybe<FilesAggregateBoolExpCount>;
};

/** aggregate fields of "files" */
export type FilesAggregateFields = {
  __typename?: 'FilesAggregateFields';
  avg?: Maybe<FilesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<FilesMaxFields>;
  min?: Maybe<FilesMinFields>;
  stddev?: Maybe<FilesStddevFields>;
  stddevPop?: Maybe<FilesStddevPopFields>;
  stddevSamp?: Maybe<FilesStddevSampFields>;
  sum?: Maybe<FilesSumFields>;
  varPop?: Maybe<FilesVarPopFields>;
  varSamp?: Maybe<FilesVarSampFields>;
  variance?: Maybe<FilesVarianceFields>;
};


/** aggregate fields of "files" */
export type FilesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<FilesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "files" */
export type FilesAggregateOrderBy = {
  avg?: InputMaybe<FilesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<FilesMaxOrderBy>;
  min?: InputMaybe<FilesMinOrderBy>;
  stddev?: InputMaybe<FilesStddevOrderBy>;
  stddevPop?: InputMaybe<FilesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<FilesStddevSampOrderBy>;
  sum?: InputMaybe<FilesSumOrderBy>;
  varPop?: InputMaybe<FilesVarPopOrderBy>;
  varSamp?: InputMaybe<FilesVarSampOrderBy>;
  variance?: InputMaybe<FilesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type FilesAppendInput = {
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "files" */
export type FilesArrRelInsertInput = {
  data: Array<FilesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<FilesOnConflict>;
};

/** aggregate avg on columns */
export type FilesAvgFields = {
  __typename?: 'FilesAvgFields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "files" */
export type FilesAvgOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "files". All fields are combined with a logical 'AND'. */
export type FilesBoolExp = {
  _and?: InputMaybe<Array<FilesBoolExp>>;
  _not?: InputMaybe<FilesBoolExp>;
  _or?: InputMaybe<Array<FilesBoolExp>>;
  bucket?: InputMaybe<StringComparisonExp>;
  category?: InputMaybe<StringComparisonExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  fileType?: InputMaybe<StringComparisonExp>;
  filename?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isPublic?: InputMaybe<BooleanComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  mimetype?: InputMaybe<StringComparisonExp>;
  objectKey?: InputMaybe<StringComparisonExp>;
  payroll?: InputMaybe<PayrollsBoolExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  size?: InputMaybe<IntComparisonExp>;
  uploadedBy?: InputMaybe<UuidComparisonExp>;
  uploadedByUser?: InputMaybe<UsersBoolExp>;
  url?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "files" */
export type FilesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'files_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type FilesDeleteAtPathInput = {
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type FilesDeleteElemInput = {
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type FilesDeleteKeyInput = {
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "files" */
export type FilesIncInput = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "files" */
export type FilesInsertInput = {
  bucket?: InputMaybe<Scalars['String']['input']>;
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: InputMaybe<Scalars['String']['input']>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  /** Links document to a specific client */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: InputMaybe<Scalars['String']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether document is publicly accessible within permissions */
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  objectKey?: InputMaybe<Scalars['String']['input']>;
  payroll?: InputMaybe<PayrollsObjRelInsertInput>;
  /** Links document to a specific payroll */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  /** User who uploaded the document */
  uploadedBy?: InputMaybe<Scalars['uuid']['input']>;
  uploadedByUser?: InputMaybe<UsersObjRelInsertInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type FilesMaxFields = {
  __typename?: 'FilesMaxFields';
  bucket?: Maybe<Scalars['String']['output']>;
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: Maybe<Scalars['String']['output']>;
  /** Links document to a specific client */
  clientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: Maybe<Scalars['String']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  mimetype?: Maybe<Scalars['String']['output']>;
  objectKey?: Maybe<Scalars['String']['output']>;
  /** Links document to a specific payroll */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  /** User who uploaded the document */
  uploadedBy?: Maybe<Scalars['uuid']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "files" */
export type FilesMaxOrderBy = {
  bucket?: InputMaybe<OrderBy>;
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: InputMaybe<OrderBy>;
  /** Links document to a specific client */
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: InputMaybe<OrderBy>;
  filename?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mimetype?: InputMaybe<OrderBy>;
  objectKey?: InputMaybe<OrderBy>;
  /** Links document to a specific payroll */
  payrollId?: InputMaybe<OrderBy>;
  size?: InputMaybe<OrderBy>;
  /** User who uploaded the document */
  uploadedBy?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type FilesMinFields = {
  __typename?: 'FilesMinFields';
  bucket?: Maybe<Scalars['String']['output']>;
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: Maybe<Scalars['String']['output']>;
  /** Links document to a specific client */
  clientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: Maybe<Scalars['String']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  mimetype?: Maybe<Scalars['String']['output']>;
  objectKey?: Maybe<Scalars['String']['output']>;
  /** Links document to a specific payroll */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  /** User who uploaded the document */
  uploadedBy?: Maybe<Scalars['uuid']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "files" */
export type FilesMinOrderBy = {
  bucket?: InputMaybe<OrderBy>;
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: InputMaybe<OrderBy>;
  /** Links document to a specific client */
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: InputMaybe<OrderBy>;
  filename?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  mimetype?: InputMaybe<OrderBy>;
  objectKey?: InputMaybe<OrderBy>;
  /** Links document to a specific payroll */
  payrollId?: InputMaybe<OrderBy>;
  size?: InputMaybe<OrderBy>;
  /** User who uploaded the document */
  uploadedBy?: InputMaybe<OrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "files" */
export type FilesMutationResponse = {
  __typename?: 'FilesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Files>;
};

/** on_conflict condition type for table "files" */
export type FilesOnConflict = {
  constraint: FilesConstraint;
  updateColumns?: Array<FilesUpdateColumn>;
  where?: InputMaybe<FilesBoolExp>;
};

/** Ordering options when selecting data from "files". */
export type FilesOrderBy = {
  bucket?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  fileType?: InputMaybe<OrderBy>;
  filename?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isPublic?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  mimetype?: InputMaybe<OrderBy>;
  objectKey?: InputMaybe<OrderBy>;
  payroll?: InputMaybe<PayrollsOrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  size?: InputMaybe<OrderBy>;
  uploadedBy?: InputMaybe<OrderBy>;
  uploadedByUser?: InputMaybe<UsersOrderBy>;
  url?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: files */
export type FilesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type FilesPrependInput = {
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "files" */
export type FilesSelectColumn =
  /** column name */
  | 'bucket'
  /** column name */
  | 'category'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'fileType'
  /** column name */
  | 'filename'
  /** column name */
  | 'id'
  /** column name */
  | 'isPublic'
  /** column name */
  | 'metadata'
  /** column name */
  | 'mimetype'
  /** column name */
  | 'objectKey'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'size'
  /** column name */
  | 'uploadedBy'
  /** column name */
  | 'url'
  | '%future added value';

/** select "filesAggregateBoolExpBool_andArgumentsColumns" columns of table "files" */
export type FilesSelectColumnFilesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isPublic'
  | '%future added value';

/** select "filesAggregateBoolExpBool_orArgumentsColumns" columns of table "files" */
export type FilesSelectColumnFilesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isPublic'
  | '%future added value';

/** input type for updating data in table "files" */
export type FilesSetInput = {
  bucket?: InputMaybe<Scalars['String']['input']>;
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Links document to a specific client */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: InputMaybe<Scalars['String']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether document is publicly accessible within permissions */
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  objectKey?: InputMaybe<Scalars['String']['input']>;
  /** Links document to a specific payroll */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  /** User who uploaded the document */
  uploadedBy?: InputMaybe<Scalars['uuid']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type FilesStddevFields = {
  __typename?: 'FilesStddevFields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "files" */
export type FilesStddevOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type FilesStddevPopFields = {
  __typename?: 'FilesStddevPopFields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "files" */
export type FilesStddevPopOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type FilesStddevSampFields = {
  __typename?: 'FilesStddevSampFields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "files" */
export type FilesStddevSampOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "files" */
export type FilesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: FilesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type FilesStreamCursorValueInput = {
  bucket?: InputMaybe<Scalars['String']['input']>;
  /** Document category: contract, invoice, report, timesheet, correspondence, other */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Links document to a specific client */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Type of file: document (MinIO) or avatar (Clerk) */
  fileType?: InputMaybe<Scalars['String']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether document is publicly accessible within permissions */
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  /** Additional document metadata as JSON */
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  objectKey?: InputMaybe<Scalars['String']['input']>;
  /** Links document to a specific payroll */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  /** User who uploaded the document */
  uploadedBy?: InputMaybe<Scalars['uuid']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type FilesSumFields = {
  __typename?: 'FilesSumFields';
  size?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "files" */
export type FilesSumOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** update columns of table "files" */
export type FilesUpdateColumn =
  /** column name */
  | 'bucket'
  /** column name */
  | 'category'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'fileType'
  /** column name */
  | 'filename'
  /** column name */
  | 'id'
  /** column name */
  | 'isPublic'
  /** column name */
  | 'metadata'
  /** column name */
  | 'mimetype'
  /** column name */
  | 'objectKey'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'size'
  /** column name */
  | 'uploadedBy'
  /** column name */
  | 'url'
  | '%future added value';

export type FilesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<FilesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<FilesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<FilesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<FilesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<FilesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<FilesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FilesSetInput>;
  /** filter the rows which have to be updated */
  where: FilesBoolExp;
};

/** aggregate varPop on columns */
export type FilesVarPopFields = {
  __typename?: 'FilesVarPopFields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "files" */
export type FilesVarPopOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type FilesVarSampFields = {
  __typename?: 'FilesVarSampFields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "files" */
export type FilesVarSampOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type FilesVarianceFields = {
  __typename?: 'FilesVarianceFields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "files" */
export type FilesVarianceOrderBy = {
  size?: InputMaybe<OrderBy>;
};

/** columns and relationships of "holidays" */
export type Holidays = {
  __typename?: 'Holidays';
  /** ISO country code where the holiday is observed */
  countryCode: Scalars['bpchar']['output'];
  /** Timestamp when the holiday record was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Date of the holiday */
  date: Scalars['date']['output'];
  /** Unique identifier for the holiday */
  id: Scalars['uuid']['output'];
  /** Whether the holiday occurs on the same date each year */
  isFixed?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the holiday is observed globally */
  isGlobal?: Maybe<Scalars['Boolean']['output']>;
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Int']['output']>;
  /** Name of the holiday in local language */
  localName: Scalars['String']['output'];
  /** Name of the holiday in English */
  name: Scalars['String']['output'];
  /** Array of regions within the country where the holiday applies */
  region?: Maybe<Array<Scalars['String']['output']>>;
  /** Array of holiday types (e.g., public, bank, religious) */
  types: Array<Scalars['String']['output']>;
  /** Timestamp when the holiday record was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "holidays" */
export type HolidaysAggregate = {
  __typename?: 'HolidaysAggregate';
  aggregate?: Maybe<HolidaysAggregateFields>;
  nodes: Array<Holidays>;
};

/** aggregate fields of "holidays" */
export type HolidaysAggregateFields = {
  __typename?: 'HolidaysAggregateFields';
  avg?: Maybe<HolidaysAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<HolidaysMaxFields>;
  min?: Maybe<HolidaysMinFields>;
  stddev?: Maybe<HolidaysStddevFields>;
  stddevPop?: Maybe<HolidaysStddevPopFields>;
  stddevSamp?: Maybe<HolidaysStddevSampFields>;
  sum?: Maybe<HolidaysSumFields>;
  varPop?: Maybe<HolidaysVarPopFields>;
  varSamp?: Maybe<HolidaysVarSampFields>;
  variance?: Maybe<HolidaysVarianceFields>;
};


/** aggregate fields of "holidays" */
export type HolidaysAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<HolidaysSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type HolidaysAvgFields = {
  __typename?: 'HolidaysAvgFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "holidays". All fields are combined with a logical 'AND'. */
export type HolidaysBoolExp = {
  _and?: InputMaybe<Array<HolidaysBoolExp>>;
  _not?: InputMaybe<HolidaysBoolExp>;
  _or?: InputMaybe<Array<HolidaysBoolExp>>;
  countryCode?: InputMaybe<BpcharComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  date?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isFixed?: InputMaybe<BooleanComparisonExp>;
  isGlobal?: InputMaybe<BooleanComparisonExp>;
  launchYear?: InputMaybe<IntComparisonExp>;
  localName?: InputMaybe<StringComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  region?: InputMaybe<StringArrayComparisonExp>;
  types?: InputMaybe<StringArrayComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "holidays" */
export type HolidaysConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'holidays_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "holidays" */
export type HolidaysIncInput = {
  /** First year when the holiday was observed */
  launchYear?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "holidays" */
export type HolidaysInsertInput = {
  /** ISO country code where the holiday is observed */
  countryCode?: InputMaybe<Scalars['bpchar']['input']>;
  /** Timestamp when the holiday record was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date of the holiday */
  date?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the holiday */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the holiday occurs on the same date each year */
  isFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the holiday is observed globally */
  isGlobal?: InputMaybe<Scalars['Boolean']['input']>;
  /** First year when the holiday was observed */
  launchYear?: InputMaybe<Scalars['Int']['input']>;
  /** Name of the holiday in local language */
  localName?: InputMaybe<Scalars['String']['input']>;
  /** Name of the holiday in English */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Array of regions within the country where the holiday applies */
  region?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Array of holiday types (e.g., public, bank, religious) */
  types?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Timestamp when the holiday record was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type HolidaysMaxFields = {
  __typename?: 'HolidaysMaxFields';
  /** ISO country code where the holiday is observed */
  countryCode?: Maybe<Scalars['bpchar']['output']>;
  /** Timestamp when the holiday record was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Date of the holiday */
  date?: Maybe<Scalars['date']['output']>;
  /** Unique identifier for the holiday */
  id?: Maybe<Scalars['uuid']['output']>;
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Int']['output']>;
  /** Name of the holiday in local language */
  localName?: Maybe<Scalars['String']['output']>;
  /** Name of the holiday in English */
  name?: Maybe<Scalars['String']['output']>;
  /** Array of regions within the country where the holiday applies */
  region?: Maybe<Array<Scalars['String']['output']>>;
  /** Array of holiday types (e.g., public, bank, religious) */
  types?: Maybe<Array<Scalars['String']['output']>>;
  /** Timestamp when the holiday record was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type HolidaysMinFields = {
  __typename?: 'HolidaysMinFields';
  /** ISO country code where the holiday is observed */
  countryCode?: Maybe<Scalars['bpchar']['output']>;
  /** Timestamp when the holiday record was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Date of the holiday */
  date?: Maybe<Scalars['date']['output']>;
  /** Unique identifier for the holiday */
  id?: Maybe<Scalars['uuid']['output']>;
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Int']['output']>;
  /** Name of the holiday in local language */
  localName?: Maybe<Scalars['String']['output']>;
  /** Name of the holiday in English */
  name?: Maybe<Scalars['String']['output']>;
  /** Array of regions within the country where the holiday applies */
  region?: Maybe<Array<Scalars['String']['output']>>;
  /** Array of holiday types (e.g., public, bank, religious) */
  types?: Maybe<Array<Scalars['String']['output']>>;
  /** Timestamp when the holiday record was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "holidays" */
export type HolidaysMutationResponse = {
  __typename?: 'HolidaysMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Holidays>;
};

/** on_conflict condition type for table "holidays" */
export type HolidaysOnConflict = {
  constraint: HolidaysConstraint;
  updateColumns?: Array<HolidaysUpdateColumn>;
  where?: InputMaybe<HolidaysBoolExp>;
};

/** Ordering options when selecting data from "holidays". */
export type HolidaysOrderBy = {
  countryCode?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  date?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isFixed?: InputMaybe<OrderBy>;
  isGlobal?: InputMaybe<OrderBy>;
  launchYear?: InputMaybe<OrderBy>;
  localName?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  region?: InputMaybe<OrderBy>;
  types?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: holidays */
export type HolidaysPkColumnsInput = {
  /** Unique identifier for the holiday */
  id: Scalars['uuid']['input'];
};

/** select columns of table "holidays" */
export type HolidaysSelectColumn =
  /** column name */
  | 'countryCode'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'date'
  /** column name */
  | 'id'
  /** column name */
  | 'isFixed'
  /** column name */
  | 'isGlobal'
  /** column name */
  | 'launchYear'
  /** column name */
  | 'localName'
  /** column name */
  | 'name'
  /** column name */
  | 'region'
  /** column name */
  | 'types'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "holidays" */
export type HolidaysSetInput = {
  /** ISO country code where the holiday is observed */
  countryCode?: InputMaybe<Scalars['bpchar']['input']>;
  /** Timestamp when the holiday record was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date of the holiday */
  date?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the holiday */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the holiday occurs on the same date each year */
  isFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the holiday is observed globally */
  isGlobal?: InputMaybe<Scalars['Boolean']['input']>;
  /** First year when the holiday was observed */
  launchYear?: InputMaybe<Scalars['Int']['input']>;
  /** Name of the holiday in local language */
  localName?: InputMaybe<Scalars['String']['input']>;
  /** Name of the holiday in English */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Array of regions within the country where the holiday applies */
  region?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Array of holiday types (e.g., public, bank, religious) */
  types?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Timestamp when the holiday record was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type HolidaysStddevFields = {
  __typename?: 'HolidaysStddevFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type HolidaysStddevPopFields = {
  __typename?: 'HolidaysStddevPopFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type HolidaysStddevSampFields = {
  __typename?: 'HolidaysStddevSampFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "holidays" */
export type HolidaysStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: HolidaysStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type HolidaysStreamCursorValueInput = {
  /** ISO country code where the holiday is observed */
  countryCode?: InputMaybe<Scalars['bpchar']['input']>;
  /** Timestamp when the holiday record was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date of the holiday */
  date?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the holiday */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the holiday occurs on the same date each year */
  isFixed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the holiday is observed globally */
  isGlobal?: InputMaybe<Scalars['Boolean']['input']>;
  /** First year when the holiday was observed */
  launchYear?: InputMaybe<Scalars['Int']['input']>;
  /** Name of the holiday in local language */
  localName?: InputMaybe<Scalars['String']['input']>;
  /** Name of the holiday in English */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Array of regions within the country where the holiday applies */
  region?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Array of holiday types (e.g., public, bank, religious) */
  types?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Timestamp when the holiday record was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type HolidaysSumFields = {
  __typename?: 'HolidaysSumFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "holidays" */
export type HolidaysUpdateColumn =
  /** column name */
  | 'countryCode'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'date'
  /** column name */
  | 'id'
  /** column name */
  | 'isFixed'
  /** column name */
  | 'isGlobal'
  /** column name */
  | 'launchYear'
  /** column name */
  | 'localName'
  /** column name */
  | 'name'
  /** column name */
  | 'region'
  /** column name */
  | 'types'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type HolidaysUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<HolidaysIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<HolidaysSetInput>;
  /** filter the rows which have to be updated */
  where: HolidaysBoolExp;
};

/** aggregate varPop on columns */
export type HolidaysVarPopFields = {
  __typename?: 'HolidaysVarPopFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type HolidaysVarSampFields = {
  __typename?: 'HolidaysVarSampFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type HolidaysVarianceFields = {
  __typename?: 'HolidaysVarianceFields';
  /** First year when the holiday was observed */
  launchYear?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'. */
export type InetComparisonExp = {
  _eq?: InputMaybe<Scalars['inet']['input']>;
  _gt?: InputMaybe<Scalars['inet']['input']>;
  _gte?: InputMaybe<Scalars['inet']['input']>;
  _in?: InputMaybe<Array<Scalars['inet']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['inet']['input']>;
  _lte?: InputMaybe<Scalars['inet']['input']>;
  _neq?: InputMaybe<Scalars['inet']['input']>;
  _nin?: InputMaybe<Array<Scalars['inet']['input']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type IntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'. */
export type IntervalComparisonExp = {
  _eq?: InputMaybe<Scalars['interval']['input']>;
  _gt?: InputMaybe<Scalars['interval']['input']>;
  _gte?: InputMaybe<Scalars['interval']['input']>;
  _in?: InputMaybe<Array<Scalars['interval']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['interval']['input']>;
  _lte?: InputMaybe<Scalars['interval']['input']>;
  _neq?: InputMaybe<Scalars['interval']['input']>;
  _nin?: InputMaybe<Array<Scalars['interval']['input']>>;
};

/** Boolean expression to compare columns of type "invitation_status_enum". All fields are combined with logical 'AND'. */
export type InvitationStatusEnumComparisonExp = {
  _eq?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  _gt?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  _gte?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['invitation_status_enum']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  _lte?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  _neq?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['invitation_status_enum']['input']>>;
};

/** Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'. */
export type JsonComparisonExp = {
  _eq?: InputMaybe<Scalars['json']['input']>;
  _gt?: InputMaybe<Scalars['json']['input']>;
  _gte?: InputMaybe<Scalars['json']['input']>;
  _in?: InputMaybe<Array<Scalars['json']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['json']['input']>;
  _lte?: InputMaybe<Scalars['json']['input']>;
  _neq?: InputMaybe<Scalars['json']['input']>;
  _nin?: InputMaybe<Array<Scalars['json']['input']>>;
};

export type JsonbCastExp = {
  String?: InputMaybe<StringComparisonExp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type JsonbComparisonExp = {
  _cast?: InputMaybe<JsonbCastExp>;
  /** is the column contained in the given json value */
  _containedIn?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']['input']>;
  _eq?: InputMaybe<Scalars['jsonb']['input']>;
  _gt?: InputMaybe<Scalars['jsonb']['input']>;
  _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  _hasKey?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  _hasKeysAll?: InputMaybe<Array<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  _hasKeysAny?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['jsonb']['input']>;
  _lte?: InputMaybe<Scalars['jsonb']['input']>;
  _neq?: InputMaybe<Scalars['jsonb']['input']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;
};

/** columns and relationships of "latest_payroll_version_results" */
export type LatestPayrollVersionResults = {
  __typename?: 'LatestPayrollVersionResults';
  active: Scalars['Boolean']['output'];
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  payrollId: Scalars['uuid']['output'];
  queriedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber: Scalars['Int']['output'];
};

export type LatestPayrollVersionResultsAggregate = {
  __typename?: 'LatestPayrollVersionResultsAggregate';
  aggregate?: Maybe<LatestPayrollVersionResultsAggregateFields>;
  nodes: Array<LatestPayrollVersionResults>;
};

/** aggregate fields of "latest_payroll_version_results" */
export type LatestPayrollVersionResultsAggregateFields = {
  __typename?: 'LatestPayrollVersionResultsAggregateFields';
  avg?: Maybe<LatestPayrollVersionResultsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<LatestPayrollVersionResultsMaxFields>;
  min?: Maybe<LatestPayrollVersionResultsMinFields>;
  stddev?: Maybe<LatestPayrollVersionResultsStddevFields>;
  stddevPop?: Maybe<LatestPayrollVersionResultsStddevPopFields>;
  stddevSamp?: Maybe<LatestPayrollVersionResultsStddevSampFields>;
  sum?: Maybe<LatestPayrollVersionResultsSumFields>;
  varPop?: Maybe<LatestPayrollVersionResultsVarPopFields>;
  varSamp?: Maybe<LatestPayrollVersionResultsVarSampFields>;
  variance?: Maybe<LatestPayrollVersionResultsVarianceFields>;
};


/** aggregate fields of "latest_payroll_version_results" */
export type LatestPayrollVersionResultsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type LatestPayrollVersionResultsAvgFields = {
  __typename?: 'LatestPayrollVersionResultsAvgFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "latest_payroll_version_results". All fields are combined with a logical 'AND'. */
export type LatestPayrollVersionResultsBoolExp = {
  _and?: InputMaybe<Array<LatestPayrollVersionResultsBoolExp>>;
  _not?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
  _or?: InputMaybe<Array<LatestPayrollVersionResultsBoolExp>>;
  active?: InputMaybe<BooleanComparisonExp>;
  goLiveDate?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  queriedAt?: InputMaybe<TimestamptzComparisonExp>;
  versionNumber?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'latest_payroll_version_results_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsIncInput = {
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsInsertInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  queriedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type LatestPayrollVersionResultsMaxFields = {
  __typename?: 'LatestPayrollVersionResultsMaxFields';
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  queriedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type LatestPayrollVersionResultsMinFields = {
  __typename?: 'LatestPayrollVersionResultsMinFields';
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  queriedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsMutationResponse = {
  __typename?: 'LatestPayrollVersionResultsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<LatestPayrollVersionResults>;
};

/** on_conflict condition type for table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsOnConflict = {
  constraint: LatestPayrollVersionResultsConstraint;
  updateColumns?: Array<LatestPayrollVersionResultsUpdateColumn>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};

/** Ordering options when selecting data from "latest_payroll_version_results". */
export type LatestPayrollVersionResultsOrderBy = {
  active?: InputMaybe<OrderBy>;
  goLiveDate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  queriedAt?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: latest_payroll_version_results */
export type LatestPayrollVersionResultsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsSelectColumn =
  /** column name */
  | 'active'
  /** column name */
  | 'goLiveDate'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'queriedAt'
  /** column name */
  | 'versionNumber'
  | '%future added value';

/** input type for updating data in table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsSetInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  queriedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type LatestPayrollVersionResultsStddevFields = {
  __typename?: 'LatestPayrollVersionResultsStddevFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type LatestPayrollVersionResultsStddevPopFields = {
  __typename?: 'LatestPayrollVersionResultsStddevPopFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type LatestPayrollVersionResultsStddevSampFields = {
  __typename?: 'LatestPayrollVersionResultsStddevSampFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LatestPayrollVersionResultsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LatestPayrollVersionResultsStreamCursorValueInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  queriedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type LatestPayrollVersionResultsSumFields = {
  __typename?: 'LatestPayrollVersionResultsSumFields';
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "latest_payroll_version_results" */
export type LatestPayrollVersionResultsUpdateColumn =
  /** column name */
  | 'active'
  /** column name */
  | 'goLiveDate'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'queriedAt'
  /** column name */
  | 'versionNumber'
  | '%future added value';

export type LatestPayrollVersionResultsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<LatestPayrollVersionResultsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LatestPayrollVersionResultsSetInput>;
  /** filter the rows which have to be updated */
  where: LatestPayrollVersionResultsBoolExp;
};

/** aggregate varPop on columns */
export type LatestPayrollVersionResultsVarPopFields = {
  __typename?: 'LatestPayrollVersionResultsVarPopFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type LatestPayrollVersionResultsVarSampFields = {
  __typename?: 'LatestPayrollVersionResultsVarSampFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type LatestPayrollVersionResultsVarianceFields = {
  __typename?: 'LatestPayrollVersionResultsVarianceFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "leave" */
export type Leave = {
  __typename?: 'Leave';
  /** Timestamp when the leave request was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  employee: Users;
  /** Last day of the leave period */
  endDate: Scalars['date']['output'];
  /** Unique identifier for the leave record */
  id: Scalars['uuid']['output'];
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType: Scalars['String']['output'];
  /** Reason provided for the leave request */
  reason?: Maybe<Scalars['String']['output']>;
  /** First day of the leave period */
  startDate: Scalars['date']['output'];
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: Maybe<Scalars['leave_status_enum']['output']>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Reference to the user taking leave */
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "leave" */
export type LeaveAggregate = {
  __typename?: 'LeaveAggregate';
  aggregate?: Maybe<LeaveAggregateFields>;
  nodes: Array<Leave>;
};

export type LeaveAggregateBoolExp = {
  count?: InputMaybe<LeaveAggregateBoolExpCount>;
};

/** aggregate fields of "leave" */
export type LeaveAggregateFields = {
  __typename?: 'LeaveAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<LeaveMaxFields>;
  min?: Maybe<LeaveMinFields>;
};


/** aggregate fields of "leave" */
export type LeaveAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<LeaveSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "leave" */
export type LeaveAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<LeaveMaxOrderBy>;
  min?: InputMaybe<LeaveMinOrderBy>;
};

/** input type for inserting array relation for remote table "leave" */
export type LeaveArrRelInsertInput = {
  data: Array<LeaveInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<LeaveOnConflict>;
};

/** Boolean expression to filter rows from the table "leave". All fields are combined with a logical 'AND'. */
export type LeaveBoolExp = {
  _and?: InputMaybe<Array<LeaveBoolExp>>;
  _not?: InputMaybe<LeaveBoolExp>;
  _or?: InputMaybe<Array<LeaveBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  employee?: InputMaybe<UsersBoolExp>;
  endDate?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  leaveType?: InputMaybe<StringComparisonExp>;
  reason?: InputMaybe<StringComparisonExp>;
  startDate?: InputMaybe<DateComparisonExp>;
  status?: InputMaybe<LeaveStatusEnumComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "leave" */
export type LeaveConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'leave_pkey'
  | '%future added value';

/** input type for inserting data into table "leave" */
export type LeaveInsertInput = {
  /** Timestamp when the leave request was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  employee?: InputMaybe<UsersObjRelInsertInput>;
  /** Last day of the leave period */
  endDate?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the leave record */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType?: InputMaybe<Scalars['String']['input']>;
  /** Reason provided for the leave request */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** First day of the leave period */
  startDate?: InputMaybe<Scalars['date']['input']>;
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: InputMaybe<Scalars['leave_status_enum']['input']>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Reference to the user taking leave */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type LeaveMaxFields = {
  __typename?: 'LeaveMaxFields';
  /** Timestamp when the leave request was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Last day of the leave period */
  endDate?: Maybe<Scalars['date']['output']>;
  /** Unique identifier for the leave record */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType?: Maybe<Scalars['String']['output']>;
  /** Reason provided for the leave request */
  reason?: Maybe<Scalars['String']['output']>;
  /** First day of the leave period */
  startDate?: Maybe<Scalars['date']['output']>;
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: Maybe<Scalars['leave_status_enum']['output']>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Reference to the user taking leave */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "leave" */
export type LeaveMaxOrderBy = {
  /** Timestamp when the leave request was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Last day of the leave period */
  endDate?: InputMaybe<OrderBy>;
  /** Unique identifier for the leave record */
  id?: InputMaybe<OrderBy>;
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType?: InputMaybe<OrderBy>;
  /** Reason provided for the leave request */
  reason?: InputMaybe<OrderBy>;
  /** First day of the leave period */
  startDate?: InputMaybe<OrderBy>;
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: InputMaybe<OrderBy>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** Reference to the user taking leave */
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type LeaveMinFields = {
  __typename?: 'LeaveMinFields';
  /** Timestamp when the leave request was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Last day of the leave period */
  endDate?: Maybe<Scalars['date']['output']>;
  /** Unique identifier for the leave record */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType?: Maybe<Scalars['String']['output']>;
  /** Reason provided for the leave request */
  reason?: Maybe<Scalars['String']['output']>;
  /** First day of the leave period */
  startDate?: Maybe<Scalars['date']['output']>;
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: Maybe<Scalars['leave_status_enum']['output']>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Reference to the user taking leave */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "leave" */
export type LeaveMinOrderBy = {
  /** Timestamp when the leave request was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Last day of the leave period */
  endDate?: InputMaybe<OrderBy>;
  /** Unique identifier for the leave record */
  id?: InputMaybe<OrderBy>;
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType?: InputMaybe<OrderBy>;
  /** Reason provided for the leave request */
  reason?: InputMaybe<OrderBy>;
  /** First day of the leave period */
  startDate?: InputMaybe<OrderBy>;
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: InputMaybe<OrderBy>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** Reference to the user taking leave */
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "leave" */
export type LeaveMutationResponse = {
  __typename?: 'LeaveMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Leave>;
};

/** on_conflict condition type for table "leave" */
export type LeaveOnConflict = {
  constraint: LeaveConstraint;
  updateColumns?: Array<LeaveUpdateColumn>;
  where?: InputMaybe<LeaveBoolExp>;
};

/** Ordering options when selecting data from "leave". */
export type LeaveOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  employee?: InputMaybe<UsersOrderBy>;
  endDate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  leaveType?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  startDate?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: leave */
export type LeavePkColumnsInput = {
  /** Unique identifier for the leave record */
  id: Scalars['uuid']['input'];
};

/** select columns of table "leave" */
export type LeaveSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'endDate'
  /** column name */
  | 'id'
  /** column name */
  | 'leaveType'
  /** column name */
  | 'reason'
  /** column name */
  | 'startDate'
  /** column name */
  | 'status'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "leave" */
export type LeaveSetInput = {
  /** Timestamp when the leave request was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Last day of the leave period */
  endDate?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the leave record */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType?: InputMaybe<Scalars['String']['input']>;
  /** Reason provided for the leave request */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** First day of the leave period */
  startDate?: InputMaybe<Scalars['date']['input']>;
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: InputMaybe<Scalars['leave_status_enum']['input']>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Reference to the user taking leave */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Boolean expression to compare columns of type "leave_status_enum". All fields are combined with logical 'AND'. */
export type LeaveStatusEnumComparisonExp = {
  _eq?: InputMaybe<Scalars['leave_status_enum']['input']>;
  _gt?: InputMaybe<Scalars['leave_status_enum']['input']>;
  _gte?: InputMaybe<Scalars['leave_status_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['leave_status_enum']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['leave_status_enum']['input']>;
  _lte?: InputMaybe<Scalars['leave_status_enum']['input']>;
  _neq?: InputMaybe<Scalars['leave_status_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['leave_status_enum']['input']>>;
};

/** Streaming cursor of the table "leave" */
export type LeaveStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: LeaveStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type LeaveStreamCursorValueInput = {
  /** Timestamp when the leave request was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Last day of the leave period */
  endDate?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the leave record */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Type of leave (vacation, sick, personal, etc.) */
  leaveType?: InputMaybe<Scalars['String']['input']>;
  /** Reason provided for the leave request */
  reason?: InputMaybe<Scalars['String']['input']>;
  /** First day of the leave period */
  startDate?: InputMaybe<Scalars['date']['input']>;
  /** Current status of the leave request (Pending, Approved, Denied) */
  status?: InputMaybe<Scalars['leave_status_enum']['input']>;
  /** Timestamp when the leave request was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Reference to the user taking leave */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "leave" */
export type LeaveUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'endDate'
  /** column name */
  | 'id'
  /** column name */
  | 'leaveType'
  /** column name */
  | 'reason'
  /** column name */
  | 'startDate'
  /** column name */
  | 'status'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

export type LeaveUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<LeaveSetInput>;
  /** filter the rows which have to be updated */
  where: LeaveBoolExp;
};

/** Tracks monthly billing completion status for each client, enabling 3-tier billing automation */
export type MonthlyBillingCompletion = {
  __typename?: 'MonthlyBillingCompletion';
  autoBillingEnabled?: Maybe<Scalars['Boolean']['output']>;
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  billingMonth: Scalars['date']['output'];
  /** An object relationship */
  billingPeriod?: Maybe<BillingPeriods>;
  billingPeriodId?: Maybe<Scalars['uuid']['output']>;
  billingReadyAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  client: Clients;
  clientId: Scalars['uuid']['output'];
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  completionNotes?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  firstPayrollCompletedAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  lastPayrollCompletedAt?: Maybe<Scalars['timestamptz']['output']>;
  overrideCompletionDate?: Maybe<Scalars['date']['output']>;
  pendingPayrollDateIds?: Maybe<Array<Scalars['uuid']['output']>>;
  pendingPayrollIds?: Maybe<Array<Scalars['uuid']['output']>>;
  status?: Maybe<Scalars['monthly_billing_status']['output']>;
  tier1BillingGenerated?: Maybe<Scalars['Boolean']['output']>;
  tier2BillingGenerated?: Maybe<Scalars['Boolean']['output']>;
  tier3BillingGenerated?: Maybe<Scalars['Boolean']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "monthly_billing_completion" */
export type MonthlyBillingCompletionAggregate = {
  __typename?: 'MonthlyBillingCompletionAggregate';
  aggregate?: Maybe<MonthlyBillingCompletionAggregateFields>;
  nodes: Array<MonthlyBillingCompletion>;
};

export type MonthlyBillingCompletionAggregateBoolExp = {
  bool_and?: InputMaybe<MonthlyBillingCompletionAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<MonthlyBillingCompletionAggregateBoolExpBool_Or>;
  count?: InputMaybe<MonthlyBillingCompletionAggregateBoolExpCount>;
};

/** aggregate fields of "monthly_billing_completion" */
export type MonthlyBillingCompletionAggregateFields = {
  __typename?: 'MonthlyBillingCompletionAggregateFields';
  avg?: Maybe<MonthlyBillingCompletionAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MonthlyBillingCompletionMaxFields>;
  min?: Maybe<MonthlyBillingCompletionMinFields>;
  stddev?: Maybe<MonthlyBillingCompletionStddevFields>;
  stddevPop?: Maybe<MonthlyBillingCompletionStddevPopFields>;
  stddevSamp?: Maybe<MonthlyBillingCompletionStddevSampFields>;
  sum?: Maybe<MonthlyBillingCompletionSumFields>;
  varPop?: Maybe<MonthlyBillingCompletionVarPopFields>;
  varSamp?: Maybe<MonthlyBillingCompletionVarSampFields>;
  variance?: Maybe<MonthlyBillingCompletionVarianceFields>;
};


/** aggregate fields of "monthly_billing_completion" */
export type MonthlyBillingCompletionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "monthly_billing_completion" */
export type MonthlyBillingCompletionAggregateOrderBy = {
  avg?: InputMaybe<MonthlyBillingCompletionAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<MonthlyBillingCompletionMaxOrderBy>;
  min?: InputMaybe<MonthlyBillingCompletionMinOrderBy>;
  stddev?: InputMaybe<MonthlyBillingCompletionStddevOrderBy>;
  stddevPop?: InputMaybe<MonthlyBillingCompletionStddevPopOrderBy>;
  stddevSamp?: InputMaybe<MonthlyBillingCompletionStddevSampOrderBy>;
  sum?: InputMaybe<MonthlyBillingCompletionSumOrderBy>;
  varPop?: InputMaybe<MonthlyBillingCompletionVarPopOrderBy>;
  varSamp?: InputMaybe<MonthlyBillingCompletionVarSampOrderBy>;
  variance?: InputMaybe<MonthlyBillingCompletionVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "monthly_billing_completion" */
export type MonthlyBillingCompletionArrRelInsertInput = {
  data: Array<MonthlyBillingCompletionInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<MonthlyBillingCompletionOnConflict>;
};

/** aggregate avg on columns */
export type MonthlyBillingCompletionAvgFields = {
  __typename?: 'MonthlyBillingCompletionAvgFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionAvgOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "monthly_billing_completion". All fields are combined with a logical 'AND'. */
export type MonthlyBillingCompletionBoolExp = {
  _and?: InputMaybe<Array<MonthlyBillingCompletionBoolExp>>;
  _not?: InputMaybe<MonthlyBillingCompletionBoolExp>;
  _or?: InputMaybe<Array<MonthlyBillingCompletionBoolExp>>;
  autoBillingEnabled?: InputMaybe<BooleanComparisonExp>;
  billingGeneratedAt?: InputMaybe<TimestamptzComparisonExp>;
  billingMonth?: InputMaybe<DateComparisonExp>;
  billingPeriod?: InputMaybe<BillingPeriodsBoolExp>;
  billingPeriodId?: InputMaybe<UuidComparisonExp>;
  billingReadyAt?: InputMaybe<TimestamptzComparisonExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  completedPayrollDates?: InputMaybe<IntComparisonExp>;
  completedPayrolls?: InputMaybe<IntComparisonExp>;
  completionNotes?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  firstPayrollCompletedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastPayrollCompletedAt?: InputMaybe<TimestamptzComparisonExp>;
  overrideCompletionDate?: InputMaybe<DateComparisonExp>;
  pendingPayrollDateIds?: InputMaybe<UuidArrayComparisonExp>;
  pendingPayrollIds?: InputMaybe<UuidArrayComparisonExp>;
  status?: InputMaybe<MonthlyBillingStatusComparisonExp>;
  tier1BillingGenerated?: InputMaybe<BooleanComparisonExp>;
  tier2BillingGenerated?: InputMaybe<BooleanComparisonExp>;
  tier3BillingGenerated?: InputMaybe<BooleanComparisonExp>;
  totalPayrollDates?: InputMaybe<IntComparisonExp>;
  totalPayrolls?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "monthly_billing_completion" */
export type MonthlyBillingCompletionConstraint =
  /** unique or primary key constraint on columns "billing_month", "client_id" */
  | 'monthly_billing_completion_client_id_billing_month_key'
  /** unique or primary key constraint on columns "id" */
  | 'monthly_billing_completion_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "monthly_billing_completion" */
export type MonthlyBillingCompletionIncInput = {
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "monthly_billing_completion" */
export type MonthlyBillingCompletionInsertInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingGeneratedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  billingMonth?: InputMaybe<Scalars['date']['input']>;
  billingPeriod?: InputMaybe<BillingPeriodsObjRelInsertInput>;
  billingPeriodId?: InputMaybe<Scalars['uuid']['input']>;
  billingReadyAt?: InputMaybe<Scalars['timestamptz']['input']>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  completionNotes?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstPayrollCompletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastPayrollCompletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  overrideCompletionDate?: InputMaybe<Scalars['date']['input']>;
  pendingPayrollDateIds?: InputMaybe<Array<Scalars['uuid']['input']>>;
  pendingPayrollIds?: InputMaybe<Array<Scalars['uuid']['input']>>;
  status?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  tier1BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier2BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier3BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type MonthlyBillingCompletionMaxFields = {
  __typename?: 'MonthlyBillingCompletionMaxFields';
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  billingMonth?: Maybe<Scalars['date']['output']>;
  billingPeriodId?: Maybe<Scalars['uuid']['output']>;
  billingReadyAt?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  completionNotes?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  firstPayrollCompletedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastPayrollCompletedAt?: Maybe<Scalars['timestamptz']['output']>;
  overrideCompletionDate?: Maybe<Scalars['date']['output']>;
  pendingPayrollDateIds?: Maybe<Array<Scalars['uuid']['output']>>;
  pendingPayrollIds?: Maybe<Array<Scalars['uuid']['output']>>;
  status?: Maybe<Scalars['monthly_billing_status']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionMaxOrderBy = {
  billingGeneratedAt?: InputMaybe<OrderBy>;
  billingMonth?: InputMaybe<OrderBy>;
  billingPeriodId?: InputMaybe<OrderBy>;
  billingReadyAt?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  completionNotes?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  firstPayrollCompletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastPayrollCompletedAt?: InputMaybe<OrderBy>;
  overrideCompletionDate?: InputMaybe<OrderBy>;
  pendingPayrollDateIds?: InputMaybe<OrderBy>;
  pendingPayrollIds?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type MonthlyBillingCompletionMinFields = {
  __typename?: 'MonthlyBillingCompletionMinFields';
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  billingMonth?: Maybe<Scalars['date']['output']>;
  billingPeriodId?: Maybe<Scalars['uuid']['output']>;
  billingReadyAt?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  completionNotes?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  firstPayrollCompletedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastPayrollCompletedAt?: Maybe<Scalars['timestamptz']['output']>;
  overrideCompletionDate?: Maybe<Scalars['date']['output']>;
  pendingPayrollDateIds?: Maybe<Array<Scalars['uuid']['output']>>;
  pendingPayrollIds?: Maybe<Array<Scalars['uuid']['output']>>;
  status?: Maybe<Scalars['monthly_billing_status']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionMinOrderBy = {
  billingGeneratedAt?: InputMaybe<OrderBy>;
  billingMonth?: InputMaybe<OrderBy>;
  billingPeriodId?: InputMaybe<OrderBy>;
  billingReadyAt?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  completionNotes?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  firstPayrollCompletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastPayrollCompletedAt?: InputMaybe<OrderBy>;
  overrideCompletionDate?: InputMaybe<OrderBy>;
  pendingPayrollDateIds?: InputMaybe<OrderBy>;
  pendingPayrollIds?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "monthly_billing_completion" */
export type MonthlyBillingCompletionMutationResponse = {
  __typename?: 'MonthlyBillingCompletionMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MonthlyBillingCompletion>;
};

/** on_conflict condition type for table "monthly_billing_completion" */
export type MonthlyBillingCompletionOnConflict = {
  constraint: MonthlyBillingCompletionConstraint;
  updateColumns?: Array<MonthlyBillingCompletionUpdateColumn>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};

/** Ordering options when selecting data from "monthly_billing_completion". */
export type MonthlyBillingCompletionOrderBy = {
  autoBillingEnabled?: InputMaybe<OrderBy>;
  billingGeneratedAt?: InputMaybe<OrderBy>;
  billingMonth?: InputMaybe<OrderBy>;
  billingPeriod?: InputMaybe<BillingPeriodsOrderBy>;
  billingPeriodId?: InputMaybe<OrderBy>;
  billingReadyAt?: InputMaybe<OrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  completionNotes?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  firstPayrollCompletedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastPayrollCompletedAt?: InputMaybe<OrderBy>;
  overrideCompletionDate?: InputMaybe<OrderBy>;
  pendingPayrollDateIds?: InputMaybe<OrderBy>;
  pendingPayrollIds?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  tier1BillingGenerated?: InputMaybe<OrderBy>;
  tier2BillingGenerated?: InputMaybe<OrderBy>;
  tier3BillingGenerated?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: monthly_billing_completion */
export type MonthlyBillingCompletionPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionSelectColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingGeneratedAt'
  /** column name */
  | 'billingMonth'
  /** column name */
  | 'billingPeriodId'
  /** column name */
  | 'billingReadyAt'
  /** column name */
  | 'clientId'
  /** column name */
  | 'completedPayrollDates'
  /** column name */
  | 'completedPayrolls'
  /** column name */
  | 'completionNotes'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'firstPayrollCompletedAt'
  /** column name */
  | 'id'
  /** column name */
  | 'lastPayrollCompletedAt'
  /** column name */
  | 'overrideCompletionDate'
  /** column name */
  | 'pendingPayrollDateIds'
  /** column name */
  | 'pendingPayrollIds'
  /** column name */
  | 'status'
  /** column name */
  | 'tier1BillingGenerated'
  /** column name */
  | 'tier2BillingGenerated'
  /** column name */
  | 'tier3BillingGenerated'
  /** column name */
  | 'totalPayrollDates'
  /** column name */
  | 'totalPayrolls'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "monthlyBillingCompletionAggregateBoolExpBool_andArgumentsColumns" columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionSelectColumnMonthlyBillingCompletionAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'tier1BillingGenerated'
  /** column name */
  | 'tier2BillingGenerated'
  /** column name */
  | 'tier3BillingGenerated'
  | '%future added value';

/** select "monthlyBillingCompletionAggregateBoolExpBool_orArgumentsColumns" columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionSelectColumnMonthlyBillingCompletionAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'tier1BillingGenerated'
  /** column name */
  | 'tier2BillingGenerated'
  /** column name */
  | 'tier3BillingGenerated'
  | '%future added value';

/** input type for updating data in table "monthly_billing_completion" */
export type MonthlyBillingCompletionSetInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingGeneratedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  billingMonth?: InputMaybe<Scalars['date']['input']>;
  billingPeriodId?: InputMaybe<Scalars['uuid']['input']>;
  billingReadyAt?: InputMaybe<Scalars['timestamptz']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  completionNotes?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstPayrollCompletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastPayrollCompletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  overrideCompletionDate?: InputMaybe<Scalars['date']['input']>;
  pendingPayrollDateIds?: InputMaybe<Array<Scalars['uuid']['input']>>;
  pendingPayrollIds?: InputMaybe<Array<Scalars['uuid']['input']>>;
  status?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  tier1BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier2BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier3BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type MonthlyBillingCompletionStddevFields = {
  __typename?: 'MonthlyBillingCompletionStddevFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionStddevOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type MonthlyBillingCompletionStddevPopFields = {
  __typename?: 'MonthlyBillingCompletionStddevPopFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionStddevPopOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type MonthlyBillingCompletionStddevSampFields = {
  __typename?: 'MonthlyBillingCompletionStddevSampFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionStddevSampOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "monthly_billing_completion" */
export type MonthlyBillingCompletionStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MonthlyBillingCompletionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MonthlyBillingCompletionStreamCursorValueInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingGeneratedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  billingMonth?: InputMaybe<Scalars['date']['input']>;
  billingPeriodId?: InputMaybe<Scalars['uuid']['input']>;
  billingReadyAt?: InputMaybe<Scalars['timestamptz']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  completionNotes?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstPayrollCompletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastPayrollCompletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  overrideCompletionDate?: InputMaybe<Scalars['date']['input']>;
  pendingPayrollDateIds?: InputMaybe<Array<Scalars['uuid']['input']>>;
  pendingPayrollIds?: InputMaybe<Array<Scalars['uuid']['input']>>;
  status?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  tier1BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier2BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier3BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type MonthlyBillingCompletionSumFields = {
  __typename?: 'MonthlyBillingCompletionSumFields';
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionSumOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** update columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionUpdateColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingGeneratedAt'
  /** column name */
  | 'billingMonth'
  /** column name */
  | 'billingPeriodId'
  /** column name */
  | 'billingReadyAt'
  /** column name */
  | 'clientId'
  /** column name */
  | 'completedPayrollDates'
  /** column name */
  | 'completedPayrolls'
  /** column name */
  | 'completionNotes'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'firstPayrollCompletedAt'
  /** column name */
  | 'id'
  /** column name */
  | 'lastPayrollCompletedAt'
  /** column name */
  | 'overrideCompletionDate'
  /** column name */
  | 'pendingPayrollDateIds'
  /** column name */
  | 'pendingPayrollIds'
  /** column name */
  | 'status'
  /** column name */
  | 'tier1BillingGenerated'
  /** column name */
  | 'tier2BillingGenerated'
  /** column name */
  | 'tier3BillingGenerated'
  /** column name */
  | 'totalPayrollDates'
  /** column name */
  | 'totalPayrolls'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type MonthlyBillingCompletionUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MonthlyBillingCompletionIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MonthlyBillingCompletionSetInput>;
  /** filter the rows which have to be updated */
  where: MonthlyBillingCompletionBoolExp;
};

/** aggregate varPop on columns */
export type MonthlyBillingCompletionVarPopFields = {
  __typename?: 'MonthlyBillingCompletionVarPopFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionVarPopOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type MonthlyBillingCompletionVarSampFields = {
  __typename?: 'MonthlyBillingCompletionVarSampFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionVarSampOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type MonthlyBillingCompletionVarianceFields = {
  __typename?: 'MonthlyBillingCompletionVarianceFields';
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "monthly_billing_completion" */
export type MonthlyBillingCompletionVarianceOrderBy = {
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** Comprehensive dashboard view for monthly billing management and oversight */
export type MonthlyBillingDashboard = {
  __typename?: 'MonthlyBillingDashboard';
  activeServiceAgreements?: Maybe<Scalars['bigint']['output']>;
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingMonth?: Maybe<Scalars['date']['output']>;
  billingMonthDisplay?: Maybe<Scalars['String']['output']>;
  billingReadyAt?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  completionPercentage?: Maybe<Scalars['numeric']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['monthly_billing_status']['output']>;
  tier1BillingGenerated?: Maybe<Scalars['Boolean']['output']>;
  tier2BillingGenerated?: Maybe<Scalars['Boolean']['output']>;
  tier3BillingGenerated?: Maybe<Scalars['Boolean']['output']>;
  totalBillingAmount?: Maybe<Scalars['numeric']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "monthly_billing_dashboard" */
export type MonthlyBillingDashboardAggregate = {
  __typename?: 'MonthlyBillingDashboardAggregate';
  aggregate?: Maybe<MonthlyBillingDashboardAggregateFields>;
  nodes: Array<MonthlyBillingDashboard>;
};

/** aggregate fields of "monthly_billing_dashboard" */
export type MonthlyBillingDashboardAggregateFields = {
  __typename?: 'MonthlyBillingDashboardAggregateFields';
  avg?: Maybe<MonthlyBillingDashboardAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MonthlyBillingDashboardMaxFields>;
  min?: Maybe<MonthlyBillingDashboardMinFields>;
  stddev?: Maybe<MonthlyBillingDashboardStddevFields>;
  stddevPop?: Maybe<MonthlyBillingDashboardStddevPopFields>;
  stddevSamp?: Maybe<MonthlyBillingDashboardStddevSampFields>;
  sum?: Maybe<MonthlyBillingDashboardSumFields>;
  varPop?: Maybe<MonthlyBillingDashboardVarPopFields>;
  varSamp?: Maybe<MonthlyBillingDashboardVarSampFields>;
  variance?: Maybe<MonthlyBillingDashboardVarianceFields>;
};


/** aggregate fields of "monthly_billing_dashboard" */
export type MonthlyBillingDashboardAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<MonthlyBillingDashboardSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type MonthlyBillingDashboardAvgFields = {
  __typename?: 'MonthlyBillingDashboardAvgFields';
  activeServiceAgreements?: Maybe<Scalars['Float']['output']>;
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  completionPercentage?: Maybe<Scalars['Float']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Float']['output']>;
  totalBillingAmount?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "monthly_billing_dashboard". All fields are combined with a logical 'AND'. */
export type MonthlyBillingDashboardBoolExp = {
  _and?: InputMaybe<Array<MonthlyBillingDashboardBoolExp>>;
  _not?: InputMaybe<MonthlyBillingDashboardBoolExp>;
  _or?: InputMaybe<Array<MonthlyBillingDashboardBoolExp>>;
  activeServiceAgreements?: InputMaybe<BigintComparisonExp>;
  billingGeneratedAt?: InputMaybe<TimestamptzComparisonExp>;
  billingItemsCount?: InputMaybe<BigintComparisonExp>;
  billingMonth?: InputMaybe<DateComparisonExp>;
  billingMonthDisplay?: InputMaybe<StringComparisonExp>;
  billingReadyAt?: InputMaybe<TimestamptzComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  completedPayrollDates?: InputMaybe<IntComparisonExp>;
  completedPayrolls?: InputMaybe<IntComparisonExp>;
  completionPercentage?: InputMaybe<NumericComparisonExp>;
  daysReadyForBilling?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<MonthlyBillingStatusComparisonExp>;
  tier1BillingGenerated?: InputMaybe<BooleanComparisonExp>;
  tier2BillingGenerated?: InputMaybe<BooleanComparisonExp>;
  tier3BillingGenerated?: InputMaybe<BooleanComparisonExp>;
  totalBillingAmount?: InputMaybe<NumericComparisonExp>;
  totalPayrollDates?: InputMaybe<IntComparisonExp>;
  totalPayrolls?: InputMaybe<IntComparisonExp>;
};

/** aggregate max on columns */
export type MonthlyBillingDashboardMaxFields = {
  __typename?: 'MonthlyBillingDashboardMaxFields';
  activeServiceAgreements?: Maybe<Scalars['bigint']['output']>;
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingMonth?: Maybe<Scalars['date']['output']>;
  billingMonthDisplay?: Maybe<Scalars['String']['output']>;
  billingReadyAt?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  completionPercentage?: Maybe<Scalars['numeric']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['monthly_billing_status']['output']>;
  totalBillingAmount?: Maybe<Scalars['numeric']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type MonthlyBillingDashboardMinFields = {
  __typename?: 'MonthlyBillingDashboardMinFields';
  activeServiceAgreements?: Maybe<Scalars['bigint']['output']>;
  billingGeneratedAt?: Maybe<Scalars['timestamptz']['output']>;
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingMonth?: Maybe<Scalars['date']['output']>;
  billingMonthDisplay?: Maybe<Scalars['String']['output']>;
  billingReadyAt?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  completionPercentage?: Maybe<Scalars['numeric']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['monthly_billing_status']['output']>;
  totalBillingAmount?: Maybe<Scalars['numeric']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
};

/** Ordering options when selecting data from "monthly_billing_dashboard". */
export type MonthlyBillingDashboardOrderBy = {
  activeServiceAgreements?: InputMaybe<OrderBy>;
  billingGeneratedAt?: InputMaybe<OrderBy>;
  billingItemsCount?: InputMaybe<OrderBy>;
  billingMonth?: InputMaybe<OrderBy>;
  billingMonthDisplay?: InputMaybe<OrderBy>;
  billingReadyAt?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  completedPayrollDates?: InputMaybe<OrderBy>;
  completedPayrolls?: InputMaybe<OrderBy>;
  completionPercentage?: InputMaybe<OrderBy>;
  daysReadyForBilling?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  tier1BillingGenerated?: InputMaybe<OrderBy>;
  tier2BillingGenerated?: InputMaybe<OrderBy>;
  tier3BillingGenerated?: InputMaybe<OrderBy>;
  totalBillingAmount?: InputMaybe<OrderBy>;
  totalPayrollDates?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** select columns of table "monthly_billing_dashboard" */
export type MonthlyBillingDashboardSelectColumn =
  /** column name */
  | 'activeServiceAgreements'
  /** column name */
  | 'billingGeneratedAt'
  /** column name */
  | 'billingItemsCount'
  /** column name */
  | 'billingMonth'
  /** column name */
  | 'billingMonthDisplay'
  /** column name */
  | 'billingReadyAt'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'completedPayrollDates'
  /** column name */
  | 'completedPayrolls'
  /** column name */
  | 'completionPercentage'
  /** column name */
  | 'daysReadyForBilling'
  /** column name */
  | 'id'
  /** column name */
  | 'status'
  /** column name */
  | 'tier1BillingGenerated'
  /** column name */
  | 'tier2BillingGenerated'
  /** column name */
  | 'tier3BillingGenerated'
  /** column name */
  | 'totalBillingAmount'
  /** column name */
  | 'totalPayrollDates'
  /** column name */
  | 'totalPayrolls'
  | '%future added value';

/** aggregate stddev on columns */
export type MonthlyBillingDashboardStddevFields = {
  __typename?: 'MonthlyBillingDashboardStddevFields';
  activeServiceAgreements?: Maybe<Scalars['Float']['output']>;
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  completionPercentage?: Maybe<Scalars['Float']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Float']['output']>;
  totalBillingAmount?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type MonthlyBillingDashboardStddevPopFields = {
  __typename?: 'MonthlyBillingDashboardStddevPopFields';
  activeServiceAgreements?: Maybe<Scalars['Float']['output']>;
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  completionPercentage?: Maybe<Scalars['Float']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Float']['output']>;
  totalBillingAmount?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type MonthlyBillingDashboardStddevSampFields = {
  __typename?: 'MonthlyBillingDashboardStddevSampFields';
  activeServiceAgreements?: Maybe<Scalars['Float']['output']>;
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  completionPercentage?: Maybe<Scalars['Float']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Float']['output']>;
  totalBillingAmount?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "monthly_billing_dashboard" */
export type MonthlyBillingDashboardStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: MonthlyBillingDashboardStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type MonthlyBillingDashboardStreamCursorValueInput = {
  activeServiceAgreements?: InputMaybe<Scalars['bigint']['input']>;
  billingGeneratedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  billingItemsCount?: InputMaybe<Scalars['bigint']['input']>;
  billingMonth?: InputMaybe<Scalars['date']['input']>;
  billingMonthDisplay?: InputMaybe<Scalars['String']['input']>;
  billingReadyAt?: InputMaybe<Scalars['timestamptz']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  completedPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  completedPayrolls?: InputMaybe<Scalars['Int']['input']>;
  completionPercentage?: InputMaybe<Scalars['numeric']['input']>;
  daysReadyForBilling?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  status?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  tier1BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier2BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  tier3BillingGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  totalBillingAmount?: InputMaybe<Scalars['numeric']['input']>;
  totalPayrollDates?: InputMaybe<Scalars['Int']['input']>;
  totalPayrolls?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type MonthlyBillingDashboardSumFields = {
  __typename?: 'MonthlyBillingDashboardSumFields';
  activeServiceAgreements?: Maybe<Scalars['bigint']['output']>;
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  completedPayrollDates?: Maybe<Scalars['Int']['output']>;
  completedPayrolls?: Maybe<Scalars['Int']['output']>;
  completionPercentage?: Maybe<Scalars['numeric']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Int']['output']>;
  totalBillingAmount?: Maybe<Scalars['numeric']['output']>;
  totalPayrollDates?: Maybe<Scalars['Int']['output']>;
  totalPayrolls?: Maybe<Scalars['Int']['output']>;
};

/** aggregate varPop on columns */
export type MonthlyBillingDashboardVarPopFields = {
  __typename?: 'MonthlyBillingDashboardVarPopFields';
  activeServiceAgreements?: Maybe<Scalars['Float']['output']>;
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  completionPercentage?: Maybe<Scalars['Float']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Float']['output']>;
  totalBillingAmount?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type MonthlyBillingDashboardVarSampFields = {
  __typename?: 'MonthlyBillingDashboardVarSampFields';
  activeServiceAgreements?: Maybe<Scalars['Float']['output']>;
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  completionPercentage?: Maybe<Scalars['Float']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Float']['output']>;
  totalBillingAmount?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type MonthlyBillingDashboardVarianceFields = {
  __typename?: 'MonthlyBillingDashboardVarianceFields';
  activeServiceAgreements?: Maybe<Scalars['Float']['output']>;
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  completedPayrollDates?: Maybe<Scalars['Float']['output']>;
  completedPayrolls?: Maybe<Scalars['Float']['output']>;
  completionPercentage?: Maybe<Scalars['Float']['output']>;
  daysReadyForBilling?: Maybe<Scalars['Float']['output']>;
  totalBillingAmount?: Maybe<Scalars['Float']['output']>;
  totalPayrollDates?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "monthly_billing_status". All fields are combined with logical 'AND'. */
export type MonthlyBillingStatusComparisonExp = {
  _eq?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  _gt?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  _gte?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  _in?: InputMaybe<Array<Scalars['monthly_billing_status']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  _lte?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  _neq?: InputMaybe<Scalars['monthly_billing_status']['input']>;
  _nin?: InputMaybe<Array<Scalars['monthly_billing_status']['input']>>;
};

/** Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'. */
export type NameComparisonExp = {
  _eq?: InputMaybe<Scalars['name']['input']>;
  _gt?: InputMaybe<Scalars['name']['input']>;
  _gte?: InputMaybe<Scalars['name']['input']>;
  _in?: InputMaybe<Array<Scalars['name']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['name']['input']>;
  _lte?: InputMaybe<Scalars['name']['input']>;
  _neq?: InputMaybe<Scalars['name']['input']>;
  _nin?: InputMaybe<Array<Scalars['name']['input']>>;
};

/** columns and relationships of "notes" */
export type Notes = {
  __typename?: 'Notes';
  /** An object relationship */
  author?: Maybe<Users>;
  /** Content of the note */
  content: Scalars['String']['output'];
  /** Timestamp when the note was created */
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Identifier of the entity this note is attached to */
  entityId: Scalars['uuid']['output'];
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType: Scalars['String']['output'];
  /** Unique identifier for the note */
  id: Scalars['uuid']['output'];
  /** Whether the note is flagged as important */
  isImportant?: Maybe<Scalars['Boolean']['output']>;
  /** Timestamp when the note was last updated */
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** User who created the note */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "notes" */
export type NotesAggregate = {
  __typename?: 'NotesAggregate';
  aggregate?: Maybe<NotesAggregateFields>;
  nodes: Array<Notes>;
};

export type NotesAggregateBoolExp = {
  bool_and?: InputMaybe<NotesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<NotesAggregateBoolExpBool_Or>;
  count?: InputMaybe<NotesAggregateBoolExpCount>;
};

/** aggregate fields of "notes" */
export type NotesAggregateFields = {
  __typename?: 'NotesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<NotesMaxFields>;
  min?: Maybe<NotesMinFields>;
};


/** aggregate fields of "notes" */
export type NotesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<NotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "notes" */
export type NotesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<NotesMaxOrderBy>;
  min?: InputMaybe<NotesMinOrderBy>;
};

/** input type for inserting array relation for remote table "notes" */
export type NotesArrRelInsertInput = {
  data: Array<NotesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<NotesOnConflict>;
};

/** Boolean expression to filter rows from the table "notes". All fields are combined with a logical 'AND'. */
export type NotesBoolExp = {
  _and?: InputMaybe<Array<NotesBoolExp>>;
  _not?: InputMaybe<NotesBoolExp>;
  _or?: InputMaybe<Array<NotesBoolExp>>;
  author?: InputMaybe<UsersBoolExp>;
  content?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  entityId?: InputMaybe<UuidComparisonExp>;
  entityType?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isImportant?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "notes" */
export type NotesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'notes_pkey'
  | '%future added value';

/** input type for inserting data into table "notes" */
export type NotesInsertInput = {
  author?: InputMaybe<UsersObjRelInsertInput>;
  /** Content of the note */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the note was created */
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Identifier of the entity this note is attached to */
  entityId?: InputMaybe<Scalars['uuid']['input']>;
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the note */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the note is flagged as important */
  isImportant?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp when the note was last updated */
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User who created the note */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type NotesMaxFields = {
  __typename?: 'NotesMaxFields';
  /** Content of the note */
  content?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the note was created */
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Identifier of the entity this note is attached to */
  entityId?: Maybe<Scalars['uuid']['output']>;
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the note */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the note was last updated */
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** User who created the note */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "notes" */
export type NotesMaxOrderBy = {
  /** Content of the note */
  content?: InputMaybe<OrderBy>;
  /** Timestamp when the note was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Identifier of the entity this note is attached to */
  entityId?: InputMaybe<OrderBy>;
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType?: InputMaybe<OrderBy>;
  /** Unique identifier for the note */
  id?: InputMaybe<OrderBy>;
  /** Timestamp when the note was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** User who created the note */
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type NotesMinFields = {
  __typename?: 'NotesMinFields';
  /** Content of the note */
  content?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the note was created */
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Identifier of the entity this note is attached to */
  entityId?: Maybe<Scalars['uuid']['output']>;
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the note */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the note was last updated */
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** User who created the note */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "notes" */
export type NotesMinOrderBy = {
  /** Content of the note */
  content?: InputMaybe<OrderBy>;
  /** Timestamp when the note was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Identifier of the entity this note is attached to */
  entityId?: InputMaybe<OrderBy>;
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType?: InputMaybe<OrderBy>;
  /** Unique identifier for the note */
  id?: InputMaybe<OrderBy>;
  /** Timestamp when the note was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** User who created the note */
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "notes" */
export type NotesMutationResponse = {
  __typename?: 'NotesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Notes>;
};

/** on_conflict condition type for table "notes" */
export type NotesOnConflict = {
  constraint: NotesConstraint;
  updateColumns?: Array<NotesUpdateColumn>;
  where?: InputMaybe<NotesBoolExp>;
};

/** Ordering options when selecting data from "notes". */
export type NotesOrderBy = {
  author?: InputMaybe<UsersOrderBy>;
  content?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  entityId?: InputMaybe<OrderBy>;
  entityType?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isImportant?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: notes */
export type NotesPkColumnsInput = {
  /** Unique identifier for the note */
  id: Scalars['uuid']['input'];
};

/** select columns of table "notes" */
export type NotesSelectColumn =
  /** column name */
  | 'content'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'entityId'
  /** column name */
  | 'entityType'
  /** column name */
  | 'id'
  /** column name */
  | 'isImportant'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

/** select "notesAggregateBoolExpBool_andArgumentsColumns" columns of table "notes" */
export type NotesSelectColumnNotesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isImportant'
  | '%future added value';

/** select "notesAggregateBoolExpBool_orArgumentsColumns" columns of table "notes" */
export type NotesSelectColumnNotesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isImportant'
  | '%future added value';

/** input type for updating data in table "notes" */
export type NotesSetInput = {
  /** Content of the note */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the note was created */
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Identifier of the entity this note is attached to */
  entityId?: InputMaybe<Scalars['uuid']['input']>;
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the note */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the note is flagged as important */
  isImportant?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp when the note was last updated */
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User who created the note */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "notes" */
export type NotesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: NotesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type NotesStreamCursorValueInput = {
  /** Content of the note */
  content?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the note was created */
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Identifier of the entity this note is attached to */
  entityId?: InputMaybe<Scalars['uuid']['input']>;
  /** Type of entity this note is attached to (client, payroll, etc.) */
  entityType?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the note */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether the note is flagged as important */
  isImportant?: InputMaybe<Scalars['Boolean']['input']>;
  /** Timestamp when the note was last updated */
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** User who created the note */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "notes" */
export type NotesUpdateColumn =
  /** column name */
  | 'content'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'entityId'
  /** column name */
  | 'entityType'
  /** column name */
  | 'id'
  /** column name */
  | 'isImportant'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

export type NotesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<NotesSetInput>;
  /** filter the rows which have to be updated */
  where: NotesBoolExp;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type NumericComparisonExp = {
  _eq?: InputMaybe<Scalars['numeric']['input']>;
  _gt?: InputMaybe<Scalars['numeric']['input']>;
  _gte?: InputMaybe<Scalars['numeric']['input']>;
  _in?: InputMaybe<Array<Scalars['numeric']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['numeric']['input']>;
  _lte?: InputMaybe<Scalars['numeric']['input']>;
  _neq?: InputMaybe<Scalars['numeric']['input']>;
  _nin?: InputMaybe<Array<Scalars['numeric']['input']>>;
};

/** column ordering options */
export type OrderBy =
  /** in ascending order, nulls last */
  | 'ASC'
  /** in ascending order, nulls first */
  | 'ASC_NULLS_FIRST'
  /** in ascending order, nulls last */
  | 'ASC_NULLS_LAST'
  /** in descending order, nulls first */
  | 'DESC'
  /** in descending order, nulls first */
  | 'DESC_NULLS_FIRST'
  /** in descending order, nulls last */
  | 'DESC_NULLS_LAST'
  | '%future added value';

/** columns and relationships of "payroll_activation_results" */
export type PayrollActivationResults = {
  __typename?: 'PayrollActivationResults';
  actionTaken: Scalars['String']['output'];
  executedAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  payrollId: Scalars['uuid']['output'];
  versionNumber: Scalars['Int']['output'];
};

/** aggregated selection of "payroll_activation_results" */
export type PayrollActivationResultsAggregate = {
  __typename?: 'PayrollActivationResultsAggregate';
  aggregate?: Maybe<PayrollActivationResultsAggregateFields>;
  nodes: Array<PayrollActivationResults>;
};

/** aggregate fields of "payroll_activation_results" */
export type PayrollActivationResultsAggregateFields = {
  __typename?: 'PayrollActivationResultsAggregateFields';
  avg?: Maybe<PayrollActivationResultsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollActivationResultsMaxFields>;
  min?: Maybe<PayrollActivationResultsMinFields>;
  stddev?: Maybe<PayrollActivationResultsStddevFields>;
  stddevPop?: Maybe<PayrollActivationResultsStddevPopFields>;
  stddevSamp?: Maybe<PayrollActivationResultsStddevSampFields>;
  sum?: Maybe<PayrollActivationResultsSumFields>;
  varPop?: Maybe<PayrollActivationResultsVarPopFields>;
  varSamp?: Maybe<PayrollActivationResultsVarSampFields>;
  variance?: Maybe<PayrollActivationResultsVarianceFields>;
};


/** aggregate fields of "payroll_activation_results" */
export type PayrollActivationResultsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollActivationResultsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollActivationResultsAvgFields = {
  __typename?: 'PayrollActivationResultsAvgFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_activation_results". All fields are combined with a logical 'AND'. */
export type PayrollActivationResultsBoolExp = {
  _and?: InputMaybe<Array<PayrollActivationResultsBoolExp>>;
  _not?: InputMaybe<PayrollActivationResultsBoolExp>;
  _or?: InputMaybe<Array<PayrollActivationResultsBoolExp>>;
  actionTaken?: InputMaybe<StringComparisonExp>;
  executedAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  versionNumber?: InputMaybe<IntComparisonExp>;
};

/** unique or primary key constraints on table "payroll_activation_results" */
export type PayrollActivationResultsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'payroll_activation_results_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "payroll_activation_results" */
export type PayrollActivationResultsIncInput = {
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "payroll_activation_results" */
export type PayrollActivationResultsInsertInput = {
  actionTaken?: InputMaybe<Scalars['String']['input']>;
  executedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type PayrollActivationResultsMaxFields = {
  __typename?: 'PayrollActivationResultsMaxFields';
  actionTaken?: Maybe<Scalars['String']['output']>;
  executedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type PayrollActivationResultsMinFields = {
  __typename?: 'PayrollActivationResultsMinFields';
  actionTaken?: Maybe<Scalars['String']['output']>;
  executedAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "payroll_activation_results" */
export type PayrollActivationResultsMutationResponse = {
  __typename?: 'PayrollActivationResultsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollActivationResults>;
};

/** on_conflict condition type for table "payroll_activation_results" */
export type PayrollActivationResultsOnConflict = {
  constraint: PayrollActivationResultsConstraint;
  updateColumns?: Array<PayrollActivationResultsUpdateColumn>;
  where?: InputMaybe<PayrollActivationResultsBoolExp>;
};

/** Ordering options when selecting data from "payroll_activation_results". */
export type PayrollActivationResultsOrderBy = {
  actionTaken?: InputMaybe<OrderBy>;
  executedAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_activation_results */
export type PayrollActivationResultsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_activation_results" */
export type PayrollActivationResultsSelectColumn =
  /** column name */
  | 'actionTaken'
  /** column name */
  | 'executedAt'
  /** column name */
  | 'id'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'versionNumber'
  | '%future added value';

/** input type for updating data in table "payroll_activation_results" */
export type PayrollActivationResultsSetInput = {
  actionTaken?: InputMaybe<Scalars['String']['input']>;
  executedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type PayrollActivationResultsStddevFields = {
  __typename?: 'PayrollActivationResultsStddevFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollActivationResultsStddevPopFields = {
  __typename?: 'PayrollActivationResultsStddevPopFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollActivationResultsStddevSampFields = {
  __typename?: 'PayrollActivationResultsStddevSampFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_activation_results" */
export type PayrollActivationResultsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollActivationResultsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollActivationResultsStreamCursorValueInput = {
  actionTaken?: InputMaybe<Scalars['String']['input']>;
  executedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type PayrollActivationResultsSumFields = {
  __typename?: 'PayrollActivationResultsSumFields';
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "payroll_activation_results" */
export type PayrollActivationResultsUpdateColumn =
  /** column name */
  | 'actionTaken'
  /** column name */
  | 'executedAt'
  /** column name */
  | 'id'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'versionNumber'
  | '%future added value';

export type PayrollActivationResultsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PayrollActivationResultsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollActivationResultsSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollActivationResultsBoolExp;
};

/** aggregate varPop on columns */
export type PayrollActivationResultsVarPopFields = {
  __typename?: 'PayrollActivationResultsVarPopFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollActivationResultsVarSampFields = {
  __typename?: 'PayrollActivationResultsVarSampFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollActivationResultsVarianceFields = {
  __typename?: 'PayrollActivationResultsVarianceFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "payroll_assignment_audit" */
export type PayrollAssignmentAudit = {
  __typename?: 'PayrollAssignmentAudit';
  assignmentId?: Maybe<Scalars['uuid']['output']>;
  changeReason?: Maybe<Scalars['String']['output']>;
  changedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  changedByUser?: Maybe<Users>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  fromConsultant?: Maybe<Users>;
  fromConsultantId?: Maybe<Scalars['uuid']['output']>;
  id: Scalars['uuid']['output'];
  /** An object relationship */
  payrollAssignment?: Maybe<PayrollAssignments>;
  /** An object relationship */
  payrollDate: PayrollDates;
  payrollDateId: Scalars['uuid']['output'];
  /** An object relationship */
  toConsultant: Users;
  toConsultantId: Scalars['uuid']['output'];
};

/** aggregated selection of "payroll_assignment_audit" */
export type PayrollAssignmentAuditAggregate = {
  __typename?: 'PayrollAssignmentAuditAggregate';
  aggregate?: Maybe<PayrollAssignmentAuditAggregateFields>;
  nodes: Array<PayrollAssignmentAudit>;
};

export type PayrollAssignmentAuditAggregateBoolExp = {
  count?: InputMaybe<PayrollAssignmentAuditAggregateBoolExpCount>;
};

/** aggregate fields of "payroll_assignment_audit" */
export type PayrollAssignmentAuditAggregateFields = {
  __typename?: 'PayrollAssignmentAuditAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollAssignmentAuditMaxFields>;
  min?: Maybe<PayrollAssignmentAuditMinFields>;
};


/** aggregate fields of "payroll_assignment_audit" */
export type PayrollAssignmentAuditAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payroll_assignment_audit" */
export type PayrollAssignmentAuditAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PayrollAssignmentAuditMaxOrderBy>;
  min?: InputMaybe<PayrollAssignmentAuditMinOrderBy>;
};

/** input type for inserting array relation for remote table "payroll_assignment_audit" */
export type PayrollAssignmentAuditArrRelInsertInput = {
  data: Array<PayrollAssignmentAuditInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollAssignmentAuditOnConflict>;
};

/** Boolean expression to filter rows from the table "payroll_assignment_audit". All fields are combined with a logical 'AND'. */
export type PayrollAssignmentAuditBoolExp = {
  _and?: InputMaybe<Array<PayrollAssignmentAuditBoolExp>>;
  _not?: InputMaybe<PayrollAssignmentAuditBoolExp>;
  _or?: InputMaybe<Array<PayrollAssignmentAuditBoolExp>>;
  assignmentId?: InputMaybe<UuidComparisonExp>;
  changeReason?: InputMaybe<StringComparisonExp>;
  changedBy?: InputMaybe<UuidComparisonExp>;
  changedByUser?: InputMaybe<UsersBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  fromConsultant?: InputMaybe<UsersBoolExp>;
  fromConsultantId?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  payrollAssignment?: InputMaybe<PayrollAssignmentsBoolExp>;
  payrollDate?: InputMaybe<PayrollDatesBoolExp>;
  payrollDateId?: InputMaybe<UuidComparisonExp>;
  toConsultant?: InputMaybe<UsersBoolExp>;
  toConsultantId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "payroll_assignment_audit" */
export type PayrollAssignmentAuditConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'payroll_assignment_audit_pkey'
  | '%future added value';

/** input type for inserting data into table "payroll_assignment_audit" */
export type PayrollAssignmentAuditInsertInput = {
  assignmentId?: InputMaybe<Scalars['uuid']['input']>;
  changeReason?: InputMaybe<Scalars['String']['input']>;
  changedBy?: InputMaybe<Scalars['uuid']['input']>;
  changedByUser?: InputMaybe<UsersObjRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  fromConsultant?: InputMaybe<UsersObjRelInsertInput>;
  fromConsultantId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payrollAssignment?: InputMaybe<PayrollAssignmentsObjRelInsertInput>;
  payrollDate?: InputMaybe<PayrollDatesObjRelInsertInput>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  toConsultant?: InputMaybe<UsersObjRelInsertInput>;
  toConsultantId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type PayrollAssignmentAuditMaxFields = {
  __typename?: 'PayrollAssignmentAuditMaxFields';
  assignmentId?: Maybe<Scalars['uuid']['output']>;
  changeReason?: Maybe<Scalars['String']['output']>;
  changedBy?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  fromConsultantId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  toConsultantId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "payroll_assignment_audit" */
export type PayrollAssignmentAuditMaxOrderBy = {
  assignmentId?: InputMaybe<OrderBy>;
  changeReason?: InputMaybe<OrderBy>;
  changedBy?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  fromConsultantId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  toConsultantId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PayrollAssignmentAuditMinFields = {
  __typename?: 'PayrollAssignmentAuditMinFields';
  assignmentId?: Maybe<Scalars['uuid']['output']>;
  changeReason?: Maybe<Scalars['String']['output']>;
  changedBy?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  fromConsultantId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  toConsultantId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "payroll_assignment_audit" */
export type PayrollAssignmentAuditMinOrderBy = {
  assignmentId?: InputMaybe<OrderBy>;
  changeReason?: InputMaybe<OrderBy>;
  changedBy?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  fromConsultantId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  toConsultantId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "payroll_assignment_audit" */
export type PayrollAssignmentAuditMutationResponse = {
  __typename?: 'PayrollAssignmentAuditMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollAssignmentAudit>;
};

/** on_conflict condition type for table "payroll_assignment_audit" */
export type PayrollAssignmentAuditOnConflict = {
  constraint: PayrollAssignmentAuditConstraint;
  updateColumns?: Array<PayrollAssignmentAuditUpdateColumn>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};

/** Ordering options when selecting data from "payroll_assignment_audit". */
export type PayrollAssignmentAuditOrderBy = {
  assignmentId?: InputMaybe<OrderBy>;
  changeReason?: InputMaybe<OrderBy>;
  changedBy?: InputMaybe<OrderBy>;
  changedByUser?: InputMaybe<UsersOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  fromConsultant?: InputMaybe<UsersOrderBy>;
  fromConsultantId?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollAssignment?: InputMaybe<PayrollAssignmentsOrderBy>;
  payrollDate?: InputMaybe<PayrollDatesOrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  toConsultant?: InputMaybe<UsersOrderBy>;
  toConsultantId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_assignment_audit */
export type PayrollAssignmentAuditPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_assignment_audit" */
export type PayrollAssignmentAuditSelectColumn =
  /** column name */
  | 'assignmentId'
  /** column name */
  | 'changeReason'
  /** column name */
  | 'changedBy'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'fromConsultantId'
  /** column name */
  | 'id'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'toConsultantId'
  | '%future added value';

/** input type for updating data in table "payroll_assignment_audit" */
export type PayrollAssignmentAuditSetInput = {
  assignmentId?: InputMaybe<Scalars['uuid']['input']>;
  changeReason?: InputMaybe<Scalars['String']['input']>;
  changedBy?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  fromConsultantId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  toConsultantId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "payroll_assignment_audit" */
export type PayrollAssignmentAuditStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollAssignmentAuditStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollAssignmentAuditStreamCursorValueInput = {
  assignmentId?: InputMaybe<Scalars['uuid']['input']>;
  changeReason?: InputMaybe<Scalars['String']['input']>;
  changedBy?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  fromConsultantId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  toConsultantId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "payroll_assignment_audit" */
export type PayrollAssignmentAuditUpdateColumn =
  /** column name */
  | 'assignmentId'
  /** column name */
  | 'changeReason'
  /** column name */
  | 'changedBy'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'fromConsultantId'
  /** column name */
  | 'id'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'toConsultantId'
  | '%future added value';

export type PayrollAssignmentAuditUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollAssignmentAuditSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollAssignmentAuditBoolExp;
};

/** columns and relationships of "payroll_assignments" */
export type PayrollAssignments = {
  __typename?: 'PayrollAssignments';
  assignedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  assignedByUser?: Maybe<Users>;
  assignedDate?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  auditTrail: Array<PayrollAssignmentAudit>;
  /** An aggregate relationship */
  auditTrailAggregate: PayrollAssignmentAuditAggregate;
  /** An object relationship */
  consultant: Users;
  consultantId: Scalars['uuid']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  isBackup?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  originalConsultant?: Maybe<Users>;
  originalConsultantId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  payrollDate: PayrollDates;
  payrollDateId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "payroll_assignments" */
export type PayrollAssignmentsAuditTrailArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "payroll_assignments" */
export type PayrollAssignmentsAuditTrailAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};

/** aggregated selection of "payroll_assignments" */
export type PayrollAssignmentsAggregate = {
  __typename?: 'PayrollAssignmentsAggregate';
  aggregate?: Maybe<PayrollAssignmentsAggregateFields>;
  nodes: Array<PayrollAssignments>;
};

export type PayrollAssignmentsAggregateBoolExp = {
  bool_and?: InputMaybe<PayrollAssignmentsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<PayrollAssignmentsAggregateBoolExpBool_Or>;
  count?: InputMaybe<PayrollAssignmentsAggregateBoolExpCount>;
};

/** aggregate fields of "payroll_assignments" */
export type PayrollAssignmentsAggregateFields = {
  __typename?: 'PayrollAssignmentsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollAssignmentsMaxFields>;
  min?: Maybe<PayrollAssignmentsMinFields>;
};


/** aggregate fields of "payroll_assignments" */
export type PayrollAssignmentsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payroll_assignments" */
export type PayrollAssignmentsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PayrollAssignmentsMaxOrderBy>;
  min?: InputMaybe<PayrollAssignmentsMinOrderBy>;
};

/** input type for inserting array relation for remote table "payroll_assignments" */
export type PayrollAssignmentsArrRelInsertInput = {
  data: Array<PayrollAssignmentsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollAssignmentsOnConflict>;
};

/** Boolean expression to filter rows from the table "payroll_assignments". All fields are combined with a logical 'AND'. */
export type PayrollAssignmentsBoolExp = {
  _and?: InputMaybe<Array<PayrollAssignmentsBoolExp>>;
  _not?: InputMaybe<PayrollAssignmentsBoolExp>;
  _or?: InputMaybe<Array<PayrollAssignmentsBoolExp>>;
  assignedBy?: InputMaybe<UuidComparisonExp>;
  assignedByUser?: InputMaybe<UsersBoolExp>;
  assignedDate?: InputMaybe<TimestamptzComparisonExp>;
  auditTrail?: InputMaybe<PayrollAssignmentAuditBoolExp>;
  auditTrailAggregate?: InputMaybe<PayrollAssignmentAuditAggregateBoolExp>;
  consultant?: InputMaybe<UsersBoolExp>;
  consultantId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBackup?: InputMaybe<BooleanComparisonExp>;
  originalConsultant?: InputMaybe<UsersBoolExp>;
  originalConsultantId?: InputMaybe<UuidComparisonExp>;
  payrollDate?: InputMaybe<PayrollDatesBoolExp>;
  payrollDateId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "payroll_assignments" */
export type PayrollAssignmentsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'payroll_assignments_pkey'
  /** unique or primary key constraint on columns "payroll_date_id" */
  | 'uq_payroll_assignment_payroll_date'
  | '%future added value';

/** input type for inserting data into table "payroll_assignments" */
export type PayrollAssignmentsInsertInput = {
  assignedBy?: InputMaybe<Scalars['uuid']['input']>;
  assignedByUser?: InputMaybe<UsersObjRelInsertInput>;
  assignedDate?: InputMaybe<Scalars['timestamptz']['input']>;
  auditTrail?: InputMaybe<PayrollAssignmentAuditArrRelInsertInput>;
  consultant?: InputMaybe<UsersObjRelInsertInput>;
  consultantId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isBackup?: InputMaybe<Scalars['Boolean']['input']>;
  originalConsultant?: InputMaybe<UsersObjRelInsertInput>;
  originalConsultantId?: InputMaybe<Scalars['uuid']['input']>;
  payrollDate?: InputMaybe<PayrollDatesObjRelInsertInput>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PayrollAssignmentsMaxFields = {
  __typename?: 'PayrollAssignmentsMaxFields';
  assignedBy?: Maybe<Scalars['uuid']['output']>;
  assignedDate?: Maybe<Scalars['timestamptz']['output']>;
  consultantId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  originalConsultantId?: Maybe<Scalars['uuid']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "payroll_assignments" */
export type PayrollAssignmentsMaxOrderBy = {
  assignedBy?: InputMaybe<OrderBy>;
  assignedDate?: InputMaybe<OrderBy>;
  consultantId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalConsultantId?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PayrollAssignmentsMinFields = {
  __typename?: 'PayrollAssignmentsMinFields';
  assignedBy?: Maybe<Scalars['uuid']['output']>;
  assignedDate?: Maybe<Scalars['timestamptz']['output']>;
  consultantId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  originalConsultantId?: Maybe<Scalars['uuid']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "payroll_assignments" */
export type PayrollAssignmentsMinOrderBy = {
  assignedBy?: InputMaybe<OrderBy>;
  assignedDate?: InputMaybe<OrderBy>;
  consultantId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalConsultantId?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "payroll_assignments" */
export type PayrollAssignmentsMutationResponse = {
  __typename?: 'PayrollAssignmentsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollAssignments>;
};

/** input type for inserting object relation for remote table "payroll_assignments" */
export type PayrollAssignmentsObjRelInsertInput = {
  data: PayrollAssignmentsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollAssignmentsOnConflict>;
};

/** on_conflict condition type for table "payroll_assignments" */
export type PayrollAssignmentsOnConflict = {
  constraint: PayrollAssignmentsConstraint;
  updateColumns?: Array<PayrollAssignmentsUpdateColumn>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};

/** Ordering options when selecting data from "payroll_assignments". */
export type PayrollAssignmentsOrderBy = {
  assignedBy?: InputMaybe<OrderBy>;
  assignedByUser?: InputMaybe<UsersOrderBy>;
  assignedDate?: InputMaybe<OrderBy>;
  auditTrailAggregate?: InputMaybe<PayrollAssignmentAuditAggregateOrderBy>;
  consultant?: InputMaybe<UsersOrderBy>;
  consultantId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isBackup?: InputMaybe<OrderBy>;
  originalConsultant?: InputMaybe<UsersOrderBy>;
  originalConsultantId?: InputMaybe<OrderBy>;
  payrollDate?: InputMaybe<PayrollDatesOrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_assignments */
export type PayrollAssignmentsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_assignments" */
export type PayrollAssignmentsSelectColumn =
  /** column name */
  | 'assignedBy'
  /** column name */
  | 'assignedDate'
  /** column name */
  | 'consultantId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'isBackup'
  /** column name */
  | 'originalConsultantId'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "payrollAssignmentsAggregateBoolExpBool_andArgumentsColumns" columns of table "payroll_assignments" */
export type PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isBackup'
  | '%future added value';

/** select "payrollAssignmentsAggregateBoolExpBool_orArgumentsColumns" columns of table "payroll_assignments" */
export type PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isBackup'
  | '%future added value';

/** input type for updating data in table "payroll_assignments" */
export type PayrollAssignmentsSetInput = {
  assignedBy?: InputMaybe<Scalars['uuid']['input']>;
  assignedDate?: InputMaybe<Scalars['timestamptz']['input']>;
  consultantId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isBackup?: InputMaybe<Scalars['Boolean']['input']>;
  originalConsultantId?: InputMaybe<Scalars['uuid']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "payroll_assignments" */
export type PayrollAssignmentsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollAssignmentsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollAssignmentsStreamCursorValueInput = {
  assignedBy?: InputMaybe<Scalars['uuid']['input']>;
  assignedDate?: InputMaybe<Scalars['timestamptz']['input']>;
  consultantId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isBackup?: InputMaybe<Scalars['Boolean']['input']>;
  originalConsultantId?: InputMaybe<Scalars['uuid']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "payroll_assignments" */
export type PayrollAssignmentsUpdateColumn =
  /** column name */
  | 'assignedBy'
  /** column name */
  | 'assignedDate'
  /** column name */
  | 'consultantId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'isBackup'
  /** column name */
  | 'originalConsultantId'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type PayrollAssignmentsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollAssignmentsSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollAssignmentsBoolExp;
};

/** Comprehensive cost vs revenue analysis for payroll dates */
export type PayrollCostAnalysis = {
  __typename?: 'PayrollCostAnalysis';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingMonth?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  completedBy?: Maybe<Scalars['uuid']['output']>;
  costPerHour?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollDateStatus?: Maybe<Scalars['String']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  profitMarginPercentage?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeMinutes?: Maybe<Scalars['bigint']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "payroll_cost_analysis" */
export type PayrollCostAnalysisAggregate = {
  __typename?: 'PayrollCostAnalysisAggregate';
  aggregate?: Maybe<PayrollCostAnalysisAggregateFields>;
  nodes: Array<PayrollCostAnalysis>;
};

/** aggregate fields of "payroll_cost_analysis" */
export type PayrollCostAnalysisAggregateFields = {
  __typename?: 'PayrollCostAnalysisAggregateFields';
  avg?: Maybe<PayrollCostAnalysisAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollCostAnalysisMaxFields>;
  min?: Maybe<PayrollCostAnalysisMinFields>;
  stddev?: Maybe<PayrollCostAnalysisStddevFields>;
  stddevPop?: Maybe<PayrollCostAnalysisStddevPopFields>;
  stddevSamp?: Maybe<PayrollCostAnalysisStddevSampFields>;
  sum?: Maybe<PayrollCostAnalysisSumFields>;
  varPop?: Maybe<PayrollCostAnalysisVarPopFields>;
  varSamp?: Maybe<PayrollCostAnalysisVarSampFields>;
  variance?: Maybe<PayrollCostAnalysisVarianceFields>;
};


/** aggregate fields of "payroll_cost_analysis" */
export type PayrollCostAnalysisAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollCostAnalysisSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollCostAnalysisAvgFields = {
  __typename?: 'PayrollCostAnalysisAvgFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  costPerHour?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  profitMarginPercentage?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalInternalCost?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeMinutes?: Maybe<Scalars['Float']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_cost_analysis". All fields are combined with a logical 'AND'. */
export type PayrollCostAnalysisBoolExp = {
  _and?: InputMaybe<Array<PayrollCostAnalysisBoolExp>>;
  _not?: InputMaybe<PayrollCostAnalysisBoolExp>;
  _or?: InputMaybe<Array<PayrollCostAnalysisBoolExp>>;
  billingItemsCount?: InputMaybe<BigintComparisonExp>;
  billingMonth?: InputMaybe<TimestamptzComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  completedAt?: InputMaybe<TimestamptzComparisonExp>;
  completedBy?: InputMaybe<UuidComparisonExp>;
  costPerHour?: InputMaybe<NumericComparisonExp>;
  estimatedProfit?: InputMaybe<NumericComparisonExp>;
  payrollDateId?: InputMaybe<UuidComparisonExp>;
  payrollDateStatus?: InputMaybe<StringComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  payrollName?: InputMaybe<StringComparisonExp>;
  profitMarginPercentage?: InputMaybe<NumericComparisonExp>;
  revenuePerHour?: InputMaybe<NumericComparisonExp>;
  totalHours?: InputMaybe<NumericComparisonExp>;
  totalInternalCost?: InputMaybe<NumericComparisonExp>;
  totalRevenue?: InputMaybe<NumericComparisonExp>;
  totalTimeMinutes?: InputMaybe<BigintComparisonExp>;
  uniqueUsersWorked?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type PayrollCostAnalysisMaxFields = {
  __typename?: 'PayrollCostAnalysisMaxFields';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingMonth?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  completedBy?: Maybe<Scalars['uuid']['output']>;
  costPerHour?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollDateStatus?: Maybe<Scalars['String']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  profitMarginPercentage?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeMinutes?: Maybe<Scalars['bigint']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type PayrollCostAnalysisMinFields = {
  __typename?: 'PayrollCostAnalysisMinFields';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingMonth?: Maybe<Scalars['timestamptz']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  completedBy?: Maybe<Scalars['uuid']['output']>;
  costPerHour?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollDateStatus?: Maybe<Scalars['String']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  profitMarginPercentage?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeMinutes?: Maybe<Scalars['bigint']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "payroll_cost_analysis". */
export type PayrollCostAnalysisOrderBy = {
  billingItemsCount?: InputMaybe<OrderBy>;
  billingMonth?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  completedAt?: InputMaybe<OrderBy>;
  completedBy?: InputMaybe<OrderBy>;
  costPerHour?: InputMaybe<OrderBy>;
  estimatedProfit?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  payrollDateStatus?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  payrollName?: InputMaybe<OrderBy>;
  profitMarginPercentage?: InputMaybe<OrderBy>;
  revenuePerHour?: InputMaybe<OrderBy>;
  totalHours?: InputMaybe<OrderBy>;
  totalInternalCost?: InputMaybe<OrderBy>;
  totalRevenue?: InputMaybe<OrderBy>;
  totalTimeMinutes?: InputMaybe<OrderBy>;
  uniqueUsersWorked?: InputMaybe<OrderBy>;
};

/** select columns of table "payroll_cost_analysis" */
export type PayrollCostAnalysisSelectColumn =
  /** column name */
  | 'billingItemsCount'
  /** column name */
  | 'billingMonth'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'completedAt'
  /** column name */
  | 'completedBy'
  /** column name */
  | 'costPerHour'
  /** column name */
  | 'estimatedProfit'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'payrollDateStatus'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'payrollName'
  /** column name */
  | 'profitMarginPercentage'
  /** column name */
  | 'revenuePerHour'
  /** column name */
  | 'totalHours'
  /** column name */
  | 'totalInternalCost'
  /** column name */
  | 'totalRevenue'
  /** column name */
  | 'totalTimeMinutes'
  /** column name */
  | 'uniqueUsersWorked'
  | '%future added value';

/** aggregate stddev on columns */
export type PayrollCostAnalysisStddevFields = {
  __typename?: 'PayrollCostAnalysisStddevFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  costPerHour?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  profitMarginPercentage?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalInternalCost?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeMinutes?: Maybe<Scalars['Float']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollCostAnalysisStddevPopFields = {
  __typename?: 'PayrollCostAnalysisStddevPopFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  costPerHour?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  profitMarginPercentage?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalInternalCost?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeMinutes?: Maybe<Scalars['Float']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollCostAnalysisStddevSampFields = {
  __typename?: 'PayrollCostAnalysisStddevSampFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  costPerHour?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  profitMarginPercentage?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalInternalCost?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeMinutes?: Maybe<Scalars['Float']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_cost_analysis" */
export type PayrollCostAnalysisStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollCostAnalysisStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollCostAnalysisStreamCursorValueInput = {
  billingItemsCount?: InputMaybe<Scalars['bigint']['input']>;
  billingMonth?: InputMaybe<Scalars['timestamptz']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  completedBy?: InputMaybe<Scalars['uuid']['input']>;
  costPerHour?: InputMaybe<Scalars['numeric']['input']>;
  estimatedProfit?: InputMaybe<Scalars['numeric']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  payrollDateStatus?: InputMaybe<Scalars['String']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollName?: InputMaybe<Scalars['String']['input']>;
  profitMarginPercentage?: InputMaybe<Scalars['numeric']['input']>;
  revenuePerHour?: InputMaybe<Scalars['numeric']['input']>;
  totalHours?: InputMaybe<Scalars['numeric']['input']>;
  totalInternalCost?: InputMaybe<Scalars['numeric']['input']>;
  totalRevenue?: InputMaybe<Scalars['numeric']['input']>;
  totalTimeMinutes?: InputMaybe<Scalars['bigint']['input']>;
  uniqueUsersWorked?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type PayrollCostAnalysisSumFields = {
  __typename?: 'PayrollCostAnalysisSumFields';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  costPerHour?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  profitMarginPercentage?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeMinutes?: Maybe<Scalars['bigint']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate varPop on columns */
export type PayrollCostAnalysisVarPopFields = {
  __typename?: 'PayrollCostAnalysisVarPopFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  costPerHour?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  profitMarginPercentage?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalInternalCost?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeMinutes?: Maybe<Scalars['Float']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollCostAnalysisVarSampFields = {
  __typename?: 'PayrollCostAnalysisVarSampFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  costPerHour?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  profitMarginPercentage?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalInternalCost?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeMinutes?: Maybe<Scalars['Float']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollCostAnalysisVarianceFields = {
  __typename?: 'PayrollCostAnalysisVarianceFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  costPerHour?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  profitMarginPercentage?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalInternalCost?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeMinutes?: Maybe<Scalars['Float']['output']>;
  uniqueUsersWorked?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "payroll_cycle_type". All fields are combined with logical 'AND'. */
export type PayrollCycleTypeComparisonExp = {
  _eq?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  _gt?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  _gte?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  _in?: InputMaybe<Array<Scalars['payroll_cycle_type']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  _lte?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  _neq?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  _nin?: InputMaybe<Array<Scalars['payroll_cycle_type']['input']>>;
};

/** columns and relationships of "payroll_cycles" */
export type PayrollCycles = {
  __typename?: 'PayrollCycles';
  /** An array relationship */
  adjustmentRules: Array<AdjustmentRules>;
  /** An aggregate relationship */
  adjustmentRulesAggregate: AdjustmentRulesAggregate;
  /** Timestamp when the cycle was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Detailed description of the payroll cycle */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the payroll cycle */
  id: Scalars['uuid']['output'];
  /** Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.) */
  name: Scalars['payroll_cycle_type']['output'];
  /** An array relationship */
  payrolls: Array<Payrolls>;
  /** An aggregate relationship */
  payrollsAggregate: PayrollsAggregate;
  /** Timestamp when the cycle was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "payroll_cycles" */
export type PayrollCyclesAdjustmentRulesArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


/** columns and relationships of "payroll_cycles" */
export type PayrollCyclesAdjustmentRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


/** columns and relationships of "payroll_cycles" */
export type PayrollCyclesPayrollsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "payroll_cycles" */
export type PayrollCyclesPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};

/** aggregated selection of "payroll_cycles" */
export type PayrollCyclesAggregate = {
  __typename?: 'PayrollCyclesAggregate';
  aggregate?: Maybe<PayrollCyclesAggregateFields>;
  nodes: Array<PayrollCycles>;
};

/** aggregate fields of "payroll_cycles" */
export type PayrollCyclesAggregateFields = {
  __typename?: 'PayrollCyclesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollCyclesMaxFields>;
  min?: Maybe<PayrollCyclesMinFields>;
};


/** aggregate fields of "payroll_cycles" */
export type PayrollCyclesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollCyclesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "payroll_cycles". All fields are combined with a logical 'AND'. */
export type PayrollCyclesBoolExp = {
  _and?: InputMaybe<Array<PayrollCyclesBoolExp>>;
  _not?: InputMaybe<PayrollCyclesBoolExp>;
  _or?: InputMaybe<Array<PayrollCyclesBoolExp>>;
  adjustmentRules?: InputMaybe<AdjustmentRulesBoolExp>;
  adjustmentRulesAggregate?: InputMaybe<AdjustmentRulesAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<PayrollCycleTypeComparisonExp>;
  payrolls?: InputMaybe<PayrollsBoolExp>;
  payrollsAggregate?: InputMaybe<PayrollsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "payroll_cycles" */
export type PayrollCyclesConstraint =
  /** unique or primary key constraint on columns "name" */
  | 'payroll_cycles_name_key'
  /** unique or primary key constraint on columns "id" */
  | 'payroll_cycles_pkey'
  | '%future added value';

/** input type for inserting data into table "payroll_cycles" */
export type PayrollCyclesInsertInput = {
  adjustmentRules?: InputMaybe<AdjustmentRulesArrRelInsertInput>;
  /** Timestamp when the cycle was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Detailed description of the payroll cycle */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the payroll cycle */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.) */
  name?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  payrolls?: InputMaybe<PayrollsArrRelInsertInput>;
  /** Timestamp when the cycle was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PayrollCyclesMaxFields = {
  __typename?: 'PayrollCyclesMaxFields';
  /** Timestamp when the cycle was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Detailed description of the payroll cycle */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the payroll cycle */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.) */
  name?: Maybe<Scalars['payroll_cycle_type']['output']>;
  /** Timestamp when the cycle was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type PayrollCyclesMinFields = {
  __typename?: 'PayrollCyclesMinFields';
  /** Timestamp when the cycle was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Detailed description of the payroll cycle */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the payroll cycle */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.) */
  name?: Maybe<Scalars['payroll_cycle_type']['output']>;
  /** Timestamp when the cycle was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "payroll_cycles" */
export type PayrollCyclesMutationResponse = {
  __typename?: 'PayrollCyclesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollCycles>;
};

/** input type for inserting object relation for remote table "payroll_cycles" */
export type PayrollCyclesObjRelInsertInput = {
  data: PayrollCyclesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollCyclesOnConflict>;
};

/** on_conflict condition type for table "payroll_cycles" */
export type PayrollCyclesOnConflict = {
  constraint: PayrollCyclesConstraint;
  updateColumns?: Array<PayrollCyclesUpdateColumn>;
  where?: InputMaybe<PayrollCyclesBoolExp>;
};

/** Ordering options when selecting data from "payroll_cycles". */
export type PayrollCyclesOrderBy = {
  adjustmentRulesAggregate?: InputMaybe<AdjustmentRulesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payrollsAggregate?: InputMaybe<PayrollsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_cycles */
export type PayrollCyclesPkColumnsInput = {
  /** Unique identifier for the payroll cycle */
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_cycles" */
export type PayrollCyclesSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "payroll_cycles" */
export type PayrollCyclesSetInput = {
  /** Timestamp when the cycle was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Detailed description of the payroll cycle */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the payroll cycle */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.) */
  name?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  /** Timestamp when the cycle was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "payroll_cycles" */
export type PayrollCyclesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollCyclesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollCyclesStreamCursorValueInput = {
  /** Timestamp when the cycle was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Detailed description of the payroll cycle */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the payroll cycle */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the payroll cycle (Weekly, Biweekly, Monthly, etc.) */
  name?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  /** Timestamp when the cycle was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "payroll_cycles" */
export type PayrollCyclesUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type PayrollCyclesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollCyclesSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollCyclesBoolExp;
};

/** columns and relationships of "payroll_dashboard_stats" */
export type PayrollDashboardStats = {
  __typename?: 'PayrollDashboardStats';
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  cycleName?: Maybe<Scalars['payroll_cycle_type']['output']>;
  futureDates?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextEftDate?: Maybe<Scalars['date']['output']>;
  pastDates?: Maybe<Scalars['bigint']['output']>;
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['payroll_status']['output']>;
  totalDates?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "payroll_dashboard_stats" */
export type PayrollDashboardStatsAggregate = {
  __typename?: 'PayrollDashboardStatsAggregate';
  aggregate?: Maybe<PayrollDashboardStatsAggregateFields>;
  nodes: Array<PayrollDashboardStats>;
};

/** aggregate fields of "payroll_dashboard_stats" */
export type PayrollDashboardStatsAggregateFields = {
  __typename?: 'PayrollDashboardStatsAggregateFields';
  avg?: Maybe<PayrollDashboardStatsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollDashboardStatsMaxFields>;
  min?: Maybe<PayrollDashboardStatsMinFields>;
  stddev?: Maybe<PayrollDashboardStatsStddevFields>;
  stddevPop?: Maybe<PayrollDashboardStatsStddevPopFields>;
  stddevSamp?: Maybe<PayrollDashboardStatsStddevSampFields>;
  sum?: Maybe<PayrollDashboardStatsSumFields>;
  varPop?: Maybe<PayrollDashboardStatsVarPopFields>;
  varSamp?: Maybe<PayrollDashboardStatsVarSampFields>;
  variance?: Maybe<PayrollDashboardStatsVarianceFields>;
};


/** aggregate fields of "payroll_dashboard_stats" */
export type PayrollDashboardStatsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollDashboardStatsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollDashboardStatsAvgFields = {
  __typename?: 'PayrollDashboardStatsAvgFields';
  futureDates?: Maybe<Scalars['Float']['output']>;
  pastDates?: Maybe<Scalars['Float']['output']>;
  totalDates?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_dashboard_stats". All fields are combined with a logical 'AND'. */
export type PayrollDashboardStatsBoolExp = {
  _and?: InputMaybe<Array<PayrollDashboardStatsBoolExp>>;
  _not?: InputMaybe<PayrollDashboardStatsBoolExp>;
  _or?: InputMaybe<Array<PayrollDashboardStatsBoolExp>>;
  backupConsultantUserId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  cycleName?: InputMaybe<PayrollCycleTypeComparisonExp>;
  futureDates?: InputMaybe<BigintComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  managerUserId?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  nextEftDate?: InputMaybe<DateComparisonExp>;
  pastDates?: InputMaybe<BigintComparisonExp>;
  primaryConsultantUserId?: InputMaybe<UuidComparisonExp>;
  status?: InputMaybe<PayrollStatusComparisonExp>;
  totalDates?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type PayrollDashboardStatsMaxFields = {
  __typename?: 'PayrollDashboardStatsMaxFields';
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  cycleName?: Maybe<Scalars['payroll_cycle_type']['output']>;
  futureDates?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextEftDate?: Maybe<Scalars['date']['output']>;
  pastDates?: Maybe<Scalars['bigint']['output']>;
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['payroll_status']['output']>;
  totalDates?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type PayrollDashboardStatsMinFields = {
  __typename?: 'PayrollDashboardStatsMinFields';
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  cycleName?: Maybe<Scalars['payroll_cycle_type']['output']>;
  futureDates?: Maybe<Scalars['bigint']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nextEftDate?: Maybe<Scalars['date']['output']>;
  pastDates?: Maybe<Scalars['bigint']['output']>;
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['payroll_status']['output']>;
  totalDates?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "payroll_dashboard_stats". */
export type PayrollDashboardStatsOrderBy = {
  backupConsultantUserId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  cycleName?: InputMaybe<OrderBy>;
  futureDates?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  managerUserId?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  nextEftDate?: InputMaybe<OrderBy>;
  pastDates?: InputMaybe<OrderBy>;
  primaryConsultantUserId?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalDates?: InputMaybe<OrderBy>;
};

/** select columns of table "payroll_dashboard_stats" */
export type PayrollDashboardStatsSelectColumn =
  /** column name */
  | 'backupConsultantUserId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'cycleName'
  /** column name */
  | 'futureDates'
  /** column name */
  | 'id'
  /** column name */
  | 'managerUserId'
  /** column name */
  | 'name'
  /** column name */
  | 'nextEftDate'
  /** column name */
  | 'pastDates'
  /** column name */
  | 'primaryConsultantUserId'
  /** column name */
  | 'status'
  /** column name */
  | 'totalDates'
  | '%future added value';

/** aggregate stddev on columns */
export type PayrollDashboardStatsStddevFields = {
  __typename?: 'PayrollDashboardStatsStddevFields';
  futureDates?: Maybe<Scalars['Float']['output']>;
  pastDates?: Maybe<Scalars['Float']['output']>;
  totalDates?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollDashboardStatsStddevPopFields = {
  __typename?: 'PayrollDashboardStatsStddevPopFields';
  futureDates?: Maybe<Scalars['Float']['output']>;
  pastDates?: Maybe<Scalars['Float']['output']>;
  totalDates?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollDashboardStatsStddevSampFields = {
  __typename?: 'PayrollDashboardStatsStddevSampFields';
  futureDates?: Maybe<Scalars['Float']['output']>;
  pastDates?: Maybe<Scalars['Float']['output']>;
  totalDates?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_dashboard_stats" */
export type PayrollDashboardStatsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollDashboardStatsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollDashboardStatsStreamCursorValueInput = {
  backupConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  cycleName?: InputMaybe<Scalars['payroll_cycle_type']['input']>;
  futureDates?: InputMaybe<Scalars['bigint']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  managerUserId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nextEftDate?: InputMaybe<Scalars['date']['input']>;
  pastDates?: InputMaybe<Scalars['bigint']['input']>;
  primaryConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  status?: InputMaybe<Scalars['payroll_status']['input']>;
  totalDates?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type PayrollDashboardStatsSumFields = {
  __typename?: 'PayrollDashboardStatsSumFields';
  futureDates?: Maybe<Scalars['bigint']['output']>;
  pastDates?: Maybe<Scalars['bigint']['output']>;
  totalDates?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate varPop on columns */
export type PayrollDashboardStatsVarPopFields = {
  __typename?: 'PayrollDashboardStatsVarPopFields';
  futureDates?: Maybe<Scalars['Float']['output']>;
  pastDates?: Maybe<Scalars['Float']['output']>;
  totalDates?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollDashboardStatsVarSampFields = {
  __typename?: 'PayrollDashboardStatsVarSampFields';
  futureDates?: Maybe<Scalars['Float']['output']>;
  pastDates?: Maybe<Scalars['Float']['output']>;
  totalDates?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollDashboardStatsVarianceFields = {
  __typename?: 'PayrollDashboardStatsVarianceFields';
  futureDates?: Maybe<Scalars['Float']['output']>;
  pastDates?: Maybe<Scalars['Float']['output']>;
  totalDates?: Maybe<Scalars['Float']['output']>;
};

/** Comprehensive analytics view for payroll date completion, time tracking, and cost/revenue analysis */
export type PayrollDateCompletionAnalytics = {
  __typename?: 'PayrollDateCompletionAnalytics';
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  completedBy?: Maybe<Scalars['uuid']['output']>;
  completedByName?: Maybe<Scalars['String']['output']>;
  completionNotes?: Maybe<Scalars['String']['output']>;
  estimatedCost?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  originalEftDate?: Maybe<Scalars['date']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  processingDate?: Maybe<Scalars['date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  timeBreakdown?: Maybe<Scalars['json']['output']>;
  totalHoursSpent?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
};


/** Comprehensive analytics view for payroll date completion, time tracking, and cost/revenue analysis */
export type PayrollDateCompletionAnalyticsTimeBreakdownArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "payroll_date_completion_analytics" */
export type PayrollDateCompletionAnalyticsAggregate = {
  __typename?: 'PayrollDateCompletionAnalyticsAggregate';
  aggregate?: Maybe<PayrollDateCompletionAnalyticsAggregateFields>;
  nodes: Array<PayrollDateCompletionAnalytics>;
};

/** aggregate fields of "payroll_date_completion_analytics" */
export type PayrollDateCompletionAnalyticsAggregateFields = {
  __typename?: 'PayrollDateCompletionAnalyticsAggregateFields';
  avg?: Maybe<PayrollDateCompletionAnalyticsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollDateCompletionAnalyticsMaxFields>;
  min?: Maybe<PayrollDateCompletionAnalyticsMinFields>;
  stddev?: Maybe<PayrollDateCompletionAnalyticsStddevFields>;
  stddevPop?: Maybe<PayrollDateCompletionAnalyticsStddevPopFields>;
  stddevSamp?: Maybe<PayrollDateCompletionAnalyticsStddevSampFields>;
  sum?: Maybe<PayrollDateCompletionAnalyticsSumFields>;
  varPop?: Maybe<PayrollDateCompletionAnalyticsVarPopFields>;
  varSamp?: Maybe<PayrollDateCompletionAnalyticsVarSampFields>;
  variance?: Maybe<PayrollDateCompletionAnalyticsVarianceFields>;
};


/** aggregate fields of "payroll_date_completion_analytics" */
export type PayrollDateCompletionAnalyticsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollDateCompletionAnalyticsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollDateCompletionAnalyticsAvgFields = {
  __typename?: 'PayrollDateCompletionAnalyticsAvgFields';
  estimatedCost?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  totalHoursSpent?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_date_completion_analytics". All fields are combined with a logical 'AND'. */
export type PayrollDateCompletionAnalyticsBoolExp = {
  _and?: InputMaybe<Array<PayrollDateCompletionAnalyticsBoolExp>>;
  _not?: InputMaybe<PayrollDateCompletionAnalyticsBoolExp>;
  _or?: InputMaybe<Array<PayrollDateCompletionAnalyticsBoolExp>>;
  adjustedEftDate?: InputMaybe<DateComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  completedAt?: InputMaybe<TimestamptzComparisonExp>;
  completedBy?: InputMaybe<UuidComparisonExp>;
  completedByName?: InputMaybe<StringComparisonExp>;
  completionNotes?: InputMaybe<StringComparisonExp>;
  estimatedCost?: InputMaybe<NumericComparisonExp>;
  estimatedProfit?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  originalEftDate?: InputMaybe<DateComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  payrollName?: InputMaybe<StringComparisonExp>;
  processingDate?: InputMaybe<DateComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  timeBreakdown?: InputMaybe<JsonComparisonExp>;
  totalHoursSpent?: InputMaybe<NumericComparisonExp>;
  totalRevenue?: InputMaybe<NumericComparisonExp>;
  totalTimeSpentMinutes?: InputMaybe<IntComparisonExp>;
};

/** aggregate max on columns */
export type PayrollDateCompletionAnalyticsMaxFields = {
  __typename?: 'PayrollDateCompletionAnalyticsMaxFields';
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  completedBy?: Maybe<Scalars['uuid']['output']>;
  completedByName?: Maybe<Scalars['String']['output']>;
  completionNotes?: Maybe<Scalars['String']['output']>;
  estimatedCost?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  originalEftDate?: Maybe<Scalars['date']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  processingDate?: Maybe<Scalars['date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalHoursSpent?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type PayrollDateCompletionAnalyticsMinFields = {
  __typename?: 'PayrollDateCompletionAnalyticsMinFields';
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  completedBy?: Maybe<Scalars['uuid']['output']>;
  completedByName?: Maybe<Scalars['String']['output']>;
  completionNotes?: Maybe<Scalars['String']['output']>;
  estimatedCost?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  originalEftDate?: Maybe<Scalars['date']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  processingDate?: Maybe<Scalars['date']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalHoursSpent?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
};

/** Ordering options when selecting data from "payroll_date_completion_analytics". */
export type PayrollDateCompletionAnalyticsOrderBy = {
  adjustedEftDate?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  completedAt?: InputMaybe<OrderBy>;
  completedBy?: InputMaybe<OrderBy>;
  completedByName?: InputMaybe<OrderBy>;
  completionNotes?: InputMaybe<OrderBy>;
  estimatedCost?: InputMaybe<OrderBy>;
  estimatedProfit?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  originalEftDate?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  payrollName?: InputMaybe<OrderBy>;
  processingDate?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  timeBreakdown?: InputMaybe<OrderBy>;
  totalHoursSpent?: InputMaybe<OrderBy>;
  totalRevenue?: InputMaybe<OrderBy>;
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** select columns of table "payroll_date_completion_analytics" */
export type PayrollDateCompletionAnalyticsSelectColumn =
  /** column name */
  | 'adjustedEftDate'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'completedAt'
  /** column name */
  | 'completedBy'
  /** column name */
  | 'completedByName'
  /** column name */
  | 'completionNotes'
  /** column name */
  | 'estimatedCost'
  /** column name */
  | 'estimatedProfit'
  /** column name */
  | 'id'
  /** column name */
  | 'originalEftDate'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'payrollName'
  /** column name */
  | 'processingDate'
  /** column name */
  | 'status'
  /** column name */
  | 'timeBreakdown'
  /** column name */
  | 'totalHoursSpent'
  /** column name */
  | 'totalRevenue'
  /** column name */
  | 'totalTimeSpentMinutes'
  | '%future added value';

/** aggregate stddev on columns */
export type PayrollDateCompletionAnalyticsStddevFields = {
  __typename?: 'PayrollDateCompletionAnalyticsStddevFields';
  estimatedCost?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  totalHoursSpent?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollDateCompletionAnalyticsStddevPopFields = {
  __typename?: 'PayrollDateCompletionAnalyticsStddevPopFields';
  estimatedCost?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  totalHoursSpent?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollDateCompletionAnalyticsStddevSampFields = {
  __typename?: 'PayrollDateCompletionAnalyticsStddevSampFields';
  estimatedCost?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  totalHoursSpent?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_date_completion_analytics" */
export type PayrollDateCompletionAnalyticsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollDateCompletionAnalyticsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollDateCompletionAnalyticsStreamCursorValueInput = {
  adjustedEftDate?: InputMaybe<Scalars['date']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  completedBy?: InputMaybe<Scalars['uuid']['input']>;
  completedByName?: InputMaybe<Scalars['String']['input']>;
  completionNotes?: InputMaybe<Scalars['String']['input']>;
  estimatedCost?: InputMaybe<Scalars['numeric']['input']>;
  estimatedProfit?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  originalEftDate?: InputMaybe<Scalars['date']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollName?: InputMaybe<Scalars['String']['input']>;
  processingDate?: InputMaybe<Scalars['date']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  timeBreakdown?: InputMaybe<Scalars['json']['input']>;
  totalHoursSpent?: InputMaybe<Scalars['numeric']['input']>;
  totalRevenue?: InputMaybe<Scalars['numeric']['input']>;
  totalTimeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type PayrollDateCompletionAnalyticsSumFields = {
  __typename?: 'PayrollDateCompletionAnalyticsSumFields';
  estimatedCost?: Maybe<Scalars['numeric']['output']>;
  estimatedProfit?: Maybe<Scalars['numeric']['output']>;
  totalHoursSpent?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
};

/** aggregate varPop on columns */
export type PayrollDateCompletionAnalyticsVarPopFields = {
  __typename?: 'PayrollDateCompletionAnalyticsVarPopFields';
  estimatedCost?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  totalHoursSpent?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollDateCompletionAnalyticsVarSampFields = {
  __typename?: 'PayrollDateCompletionAnalyticsVarSampFields';
  estimatedCost?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  totalHoursSpent?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollDateCompletionAnalyticsVarianceFields = {
  __typename?: 'PayrollDateCompletionAnalyticsVarianceFields';
  estimatedCost?: Maybe<Scalars['Float']['output']>;
  estimatedProfit?: Maybe<Scalars['Float']['output']>;
  totalHoursSpent?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** Detailed time tracking for individual users working on payroll dates */
export type PayrollDateTimeEntries = {
  __typename?: 'PayrollDateTimeEntries';
  billingNotes?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['uuid']['output'];
  /** Whether this time should be included in client billing */
  isBillable?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  payrollDate: PayrollDates;
  payrollDateId: Scalars['uuid']['output'];
  timeSpentMinutes: Scalars['Int']['output'];
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
  workDate: Scalars['date']['output'];
};

/** aggregated selection of "payroll_date_time_entries" */
export type PayrollDateTimeEntriesAggregate = {
  __typename?: 'PayrollDateTimeEntriesAggregate';
  aggregate?: Maybe<PayrollDateTimeEntriesAggregateFields>;
  nodes: Array<PayrollDateTimeEntries>;
};

export type PayrollDateTimeEntriesAggregateBoolExp = {
  bool_and?: InputMaybe<PayrollDateTimeEntriesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<PayrollDateTimeEntriesAggregateBoolExpBool_Or>;
  count?: InputMaybe<PayrollDateTimeEntriesAggregateBoolExpCount>;
};

/** aggregate fields of "payroll_date_time_entries" */
export type PayrollDateTimeEntriesAggregateFields = {
  __typename?: 'PayrollDateTimeEntriesAggregateFields';
  avg?: Maybe<PayrollDateTimeEntriesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollDateTimeEntriesMaxFields>;
  min?: Maybe<PayrollDateTimeEntriesMinFields>;
  stddev?: Maybe<PayrollDateTimeEntriesStddevFields>;
  stddevPop?: Maybe<PayrollDateTimeEntriesStddevPopFields>;
  stddevSamp?: Maybe<PayrollDateTimeEntriesStddevSampFields>;
  sum?: Maybe<PayrollDateTimeEntriesSumFields>;
  varPop?: Maybe<PayrollDateTimeEntriesVarPopFields>;
  varSamp?: Maybe<PayrollDateTimeEntriesVarSampFields>;
  variance?: Maybe<PayrollDateTimeEntriesVarianceFields>;
};


/** aggregate fields of "payroll_date_time_entries" */
export type PayrollDateTimeEntriesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesAggregateOrderBy = {
  avg?: InputMaybe<PayrollDateTimeEntriesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PayrollDateTimeEntriesMaxOrderBy>;
  min?: InputMaybe<PayrollDateTimeEntriesMinOrderBy>;
  stddev?: InputMaybe<PayrollDateTimeEntriesStddevOrderBy>;
  stddevPop?: InputMaybe<PayrollDateTimeEntriesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<PayrollDateTimeEntriesStddevSampOrderBy>;
  sum?: InputMaybe<PayrollDateTimeEntriesSumOrderBy>;
  varPop?: InputMaybe<PayrollDateTimeEntriesVarPopOrderBy>;
  varSamp?: InputMaybe<PayrollDateTimeEntriesVarSampOrderBy>;
  variance?: InputMaybe<PayrollDateTimeEntriesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesArrRelInsertInput = {
  data: Array<PayrollDateTimeEntriesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollDateTimeEntriesOnConflict>;
};

/** aggregate avg on columns */
export type PayrollDateTimeEntriesAvgFields = {
  __typename?: 'PayrollDateTimeEntriesAvgFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['Float']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Float']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesAvgOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "payroll_date_time_entries". All fields are combined with a logical 'AND'. */
export type PayrollDateTimeEntriesBoolExp = {
  _and?: InputMaybe<Array<PayrollDateTimeEntriesBoolExp>>;
  _not?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
  _or?: InputMaybe<Array<PayrollDateTimeEntriesBoolExp>>;
  billingNotes?: InputMaybe<StringComparisonExp>;
  costCenter?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  hourlyRateUsed?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBillable?: InputMaybe<BooleanComparisonExp>;
  payrollDate?: InputMaybe<PayrollDatesBoolExp>;
  payrollDateId?: InputMaybe<UuidComparisonExp>;
  timeSpentMinutes?: InputMaybe<IntComparisonExp>;
  totalCost?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  workDate?: InputMaybe<DateComparisonExp>;
};

/** unique or primary key constraints on table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesConstraint =
  /** unique or primary key constraint on columns "user_id", "work_date", "payroll_date_id" */
  | 'payroll_date_time_entries_payroll_date_id_user_id_work_date_key'
  /** unique or primary key constraint on columns "id" */
  | 'payroll_date_time_entries_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesIncInput = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<Scalars['numeric']['input']>;
  timeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesInsertInput = {
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  costCenter?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether this time should be included in client billing */
  isBillable?: InputMaybe<Scalars['Boolean']['input']>;
  payrollDate?: InputMaybe<PayrollDatesObjRelInsertInput>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  timeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  workDate?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate max on columns */
export type PayrollDateTimeEntriesMaxFields = {
  __typename?: 'PayrollDateTimeEntriesMaxFields';
  billingNotes?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Int']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  workDate?: Maybe<Scalars['date']['output']>;
};

/** order by max() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesMaxOrderBy = {
  billingNotes?: InputMaybe<OrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  workDate?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PayrollDateTimeEntriesMinFields = {
  __typename?: 'PayrollDateTimeEntriesMinFields';
  billingNotes?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Int']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  workDate?: Maybe<Scalars['date']['output']>;
};

/** order by min() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesMinOrderBy = {
  billingNotes?: InputMaybe<OrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  workDate?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesMutationResponse = {
  __typename?: 'PayrollDateTimeEntriesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollDateTimeEntries>;
};

/** on_conflict condition type for table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesOnConflict = {
  constraint: PayrollDateTimeEntriesConstraint;
  updateColumns?: Array<PayrollDateTimeEntriesUpdateColumn>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};

/** Ordering options when selecting data from "payroll_date_time_entries". */
export type PayrollDateTimeEntriesOrderBy = {
  billingNotes?: InputMaybe<OrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  hourlyRateUsed?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isBillable?: InputMaybe<OrderBy>;
  payrollDate?: InputMaybe<PayrollDatesOrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  totalCost?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  workDate?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_date_time_entries */
export type PayrollDateTimeEntriesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesSelectColumn =
  /** column name */
  | 'billingNotes'
  /** column name */
  | 'costCenter'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'hourlyRateUsed'
  /** column name */
  | 'id'
  /** column name */
  | 'isBillable'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'timeSpentMinutes'
  /** column name */
  | 'totalCost'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  /** column name */
  | 'workDate'
  | '%future added value';

/** select "payrollDateTimeEntriesAggregateBoolExpBool_andArgumentsColumns" columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesSelectColumnPayrollDateTimeEntriesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isBillable'
  | '%future added value';

/** select "payrollDateTimeEntriesAggregateBoolExpBool_orArgumentsColumns" columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesSelectColumnPayrollDateTimeEntriesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isBillable'
  | '%future added value';

/** input type for updating data in table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesSetInput = {
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  costCenter?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether this time should be included in client billing */
  isBillable?: InputMaybe<Scalars['Boolean']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  timeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  workDate?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate stddev on columns */
export type PayrollDateTimeEntriesStddevFields = {
  __typename?: 'PayrollDateTimeEntriesStddevFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['Float']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Float']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesStddevOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type PayrollDateTimeEntriesStddevPopFields = {
  __typename?: 'PayrollDateTimeEntriesStddevPopFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['Float']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Float']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesStddevPopOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type PayrollDateTimeEntriesStddevSampFields = {
  __typename?: 'PayrollDateTimeEntriesStddevSampFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['Float']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Float']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesStddevSampOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollDateTimeEntriesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollDateTimeEntriesStreamCursorValueInput = {
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  costCenter?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether this time should be included in client billing */
  isBillable?: InputMaybe<Scalars['Boolean']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  timeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  workDate?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type PayrollDateTimeEntriesSumFields = {
  __typename?: 'PayrollDateTimeEntriesSumFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['numeric']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Int']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesSumOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** update columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesUpdateColumn =
  /** column name */
  | 'billingNotes'
  /** column name */
  | 'costCenter'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'hourlyRateUsed'
  /** column name */
  | 'id'
  /** column name */
  | 'isBillable'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'timeSpentMinutes'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  /** column name */
  | 'workDate'
  | '%future added value';

export type PayrollDateTimeEntriesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PayrollDateTimeEntriesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollDateTimeEntriesSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollDateTimeEntriesBoolExp;
};

/** aggregate varPop on columns */
export type PayrollDateTimeEntriesVarPopFields = {
  __typename?: 'PayrollDateTimeEntriesVarPopFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['Float']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Float']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesVarPopOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type PayrollDateTimeEntriesVarSampFields = {
  __typename?: 'PayrollDateTimeEntriesVarSampFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['Float']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Float']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesVarSampOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PayrollDateTimeEntriesVarianceFields = {
  __typename?: 'PayrollDateTimeEntriesVarianceFields';
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: Maybe<Scalars['Float']['output']>;
  timeSpentMinutes?: Maybe<Scalars['Float']['output']>;
  /** Calculated internal cost (time * rate) */
  totalCost?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "payroll_date_time_entries" */
export type PayrollDateTimeEntriesVarianceOrderBy = {
  /** Hourly rate applied when this time entry was created */
  hourlyRateUsed?: InputMaybe<OrderBy>;
  timeSpentMinutes?: InputMaybe<OrderBy>;
  /** Calculated internal cost (time * rate) */
  totalCost?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "payroll_date_type". All fields are combined with logical 'AND'. */
export type PayrollDateTypeComparisonExp = {
  _eq?: InputMaybe<Scalars['payroll_date_type']['input']>;
  _gt?: InputMaybe<Scalars['payroll_date_type']['input']>;
  _gte?: InputMaybe<Scalars['payroll_date_type']['input']>;
  _in?: InputMaybe<Array<Scalars['payroll_date_type']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['payroll_date_type']['input']>;
  _lte?: InputMaybe<Scalars['payroll_date_type']['input']>;
  _neq?: InputMaybe<Scalars['payroll_date_type']['input']>;
  _nin?: InputMaybe<Array<Scalars['payroll_date_type']['input']>>;
};

/** columns and relationships of "payroll_date_types" */
export type PayrollDateTypes = {
  __typename?: 'PayrollDateTypes';
  /** An array relationship */
  adjustmentRules: Array<AdjustmentRules>;
  /** An aggregate relationship */
  adjustmentRulesAggregate: AdjustmentRulesAggregate;
  /** Timestamp when the date type was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Detailed description of how this date type works */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the payroll date type */
  id: Scalars['uuid']['output'];
  /** Name of the date type (Fixed, Last Working Day, etc.) */
  name: Scalars['payroll_date_type']['output'];
  /** An array relationship */
  payrolls: Array<Payrolls>;
  /** An aggregate relationship */
  payrollsAggregate: PayrollsAggregate;
  /** Timestamp when the date type was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "payroll_date_types" */
export type PayrollDateTypesAdjustmentRulesArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


/** columns and relationships of "payroll_date_types" */
export type PayrollDateTypesAdjustmentRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


/** columns and relationships of "payroll_date_types" */
export type PayrollDateTypesPayrollsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "payroll_date_types" */
export type PayrollDateTypesPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};

/** aggregated selection of "payroll_date_types" */
export type PayrollDateTypesAggregate = {
  __typename?: 'PayrollDateTypesAggregate';
  aggregate?: Maybe<PayrollDateTypesAggregateFields>;
  nodes: Array<PayrollDateTypes>;
};

/** aggregate fields of "payroll_date_types" */
export type PayrollDateTypesAggregateFields = {
  __typename?: 'PayrollDateTypesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollDateTypesMaxFields>;
  min?: Maybe<PayrollDateTypesMinFields>;
};


/** aggregate fields of "payroll_date_types" */
export type PayrollDateTypesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollDateTypesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "payroll_date_types". All fields are combined with a logical 'AND'. */
export type PayrollDateTypesBoolExp = {
  _and?: InputMaybe<Array<PayrollDateTypesBoolExp>>;
  _not?: InputMaybe<PayrollDateTypesBoolExp>;
  _or?: InputMaybe<Array<PayrollDateTypesBoolExp>>;
  adjustmentRules?: InputMaybe<AdjustmentRulesBoolExp>;
  adjustmentRulesAggregate?: InputMaybe<AdjustmentRulesAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<PayrollDateTypeComparisonExp>;
  payrolls?: InputMaybe<PayrollsBoolExp>;
  payrollsAggregate?: InputMaybe<PayrollsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "payroll_date_types" */
export type PayrollDateTypesConstraint =
  /** unique or primary key constraint on columns "name" */
  | 'payroll_date_types_name_key'
  /** unique or primary key constraint on columns "id" */
  | 'payroll_date_types_pkey'
  | '%future added value';

/** input type for inserting data into table "payroll_date_types" */
export type PayrollDateTypesInsertInput = {
  adjustmentRules?: InputMaybe<AdjustmentRulesArrRelInsertInput>;
  /** Timestamp when the date type was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Detailed description of how this date type works */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the payroll date type */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the date type (Fixed, Last Working Day, etc.) */
  name?: InputMaybe<Scalars['payroll_date_type']['input']>;
  payrolls?: InputMaybe<PayrollsArrRelInsertInput>;
  /** Timestamp when the date type was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PayrollDateTypesMaxFields = {
  __typename?: 'PayrollDateTypesMaxFields';
  /** Timestamp when the date type was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Detailed description of how this date type works */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the payroll date type */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Name of the date type (Fixed, Last Working Day, etc.) */
  name?: Maybe<Scalars['payroll_date_type']['output']>;
  /** Timestamp when the date type was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type PayrollDateTypesMinFields = {
  __typename?: 'PayrollDateTypesMinFields';
  /** Timestamp when the date type was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Detailed description of how this date type works */
  description?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the payroll date type */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Name of the date type (Fixed, Last Working Day, etc.) */
  name?: Maybe<Scalars['payroll_date_type']['output']>;
  /** Timestamp when the date type was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "payroll_date_types" */
export type PayrollDateTypesMutationResponse = {
  __typename?: 'PayrollDateTypesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollDateTypes>;
};

/** input type for inserting object relation for remote table "payroll_date_types" */
export type PayrollDateTypesObjRelInsertInput = {
  data: PayrollDateTypesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollDateTypesOnConflict>;
};

/** on_conflict condition type for table "payroll_date_types" */
export type PayrollDateTypesOnConflict = {
  constraint: PayrollDateTypesConstraint;
  updateColumns?: Array<PayrollDateTypesUpdateColumn>;
  where?: InputMaybe<PayrollDateTypesBoolExp>;
};

/** Ordering options when selecting data from "payroll_date_types". */
export type PayrollDateTypesOrderBy = {
  adjustmentRulesAggregate?: InputMaybe<AdjustmentRulesAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payrollsAggregate?: InputMaybe<PayrollsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_date_types */
export type PayrollDateTypesPkColumnsInput = {
  /** Unique identifier for the payroll date type */
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_date_types" */
export type PayrollDateTypesSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "payroll_date_types" */
export type PayrollDateTypesSetInput = {
  /** Timestamp when the date type was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Detailed description of how this date type works */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the payroll date type */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the date type (Fixed, Last Working Day, etc.) */
  name?: InputMaybe<Scalars['payroll_date_type']['input']>;
  /** Timestamp when the date type was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "payroll_date_types" */
export type PayrollDateTypesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollDateTypesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollDateTypesStreamCursorValueInput = {
  /** Timestamp when the date type was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Detailed description of how this date type works */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the payroll date type */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the date type (Fixed, Last Working Day, etc.) */
  name?: InputMaybe<Scalars['payroll_date_type']['input']>;
  /** Timestamp when the date type was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "payroll_date_types" */
export type PayrollDateTypesUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type PayrollDateTypesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollDateTypesSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollDateTypesBoolExp;
};

/** columns and relationships of "payroll_dates" */
export type PayrollDates = {
  __typename?: 'PayrollDates';
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate: Scalars['date']['output'];
  /** An object relationship */
  assignmentDetails?: Maybe<PayrollAssignments>;
  /** An array relationship */
  billingItems: Array<BillingItems>;
  /** An aggregate relationship */
  billingItemsAggregate: BillingItemsAggregate;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User who marked the payroll date as completed */
  completedBy?: Maybe<Scalars['uuid']['output']>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the date record was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique identifier for the payroll date */
  id: Scalars['uuid']['output'];
  /** Additional notes about this payroll date */
  notes?: Maybe<Scalars['String']['output']>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate: Scalars['date']['output'];
  /** An object relationship */
  payroll: Payrolls;
  /** An array relationship */
  payrollAssignments: Array<PayrollAssignmentAudit>;
  /** An aggregate relationship */
  payrollAssignmentsAggregate: PayrollAssignmentAuditAggregate;
  /** An array relationship */
  payrollDateTimeEntries: Array<PayrollDateTimeEntries>;
  /** An aggregate relationship */
  payrollDateTimeEntriesAggregate: PayrollDateTimeEntriesAggregate;
  /** Reference to the payroll this date belongs to */
  payrollId: Scalars['uuid']['output'];
  /** Date when payroll processing must be completed */
  processingDate: Scalars['date']['output'];
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  timeEntries: Array<TimeEntries>;
  /** An aggregate relationship */
  timeEntriesAggregate: TimeEntriesAggregate;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the date record was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesPayrollAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesPayrollAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesPayrollDateTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesPayrollDateTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


/** columns and relationships of "payroll_dates" */
export type PayrollDatesTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};

/** aggregated selection of "payroll_dates" */
export type PayrollDatesAggregate = {
  __typename?: 'PayrollDatesAggregate';
  aggregate?: Maybe<PayrollDatesAggregateFields>;
  nodes: Array<PayrollDates>;
};

export type PayrollDatesAggregateBoolExp = {
  count?: InputMaybe<PayrollDatesAggregateBoolExpCount>;
};

/** aggregate fields of "payroll_dates" */
export type PayrollDatesAggregateFields = {
  __typename?: 'PayrollDatesAggregateFields';
  avg?: Maybe<PayrollDatesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollDatesMaxFields>;
  min?: Maybe<PayrollDatesMinFields>;
  stddev?: Maybe<PayrollDatesStddevFields>;
  stddevPop?: Maybe<PayrollDatesStddevPopFields>;
  stddevSamp?: Maybe<PayrollDatesStddevSampFields>;
  sum?: Maybe<PayrollDatesSumFields>;
  varPop?: Maybe<PayrollDatesVarPopFields>;
  varSamp?: Maybe<PayrollDatesVarSampFields>;
  variance?: Maybe<PayrollDatesVarianceFields>;
};


/** aggregate fields of "payroll_dates" */
export type PayrollDatesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payroll_dates" */
export type PayrollDatesAggregateOrderBy = {
  avg?: InputMaybe<PayrollDatesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PayrollDatesMaxOrderBy>;
  min?: InputMaybe<PayrollDatesMinOrderBy>;
  stddev?: InputMaybe<PayrollDatesStddevOrderBy>;
  stddevPop?: InputMaybe<PayrollDatesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<PayrollDatesStddevSampOrderBy>;
  sum?: InputMaybe<PayrollDatesSumOrderBy>;
  varPop?: InputMaybe<PayrollDatesVarPopOrderBy>;
  varSamp?: InputMaybe<PayrollDatesVarSampOrderBy>;
  variance?: InputMaybe<PayrollDatesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "payroll_dates" */
export type PayrollDatesArrRelInsertInput = {
  data: Array<PayrollDatesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollDatesOnConflict>;
};

/** aggregate avg on columns */
export type PayrollDatesAvgFields = {
  __typename?: 'PayrollDatesAvgFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "payroll_dates" */
export type PayrollDatesAvgOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "payroll_dates". All fields are combined with a logical 'AND'. */
export type PayrollDatesBoolExp = {
  _and?: InputMaybe<Array<PayrollDatesBoolExp>>;
  _not?: InputMaybe<PayrollDatesBoolExp>;
  _or?: InputMaybe<Array<PayrollDatesBoolExp>>;
  adjustedEftDate?: InputMaybe<DateComparisonExp>;
  assignmentDetails?: InputMaybe<PayrollAssignmentsBoolExp>;
  billingItems?: InputMaybe<BillingItemsBoolExp>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  completedAt?: InputMaybe<TimestamptzComparisonExp>;
  completedBy?: InputMaybe<UuidComparisonExp>;
  completionNotes?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  notes?: InputMaybe<StringComparisonExp>;
  originalEftDate?: InputMaybe<DateComparisonExp>;
  payroll?: InputMaybe<PayrollsBoolExp>;
  payrollAssignments?: InputMaybe<PayrollAssignmentAuditBoolExp>;
  payrollAssignmentsAggregate?: InputMaybe<PayrollAssignmentAuditAggregateBoolExp>;
  payrollDateTimeEntries?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
  payrollDateTimeEntriesAggregate?: InputMaybe<PayrollDateTimeEntriesAggregateBoolExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  processingDate?: InputMaybe<DateComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  timeEntries?: InputMaybe<TimeEntriesBoolExp>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateBoolExp>;
  totalTimeSpentMinutes?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "payroll_dates" */
export type PayrollDatesConstraint =
  /** unique or primary key constraint on columns "original_eft_date", "payroll_id" */
  | 'idx_unique_payroll_date'
  /** unique or primary key constraint on columns "id" */
  | 'payroll_dates_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "payroll_dates" */
export type PayrollDatesIncInput = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "payroll_dates" */
export type PayrollDatesInsertInput = {
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate?: InputMaybe<Scalars['date']['input']>;
  assignmentDetails?: InputMaybe<PayrollAssignmentsObjRelInsertInput>;
  billingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who marked the payroll date as completed */
  completedBy?: InputMaybe<Scalars['uuid']['input']>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the date record was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique identifier for the payroll date */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Additional notes about this payroll date */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate?: InputMaybe<Scalars['date']['input']>;
  payroll?: InputMaybe<PayrollsObjRelInsertInput>;
  payrollAssignments?: InputMaybe<PayrollAssignmentAuditArrRelInsertInput>;
  payrollDateTimeEntries?: InputMaybe<PayrollDateTimeEntriesArrRelInsertInput>;
  /** Reference to the payroll this date belongs to */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  /** Date when payroll processing must be completed */
  processingDate?: InputMaybe<Scalars['date']['input']>;
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: InputMaybe<Scalars['String']['input']>;
  timeEntries?: InputMaybe<TimeEntriesArrRelInsertInput>;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Timestamp when the date record was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type PayrollDatesMaxFields = {
  __typename?: 'PayrollDatesMaxFields';
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User who marked the payroll date as completed */
  completedBy?: Maybe<Scalars['uuid']['output']>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the date record was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique identifier for the payroll date */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Additional notes about this payroll date */
  notes?: Maybe<Scalars['String']['output']>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate?: Maybe<Scalars['date']['output']>;
  /** Reference to the payroll this date belongs to */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  /** Date when payroll processing must be completed */
  processingDate?: Maybe<Scalars['date']['output']>;
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: Maybe<Scalars['String']['output']>;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the date record was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "payroll_dates" */
export type PayrollDatesMaxOrderBy = {
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate?: InputMaybe<OrderBy>;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: InputMaybe<OrderBy>;
  /** User who marked the payroll date as completed */
  completedBy?: InputMaybe<OrderBy>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: InputMaybe<OrderBy>;
  /** Timestamp when the date record was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Unique identifier for the payroll date */
  id?: InputMaybe<OrderBy>;
  /** Additional notes about this payroll date */
  notes?: InputMaybe<OrderBy>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate?: InputMaybe<OrderBy>;
  /** Reference to the payroll this date belongs to */
  payrollId?: InputMaybe<OrderBy>;
  /** Date when payroll processing must be completed */
  processingDate?: InputMaybe<OrderBy>;
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: InputMaybe<OrderBy>;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
  /** Timestamp when the date record was last updated */
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PayrollDatesMinFields = {
  __typename?: 'PayrollDatesMinFields';
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User who marked the payroll date as completed */
  completedBy?: Maybe<Scalars['uuid']['output']>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the date record was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Unique identifier for the payroll date */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Additional notes about this payroll date */
  notes?: Maybe<Scalars['String']['output']>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate?: Maybe<Scalars['date']['output']>;
  /** Reference to the payroll this date belongs to */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  /** Date when payroll processing must be completed */
  processingDate?: Maybe<Scalars['date']['output']>;
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: Maybe<Scalars['String']['output']>;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the date record was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "payroll_dates" */
export type PayrollDatesMinOrderBy = {
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate?: InputMaybe<OrderBy>;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: InputMaybe<OrderBy>;
  /** User who marked the payroll date as completed */
  completedBy?: InputMaybe<OrderBy>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: InputMaybe<OrderBy>;
  /** Timestamp when the date record was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Unique identifier for the payroll date */
  id?: InputMaybe<OrderBy>;
  /** Additional notes about this payroll date */
  notes?: InputMaybe<OrderBy>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate?: InputMaybe<OrderBy>;
  /** Reference to the payroll this date belongs to */
  payrollId?: InputMaybe<OrderBy>;
  /** Date when payroll processing must be completed */
  processingDate?: InputMaybe<OrderBy>;
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: InputMaybe<OrderBy>;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
  /** Timestamp when the date record was last updated */
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "payroll_dates" */
export type PayrollDatesMutationResponse = {
  __typename?: 'PayrollDatesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollDates>;
};

/** input type for inserting object relation for remote table "payroll_dates" */
export type PayrollDatesObjRelInsertInput = {
  data: PayrollDatesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollDatesOnConflict>;
};

/** on_conflict condition type for table "payroll_dates" */
export type PayrollDatesOnConflict = {
  constraint: PayrollDatesConstraint;
  updateColumns?: Array<PayrollDatesUpdateColumn>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};

/** Ordering options when selecting data from "payroll_dates". */
export type PayrollDatesOrderBy = {
  adjustedEftDate?: InputMaybe<OrderBy>;
  assignmentDetails?: InputMaybe<PayrollAssignmentsOrderBy>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  completedAt?: InputMaybe<OrderBy>;
  completedBy?: InputMaybe<OrderBy>;
  completionNotes?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  originalEftDate?: InputMaybe<OrderBy>;
  payroll?: InputMaybe<PayrollsOrderBy>;
  payrollAssignmentsAggregate?: InputMaybe<PayrollAssignmentAuditAggregateOrderBy>;
  payrollDateTimeEntriesAggregate?: InputMaybe<PayrollDateTimeEntriesAggregateOrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  processingDate?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateOrderBy>;
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: payroll_dates */
export type PayrollDatesPkColumnsInput = {
  /** Unique identifier for the payroll date */
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_dates" */
export type PayrollDatesSelectColumn =
  /** column name */
  | 'adjustedEftDate'
  /** column name */
  | 'completedAt'
  /** column name */
  | 'completedBy'
  /** column name */
  | 'completionNotes'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'originalEftDate'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'processingDate'
  /** column name */
  | 'status'
  /** column name */
  | 'totalTimeSpentMinutes'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "payroll_dates" */
export type PayrollDatesSetInput = {
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate?: InputMaybe<Scalars['date']['input']>;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who marked the payroll date as completed */
  completedBy?: InputMaybe<Scalars['uuid']['input']>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the date record was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique identifier for the payroll date */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Additional notes about this payroll date */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate?: InputMaybe<Scalars['date']['input']>;
  /** Reference to the payroll this date belongs to */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  /** Date when payroll processing must be completed */
  processingDate?: InputMaybe<Scalars['date']['input']>;
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Timestamp when the date record was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type PayrollDatesStddevFields = {
  __typename?: 'PayrollDatesStddevFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "payroll_dates" */
export type PayrollDatesStddevOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type PayrollDatesStddevPopFields = {
  __typename?: 'PayrollDatesStddevPopFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "payroll_dates" */
export type PayrollDatesStddevPopOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type PayrollDatesStddevSampFields = {
  __typename?: 'PayrollDatesStddevSampFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "payroll_dates" */
export type PayrollDatesStddevSampOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "payroll_dates" */
export type PayrollDatesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollDatesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollDatesStreamCursorValueInput = {
  /** Final EFT date after holiday and weekend adjustments */
  adjustedEftDate?: InputMaybe<Scalars['date']['input']>;
  /** Timestamp when the payroll date was marked as completed */
  completedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User who marked the payroll date as completed */
  completedBy?: InputMaybe<Scalars['uuid']['input']>;
  /** Additional notes about the completion of this payroll date */
  completionNotes?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the date record was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Unique identifier for the payroll date */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Additional notes about this payroll date */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Originally calculated EFT date before adjustments */
  originalEftDate?: InputMaybe<Scalars['date']['input']>;
  /** Reference to the payroll this date belongs to */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  /** Date when payroll processing must be completed */
  processingDate?: InputMaybe<Scalars['date']['input']>;
  /** Current status of the payroll date (pending, in_progress, completed, cancelled) */
  status?: InputMaybe<Scalars['String']['input']>;
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<Scalars['Int']['input']>;
  /** Timestamp when the date record was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type PayrollDatesSumFields = {
  __typename?: 'PayrollDatesSumFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "payroll_dates" */
export type PayrollDatesSumOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** update columns of table "payroll_dates" */
export type PayrollDatesUpdateColumn =
  /** column name */
  | 'adjustedEftDate'
  /** column name */
  | 'completedAt'
  /** column name */
  | 'completedBy'
  /** column name */
  | 'completionNotes'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'originalEftDate'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'processingDate'
  /** column name */
  | 'status'
  /** column name */
  | 'totalTimeSpentMinutes'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type PayrollDatesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PayrollDatesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollDatesSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollDatesBoolExp;
};

/** aggregate varPop on columns */
export type PayrollDatesVarPopFields = {
  __typename?: 'PayrollDatesVarPopFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "payroll_dates" */
export type PayrollDatesVarPopOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type PayrollDatesVarSampFields = {
  __typename?: 'PayrollDatesVarSampFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "payroll_dates" */
export type PayrollDatesVarSampOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PayrollDatesVarianceFields = {
  __typename?: 'PayrollDatesVarianceFields';
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "payroll_dates" */
export type PayrollDatesVarianceOrderBy = {
  /** Total time spent by all users on this payroll date (in minutes) */
  totalTimeSpentMinutes?: InputMaybe<OrderBy>;
};

/** Profitability analysis for individual payroll jobs */
export type PayrollProfitability = {
  __typename?: 'PayrollProfitability';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingStatus?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  employeeCount?: Maybe<Scalars['Int']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  payslipCount?: Maybe<Scalars['Int']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  timeEntriesCount?: Maybe<Scalars['bigint']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "payroll_profitability" */
export type PayrollProfitabilityAggregate = {
  __typename?: 'PayrollProfitabilityAggregate';
  aggregate?: Maybe<PayrollProfitabilityAggregateFields>;
  nodes: Array<PayrollProfitability>;
};

/** aggregate fields of "payroll_profitability" */
export type PayrollProfitabilityAggregateFields = {
  __typename?: 'PayrollProfitabilityAggregateFields';
  avg?: Maybe<PayrollProfitabilityAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollProfitabilityMaxFields>;
  min?: Maybe<PayrollProfitabilityMinFields>;
  stddev?: Maybe<PayrollProfitabilityStddevFields>;
  stddevPop?: Maybe<PayrollProfitabilityStddevPopFields>;
  stddevSamp?: Maybe<PayrollProfitabilityStddevSampFields>;
  sum?: Maybe<PayrollProfitabilitySumFields>;
  varPop?: Maybe<PayrollProfitabilityVarPopFields>;
  varSamp?: Maybe<PayrollProfitabilityVarSampFields>;
  variance?: Maybe<PayrollProfitabilityVarianceFields>;
};


/** aggregate fields of "payroll_profitability" */
export type PayrollProfitabilityAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollProfitabilitySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollProfitabilityAvgFields = {
  __typename?: 'PayrollProfitabilityAvgFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  employeeCount?: Maybe<Scalars['Float']['output']>;
  payslipCount?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  timeEntriesCount?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_profitability". All fields are combined with a logical 'AND'. */
export type PayrollProfitabilityBoolExp = {
  _and?: InputMaybe<Array<PayrollProfitabilityBoolExp>>;
  _not?: InputMaybe<PayrollProfitabilityBoolExp>;
  _or?: InputMaybe<Array<PayrollProfitabilityBoolExp>>;
  billingItemsCount?: InputMaybe<BigintComparisonExp>;
  billingStatus?: InputMaybe<StringComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  employeeCount?: InputMaybe<IntComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  payrollName?: InputMaybe<StringComparisonExp>;
  payslipCount?: InputMaybe<IntComparisonExp>;
  revenuePerHour?: InputMaybe<NumericComparisonExp>;
  timeEntriesCount?: InputMaybe<BigintComparisonExp>;
  totalHours?: InputMaybe<NumericComparisonExp>;
  totalRevenue?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type PayrollProfitabilityMaxFields = {
  __typename?: 'PayrollProfitabilityMaxFields';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingStatus?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  employeeCount?: Maybe<Scalars['Int']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  payslipCount?: Maybe<Scalars['Int']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  timeEntriesCount?: Maybe<Scalars['bigint']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type PayrollProfitabilityMinFields = {
  __typename?: 'PayrollProfitabilityMinFields';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  billingStatus?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  employeeCount?: Maybe<Scalars['Int']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  payslipCount?: Maybe<Scalars['Int']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  timeEntriesCount?: Maybe<Scalars['bigint']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "payroll_profitability". */
export type PayrollProfitabilityOrderBy = {
  billingItemsCount?: InputMaybe<OrderBy>;
  billingStatus?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  employeeCount?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  payrollName?: InputMaybe<OrderBy>;
  payslipCount?: InputMaybe<OrderBy>;
  revenuePerHour?: InputMaybe<OrderBy>;
  timeEntriesCount?: InputMaybe<OrderBy>;
  totalHours?: InputMaybe<OrderBy>;
  totalRevenue?: InputMaybe<OrderBy>;
};

/** select columns of table "payroll_profitability" */
export type PayrollProfitabilitySelectColumn =
  /** column name */
  | 'billingItemsCount'
  /** column name */
  | 'billingStatus'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'employeeCount'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'payrollName'
  /** column name */
  | 'payslipCount'
  /** column name */
  | 'revenuePerHour'
  /** column name */
  | 'timeEntriesCount'
  /** column name */
  | 'totalHours'
  /** column name */
  | 'totalRevenue'
  | '%future added value';

/** aggregate stddev on columns */
export type PayrollProfitabilityStddevFields = {
  __typename?: 'PayrollProfitabilityStddevFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  employeeCount?: Maybe<Scalars['Float']['output']>;
  payslipCount?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  timeEntriesCount?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollProfitabilityStddevPopFields = {
  __typename?: 'PayrollProfitabilityStddevPopFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  employeeCount?: Maybe<Scalars['Float']['output']>;
  payslipCount?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  timeEntriesCount?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollProfitabilityStddevSampFields = {
  __typename?: 'PayrollProfitabilityStddevSampFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  employeeCount?: Maybe<Scalars['Float']['output']>;
  payslipCount?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  timeEntriesCount?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_profitability" */
export type PayrollProfitabilityStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollProfitabilityStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollProfitabilityStreamCursorValueInput = {
  billingItemsCount?: InputMaybe<Scalars['bigint']['input']>;
  billingStatus?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  employeeCount?: InputMaybe<Scalars['Int']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollName?: InputMaybe<Scalars['String']['input']>;
  payslipCount?: InputMaybe<Scalars['Int']['input']>;
  revenuePerHour?: InputMaybe<Scalars['numeric']['input']>;
  timeEntriesCount?: InputMaybe<Scalars['bigint']['input']>;
  totalHours?: InputMaybe<Scalars['numeric']['input']>;
  totalRevenue?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type PayrollProfitabilitySumFields = {
  __typename?: 'PayrollProfitabilitySumFields';
  billingItemsCount?: Maybe<Scalars['bigint']['output']>;
  employeeCount?: Maybe<Scalars['Int']['output']>;
  payslipCount?: Maybe<Scalars['Int']['output']>;
  revenuePerHour?: Maybe<Scalars['numeric']['output']>;
  timeEntriesCount?: Maybe<Scalars['bigint']['output']>;
  totalHours?: Maybe<Scalars['numeric']['output']>;
  totalRevenue?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type PayrollProfitabilityVarPopFields = {
  __typename?: 'PayrollProfitabilityVarPopFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  employeeCount?: Maybe<Scalars['Float']['output']>;
  payslipCount?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  timeEntriesCount?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollProfitabilityVarSampFields = {
  __typename?: 'PayrollProfitabilityVarSampFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  employeeCount?: Maybe<Scalars['Float']['output']>;
  payslipCount?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  timeEntriesCount?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollProfitabilityVarianceFields = {
  __typename?: 'PayrollProfitabilityVarianceFields';
  billingItemsCount?: Maybe<Scalars['Float']['output']>;
  employeeCount?: Maybe<Scalars['Float']['output']>;
  payslipCount?: Maybe<Scalars['Float']['output']>;
  revenuePerHour?: Maybe<Scalars['Float']['output']>;
  timeEntriesCount?: Maybe<Scalars['Float']['output']>;
  totalHours?: Maybe<Scalars['Float']['output']>;
  totalRevenue?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "payroll_required_skills" */
export type PayrollRequiredSkills = {
  __typename?: 'PayrollRequiredSkills';
  /** An object relationship */
  payroll?: Maybe<Payrolls>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  requiredLevel?: Maybe<Scalars['String']['output']>;
  skillName?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "payroll_required_skills" */
export type PayrollRequiredSkillsAggregate = {
  __typename?: 'PayrollRequiredSkillsAggregate';
  aggregate?: Maybe<PayrollRequiredSkillsAggregateFields>;
  nodes: Array<PayrollRequiredSkills>;
};

export type PayrollRequiredSkillsAggregateBoolExp = {
  count?: InputMaybe<PayrollRequiredSkillsAggregateBoolExpCount>;
};

/** aggregate fields of "payroll_required_skills" */
export type PayrollRequiredSkillsAggregateFields = {
  __typename?: 'PayrollRequiredSkillsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollRequiredSkillsMaxFields>;
  min?: Maybe<PayrollRequiredSkillsMinFields>;
};


/** aggregate fields of "payroll_required_skills" */
export type PayrollRequiredSkillsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payroll_required_skills" */
export type PayrollRequiredSkillsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PayrollRequiredSkillsMaxOrderBy>;
  min?: InputMaybe<PayrollRequiredSkillsMinOrderBy>;
};

/** input type for inserting array relation for remote table "payroll_required_skills" */
export type PayrollRequiredSkillsArrRelInsertInput = {
  data: Array<PayrollRequiredSkillsInsertInput>;
};

/** Boolean expression to filter rows from the table "payroll_required_skills". All fields are combined with a logical 'AND'. */
export type PayrollRequiredSkillsBoolExp = {
  _and?: InputMaybe<Array<PayrollRequiredSkillsBoolExp>>;
  _not?: InputMaybe<PayrollRequiredSkillsBoolExp>;
  _or?: InputMaybe<Array<PayrollRequiredSkillsBoolExp>>;
  payroll?: InputMaybe<PayrollsBoolExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  requiredLevel?: InputMaybe<StringComparisonExp>;
  skillName?: InputMaybe<StringComparisonExp>;
};

/** input type for inserting data into table "payroll_required_skills" */
export type PayrollRequiredSkillsInsertInput = {
  payroll?: InputMaybe<PayrollsObjRelInsertInput>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  requiredLevel?: InputMaybe<Scalars['String']['input']>;
  skillName?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PayrollRequiredSkillsMaxFields = {
  __typename?: 'PayrollRequiredSkillsMaxFields';
  payrollId?: Maybe<Scalars['uuid']['output']>;
  requiredLevel?: Maybe<Scalars['String']['output']>;
  skillName?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "payroll_required_skills" */
export type PayrollRequiredSkillsMaxOrderBy = {
  payrollId?: InputMaybe<OrderBy>;
  requiredLevel?: InputMaybe<OrderBy>;
  skillName?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PayrollRequiredSkillsMinFields = {
  __typename?: 'PayrollRequiredSkillsMinFields';
  payrollId?: Maybe<Scalars['uuid']['output']>;
  requiredLevel?: Maybe<Scalars['String']['output']>;
  skillName?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "payroll_required_skills" */
export type PayrollRequiredSkillsMinOrderBy = {
  payrollId?: InputMaybe<OrderBy>;
  requiredLevel?: InputMaybe<OrderBy>;
  skillName?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "payroll_required_skills" */
export type PayrollRequiredSkillsMutationResponse = {
  __typename?: 'PayrollRequiredSkillsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollRequiredSkills>;
};

/** Ordering options when selecting data from "payroll_required_skills". */
export type PayrollRequiredSkillsOrderBy = {
  payroll?: InputMaybe<PayrollsOrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  requiredLevel?: InputMaybe<OrderBy>;
  skillName?: InputMaybe<OrderBy>;
};

/** select columns of table "payroll_required_skills" */
export type PayrollRequiredSkillsSelectColumn =
  /** column name */
  | 'payrollId'
  /** column name */
  | 'requiredLevel'
  /** column name */
  | 'skillName'
  | '%future added value';

/** input type for updating data in table "payroll_required_skills" */
export type PayrollRequiredSkillsSetInput = {
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  requiredLevel?: InputMaybe<Scalars['String']['input']>;
  skillName?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "payroll_required_skills" */
export type PayrollRequiredSkillsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollRequiredSkillsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollRequiredSkillsStreamCursorValueInput = {
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  requiredLevel?: InputMaybe<Scalars['String']['input']>;
  skillName?: InputMaybe<Scalars['String']['input']>;
};

export type PayrollRequiredSkillsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollRequiredSkillsSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollRequiredSkillsBoolExp;
};

/** Payroll-level service agreement overrides for tier 2 billing */
export type PayrollServiceAgreements = {
  __typename?: 'PayrollServiceAgreements';
  autoBillingEnabled?: Maybe<Scalars['Boolean']['output']>;
  billingFrequency?: Maybe<Scalars['String']['output']>;
  billingItemsGenerated?: Maybe<Scalars['Boolean']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  clientServiceAgreement?: Maybe<ClientServiceAgreements>;
  clientServiceAgreementId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  customDescription?: Maybe<Scalars['String']['output']>;
  customQuantity?: Maybe<Scalars['Int']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  generatedAt?: Maybe<Scalars['timestamptz']['output']>;
  generatedBy?: Maybe<Scalars['uuid']['output']>;
  id: Scalars['uuid']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isOneTime?: Maybe<Scalars['Boolean']['output']>;
  payrollId: Scalars['uuid']['output'];
  /** An object relationship */
  payrollServiceAgreementsByServiceId: Services;
  /** An object relationship */
  payrollServiceAgreementsForPayroll: Payrolls;
  /** An object relationship */
  serviceAgreementCreatedByUser?: Maybe<Users>;
  /** An object relationship */
  serviceAgreementGeneratedByUser?: Maybe<Users>;
  serviceConfiguration?: Maybe<Scalars['jsonb']['output']>;
  serviceId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** Payroll-level service agreement overrides for tier 2 billing */
export type PayrollServiceAgreementsServiceConfigurationArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "payroll_service_agreements" */
export type PayrollServiceAgreementsAggregate = {
  __typename?: 'PayrollServiceAgreementsAggregate';
  aggregate?: Maybe<PayrollServiceAgreementsAggregateFields>;
  nodes: Array<PayrollServiceAgreements>;
};

export type PayrollServiceAgreementsAggregateBoolExp = {
  bool_and?: InputMaybe<PayrollServiceAgreementsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<PayrollServiceAgreementsAggregateBoolExpBool_Or>;
  count?: InputMaybe<PayrollServiceAgreementsAggregateBoolExpCount>;
};

/** aggregate fields of "payroll_service_agreements" */
export type PayrollServiceAgreementsAggregateFields = {
  __typename?: 'PayrollServiceAgreementsAggregateFields';
  avg?: Maybe<PayrollServiceAgreementsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollServiceAgreementsMaxFields>;
  min?: Maybe<PayrollServiceAgreementsMinFields>;
  stddev?: Maybe<PayrollServiceAgreementsStddevFields>;
  stddevPop?: Maybe<PayrollServiceAgreementsStddevPopFields>;
  stddevSamp?: Maybe<PayrollServiceAgreementsStddevSampFields>;
  sum?: Maybe<PayrollServiceAgreementsSumFields>;
  varPop?: Maybe<PayrollServiceAgreementsVarPopFields>;
  varSamp?: Maybe<PayrollServiceAgreementsVarSampFields>;
  variance?: Maybe<PayrollServiceAgreementsVarianceFields>;
};


/** aggregate fields of "payroll_service_agreements" */
export type PayrollServiceAgreementsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payroll_service_agreements" */
export type PayrollServiceAgreementsAggregateOrderBy = {
  avg?: InputMaybe<PayrollServiceAgreementsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PayrollServiceAgreementsMaxOrderBy>;
  min?: InputMaybe<PayrollServiceAgreementsMinOrderBy>;
  stddev?: InputMaybe<PayrollServiceAgreementsStddevOrderBy>;
  stddevPop?: InputMaybe<PayrollServiceAgreementsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<PayrollServiceAgreementsStddevSampOrderBy>;
  sum?: InputMaybe<PayrollServiceAgreementsSumOrderBy>;
  varPop?: InputMaybe<PayrollServiceAgreementsVarPopOrderBy>;
  varSamp?: InputMaybe<PayrollServiceAgreementsVarSampOrderBy>;
  variance?: InputMaybe<PayrollServiceAgreementsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type PayrollServiceAgreementsAppendInput = {
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "payroll_service_agreements" */
export type PayrollServiceAgreementsArrRelInsertInput = {
  data: Array<PayrollServiceAgreementsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollServiceAgreementsOnConflict>;
};

/** aggregate avg on columns */
export type PayrollServiceAgreementsAvgFields = {
  __typename?: 'PayrollServiceAgreementsAvgFields';
  customQuantity?: Maybe<Scalars['Float']['output']>;
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsAvgOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "payroll_service_agreements". All fields are combined with a logical 'AND'. */
export type PayrollServiceAgreementsBoolExp = {
  _and?: InputMaybe<Array<PayrollServiceAgreementsBoolExp>>;
  _not?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  _or?: InputMaybe<Array<PayrollServiceAgreementsBoolExp>>;
  autoBillingEnabled?: InputMaybe<BooleanComparisonExp>;
  billingFrequency?: InputMaybe<StringComparisonExp>;
  billingItemsGenerated?: InputMaybe<BooleanComparisonExp>;
  billingNotes?: InputMaybe<StringComparisonExp>;
  clientServiceAgreement?: InputMaybe<ClientServiceAgreementsBoolExp>;
  clientServiceAgreementId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  customDescription?: InputMaybe<StringComparisonExp>;
  customQuantity?: InputMaybe<IntComparisonExp>;
  customRate?: InputMaybe<NumericComparisonExp>;
  generatedAt?: InputMaybe<TimestamptzComparisonExp>;
  generatedBy?: InputMaybe<UuidComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isOneTime?: InputMaybe<BooleanComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  payrollServiceAgreementsByServiceId?: InputMaybe<ServicesBoolExp>;
  payrollServiceAgreementsForPayroll?: InputMaybe<PayrollsBoolExp>;
  serviceAgreementCreatedByUser?: InputMaybe<UsersBoolExp>;
  serviceAgreementGeneratedByUser?: InputMaybe<UsersBoolExp>;
  serviceConfiguration?: InputMaybe<JsonbComparisonExp>;
  serviceId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "payroll_service_agreements" */
export type PayrollServiceAgreementsConstraint =
  /** unique or primary key constraint on columns "payroll_id", "service_id" */
  | 'payroll_service_agreements_payroll_id_service_id_key'
  /** unique or primary key constraint on columns "id" */
  | 'payroll_service_agreements_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type PayrollServiceAgreementsDeleteAtPathInput = {
  serviceConfiguration?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type PayrollServiceAgreementsDeleteElemInput = {
  serviceConfiguration?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type PayrollServiceAgreementsDeleteKeyInput = {
  serviceConfiguration?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "payroll_service_agreements" */
export type PayrollServiceAgreementsIncInput = {
  customQuantity?: InputMaybe<Scalars['Int']['input']>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "payroll_service_agreements" */
export type PayrollServiceAgreementsInsertInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingFrequency?: InputMaybe<Scalars['String']['input']>;
  billingItemsGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  clientServiceAgreement?: InputMaybe<ClientServiceAgreementsObjRelInsertInput>;
  clientServiceAgreementId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  customDescription?: InputMaybe<Scalars['String']['input']>;
  customQuantity?: InputMaybe<Scalars['Int']['input']>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
  generatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  generatedBy?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isOneTime?: InputMaybe<Scalars['Boolean']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollServiceAgreementsByServiceId?: InputMaybe<ServicesObjRelInsertInput>;
  payrollServiceAgreementsForPayroll?: InputMaybe<PayrollsObjRelInsertInput>;
  serviceAgreementCreatedByUser?: InputMaybe<UsersObjRelInsertInput>;
  serviceAgreementGeneratedByUser?: InputMaybe<UsersObjRelInsertInput>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PayrollServiceAgreementsMaxFields = {
  __typename?: 'PayrollServiceAgreementsMaxFields';
  billingFrequency?: Maybe<Scalars['String']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  clientServiceAgreementId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  customDescription?: Maybe<Scalars['String']['output']>;
  customQuantity?: Maybe<Scalars['Int']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  generatedAt?: Maybe<Scalars['timestamptz']['output']>;
  generatedBy?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsMaxOrderBy = {
  billingFrequency?: InputMaybe<OrderBy>;
  billingNotes?: InputMaybe<OrderBy>;
  clientServiceAgreementId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  customDescription?: InputMaybe<OrderBy>;
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
  generatedAt?: InputMaybe<OrderBy>;
  generatedBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PayrollServiceAgreementsMinFields = {
  __typename?: 'PayrollServiceAgreementsMinFields';
  billingFrequency?: Maybe<Scalars['String']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  clientServiceAgreementId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  customDescription?: Maybe<Scalars['String']['output']>;
  customQuantity?: Maybe<Scalars['Int']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
  generatedAt?: Maybe<Scalars['timestamptz']['output']>;
  generatedBy?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsMinOrderBy = {
  billingFrequency?: InputMaybe<OrderBy>;
  billingNotes?: InputMaybe<OrderBy>;
  clientServiceAgreementId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  customDescription?: InputMaybe<OrderBy>;
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
  generatedAt?: InputMaybe<OrderBy>;
  generatedBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "payroll_service_agreements" */
export type PayrollServiceAgreementsMutationResponse = {
  __typename?: 'PayrollServiceAgreementsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollServiceAgreements>;
};

/** on_conflict condition type for table "payroll_service_agreements" */
export type PayrollServiceAgreementsOnConflict = {
  constraint: PayrollServiceAgreementsConstraint;
  updateColumns?: Array<PayrollServiceAgreementsUpdateColumn>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};

/** Ordering options when selecting data from "payroll_service_agreements". */
export type PayrollServiceAgreementsOrderBy = {
  autoBillingEnabled?: InputMaybe<OrderBy>;
  billingFrequency?: InputMaybe<OrderBy>;
  billingItemsGenerated?: InputMaybe<OrderBy>;
  billingNotes?: InputMaybe<OrderBy>;
  clientServiceAgreement?: InputMaybe<ClientServiceAgreementsOrderBy>;
  clientServiceAgreementId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  customDescription?: InputMaybe<OrderBy>;
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
  generatedAt?: InputMaybe<OrderBy>;
  generatedBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isOneTime?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  payrollServiceAgreementsByServiceId?: InputMaybe<ServicesOrderBy>;
  payrollServiceAgreementsForPayroll?: InputMaybe<PayrollsOrderBy>;
  serviceAgreementCreatedByUser?: InputMaybe<UsersOrderBy>;
  serviceAgreementGeneratedByUser?: InputMaybe<UsersOrderBy>;
  serviceConfiguration?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_service_agreements */
export type PayrollServiceAgreementsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type PayrollServiceAgreementsPrependInput = {
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsSelectColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingFrequency'
  /** column name */
  | 'billingItemsGenerated'
  /** column name */
  | 'billingNotes'
  /** column name */
  | 'clientServiceAgreementId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'customDescription'
  /** column name */
  | 'customQuantity'
  /** column name */
  | 'customRate'
  /** column name */
  | 'generatedAt'
  /** column name */
  | 'generatedBy'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isOneTime'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'serviceConfiguration'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "payrollServiceAgreementsAggregateBoolExpBool_andArgumentsColumns" columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsSelectColumnPayrollServiceAgreementsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingItemsGenerated'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isOneTime'
  | '%future added value';

/** select "payrollServiceAgreementsAggregateBoolExpBool_orArgumentsColumns" columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsSelectColumnPayrollServiceAgreementsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingItemsGenerated'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isOneTime'
  | '%future added value';

/** input type for updating data in table "payroll_service_agreements" */
export type PayrollServiceAgreementsSetInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingFrequency?: InputMaybe<Scalars['String']['input']>;
  billingItemsGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  clientServiceAgreementId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  customDescription?: InputMaybe<Scalars['String']['input']>;
  customQuantity?: InputMaybe<Scalars['Int']['input']>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
  generatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  generatedBy?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isOneTime?: InputMaybe<Scalars['Boolean']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type PayrollServiceAgreementsStddevFields = {
  __typename?: 'PayrollServiceAgreementsStddevFields';
  customQuantity?: Maybe<Scalars['Float']['output']>;
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsStddevOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type PayrollServiceAgreementsStddevPopFields = {
  __typename?: 'PayrollServiceAgreementsStddevPopFields';
  customQuantity?: Maybe<Scalars['Float']['output']>;
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsStddevPopOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type PayrollServiceAgreementsStddevSampFields = {
  __typename?: 'PayrollServiceAgreementsStddevSampFields';
  customQuantity?: Maybe<Scalars['Float']['output']>;
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsStddevSampOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "payroll_service_agreements" */
export type PayrollServiceAgreementsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollServiceAgreementsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollServiceAgreementsStreamCursorValueInput = {
  autoBillingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  billingFrequency?: InputMaybe<Scalars['String']['input']>;
  billingItemsGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  clientServiceAgreementId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  customDescription?: InputMaybe<Scalars['String']['input']>;
  customQuantity?: InputMaybe<Scalars['Int']['input']>;
  customRate?: InputMaybe<Scalars['numeric']['input']>;
  generatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  generatedBy?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isOneTime?: InputMaybe<Scalars['Boolean']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  serviceConfiguration?: InputMaybe<Scalars['jsonb']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type PayrollServiceAgreementsSumFields = {
  __typename?: 'PayrollServiceAgreementsSumFields';
  customQuantity?: Maybe<Scalars['Int']['output']>;
  customRate?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsSumOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** update columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsUpdateColumn =
  /** column name */
  | 'autoBillingEnabled'
  /** column name */
  | 'billingFrequency'
  /** column name */
  | 'billingItemsGenerated'
  /** column name */
  | 'billingNotes'
  /** column name */
  | 'clientServiceAgreementId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'customDescription'
  /** column name */
  | 'customQuantity'
  /** column name */
  | 'customRate'
  /** column name */
  | 'generatedAt'
  /** column name */
  | 'generatedBy'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isOneTime'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'serviceConfiguration'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type PayrollServiceAgreementsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<PayrollServiceAgreementsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<PayrollServiceAgreementsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<PayrollServiceAgreementsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<PayrollServiceAgreementsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PayrollServiceAgreementsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<PayrollServiceAgreementsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollServiceAgreementsSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollServiceAgreementsBoolExp;
};

/** aggregate varPop on columns */
export type PayrollServiceAgreementsVarPopFields = {
  __typename?: 'PayrollServiceAgreementsVarPopFields';
  customQuantity?: Maybe<Scalars['Float']['output']>;
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsVarPopOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type PayrollServiceAgreementsVarSampFields = {
  __typename?: 'PayrollServiceAgreementsVarSampFields';
  customQuantity?: Maybe<Scalars['Float']['output']>;
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsVarSampOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PayrollServiceAgreementsVarianceFields = {
  __typename?: 'PayrollServiceAgreementsVarianceFields';
  customQuantity?: Maybe<Scalars['Float']['output']>;
  customRate?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "payroll_service_agreements" */
export type PayrollServiceAgreementsVarianceOrderBy = {
  customQuantity?: InputMaybe<OrderBy>;
  customRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "payroll_status". All fields are combined with logical 'AND'. */
export type PayrollStatusComparisonExp = {
  _eq?: InputMaybe<Scalars['payroll_status']['input']>;
  _gt?: InputMaybe<Scalars['payroll_status']['input']>;
  _gte?: InputMaybe<Scalars['payroll_status']['input']>;
  _in?: InputMaybe<Array<Scalars['payroll_status']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['payroll_status']['input']>;
  _lte?: InputMaybe<Scalars['payroll_status']['input']>;
  _neq?: InputMaybe<Scalars['payroll_status']['input']>;
  _nin?: InputMaybe<Array<Scalars['payroll_status']['input']>>;
};

/** columns and relationships of "payroll_triggers_status" */
export type PayrollTriggersStatus = {
  __typename?: 'PayrollTriggersStatus';
  actionStatement?: Maybe<Scalars['String']['output']>;
  actionTiming?: Maybe<Scalars['String']['output']>;
  eventManipulation?: Maybe<Scalars['String']['output']>;
  eventObjectTable?: Maybe<Scalars['name']['output']>;
  triggerName?: Maybe<Scalars['name']['output']>;
};

/** aggregated selection of "payroll_triggers_status" */
export type PayrollTriggersStatusAggregate = {
  __typename?: 'PayrollTriggersStatusAggregate';
  aggregate?: Maybe<PayrollTriggersStatusAggregateFields>;
  nodes: Array<PayrollTriggersStatus>;
};

/** aggregate fields of "payroll_triggers_status" */
export type PayrollTriggersStatusAggregateFields = {
  __typename?: 'PayrollTriggersStatusAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollTriggersStatusMaxFields>;
  min?: Maybe<PayrollTriggersStatusMinFields>;
};


/** aggregate fields of "payroll_triggers_status" */
export type PayrollTriggersStatusAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollTriggersStatusSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "payroll_triggers_status". All fields are combined with a logical 'AND'. */
export type PayrollTriggersStatusBoolExp = {
  _and?: InputMaybe<Array<PayrollTriggersStatusBoolExp>>;
  _not?: InputMaybe<PayrollTriggersStatusBoolExp>;
  _or?: InputMaybe<Array<PayrollTriggersStatusBoolExp>>;
  actionStatement?: InputMaybe<StringComparisonExp>;
  actionTiming?: InputMaybe<StringComparisonExp>;
  eventManipulation?: InputMaybe<StringComparisonExp>;
  eventObjectTable?: InputMaybe<NameComparisonExp>;
  triggerName?: InputMaybe<NameComparisonExp>;
};

/** aggregate max on columns */
export type PayrollTriggersStatusMaxFields = {
  __typename?: 'PayrollTriggersStatusMaxFields';
  actionStatement?: Maybe<Scalars['String']['output']>;
  actionTiming?: Maybe<Scalars['String']['output']>;
  eventManipulation?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type PayrollTriggersStatusMinFields = {
  __typename?: 'PayrollTriggersStatusMinFields';
  actionStatement?: Maybe<Scalars['String']['output']>;
  actionTiming?: Maybe<Scalars['String']['output']>;
  eventManipulation?: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "payroll_triggers_status". */
export type PayrollTriggersStatusOrderBy = {
  actionStatement?: InputMaybe<OrderBy>;
  actionTiming?: InputMaybe<OrderBy>;
  eventManipulation?: InputMaybe<OrderBy>;
  eventObjectTable?: InputMaybe<OrderBy>;
  triggerName?: InputMaybe<OrderBy>;
};

/** select columns of table "payroll_triggers_status" */
export type PayrollTriggersStatusSelectColumn =
  /** column name */
  | 'actionStatement'
  /** column name */
  | 'actionTiming'
  /** column name */
  | 'eventManipulation'
  /** column name */
  | 'eventObjectTable'
  /** column name */
  | 'triggerName'
  | '%future added value';

/** Streaming cursor of the table "payroll_triggers_status" */
export type PayrollTriggersStatusStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollTriggersStatusStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollTriggersStatusStreamCursorValueInput = {
  actionStatement?: InputMaybe<Scalars['String']['input']>;
  actionTiming?: InputMaybe<Scalars['String']['input']>;
  eventManipulation?: InputMaybe<Scalars['String']['input']>;
  eventObjectTable?: InputMaybe<Scalars['name']['input']>;
  triggerName?: InputMaybe<Scalars['name']['input']>;
};

/** columns and relationships of "payroll_version_history_results" */
export type PayrollVersionHistoryResults = {
  __typename?: 'PayrollVersionHistoryResults';
  active: Scalars['Boolean']['output'];
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id: Scalars['uuid']['output'];
  isCurrent: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  payrollId: Scalars['uuid']['output'];
  queriedAt?: Maybe<Scalars['timestamptz']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  versionNumber: Scalars['Int']['output'];
  versionReason?: Maybe<Scalars['String']['output']>;
};

export type PayrollVersionHistoryResultsAggregate = {
  __typename?: 'PayrollVersionHistoryResultsAggregate';
  aggregate?: Maybe<PayrollVersionHistoryResultsAggregateFields>;
  nodes: Array<PayrollVersionHistoryResults>;
};

/** aggregate fields of "payroll_version_history_results" */
export type PayrollVersionHistoryResultsAggregateFields = {
  __typename?: 'PayrollVersionHistoryResultsAggregateFields';
  avg?: Maybe<PayrollVersionHistoryResultsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollVersionHistoryResultsMaxFields>;
  min?: Maybe<PayrollVersionHistoryResultsMinFields>;
  stddev?: Maybe<PayrollVersionHistoryResultsStddevFields>;
  stddevPop?: Maybe<PayrollVersionHistoryResultsStddevPopFields>;
  stddevSamp?: Maybe<PayrollVersionHistoryResultsStddevSampFields>;
  sum?: Maybe<PayrollVersionHistoryResultsSumFields>;
  varPop?: Maybe<PayrollVersionHistoryResultsVarPopFields>;
  varSamp?: Maybe<PayrollVersionHistoryResultsVarSampFields>;
  variance?: Maybe<PayrollVersionHistoryResultsVarianceFields>;
};


/** aggregate fields of "payroll_version_history_results" */
export type PayrollVersionHistoryResultsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollVersionHistoryResultsAvgFields = {
  __typename?: 'PayrollVersionHistoryResultsAvgFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_version_history_results". All fields are combined with a logical 'AND'. */
export type PayrollVersionHistoryResultsBoolExp = {
  _and?: InputMaybe<Array<PayrollVersionHistoryResultsBoolExp>>;
  _not?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
  _or?: InputMaybe<Array<PayrollVersionHistoryResultsBoolExp>>;
  active?: InputMaybe<BooleanComparisonExp>;
  goLiveDate?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isCurrent?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  queriedAt?: InputMaybe<TimestamptzComparisonExp>;
  supersededDate?: InputMaybe<DateComparisonExp>;
  versionNumber?: InputMaybe<IntComparisonExp>;
  versionReason?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'payroll_version_history_results_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsIncInput = {
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsInsertInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  queriedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  supersededDate?: InputMaybe<Scalars['date']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionReason?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PayrollVersionHistoryResultsMaxFields = {
  __typename?: 'PayrollVersionHistoryResultsMaxFields';
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  queriedAt?: Maybe<Scalars['timestamptz']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type PayrollVersionHistoryResultsMinFields = {
  __typename?: 'PayrollVersionHistoryResultsMinFields';
  goLiveDate?: Maybe<Scalars['date']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  queriedAt?: Maybe<Scalars['timestamptz']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsMutationResponse = {
  __typename?: 'PayrollVersionHistoryResultsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollVersionHistoryResults>;
};

/** on_conflict condition type for table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsOnConflict = {
  constraint: PayrollVersionHistoryResultsConstraint;
  updateColumns?: Array<PayrollVersionHistoryResultsUpdateColumn>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};

/** Ordering options when selecting data from "payroll_version_history_results". */
export type PayrollVersionHistoryResultsOrderBy = {
  active?: InputMaybe<OrderBy>;
  goLiveDate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isCurrent?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  queriedAt?: InputMaybe<OrderBy>;
  supersededDate?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
  versionReason?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_version_history_results */
export type PayrollVersionHistoryResultsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsSelectColumn =
  /** column name */
  | 'active'
  /** column name */
  | 'goLiveDate'
  /** column name */
  | 'id'
  /** column name */
  | 'isCurrent'
  /** column name */
  | 'name'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'queriedAt'
  /** column name */
  | 'supersededDate'
  /** column name */
  | 'versionNumber'
  /** column name */
  | 'versionReason'
  | '%future added value';

/** input type for updating data in table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsSetInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  queriedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  supersededDate?: InputMaybe<Scalars['date']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionReason?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type PayrollVersionHistoryResultsStddevFields = {
  __typename?: 'PayrollVersionHistoryResultsStddevFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollVersionHistoryResultsStddevPopFields = {
  __typename?: 'PayrollVersionHistoryResultsStddevPopFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollVersionHistoryResultsStddevSampFields = {
  __typename?: 'PayrollVersionHistoryResultsStddevSampFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollVersionHistoryResultsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollVersionHistoryResultsStreamCursorValueInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  queriedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  supersededDate?: InputMaybe<Scalars['date']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionReason?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type PayrollVersionHistoryResultsSumFields = {
  __typename?: 'PayrollVersionHistoryResultsSumFields';
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "payroll_version_history_results" */
export type PayrollVersionHistoryResultsUpdateColumn =
  /** column name */
  | 'active'
  /** column name */
  | 'goLiveDate'
  /** column name */
  | 'id'
  /** column name */
  | 'isCurrent'
  /** column name */
  | 'name'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'queriedAt'
  /** column name */
  | 'supersededDate'
  /** column name */
  | 'versionNumber'
  /** column name */
  | 'versionReason'
  | '%future added value';

export type PayrollVersionHistoryResultsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PayrollVersionHistoryResultsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollVersionHistoryResultsSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollVersionHistoryResultsBoolExp;
};

/** aggregate varPop on columns */
export type PayrollVersionHistoryResultsVarPopFields = {
  __typename?: 'PayrollVersionHistoryResultsVarPopFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollVersionHistoryResultsVarSampFields = {
  __typename?: 'PayrollVersionHistoryResultsVarSampFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollVersionHistoryResultsVarianceFields = {
  __typename?: 'PayrollVersionHistoryResultsVarianceFields';
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "payroll_version_results" */
export type PayrollVersionResults = {
  __typename?: 'PayrollVersionResults';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  datesDeleted: Scalars['Int']['output'];
  id: Scalars['uuid']['output'];
  message: Scalars['String']['output'];
  newPayrollId: Scalars['uuid']['output'];
  newVersionNumber: Scalars['Int']['output'];
  oldPayrollId: Scalars['uuid']['output'];
};

/** aggregated selection of "payroll_version_results" */
export type PayrollVersionResultsAggregate = {
  __typename?: 'PayrollVersionResultsAggregate';
  aggregate?: Maybe<PayrollVersionResultsAggregateFields>;
  nodes: Array<PayrollVersionResults>;
};

/** aggregate fields of "payroll_version_results" */
export type PayrollVersionResultsAggregateFields = {
  __typename?: 'PayrollVersionResultsAggregateFields';
  avg?: Maybe<PayrollVersionResultsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollVersionResultsMaxFields>;
  min?: Maybe<PayrollVersionResultsMinFields>;
  stddev?: Maybe<PayrollVersionResultsStddevFields>;
  stddevPop?: Maybe<PayrollVersionResultsStddevPopFields>;
  stddevSamp?: Maybe<PayrollVersionResultsStddevSampFields>;
  sum?: Maybe<PayrollVersionResultsSumFields>;
  varPop?: Maybe<PayrollVersionResultsVarPopFields>;
  varSamp?: Maybe<PayrollVersionResultsVarSampFields>;
  variance?: Maybe<PayrollVersionResultsVarianceFields>;
};


/** aggregate fields of "payroll_version_results" */
export type PayrollVersionResultsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollVersionResultsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollVersionResultsAvgFields = {
  __typename?: 'PayrollVersionResultsAvgFields';
  datesDeleted?: Maybe<Scalars['Float']['output']>;
  newVersionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_version_results". All fields are combined with a logical 'AND'. */
export type PayrollVersionResultsBoolExp = {
  _and?: InputMaybe<Array<PayrollVersionResultsBoolExp>>;
  _not?: InputMaybe<PayrollVersionResultsBoolExp>;
  _or?: InputMaybe<Array<PayrollVersionResultsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdByUserId?: InputMaybe<UuidComparisonExp>;
  datesDeleted?: InputMaybe<IntComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  message?: InputMaybe<StringComparisonExp>;
  newPayrollId?: InputMaybe<UuidComparisonExp>;
  newVersionNumber?: InputMaybe<IntComparisonExp>;
  oldPayrollId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "payroll_version_results" */
export type PayrollVersionResultsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'payroll_version_results_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "payroll_version_results" */
export type PayrollVersionResultsIncInput = {
  datesDeleted?: InputMaybe<Scalars['Int']['input']>;
  newVersionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "payroll_version_results" */
export type PayrollVersionResultsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  datesDeleted?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  newPayrollId?: InputMaybe<Scalars['uuid']['input']>;
  newVersionNumber?: InputMaybe<Scalars['Int']['input']>;
  oldPayrollId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type PayrollVersionResultsMaxFields = {
  __typename?: 'PayrollVersionResultsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  datesDeleted?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  newPayrollId?: Maybe<Scalars['uuid']['output']>;
  newVersionNumber?: Maybe<Scalars['Int']['output']>;
  oldPayrollId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type PayrollVersionResultsMinFields = {
  __typename?: 'PayrollVersionResultsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  datesDeleted?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  newPayrollId?: Maybe<Scalars['uuid']['output']>;
  newVersionNumber?: Maybe<Scalars['Int']['output']>;
  oldPayrollId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "payroll_version_results" */
export type PayrollVersionResultsMutationResponse = {
  __typename?: 'PayrollVersionResultsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PayrollVersionResults>;
};

/** on_conflict condition type for table "payroll_version_results" */
export type PayrollVersionResultsOnConflict = {
  constraint: PayrollVersionResultsConstraint;
  updateColumns?: Array<PayrollVersionResultsUpdateColumn>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};

/** Ordering options when selecting data from "payroll_version_results". */
export type PayrollVersionResultsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdByUserId?: InputMaybe<OrderBy>;
  datesDeleted?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  message?: InputMaybe<OrderBy>;
  newPayrollId?: InputMaybe<OrderBy>;
  newVersionNumber?: InputMaybe<OrderBy>;
  oldPayrollId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payroll_version_results */
export type PayrollVersionResultsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "payroll_version_results" */
export type PayrollVersionResultsSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdByUserId'
  /** column name */
  | 'datesDeleted'
  /** column name */
  | 'id'
  /** column name */
  | 'message'
  /** column name */
  | 'newPayrollId'
  /** column name */
  | 'newVersionNumber'
  /** column name */
  | 'oldPayrollId'
  | '%future added value';

/** input type for updating data in table "payroll_version_results" */
export type PayrollVersionResultsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  datesDeleted?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  newPayrollId?: InputMaybe<Scalars['uuid']['input']>;
  newVersionNumber?: InputMaybe<Scalars['Int']['input']>;
  oldPayrollId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type PayrollVersionResultsStddevFields = {
  __typename?: 'PayrollVersionResultsStddevFields';
  datesDeleted?: Maybe<Scalars['Float']['output']>;
  newVersionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollVersionResultsStddevPopFields = {
  __typename?: 'PayrollVersionResultsStddevPopFields';
  datesDeleted?: Maybe<Scalars['Float']['output']>;
  newVersionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollVersionResultsStddevSampFields = {
  __typename?: 'PayrollVersionResultsStddevSampFields';
  datesDeleted?: Maybe<Scalars['Float']['output']>;
  newVersionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_version_results" */
export type PayrollVersionResultsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollVersionResultsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollVersionResultsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  datesDeleted?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  newPayrollId?: InputMaybe<Scalars['uuid']['input']>;
  newVersionNumber?: InputMaybe<Scalars['Int']['input']>;
  oldPayrollId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type PayrollVersionResultsSumFields = {
  __typename?: 'PayrollVersionResultsSumFields';
  datesDeleted?: Maybe<Scalars['Int']['output']>;
  newVersionNumber?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "payroll_version_results" */
export type PayrollVersionResultsUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdByUserId'
  /** column name */
  | 'datesDeleted'
  /** column name */
  | 'id'
  /** column name */
  | 'message'
  /** column name */
  | 'newPayrollId'
  /** column name */
  | 'newVersionNumber'
  /** column name */
  | 'oldPayrollId'
  | '%future added value';

export type PayrollVersionResultsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PayrollVersionResultsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollVersionResultsSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollVersionResultsBoolExp;
};

/** aggregate varPop on columns */
export type PayrollVersionResultsVarPopFields = {
  __typename?: 'PayrollVersionResultsVarPopFields';
  datesDeleted?: Maybe<Scalars['Float']['output']>;
  newVersionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollVersionResultsVarSampFields = {
  __typename?: 'PayrollVersionResultsVarSampFields';
  datesDeleted?: Maybe<Scalars['Float']['output']>;
  newVersionNumber?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollVersionResultsVarianceFields = {
  __typename?: 'PayrollVersionResultsVarianceFields';
  datesDeleted?: Maybe<Scalars['Float']['output']>;
  newVersionNumber?: Maybe<Scalars['Float']['output']>;
};

/** Distributes payroll processing time across working days prior to EFT dates, excluding weekends and holidays. Used for accurate workload capacity visualization. */
export type PayrollWorkloadDistribution = {
  __typename?: 'PayrollWorkloadDistribution';
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  assignmentDate?: Maybe<Scalars['date']['output']>;
  assignmentDay?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  consultantRole?: Maybe<Scalars['String']['output']>;
  dayCapacityHours?: Maybe<Scalars['numeric']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['numeric']['output']>;
  distributedProcessingTime?: Maybe<Scalars['numeric']['output']>;
  originalEftDate?: Maybe<Scalars['date']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Int']['output']>;
  processingEndDate?: Maybe<Scalars['date']['output']>;
  processingStartDate?: Maybe<Scalars['date']['output']>;
  status?: Maybe<Scalars['payroll_status']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['numeric']['output']>;
  totalProcessingTime?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "payroll_workload_distribution" */
export type PayrollWorkloadDistributionAggregate = {
  __typename?: 'PayrollWorkloadDistributionAggregate';
  aggregate?: Maybe<PayrollWorkloadDistributionAggregateFields>;
  nodes: Array<PayrollWorkloadDistribution>;
};

/** aggregate fields of "payroll_workload_distribution" */
export type PayrollWorkloadDistributionAggregateFields = {
  __typename?: 'PayrollWorkloadDistributionAggregateFields';
  avg?: Maybe<PayrollWorkloadDistributionAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollWorkloadDistributionMaxFields>;
  min?: Maybe<PayrollWorkloadDistributionMinFields>;
  stddev?: Maybe<PayrollWorkloadDistributionStddevFields>;
  stddevPop?: Maybe<PayrollWorkloadDistributionStddevPopFields>;
  stddevSamp?: Maybe<PayrollWorkloadDistributionStddevSampFields>;
  sum?: Maybe<PayrollWorkloadDistributionSumFields>;
  varPop?: Maybe<PayrollWorkloadDistributionVarPopFields>;
  varSamp?: Maybe<PayrollWorkloadDistributionVarSampFields>;
  variance?: Maybe<PayrollWorkloadDistributionVarianceFields>;
};


/** aggregate fields of "payroll_workload_distribution" */
export type PayrollWorkloadDistributionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollWorkloadDistributionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PayrollWorkloadDistributionAvgFields = {
  __typename?: 'PayrollWorkloadDistributionAvgFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  dayCapacityHours?: Maybe<Scalars['Float']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['Float']['output']>;
  distributedProcessingTime?: Maybe<Scalars['Float']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['Float']['output']>;
  totalProcessingTime?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "payroll_workload_distribution". All fields are combined with a logical 'AND'. */
export type PayrollWorkloadDistributionBoolExp = {
  _and?: InputMaybe<Array<PayrollWorkloadDistributionBoolExp>>;
  _not?: InputMaybe<PayrollWorkloadDistributionBoolExp>;
  _or?: InputMaybe<Array<PayrollWorkloadDistributionBoolExp>>;
  adjustedEftDate?: InputMaybe<DateComparisonExp>;
  adminTimeHours?: InputMaybe<NumericComparisonExp>;
  assignmentDate?: InputMaybe<DateComparisonExp>;
  assignmentDay?: InputMaybe<StringComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  consultantRole?: InputMaybe<StringComparisonExp>;
  dayCapacityHours?: InputMaybe<NumericComparisonExp>;
  dayUtilizationPercentage?: InputMaybe<NumericComparisonExp>;
  distributedProcessingTime?: InputMaybe<NumericComparisonExp>;
  originalEftDate?: InputMaybe<DateComparisonExp>;
  payrollDateId?: InputMaybe<UuidComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  payrollName?: InputMaybe<StringComparisonExp>;
  processingDaysBeforeEft?: InputMaybe<IntComparisonExp>;
  processingEndDate?: InputMaybe<DateComparisonExp>;
  processingStartDate?: InputMaybe<DateComparisonExp>;
  status?: InputMaybe<PayrollStatusComparisonExp>;
  totalPeriodCapacity?: InputMaybe<NumericComparisonExp>;
  totalProcessingTime?: InputMaybe<IntComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  workHours?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type PayrollWorkloadDistributionMaxFields = {
  __typename?: 'PayrollWorkloadDistributionMaxFields';
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  assignmentDate?: Maybe<Scalars['date']['output']>;
  assignmentDay?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  consultantRole?: Maybe<Scalars['String']['output']>;
  dayCapacityHours?: Maybe<Scalars['numeric']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['numeric']['output']>;
  distributedProcessingTime?: Maybe<Scalars['numeric']['output']>;
  originalEftDate?: Maybe<Scalars['date']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Int']['output']>;
  processingEndDate?: Maybe<Scalars['date']['output']>;
  processingStartDate?: Maybe<Scalars['date']['output']>;
  status?: Maybe<Scalars['payroll_status']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['numeric']['output']>;
  totalProcessingTime?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type PayrollWorkloadDistributionMinFields = {
  __typename?: 'PayrollWorkloadDistributionMinFields';
  adjustedEftDate?: Maybe<Scalars['date']['output']>;
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  assignmentDate?: Maybe<Scalars['date']['output']>;
  assignmentDay?: Maybe<Scalars['String']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  consultantRole?: Maybe<Scalars['String']['output']>;
  dayCapacityHours?: Maybe<Scalars['numeric']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['numeric']['output']>;
  distributedProcessingTime?: Maybe<Scalars['numeric']['output']>;
  originalEftDate?: Maybe<Scalars['date']['output']>;
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Int']['output']>;
  processingEndDate?: Maybe<Scalars['date']['output']>;
  processingStartDate?: Maybe<Scalars['date']['output']>;
  status?: Maybe<Scalars['payroll_status']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['numeric']['output']>;
  totalProcessingTime?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "payroll_workload_distribution". */
export type PayrollWorkloadDistributionOrderBy = {
  adjustedEftDate?: InputMaybe<OrderBy>;
  adminTimeHours?: InputMaybe<OrderBy>;
  assignmentDate?: InputMaybe<OrderBy>;
  assignmentDay?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  consultantRole?: InputMaybe<OrderBy>;
  dayCapacityHours?: InputMaybe<OrderBy>;
  dayUtilizationPercentage?: InputMaybe<OrderBy>;
  distributedProcessingTime?: InputMaybe<OrderBy>;
  originalEftDate?: InputMaybe<OrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  payrollName?: InputMaybe<OrderBy>;
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  processingEndDate?: InputMaybe<OrderBy>;
  processingStartDate?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalPeriodCapacity?: InputMaybe<OrderBy>;
  totalProcessingTime?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
  workHours?: InputMaybe<OrderBy>;
};

/** select columns of table "payroll_workload_distribution" */
export type PayrollWorkloadDistributionSelectColumn =
  /** column name */
  | 'adjustedEftDate'
  /** column name */
  | 'adminTimeHours'
  /** column name */
  | 'assignmentDate'
  /** column name */
  | 'assignmentDay'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'consultantRole'
  /** column name */
  | 'dayCapacityHours'
  /** column name */
  | 'dayUtilizationPercentage'
  /** column name */
  | 'distributedProcessingTime'
  /** column name */
  | 'originalEftDate'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'payrollName'
  /** column name */
  | 'processingDaysBeforeEft'
  /** column name */
  | 'processingEndDate'
  /** column name */
  | 'processingStartDate'
  /** column name */
  | 'status'
  /** column name */
  | 'totalPeriodCapacity'
  /** column name */
  | 'totalProcessingTime'
  /** column name */
  | 'userId'
  /** column name */
  | 'workHours'
  | '%future added value';

/** aggregate stddev on columns */
export type PayrollWorkloadDistributionStddevFields = {
  __typename?: 'PayrollWorkloadDistributionStddevFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  dayCapacityHours?: Maybe<Scalars['Float']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['Float']['output']>;
  distributedProcessingTime?: Maybe<Scalars['Float']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['Float']['output']>;
  totalProcessingTime?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PayrollWorkloadDistributionStddevPopFields = {
  __typename?: 'PayrollWorkloadDistributionStddevPopFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  dayCapacityHours?: Maybe<Scalars['Float']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['Float']['output']>;
  distributedProcessingTime?: Maybe<Scalars['Float']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['Float']['output']>;
  totalProcessingTime?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PayrollWorkloadDistributionStddevSampFields = {
  __typename?: 'PayrollWorkloadDistributionStddevSampFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  dayCapacityHours?: Maybe<Scalars['Float']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['Float']['output']>;
  distributedProcessingTime?: Maybe<Scalars['Float']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['Float']['output']>;
  totalProcessingTime?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "payroll_workload_distribution" */
export type PayrollWorkloadDistributionStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollWorkloadDistributionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollWorkloadDistributionStreamCursorValueInput = {
  adjustedEftDate?: InputMaybe<Scalars['date']['input']>;
  adminTimeHours?: InputMaybe<Scalars['numeric']['input']>;
  assignmentDate?: InputMaybe<Scalars['date']['input']>;
  assignmentDay?: InputMaybe<Scalars['String']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  consultantRole?: InputMaybe<Scalars['String']['input']>;
  dayCapacityHours?: InputMaybe<Scalars['numeric']['input']>;
  dayUtilizationPercentage?: InputMaybe<Scalars['numeric']['input']>;
  distributedProcessingTime?: InputMaybe<Scalars['numeric']['input']>;
  originalEftDate?: InputMaybe<Scalars['date']['input']>;
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollName?: InputMaybe<Scalars['String']['input']>;
  processingDaysBeforeEft?: InputMaybe<Scalars['Int']['input']>;
  processingEndDate?: InputMaybe<Scalars['date']['input']>;
  processingStartDate?: InputMaybe<Scalars['date']['input']>;
  status?: InputMaybe<Scalars['payroll_status']['input']>;
  totalPeriodCapacity?: InputMaybe<Scalars['numeric']['input']>;
  totalProcessingTime?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
  workHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type PayrollWorkloadDistributionSumFields = {
  __typename?: 'PayrollWorkloadDistributionSumFields';
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  dayCapacityHours?: Maybe<Scalars['numeric']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['numeric']['output']>;
  distributedProcessingTime?: Maybe<Scalars['numeric']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Int']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['numeric']['output']>;
  totalProcessingTime?: Maybe<Scalars['Int']['output']>;
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type PayrollWorkloadDistributionVarPopFields = {
  __typename?: 'PayrollWorkloadDistributionVarPopFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  dayCapacityHours?: Maybe<Scalars['Float']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['Float']['output']>;
  distributedProcessingTime?: Maybe<Scalars['Float']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['Float']['output']>;
  totalProcessingTime?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PayrollWorkloadDistributionVarSampFields = {
  __typename?: 'PayrollWorkloadDistributionVarSampFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  dayCapacityHours?: Maybe<Scalars['Float']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['Float']['output']>;
  distributedProcessingTime?: Maybe<Scalars['Float']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['Float']['output']>;
  totalProcessingTime?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PayrollWorkloadDistributionVarianceFields = {
  __typename?: 'PayrollWorkloadDistributionVarianceFields';
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  dayCapacityHours?: Maybe<Scalars['Float']['output']>;
  dayUtilizationPercentage?: Maybe<Scalars['Float']['output']>;
  distributedProcessingTime?: Maybe<Scalars['Float']['output']>;
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  totalPeriodCapacity?: Maybe<Scalars['Float']['output']>;
  totalProcessingTime?: Maybe<Scalars['Float']['output']>;
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "payrolls" */
export type Payrolls = {
  __typename?: 'Payrolls';
  actualHours?: Maybe<Scalars['numeric']['output']>;
  actualRevenue?: Maybe<Scalars['numeric']['output']>;
  /** An object relationship */
  assignedManager?: Maybe<Users>;
  /** An object relationship */
  backupConsultant?: Maybe<Users>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  billingItems: Array<BillingItems>;
  /** An aggregate relationship */
  billingItemsAggregate: BillingItemsAggregate;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  childPayrolls: Array<Payrolls>;
  /** An aggregate relationship */
  childPayrollsAggregate: PayrollsAggregate;
  /** An object relationship */
  client: Clients;
  /** Reference to the client this payroll belongs to */
  clientId: Scalars['uuid']['output'];
  /** Timestamp when the payroll was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the payroll cycle */
  cycleId: Scalars['uuid']['output'];
  /** Reference to the payroll date type */
  dateTypeId: Scalars['uuid']['output'];
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Int']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Int']['output']>;
  estimatedHours?: Maybe<Scalars['numeric']['output']>;
  estimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  /** An array relationship */
  files: Array<Files>;
  /** An aggregate relationship */
  filesAggregate: FilesAggregate;
  /** The date when the payroll went live in the system */
  goLiveDate?: Maybe<Scalars['date']['output']>;
  /** Unique identifier for the payroll */
  id: Scalars['uuid']['output'];
  lastBilledDate?: Maybe<Scalars['timestamptz']['output']>;
  /** Manager overseeing this payroll */
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  /** Name of the payroll */
  name: Scalars['String']['output'];
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  parentPayroll?: Maybe<Payrolls>;
  parentPayrollId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  payrollCycle: PayrollCycles;
  /** An object relationship */
  payrollDateType: PayrollDateTypes;
  /** An array relationship */
  payrollDates: Array<PayrollDates>;
  /** An aggregate relationship */
  payrollDatesAggregate: PayrollDatesAggregate;
  /** An array relationship */
  payrollServiceAgreementsForPayroll: Array<PayrollServiceAgreements>;
  /** An aggregate relationship */
  payrollServiceAgreementsForPayrollAggregate: PayrollServiceAgreementsAggregate;
  /** External payroll system used for this client */
  payrollSystem?: Maybe<Scalars['String']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  primaryConsultant?: Maybe<Users>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft: Scalars['Int']['output'];
  /** Number of hours required to process this payroll */
  processingTime: Scalars['Int']['output'];
  profitMargin?: Maybe<Scalars['numeric']['output']>;
  /** An array relationship */
  requiredSkills: Array<PayrollRequiredSkills>;
  /** An aggregate relationship */
  requiredSkillsAggregate: PayrollRequiredSkillsAggregate;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status: Scalars['payroll_status']['output'];
  supersededDate?: Maybe<Scalars['date']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  timeEntries: Array<TimeEntries>;
  /** An aggregate relationship */
  timeEntriesAggregate: TimeEntriesAggregate;
  /** Timestamp when the payroll was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "payrolls" */
export type PayrollsBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsChildPayrollsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsChildPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsFilesArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsPayrollDatesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsPayrollDatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsPayrollServiceAgreementsForPayrollArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsPayrollServiceAgreementsForPayrollAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsRequiredSkillsArgs = {
  distinctOn?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollRequiredSkillsOrderBy>>;
  where?: InputMaybe<PayrollRequiredSkillsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsRequiredSkillsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollRequiredSkillsOrderBy>>;
  where?: InputMaybe<PayrollRequiredSkillsBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


/** columns and relationships of "payrolls" */
export type PayrollsTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};

/** aggregated selection of "payrolls" */
export type PayrollsAggregate = {
  __typename?: 'PayrollsAggregate';
  aggregate?: Maybe<PayrollsAggregateFields>;
  nodes: Array<Payrolls>;
};

export type PayrollsAggregateBoolExp = {
  count?: InputMaybe<PayrollsAggregateBoolExpCount>;
};

/** aggregate fields of "payrolls" */
export type PayrollsAggregateFields = {
  __typename?: 'PayrollsAggregateFields';
  avg?: Maybe<PayrollsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PayrollsMaxFields>;
  min?: Maybe<PayrollsMinFields>;
  stddev?: Maybe<PayrollsStddevFields>;
  stddevPop?: Maybe<PayrollsStddevPopFields>;
  stddevSamp?: Maybe<PayrollsStddevSampFields>;
  sum?: Maybe<PayrollsSumFields>;
  varPop?: Maybe<PayrollsVarPopFields>;
  varSamp?: Maybe<PayrollsVarSampFields>;
  variance?: Maybe<PayrollsVarianceFields>;
};


/** aggregate fields of "payrolls" */
export type PayrollsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PayrollsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "payrolls" */
export type PayrollsAggregateOrderBy = {
  avg?: InputMaybe<PayrollsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PayrollsMaxOrderBy>;
  min?: InputMaybe<PayrollsMinOrderBy>;
  stddev?: InputMaybe<PayrollsStddevOrderBy>;
  stddevPop?: InputMaybe<PayrollsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<PayrollsStddevSampOrderBy>;
  sum?: InputMaybe<PayrollsSumOrderBy>;
  varPop?: InputMaybe<PayrollsVarPopOrderBy>;
  varSamp?: InputMaybe<PayrollsVarSampOrderBy>;
  variance?: InputMaybe<PayrollsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "payrolls" */
export type PayrollsArrRelInsertInput = {
  data: Array<PayrollsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollsOnConflict>;
};

/** aggregate avg on columns */
export type PayrollsAvgFields = {
  __typename?: 'PayrollsAvgFields';
  actualHours?: Maybe<Scalars['Float']['output']>;
  actualRevenue?: Maybe<Scalars['Float']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Float']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Float']['output']>;
  estimatedHours?: Maybe<Scalars['Float']['output']>;
  estimatedRevenue?: Maybe<Scalars['Float']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Float']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Float']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Float']['output']>;
  profitMargin?: Maybe<Scalars['Float']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "payrolls" */
export type PayrollsAvgOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "payrolls". All fields are combined with a logical 'AND'. */
export type PayrollsBoolExp = {
  _and?: InputMaybe<Array<PayrollsBoolExp>>;
  _not?: InputMaybe<PayrollsBoolExp>;
  _or?: InputMaybe<Array<PayrollsBoolExp>>;
  actualHours?: InputMaybe<NumericComparisonExp>;
  actualRevenue?: InputMaybe<NumericComparisonExp>;
  assignedManager?: InputMaybe<UsersBoolExp>;
  backupConsultant?: InputMaybe<UsersBoolExp>;
  backupConsultantUserId?: InputMaybe<UuidComparisonExp>;
  billingItems?: InputMaybe<BillingItemsBoolExp>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  billingStatus?: InputMaybe<StringComparisonExp>;
  childPayrolls?: InputMaybe<PayrollsBoolExp>;
  childPayrollsAggregate?: InputMaybe<PayrollsAggregateBoolExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdByUserId?: InputMaybe<UuidComparisonExp>;
  cycleId?: InputMaybe<UuidComparisonExp>;
  dateTypeId?: InputMaybe<UuidComparisonExp>;
  dateValue?: InputMaybe<IntComparisonExp>;
  employeeCount?: InputMaybe<IntComparisonExp>;
  estimatedHours?: InputMaybe<NumericComparisonExp>;
  estimatedRevenue?: InputMaybe<NumericComparisonExp>;
  files?: InputMaybe<FilesBoolExp>;
  filesAggregate?: InputMaybe<FilesAggregateBoolExp>;
  goLiveDate?: InputMaybe<DateComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lastBilledDate?: InputMaybe<TimestamptzComparisonExp>;
  managerUserId?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  newEmployees?: InputMaybe<IntComparisonExp>;
  parentPayroll?: InputMaybe<PayrollsBoolExp>;
  parentPayrollId?: InputMaybe<UuidComparisonExp>;
  payrollCycle?: InputMaybe<PayrollCyclesBoolExp>;
  payrollDateType?: InputMaybe<PayrollDateTypesBoolExp>;
  payrollDates?: InputMaybe<PayrollDatesBoolExp>;
  payrollDatesAggregate?: InputMaybe<PayrollDatesAggregateBoolExp>;
  payrollServiceAgreementsForPayroll?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  payrollServiceAgreementsForPayrollAggregate?: InputMaybe<PayrollServiceAgreementsAggregateBoolExp>;
  payrollSystem?: InputMaybe<StringComparisonExp>;
  payslipCount?: InputMaybe<IntComparisonExp>;
  primaryConsultant?: InputMaybe<UsersBoolExp>;
  primaryConsultantUserId?: InputMaybe<UuidComparisonExp>;
  processingDaysBeforeEft?: InputMaybe<IntComparisonExp>;
  processingTime?: InputMaybe<IntComparisonExp>;
  profitMargin?: InputMaybe<NumericComparisonExp>;
  requiredSkills?: InputMaybe<PayrollRequiredSkillsBoolExp>;
  requiredSkillsAggregate?: InputMaybe<PayrollRequiredSkillsAggregateBoolExp>;
  status?: InputMaybe<PayrollStatusComparisonExp>;
  supersededDate?: InputMaybe<DateComparisonExp>;
  terminatedEmployees?: InputMaybe<IntComparisonExp>;
  timeEntries?: InputMaybe<TimeEntriesBoolExp>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  versionNumber?: InputMaybe<IntComparisonExp>;
  versionReason?: InputMaybe<StringComparisonExp>;
};

/** unique or primary key constraints on table "payrolls" */
export type PayrollsConstraint =
  /** unique or primary key constraint on columns  */
  | 'only_one_current_version_per_family'
  /** unique or primary key constraint on columns "id" */
  | 'payrolls_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "payrolls" */
export type PayrollsIncInput = {
  actualHours?: InputMaybe<Scalars['numeric']['input']>;
  actualRevenue?: InputMaybe<Scalars['numeric']['input']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<Scalars['Int']['input']>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<Scalars['Int']['input']>;
  estimatedHours?: InputMaybe<Scalars['numeric']['input']>;
  estimatedRevenue?: InputMaybe<Scalars['numeric']['input']>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<Scalars['Int']['input']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<Scalars['Int']['input']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<Scalars['Int']['input']>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<Scalars['Int']['input']>;
  profitMargin?: InputMaybe<Scalars['numeric']['input']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<Scalars['Int']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "payrolls" */
export type PayrollsInsertInput = {
  actualHours?: InputMaybe<Scalars['numeric']['input']>;
  actualRevenue?: InputMaybe<Scalars['numeric']['input']>;
  assignedManager?: InputMaybe<UsersObjRelInsertInput>;
  backupConsultant?: InputMaybe<UsersObjRelInsertInput>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  billingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: InputMaybe<Scalars['String']['input']>;
  childPayrolls?: InputMaybe<PayrollsArrRelInsertInput>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  /** Reference to the client this payroll belongs to */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the payroll was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll cycle */
  cycleId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll date type */
  dateTypeId?: InputMaybe<Scalars['uuid']['input']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<Scalars['Int']['input']>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<Scalars['Int']['input']>;
  estimatedHours?: InputMaybe<Scalars['numeric']['input']>;
  estimatedRevenue?: InputMaybe<Scalars['numeric']['input']>;
  files?: InputMaybe<FilesArrRelInsertInput>;
  /** The date when the payroll went live in the system */
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the payroll */
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastBilledDate?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Manager overseeing this payroll */
  managerUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the payroll */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<Scalars['Int']['input']>;
  parentPayroll?: InputMaybe<PayrollsObjRelInsertInput>;
  parentPayrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollCycle?: InputMaybe<PayrollCyclesObjRelInsertInput>;
  payrollDateType?: InputMaybe<PayrollDateTypesObjRelInsertInput>;
  payrollDates?: InputMaybe<PayrollDatesArrRelInsertInput>;
  payrollServiceAgreementsForPayroll?: InputMaybe<PayrollServiceAgreementsArrRelInsertInput>;
  /** External payroll system used for this client */
  payrollSystem?: InputMaybe<Scalars['String']['input']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<Scalars['Int']['input']>;
  primaryConsultant?: InputMaybe<UsersObjRelInsertInput>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<Scalars['Int']['input']>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<Scalars['Int']['input']>;
  profitMargin?: InputMaybe<Scalars['numeric']['input']>;
  requiredSkills?: InputMaybe<PayrollRequiredSkillsArrRelInsertInput>;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status?: InputMaybe<Scalars['payroll_status']['input']>;
  supersededDate?: InputMaybe<Scalars['date']['input']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<Scalars['Int']['input']>;
  timeEntries?: InputMaybe<TimeEntriesArrRelInsertInput>;
  /** Timestamp when the payroll was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionReason?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type PayrollsMaxFields = {
  __typename?: 'PayrollsMaxFields';
  actualHours?: Maybe<Scalars['numeric']['output']>;
  actualRevenue?: Maybe<Scalars['numeric']['output']>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: Maybe<Scalars['String']['output']>;
  /** Reference to the client this payroll belongs to */
  clientId?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the payroll was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the payroll cycle */
  cycleId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the payroll date type */
  dateTypeId?: Maybe<Scalars['uuid']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Int']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Int']['output']>;
  estimatedHours?: Maybe<Scalars['numeric']['output']>;
  estimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  /** The date when the payroll went live in the system */
  goLiveDate?: Maybe<Scalars['date']['output']>;
  /** Unique identifier for the payroll */
  id?: Maybe<Scalars['uuid']['output']>;
  lastBilledDate?: Maybe<Scalars['timestamptz']['output']>;
  /** Manager overseeing this payroll */
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  /** Name of the payroll */
  name?: Maybe<Scalars['String']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Int']['output']>;
  parentPayrollId?: Maybe<Scalars['uuid']['output']>;
  /** External payroll system used for this client */
  payrollSystem?: Maybe<Scalars['String']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Int']['output']>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Int']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Int']['output']>;
  profitMargin?: Maybe<Scalars['numeric']['output']>;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status?: Maybe<Scalars['payroll_status']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the payroll was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "payrolls" */
export type PayrollsMaxOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: InputMaybe<OrderBy>;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: InputMaybe<OrderBy>;
  /** Reference to the client this payroll belongs to */
  clientId?: InputMaybe<OrderBy>;
  /** Timestamp when the payroll was created */
  createdAt?: InputMaybe<OrderBy>;
  createdByUserId?: InputMaybe<OrderBy>;
  /** Reference to the payroll cycle */
  cycleId?: InputMaybe<OrderBy>;
  /** Reference to the payroll date type */
  dateTypeId?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** The date when the payroll went live in the system */
  goLiveDate?: InputMaybe<OrderBy>;
  /** Unique identifier for the payroll */
  id?: InputMaybe<OrderBy>;
  lastBilledDate?: InputMaybe<OrderBy>;
  /** Manager overseeing this payroll */
  managerUserId?: InputMaybe<OrderBy>;
  /** Name of the payroll */
  name?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  parentPayrollId?: InputMaybe<OrderBy>;
  /** External payroll system used for this client */
  payrollSystem?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status?: InputMaybe<OrderBy>;
  supersededDate?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  /** Timestamp when the payroll was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
  versionReason?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PayrollsMinFields = {
  __typename?: 'PayrollsMinFields';
  actualHours?: Maybe<Scalars['numeric']['output']>;
  actualRevenue?: Maybe<Scalars['numeric']['output']>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: Maybe<Scalars['String']['output']>;
  /** Reference to the client this payroll belongs to */
  clientId?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the payroll was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByUserId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the payroll cycle */
  cycleId?: Maybe<Scalars['uuid']['output']>;
  /** Reference to the payroll date type */
  dateTypeId?: Maybe<Scalars['uuid']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Int']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Int']['output']>;
  estimatedHours?: Maybe<Scalars['numeric']['output']>;
  estimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  /** The date when the payroll went live in the system */
  goLiveDate?: Maybe<Scalars['date']['output']>;
  /** Unique identifier for the payroll */
  id?: Maybe<Scalars['uuid']['output']>;
  lastBilledDate?: Maybe<Scalars['timestamptz']['output']>;
  /** Manager overseeing this payroll */
  managerUserId?: Maybe<Scalars['uuid']['output']>;
  /** Name of the payroll */
  name?: Maybe<Scalars['String']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Int']['output']>;
  parentPayrollId?: Maybe<Scalars['uuid']['output']>;
  /** External payroll system used for this client */
  payrollSystem?: Maybe<Scalars['String']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Int']['output']>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: Maybe<Scalars['uuid']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Int']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Int']['output']>;
  profitMargin?: Maybe<Scalars['numeric']['output']>;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status?: Maybe<Scalars['payroll_status']['output']>;
  supersededDate?: Maybe<Scalars['date']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Int']['output']>;
  /** Timestamp when the payroll was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
  versionReason?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "payrolls" */
export type PayrollsMinOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: InputMaybe<OrderBy>;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: InputMaybe<OrderBy>;
  /** Reference to the client this payroll belongs to */
  clientId?: InputMaybe<OrderBy>;
  /** Timestamp when the payroll was created */
  createdAt?: InputMaybe<OrderBy>;
  createdByUserId?: InputMaybe<OrderBy>;
  /** Reference to the payroll cycle */
  cycleId?: InputMaybe<OrderBy>;
  /** Reference to the payroll date type */
  dateTypeId?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** The date when the payroll went live in the system */
  goLiveDate?: InputMaybe<OrderBy>;
  /** Unique identifier for the payroll */
  id?: InputMaybe<OrderBy>;
  lastBilledDate?: InputMaybe<OrderBy>;
  /** Manager overseeing this payroll */
  managerUserId?: InputMaybe<OrderBy>;
  /** Name of the payroll */
  name?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  parentPayrollId?: InputMaybe<OrderBy>;
  /** External payroll system used for this client */
  payrollSystem?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status?: InputMaybe<OrderBy>;
  supersededDate?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  /** Timestamp when the payroll was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
  versionReason?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "payrolls" */
export type PayrollsMutationResponse = {
  __typename?: 'PayrollsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Payrolls>;
};

/** input type for inserting object relation for remote table "payrolls" */
export type PayrollsObjRelInsertInput = {
  data: PayrollsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PayrollsOnConflict>;
};

/** on_conflict condition type for table "payrolls" */
export type PayrollsOnConflict = {
  constraint: PayrollsConstraint;
  updateColumns?: Array<PayrollsUpdateColumn>;
  where?: InputMaybe<PayrollsBoolExp>;
};

/** Ordering options when selecting data from "payrolls". */
export type PayrollsOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  assignedManager?: InputMaybe<UsersOrderBy>;
  backupConsultant?: InputMaybe<UsersOrderBy>;
  backupConsultantUserId?: InputMaybe<OrderBy>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  billingStatus?: InputMaybe<OrderBy>;
  childPayrollsAggregate?: InputMaybe<PayrollsAggregateOrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdByUserId?: InputMaybe<OrderBy>;
  cycleId?: InputMaybe<OrderBy>;
  dateTypeId?: InputMaybe<OrderBy>;
  dateValue?: InputMaybe<OrderBy>;
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  filesAggregate?: InputMaybe<FilesAggregateOrderBy>;
  goLiveDate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastBilledDate?: InputMaybe<OrderBy>;
  managerUserId?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  newEmployees?: InputMaybe<OrderBy>;
  parentPayroll?: InputMaybe<PayrollsOrderBy>;
  parentPayrollId?: InputMaybe<OrderBy>;
  payrollCycle?: InputMaybe<PayrollCyclesOrderBy>;
  payrollDateType?: InputMaybe<PayrollDateTypesOrderBy>;
  payrollDatesAggregate?: InputMaybe<PayrollDatesAggregateOrderBy>;
  payrollServiceAgreementsForPayrollAggregate?: InputMaybe<PayrollServiceAgreementsAggregateOrderBy>;
  payrollSystem?: InputMaybe<OrderBy>;
  payslipCount?: InputMaybe<OrderBy>;
  primaryConsultant?: InputMaybe<UsersOrderBy>;
  primaryConsultantUserId?: InputMaybe<OrderBy>;
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  requiredSkillsAggregate?: InputMaybe<PayrollRequiredSkillsAggregateOrderBy>;
  status?: InputMaybe<OrderBy>;
  supersededDate?: InputMaybe<OrderBy>;
  terminatedEmployees?: InputMaybe<OrderBy>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
  versionReason?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: payrolls */
export type PayrollsPkColumnsInput = {
  /** Unique identifier for the payroll */
  id: Scalars['uuid']['input'];
};

/** select columns of table "payrolls" */
export type PayrollsSelectColumn =
  /** column name */
  | 'actualHours'
  /** column name */
  | 'actualRevenue'
  /** column name */
  | 'backupConsultantUserId'
  /** column name */
  | 'billingStatus'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdByUserId'
  /** column name */
  | 'cycleId'
  /** column name */
  | 'dateTypeId'
  /** column name */
  | 'dateValue'
  /** column name */
  | 'employeeCount'
  /** column name */
  | 'estimatedHours'
  /** column name */
  | 'estimatedRevenue'
  /** column name */
  | 'goLiveDate'
  /** column name */
  | 'id'
  /** column name */
  | 'lastBilledDate'
  /** column name */
  | 'managerUserId'
  /** column name */
  | 'name'
  /** column name */
  | 'newEmployees'
  /** column name */
  | 'parentPayrollId'
  /** column name */
  | 'payrollSystem'
  /** column name */
  | 'payslipCount'
  /** column name */
  | 'primaryConsultantUserId'
  /** column name */
  | 'processingDaysBeforeEft'
  /** column name */
  | 'processingTime'
  /** column name */
  | 'profitMargin'
  /** column name */
  | 'status'
  /** column name */
  | 'supersededDate'
  /** column name */
  | 'terminatedEmployees'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'versionNumber'
  /** column name */
  | 'versionReason'
  | '%future added value';

/** input type for updating data in table "payrolls" */
export type PayrollsSetInput = {
  actualHours?: InputMaybe<Scalars['numeric']['input']>;
  actualRevenue?: InputMaybe<Scalars['numeric']['input']>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: InputMaybe<Scalars['String']['input']>;
  /** Reference to the client this payroll belongs to */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the payroll was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll cycle */
  cycleId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll date type */
  dateTypeId?: InputMaybe<Scalars['uuid']['input']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<Scalars['Int']['input']>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<Scalars['Int']['input']>;
  estimatedHours?: InputMaybe<Scalars['numeric']['input']>;
  estimatedRevenue?: InputMaybe<Scalars['numeric']['input']>;
  /** The date when the payroll went live in the system */
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the payroll */
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastBilledDate?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Manager overseeing this payroll */
  managerUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the payroll */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<Scalars['Int']['input']>;
  parentPayrollId?: InputMaybe<Scalars['uuid']['input']>;
  /** External payroll system used for this client */
  payrollSystem?: InputMaybe<Scalars['String']['input']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<Scalars['Int']['input']>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<Scalars['Int']['input']>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<Scalars['Int']['input']>;
  profitMargin?: InputMaybe<Scalars['numeric']['input']>;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status?: InputMaybe<Scalars['payroll_status']['input']>;
  supersededDate?: InputMaybe<Scalars['date']['input']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<Scalars['Int']['input']>;
  /** Timestamp when the payroll was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionReason?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type PayrollsStddevFields = {
  __typename?: 'PayrollsStddevFields';
  actualHours?: Maybe<Scalars['Float']['output']>;
  actualRevenue?: Maybe<Scalars['Float']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Float']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Float']['output']>;
  estimatedHours?: Maybe<Scalars['Float']['output']>;
  estimatedRevenue?: Maybe<Scalars['Float']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Float']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Float']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Float']['output']>;
  profitMargin?: Maybe<Scalars['Float']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "payrolls" */
export type PayrollsStddevOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type PayrollsStddevPopFields = {
  __typename?: 'PayrollsStddevPopFields';
  actualHours?: Maybe<Scalars['Float']['output']>;
  actualRevenue?: Maybe<Scalars['Float']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Float']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Float']['output']>;
  estimatedHours?: Maybe<Scalars['Float']['output']>;
  estimatedRevenue?: Maybe<Scalars['Float']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Float']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Float']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Float']['output']>;
  profitMargin?: Maybe<Scalars['Float']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "payrolls" */
export type PayrollsStddevPopOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type PayrollsStddevSampFields = {
  __typename?: 'PayrollsStddevSampFields';
  actualHours?: Maybe<Scalars['Float']['output']>;
  actualRevenue?: Maybe<Scalars['Float']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Float']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Float']['output']>;
  estimatedHours?: Maybe<Scalars['Float']['output']>;
  estimatedRevenue?: Maybe<Scalars['Float']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Float']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Float']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Float']['output']>;
  profitMargin?: Maybe<Scalars['Float']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "payrolls" */
export type PayrollsStddevSampOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "payrolls" */
export type PayrollsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PayrollsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PayrollsStreamCursorValueInput = {
  actualHours?: InputMaybe<Scalars['numeric']['input']>;
  actualRevenue?: InputMaybe<Scalars['numeric']['input']>;
  /** Backup consultant for this payroll */
  backupConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Billing status: pending, items_added, ready_to_bill, billed */
  billingStatus?: InputMaybe<Scalars['String']['input']>;
  /** Reference to the client this payroll belongs to */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the payroll was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll cycle */
  cycleId?: InputMaybe<Scalars['uuid']['input']>;
  /** Reference to the payroll date type */
  dateTypeId?: InputMaybe<Scalars['uuid']['input']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<Scalars['Int']['input']>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<Scalars['Int']['input']>;
  estimatedHours?: InputMaybe<Scalars['numeric']['input']>;
  estimatedRevenue?: InputMaybe<Scalars['numeric']['input']>;
  /** The date when the payroll went live in the system */
  goLiveDate?: InputMaybe<Scalars['date']['input']>;
  /** Unique identifier for the payroll */
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastBilledDate?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Manager overseeing this payroll */
  managerUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Name of the payroll */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<Scalars['Int']['input']>;
  parentPayrollId?: InputMaybe<Scalars['uuid']['input']>;
  /** External payroll system used for this client */
  payrollSystem?: InputMaybe<Scalars['String']['input']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<Scalars['Int']['input']>;
  /** Primary consultant responsible for this payroll */
  primaryConsultantUserId?: InputMaybe<Scalars['uuid']['input']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<Scalars['Int']['input']>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<Scalars['Int']['input']>;
  profitMargin?: InputMaybe<Scalars['numeric']['input']>;
  /** Current status of the payroll (Implementation, Active, Inactive) */
  status?: InputMaybe<Scalars['payroll_status']['input']>;
  supersededDate?: InputMaybe<Scalars['date']['input']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<Scalars['Int']['input']>;
  /** Timestamp when the payroll was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  versionNumber?: InputMaybe<Scalars['Int']['input']>;
  versionReason?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type PayrollsSumFields = {
  __typename?: 'PayrollsSumFields';
  actualHours?: Maybe<Scalars['numeric']['output']>;
  actualRevenue?: Maybe<Scalars['numeric']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Int']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Int']['output']>;
  estimatedHours?: Maybe<Scalars['numeric']['output']>;
  estimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Int']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Int']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Int']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Int']['output']>;
  profitMargin?: Maybe<Scalars['numeric']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Int']['output']>;
  versionNumber?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "payrolls" */
export type PayrollsSumOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** update columns of table "payrolls" */
export type PayrollsUpdateColumn =
  /** column name */
  | 'actualHours'
  /** column name */
  | 'actualRevenue'
  /** column name */
  | 'backupConsultantUserId'
  /** column name */
  | 'billingStatus'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdByUserId'
  /** column name */
  | 'cycleId'
  /** column name */
  | 'dateTypeId'
  /** column name */
  | 'dateValue'
  /** column name */
  | 'employeeCount'
  /** column name */
  | 'estimatedHours'
  /** column name */
  | 'estimatedRevenue'
  /** column name */
  | 'goLiveDate'
  /** column name */
  | 'id'
  /** column name */
  | 'lastBilledDate'
  /** column name */
  | 'managerUserId'
  /** column name */
  | 'name'
  /** column name */
  | 'newEmployees'
  /** column name */
  | 'parentPayrollId'
  /** column name */
  | 'payrollSystem'
  /** column name */
  | 'payslipCount'
  /** column name */
  | 'primaryConsultantUserId'
  /** column name */
  | 'processingDaysBeforeEft'
  /** column name */
  | 'processingTime'
  /** column name */
  | 'profitMargin'
  /** column name */
  | 'status'
  /** column name */
  | 'supersededDate'
  /** column name */
  | 'terminatedEmployees'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'versionNumber'
  /** column name */
  | 'versionReason'
  | '%future added value';

export type PayrollsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PayrollsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PayrollsSetInput>;
  /** filter the rows which have to be updated */
  where: PayrollsBoolExp;
};

/** aggregate varPop on columns */
export type PayrollsVarPopFields = {
  __typename?: 'PayrollsVarPopFields';
  actualHours?: Maybe<Scalars['Float']['output']>;
  actualRevenue?: Maybe<Scalars['Float']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Float']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Float']['output']>;
  estimatedHours?: Maybe<Scalars['Float']['output']>;
  estimatedRevenue?: Maybe<Scalars['Float']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Float']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Float']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Float']['output']>;
  profitMargin?: Maybe<Scalars['Float']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "payrolls" */
export type PayrollsVarPopOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type PayrollsVarSampFields = {
  __typename?: 'PayrollsVarSampFields';
  actualHours?: Maybe<Scalars['Float']['output']>;
  actualRevenue?: Maybe<Scalars['Float']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Float']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Float']['output']>;
  estimatedHours?: Maybe<Scalars['Float']['output']>;
  estimatedRevenue?: Maybe<Scalars['Float']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Float']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Float']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Float']['output']>;
  profitMargin?: Maybe<Scalars['Float']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "payrolls" */
export type PayrollsVarSampOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type PayrollsVarianceFields = {
  __typename?: 'PayrollsVarianceFields';
  actualHours?: Maybe<Scalars['Float']['output']>;
  actualRevenue?: Maybe<Scalars['Float']['output']>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: Maybe<Scalars['Float']['output']>;
  /** Number of employees in this payroll */
  employeeCount?: Maybe<Scalars['Float']['output']>;
  estimatedHours?: Maybe<Scalars['Float']['output']>;
  estimatedRevenue?: Maybe<Scalars['Float']['output']>;
  /** Number of new employees processed */
  newEmployees?: Maybe<Scalars['Float']['output']>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: Maybe<Scalars['Float']['output']>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: Maybe<Scalars['Float']['output']>;
  /** Number of hours required to process this payroll */
  processingTime?: Maybe<Scalars['Float']['output']>;
  profitMargin?: Maybe<Scalars['Float']['output']>;
  /** Number of terminated employees processed */
  terminatedEmployees?: Maybe<Scalars['Float']['output']>;
  versionNumber?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "payrolls" */
export type PayrollsVarianceOrderBy = {
  actualHours?: InputMaybe<OrderBy>;
  actualRevenue?: InputMaybe<OrderBy>;
  /** Specific value for date calculation (e.g., day of month) */
  dateValue?: InputMaybe<OrderBy>;
  /** Number of employees in this payroll */
  employeeCount?: InputMaybe<OrderBy>;
  estimatedHours?: InputMaybe<OrderBy>;
  estimatedRevenue?: InputMaybe<OrderBy>;
  /** Number of new employees processed */
  newEmployees?: InputMaybe<OrderBy>;
  /** Number of payslips processed in this payroll run */
  payslipCount?: InputMaybe<OrderBy>;
  /** Number of days before EFT that processing must complete */
  processingDaysBeforeEft?: InputMaybe<OrderBy>;
  /** Number of hours required to process this payroll */
  processingTime?: InputMaybe<OrderBy>;
  profitMargin?: InputMaybe<OrderBy>;
  /** Number of terminated employees processed */
  terminatedEmployees?: InputMaybe<OrderBy>;
  versionNumber?: InputMaybe<OrderBy>;
};

/** All billing items awaiting manager approval */
export type PendingBillingApprovals = {
  __typename?: 'PendingBillingApprovals';
  amount?: Maybe<Scalars['numeric']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  daysPending?: Maybe<Scalars['numeric']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  isAutoGenerated?: Maybe<Scalars['Boolean']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  serviceCategory?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  unitPrice?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "pending_billing_approvals" */
export type PendingBillingApprovalsAggregate = {
  __typename?: 'PendingBillingApprovalsAggregate';
  aggregate?: Maybe<PendingBillingApprovalsAggregateFields>;
  nodes: Array<PendingBillingApprovals>;
};

/** aggregate fields of "pending_billing_approvals" */
export type PendingBillingApprovalsAggregateFields = {
  __typename?: 'PendingBillingApprovalsAggregateFields';
  avg?: Maybe<PendingBillingApprovalsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PendingBillingApprovalsMaxFields>;
  min?: Maybe<PendingBillingApprovalsMinFields>;
  stddev?: Maybe<PendingBillingApprovalsStddevFields>;
  stddevPop?: Maybe<PendingBillingApprovalsStddevPopFields>;
  stddevSamp?: Maybe<PendingBillingApprovalsStddevSampFields>;
  sum?: Maybe<PendingBillingApprovalsSumFields>;
  varPop?: Maybe<PendingBillingApprovalsVarPopFields>;
  varSamp?: Maybe<PendingBillingApprovalsVarSampFields>;
  variance?: Maybe<PendingBillingApprovalsVarianceFields>;
};


/** aggregate fields of "pending_billing_approvals" */
export type PendingBillingApprovalsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PendingBillingApprovalsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PendingBillingApprovalsAvgFields = {
  __typename?: 'PendingBillingApprovalsAvgFields';
  amount?: Maybe<Scalars['Float']['output']>;
  daysPending?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "pending_billing_approvals". All fields are combined with a logical 'AND'. */
export type PendingBillingApprovalsBoolExp = {
  _and?: InputMaybe<Array<PendingBillingApprovalsBoolExp>>;
  _not?: InputMaybe<PendingBillingApprovalsBoolExp>;
  _or?: InputMaybe<Array<PendingBillingApprovalsBoolExp>>;
  amount?: InputMaybe<NumericComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  daysPending?: InputMaybe<NumericComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isAutoGenerated?: InputMaybe<BooleanComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  payrollName?: InputMaybe<StringComparisonExp>;
  quantity?: InputMaybe<IntComparisonExp>;
  serviceCategory?: InputMaybe<StringComparisonExp>;
  serviceId?: InputMaybe<UuidComparisonExp>;
  serviceName?: InputMaybe<StringComparisonExp>;
  staffName?: InputMaybe<StringComparisonExp>;
  staffUserId?: InputMaybe<UuidComparisonExp>;
  unitPrice?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type PendingBillingApprovalsMaxFields = {
  __typename?: 'PendingBillingApprovalsMaxFields';
  amount?: Maybe<Scalars['numeric']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  daysPending?: Maybe<Scalars['numeric']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  serviceCategory?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  unitPrice?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type PendingBillingApprovalsMinFields = {
  __typename?: 'PendingBillingApprovalsMinFields';
  amount?: Maybe<Scalars['numeric']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  daysPending?: Maybe<Scalars['numeric']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  serviceCategory?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  serviceName?: Maybe<Scalars['String']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  unitPrice?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "pending_billing_approvals". */
export type PendingBillingApprovalsOrderBy = {
  amount?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  daysPending?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isAutoGenerated?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  payrollName?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  serviceCategory?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  serviceName?: InputMaybe<OrderBy>;
  staffName?: InputMaybe<OrderBy>;
  staffUserId?: InputMaybe<OrderBy>;
  unitPrice?: InputMaybe<OrderBy>;
};

/** select columns of table "pending_billing_approvals" */
export type PendingBillingApprovalsSelectColumn =
  /** column name */
  | 'amount'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'daysPending'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'isAutoGenerated'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'payrollName'
  /** column name */
  | 'quantity'
  /** column name */
  | 'serviceCategory'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'serviceName'
  /** column name */
  | 'staffName'
  /** column name */
  | 'staffUserId'
  /** column name */
  | 'unitPrice'
  | '%future added value';

/** aggregate stddev on columns */
export type PendingBillingApprovalsStddevFields = {
  __typename?: 'PendingBillingApprovalsStddevFields';
  amount?: Maybe<Scalars['Float']['output']>;
  daysPending?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PendingBillingApprovalsStddevPopFields = {
  __typename?: 'PendingBillingApprovalsStddevPopFields';
  amount?: Maybe<Scalars['Float']['output']>;
  daysPending?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PendingBillingApprovalsStddevSampFields = {
  __typename?: 'PendingBillingApprovalsStddevSampFields';
  amount?: Maybe<Scalars['Float']['output']>;
  daysPending?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "pending_billing_approvals" */
export type PendingBillingApprovalsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PendingBillingApprovalsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PendingBillingApprovalsStreamCursorValueInput = {
  amount?: InputMaybe<Scalars['numeric']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  daysPending?: InputMaybe<Scalars['numeric']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isAutoGenerated?: InputMaybe<Scalars['Boolean']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollName?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  serviceCategory?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  serviceName?: InputMaybe<Scalars['String']['input']>;
  staffName?: InputMaybe<Scalars['String']['input']>;
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  unitPrice?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type PendingBillingApprovalsSumFields = {
  __typename?: 'PendingBillingApprovalsSumFields';
  amount?: Maybe<Scalars['numeric']['output']>;
  daysPending?: Maybe<Scalars['numeric']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  unitPrice?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type PendingBillingApprovalsVarPopFields = {
  __typename?: 'PendingBillingApprovalsVarPopFields';
  amount?: Maybe<Scalars['Float']['output']>;
  daysPending?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PendingBillingApprovalsVarSampFields = {
  __typename?: 'PendingBillingApprovalsVarSampFields';
  amount?: Maybe<Scalars['Float']['output']>;
  daysPending?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PendingBillingApprovalsVarianceFields = {
  __typename?: 'PendingBillingApprovalsVarianceFields';
  amount?: Maybe<Scalars['Float']['output']>;
  daysPending?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  unitPrice?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "permission_action". All fields are combined with logical 'AND'. */
export type PermissionActionComparisonExp = {
  _eq?: InputMaybe<Scalars['permission_action']['input']>;
  _gt?: InputMaybe<Scalars['permission_action']['input']>;
  _gte?: InputMaybe<Scalars['permission_action']['input']>;
  _in?: InputMaybe<Array<Scalars['permission_action']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['permission_action']['input']>;
  _lte?: InputMaybe<Scalars['permission_action']['input']>;
  _neq?: InputMaybe<Scalars['permission_action']['input']>;
  _nin?: InputMaybe<Array<Scalars['permission_action']['input']>>;
};

/** Audit log for permission changes and access attempts */
export type PermissionAuditLog = {
  __typename?: 'PermissionAuditLog';
  action: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  newValue?: Maybe<Scalars['jsonb']['output']>;
  operation: Scalars['String']['output'];
  previousValue?: Maybe<Scalars['jsonb']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  resource: Scalars['String']['output'];
  targetRole?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  targetUser?: Maybe<Users>;
  targetUserId?: Maybe<Scalars['uuid']['output']>;
  timestamp: Scalars['timestamptz']['output'];
  /** An object relationship */
  user?: Maybe<Users>;
  userId?: Maybe<Scalars['uuid']['output']>;
};


/** Audit log for permission changes and access attempts */
export type PermissionAuditLogNewValueArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Audit log for permission changes and access attempts */
export type PermissionAuditLogPreviousValueArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "permission_audit_log" */
export type PermissionAuditLogAggregate = {
  __typename?: 'PermissionAuditLogAggregate';
  aggregate?: Maybe<PermissionAuditLogAggregateFields>;
  nodes: Array<PermissionAuditLog>;
};

export type PermissionAuditLogAggregateBoolExp = {
  count?: InputMaybe<PermissionAuditLogAggregateBoolExpCount>;
};

/** aggregate fields of "permission_audit_log" */
export type PermissionAuditLogAggregateFields = {
  __typename?: 'PermissionAuditLogAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PermissionAuditLogMaxFields>;
  min?: Maybe<PermissionAuditLogMinFields>;
};


/** aggregate fields of "permission_audit_log" */
export type PermissionAuditLogAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "permission_audit_log" */
export type PermissionAuditLogAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PermissionAuditLogMaxOrderBy>;
  min?: InputMaybe<PermissionAuditLogMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type PermissionAuditLogAppendInput = {
  newValue?: InputMaybe<Scalars['jsonb']['input']>;
  previousValue?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "permission_audit_log" */
export type PermissionAuditLogArrRelInsertInput = {
  data: Array<PermissionAuditLogInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PermissionAuditLogOnConflict>;
};

/** Boolean expression to filter rows from the table "permission_audit_log". All fields are combined with a logical 'AND'. */
export type PermissionAuditLogBoolExp = {
  _and?: InputMaybe<Array<PermissionAuditLogBoolExp>>;
  _not?: InputMaybe<PermissionAuditLogBoolExp>;
  _or?: InputMaybe<Array<PermissionAuditLogBoolExp>>;
  action?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  newValue?: InputMaybe<JsonbComparisonExp>;
  operation?: InputMaybe<StringComparisonExp>;
  previousValue?: InputMaybe<JsonbComparisonExp>;
  reason?: InputMaybe<StringComparisonExp>;
  resource?: InputMaybe<StringComparisonExp>;
  targetRole?: InputMaybe<StringComparisonExp>;
  targetUser?: InputMaybe<UsersBoolExp>;
  targetUserId?: InputMaybe<UuidComparisonExp>;
  timestamp?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "permission_audit_log" */
export type PermissionAuditLogConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'permission_audit_log_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type PermissionAuditLogDeleteAtPathInput = {
  newValue?: InputMaybe<Array<Scalars['String']['input']>>;
  previousValue?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type PermissionAuditLogDeleteElemInput = {
  newValue?: InputMaybe<Scalars['Int']['input']>;
  previousValue?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type PermissionAuditLogDeleteKeyInput = {
  newValue?: InputMaybe<Scalars['String']['input']>;
  previousValue?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "permission_audit_log" */
export type PermissionAuditLogInsertInput = {
  action?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  newValue?: InputMaybe<Scalars['jsonb']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
  previousValue?: InputMaybe<Scalars['jsonb']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  targetRole?: InputMaybe<Scalars['String']['input']>;
  targetUser?: InputMaybe<UsersObjRelInsertInput>;
  targetUserId?: InputMaybe<Scalars['uuid']['input']>;
  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type PermissionAuditLogMaxFields = {
  __typename?: 'PermissionAuditLogMaxFields';
  action?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  operation?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  resource?: Maybe<Scalars['String']['output']>;
  targetRole?: Maybe<Scalars['String']['output']>;
  targetUserId?: Maybe<Scalars['uuid']['output']>;
  timestamp?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "permission_audit_log" */
export type PermissionAuditLogMaxOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  operation?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  resource?: InputMaybe<OrderBy>;
  targetRole?: InputMaybe<OrderBy>;
  targetUserId?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PermissionAuditLogMinFields = {
  __typename?: 'PermissionAuditLogMinFields';
  action?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  operation?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  resource?: Maybe<Scalars['String']['output']>;
  targetRole?: Maybe<Scalars['String']['output']>;
  targetUserId?: Maybe<Scalars['uuid']['output']>;
  timestamp?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "permission_audit_log" */
export type PermissionAuditLogMinOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  operation?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  resource?: InputMaybe<OrderBy>;
  targetRole?: InputMaybe<OrderBy>;
  targetUserId?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "permission_audit_log" */
export type PermissionAuditLogMutationResponse = {
  __typename?: 'PermissionAuditLogMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PermissionAuditLog>;
};

/** on_conflict condition type for table "permission_audit_log" */
export type PermissionAuditLogOnConflict = {
  constraint: PermissionAuditLogConstraint;
  updateColumns?: Array<PermissionAuditLogUpdateColumn>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};

/** Ordering options when selecting data from "permission_audit_log". */
export type PermissionAuditLogOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  newValue?: InputMaybe<OrderBy>;
  operation?: InputMaybe<OrderBy>;
  previousValue?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  resource?: InputMaybe<OrderBy>;
  targetRole?: InputMaybe<OrderBy>;
  targetUser?: InputMaybe<UsersOrderBy>;
  targetUserId?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: permission_audit_log */
export type PermissionAuditLogPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type PermissionAuditLogPrependInput = {
  newValue?: InputMaybe<Scalars['jsonb']['input']>;
  previousValue?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "permission_audit_log" */
export type PermissionAuditLogSelectColumn =
  /** column name */
  | 'action'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'newValue'
  /** column name */
  | 'operation'
  /** column name */
  | 'previousValue'
  /** column name */
  | 'reason'
  /** column name */
  | 'resource'
  /** column name */
  | 'targetRole'
  /** column name */
  | 'targetUserId'
  /** column name */
  | 'timestamp'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "permission_audit_log" */
export type PermissionAuditLogSetInput = {
  action?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  newValue?: InputMaybe<Scalars['jsonb']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
  previousValue?: InputMaybe<Scalars['jsonb']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  targetRole?: InputMaybe<Scalars['String']['input']>;
  targetUserId?: InputMaybe<Scalars['uuid']['input']>;
  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "permission_audit_log" */
export type PermissionAuditLogStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PermissionAuditLogStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PermissionAuditLogStreamCursorValueInput = {
  action?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  newValue?: InputMaybe<Scalars['jsonb']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
  previousValue?: InputMaybe<Scalars['jsonb']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  targetRole?: InputMaybe<Scalars['String']['input']>;
  targetUserId?: InputMaybe<Scalars['uuid']['input']>;
  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "permission_audit_log" */
export type PermissionAuditLogUpdateColumn =
  /** column name */
  | 'action'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'newValue'
  /** column name */
  | 'operation'
  /** column name */
  | 'previousValue'
  /** column name */
  | 'reason'
  /** column name */
  | 'resource'
  /** column name */
  | 'targetRole'
  /** column name */
  | 'targetUserId'
  /** column name */
  | 'timestamp'
  /** column name */
  | 'userId'
  | '%future added value';

export type PermissionAuditLogUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<PermissionAuditLogAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<PermissionAuditLogDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<PermissionAuditLogDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<PermissionAuditLogDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<PermissionAuditLogPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PermissionAuditLogSetInput>;
  /** filter the rows which have to be updated */
  where: PermissionAuditLogBoolExp;
};

/** User-specific and role-specific permission overrides */
export type PermissionOverrides = {
  __typename?: 'PermissionOverrides';
  /** JSON conditions for conditional permissions */
  conditions?: Maybe<Scalars['jsonb']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  createdByUser?: Maybe<Users>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Whether the permission is granted (true) or denied (false) */
  granted: Scalars['Boolean']['output'];
  id: Scalars['uuid']['output'];
  operation: Scalars['String']['output'];
  reason?: Maybe<Scalars['String']['output']>;
  resource: Scalars['String']['output'];
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user?: Maybe<Users>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: Maybe<Scalars['uuid']['output']>;
};


/** User-specific and role-specific permission overrides */
export type PermissionOverridesConditionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "permission_overrides" */
export type PermissionOverridesAggregate = {
  __typename?: 'PermissionOverridesAggregate';
  aggregate?: Maybe<PermissionOverridesAggregateFields>;
  nodes: Array<PermissionOverrides>;
};

export type PermissionOverridesAggregateBoolExp = {
  bool_and?: InputMaybe<PermissionOverridesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<PermissionOverridesAggregateBoolExpBool_Or>;
  count?: InputMaybe<PermissionOverridesAggregateBoolExpCount>;
};

/** aggregate fields of "permission_overrides" */
export type PermissionOverridesAggregateFields = {
  __typename?: 'PermissionOverridesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PermissionOverridesMaxFields>;
  min?: Maybe<PermissionOverridesMinFields>;
};


/** aggregate fields of "permission_overrides" */
export type PermissionOverridesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "permission_overrides" */
export type PermissionOverridesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PermissionOverridesMaxOrderBy>;
  min?: InputMaybe<PermissionOverridesMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type PermissionOverridesAppendInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "permission_overrides" */
export type PermissionOverridesArrRelInsertInput = {
  data: Array<PermissionOverridesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PermissionOverridesOnConflict>;
};

/** Boolean expression to filter rows from the table "permission_overrides". All fields are combined with a logical 'AND'. */
export type PermissionOverridesBoolExp = {
  _and?: InputMaybe<Array<PermissionOverridesBoolExp>>;
  _not?: InputMaybe<PermissionOverridesBoolExp>;
  _or?: InputMaybe<Array<PermissionOverridesBoolExp>>;
  conditions?: InputMaybe<JsonbComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  expiresAt?: InputMaybe<TimestamptzComparisonExp>;
  granted?: InputMaybe<BooleanComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  operation?: InputMaybe<StringComparisonExp>;
  reason?: InputMaybe<StringComparisonExp>;
  resource?: InputMaybe<StringComparisonExp>;
  role?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "permission_overrides" */
export type PermissionOverridesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'permission_overrides_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type PermissionOverridesDeleteAtPathInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type PermissionOverridesDeleteElemInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type PermissionOverridesDeleteKeyInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "permission_overrides" */
export type PermissionOverridesInsertInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Whether the permission is granted (true) or denied (false) */
  granted?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type PermissionOverridesMaxFields = {
  __typename?: 'PermissionOverridesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  operation?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  resource?: Maybe<Scalars['String']['output']>;
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "permission_overrides" */
export type PermissionOverridesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  operation?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  resource?: InputMaybe<OrderBy>;
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PermissionOverridesMinFields = {
  __typename?: 'PermissionOverridesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  operation?: Maybe<Scalars['String']['output']>;
  reason?: Maybe<Scalars['String']['output']>;
  resource?: Maybe<Scalars['String']['output']>;
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "permission_overrides" */
export type PermissionOverridesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  operation?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  resource?: InputMaybe<OrderBy>;
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "permission_overrides" */
export type PermissionOverridesMutationResponse = {
  __typename?: 'PermissionOverridesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PermissionOverrides>;
};

/** on_conflict condition type for table "permission_overrides" */
export type PermissionOverridesOnConflict = {
  constraint: PermissionOverridesConstraint;
  updateColumns?: Array<PermissionOverridesUpdateColumn>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};

/** Ordering options when selecting data from "permission_overrides". */
export type PermissionOverridesOrderBy = {
  conditions?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  granted?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  operation?: InputMaybe<OrderBy>;
  reason?: InputMaybe<OrderBy>;
  resource?: InputMaybe<OrderBy>;
  role?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: permission_overrides */
export type PermissionOverridesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type PermissionOverridesPrependInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "permission_overrides" */
export type PermissionOverridesSelectColumn =
  /** column name */
  | 'conditions'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'granted'
  /** column name */
  | 'id'
  /** column name */
  | 'operation'
  /** column name */
  | 'reason'
  /** column name */
  | 'resource'
  /** column name */
  | 'role'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

/** select "permissionOverridesAggregateBoolExpBool_andArgumentsColumns" columns of table "permission_overrides" */
export type PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'granted'
  | '%future added value';

/** select "permissionOverridesAggregateBoolExpBool_orArgumentsColumns" columns of table "permission_overrides" */
export type PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'granted'
  | '%future added value';

/** input type for updating data in table "permission_overrides" */
export type PermissionOverridesSetInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Whether the permission is granted (true) or denied (false) */
  granted?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "permission_overrides" */
export type PermissionOverridesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PermissionOverridesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PermissionOverridesStreamCursorValueInput = {
  /** JSON conditions for conditional permissions */
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  /** When this override expires (NULL for permanent) */
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Whether the permission is granted (true) or denied (false) */
  granted?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  operation?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<Scalars['String']['input']>;
  /** Role name for role-based overrides (mutually exclusive with user_id) */
  role?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User ID for user-specific overrides (mutually exclusive with role) */
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "permission_overrides" */
export type PermissionOverridesUpdateColumn =
  /** column name */
  | 'conditions'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'granted'
  /** column name */
  | 'id'
  /** column name */
  | 'operation'
  /** column name */
  | 'reason'
  /** column name */
  | 'resource'
  /** column name */
  | 'role'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

export type PermissionOverridesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<PermissionOverridesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<PermissionOverridesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<PermissionOverridesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<PermissionOverridesDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<PermissionOverridesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PermissionOverridesSetInput>;
  /** filter the rows which have to be updated */
  where: PermissionOverridesBoolExp;
};

/** columns and relationships of "permissions" */
export type Permissions = {
  __typename?: 'Permissions';
  action: Scalars['permission_action']['output'];
  createdAt: Scalars['timestamptz']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  legacyPermissionName?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  resource: Resources;
  resourceId: Scalars['uuid']['output'];
  /** An array relationship */
  rolePermissions: Array<RolePermissions>;
  /** An aggregate relationship */
  rolePermissionsAggregate: RolePermissionsAggregate;
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "permissions" */
export type PermissionsRolePermissionsArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


/** columns and relationships of "permissions" */
export type PermissionsRolePermissionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};

/** aggregated selection of "permissions" */
export type PermissionsAggregate = {
  __typename?: 'PermissionsAggregate';
  aggregate?: Maybe<PermissionsAggregateFields>;
  nodes: Array<Permissions>;
};

export type PermissionsAggregateBoolExp = {
  count?: InputMaybe<PermissionsAggregateBoolExpCount>;
};

/** aggregate fields of "permissions" */
export type PermissionsAggregateFields = {
  __typename?: 'PermissionsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<PermissionsMaxFields>;
  min?: Maybe<PermissionsMinFields>;
};


/** aggregate fields of "permissions" */
export type PermissionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PermissionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "permissions" */
export type PermissionsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<PermissionsMaxOrderBy>;
  min?: InputMaybe<PermissionsMinOrderBy>;
};

/** input type for inserting array relation for remote table "permissions" */
export type PermissionsArrRelInsertInput = {
  data: Array<PermissionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<PermissionsOnConflict>;
};

/** Boolean expression to filter rows from the table "permissions". All fields are combined with a logical 'AND'. */
export type PermissionsBoolExp = {
  _and?: InputMaybe<Array<PermissionsBoolExp>>;
  _not?: InputMaybe<PermissionsBoolExp>;
  _or?: InputMaybe<Array<PermissionsBoolExp>>;
  action?: InputMaybe<PermissionActionComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  legacyPermissionName?: InputMaybe<StringComparisonExp>;
  resource?: InputMaybe<ResourcesBoolExp>;
  resourceId?: InputMaybe<UuidComparisonExp>;
  rolePermissions?: InputMaybe<RolePermissionsBoolExp>;
  rolePermissionsAggregate?: InputMaybe<RolePermissionsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "permissions" */
export type PermissionsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'permissions_pkey'
  /** unique or primary key constraint on columns "action", "resource_id" */
  | 'permissions_resource_id_action_key'
  | '%future added value';

/** input type for inserting data into table "permissions" */
export type PermissionsInsertInput = {
  action?: InputMaybe<Scalars['permission_action']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  legacyPermissionName?: InputMaybe<Scalars['String']['input']>;
  resource?: InputMaybe<ResourcesObjRelInsertInput>;
  resourceId?: InputMaybe<Scalars['uuid']['input']>;
  rolePermissions?: InputMaybe<RolePermissionsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type PermissionsMaxFields = {
  __typename?: 'PermissionsMaxFields';
  action?: Maybe<Scalars['permission_action']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  legacyPermissionName?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "permissions" */
export type PermissionsMaxOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  legacyPermissionName?: InputMaybe<OrderBy>;
  resourceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type PermissionsMinFields = {
  __typename?: 'PermissionsMinFields';
  action?: Maybe<Scalars['permission_action']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  legacyPermissionName?: Maybe<Scalars['String']['output']>;
  resourceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "permissions" */
export type PermissionsMinOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  legacyPermissionName?: InputMaybe<OrderBy>;
  resourceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "permissions" */
export type PermissionsMutationResponse = {
  __typename?: 'PermissionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Permissions>;
};

/** input type for inserting object relation for remote table "permissions" */
export type PermissionsObjRelInsertInput = {
  data: PermissionsInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<PermissionsOnConflict>;
};

/** on_conflict condition type for table "permissions" */
export type PermissionsOnConflict = {
  constraint: PermissionsConstraint;
  updateColumns?: Array<PermissionsUpdateColumn>;
  where?: InputMaybe<PermissionsBoolExp>;
};

/** Ordering options when selecting data from "permissions". */
export type PermissionsOrderBy = {
  action?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  legacyPermissionName?: InputMaybe<OrderBy>;
  resource?: InputMaybe<ResourcesOrderBy>;
  resourceId?: InputMaybe<OrderBy>;
  rolePermissionsAggregate?: InputMaybe<RolePermissionsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: permissions */
export type PermissionsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "permissions" */
export type PermissionsSelectColumn =
  /** column name */
  | 'action'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'legacyPermissionName'
  /** column name */
  | 'resourceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "permissions" */
export type PermissionsSetInput = {
  action?: InputMaybe<Scalars['permission_action']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  legacyPermissionName?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "permissions" */
export type PermissionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PermissionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PermissionsStreamCursorValueInput = {
  action?: InputMaybe<Scalars['permission_action']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  legacyPermissionName?: InputMaybe<Scalars['String']['input']>;
  resourceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "permissions" */
export type PermissionsUpdateColumn =
  /** column name */
  | 'action'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'legacyPermissionName'
  /** column name */
  | 'resourceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type PermissionsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PermissionsSetInput>;
  /** filter the rows which have to be updated */
  where: PermissionsBoolExp;
};

/** columns and relationships of "position_admin_defaults" */
export type PositionAdminDefaults = {
  __typename?: 'PositionAdminDefaults';
  defaultAdminPercentage: Scalars['numeric']['output'];
  description?: Maybe<Scalars['String']['output']>;
  position: Scalars['user_position']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "position_admin_defaults" */
export type PositionAdminDefaultsAggregate = {
  __typename?: 'PositionAdminDefaultsAggregate';
  aggregate?: Maybe<PositionAdminDefaultsAggregateFields>;
  nodes: Array<PositionAdminDefaults>;
};

/** aggregate fields of "position_admin_defaults" */
export type PositionAdminDefaultsAggregateFields = {
  __typename?: 'PositionAdminDefaultsAggregateFields';
  avg?: Maybe<PositionAdminDefaultsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<PositionAdminDefaultsMaxFields>;
  min?: Maybe<PositionAdminDefaultsMinFields>;
  stddev?: Maybe<PositionAdminDefaultsStddevFields>;
  stddevPop?: Maybe<PositionAdminDefaultsStddevPopFields>;
  stddevSamp?: Maybe<PositionAdminDefaultsStddevSampFields>;
  sum?: Maybe<PositionAdminDefaultsSumFields>;
  varPop?: Maybe<PositionAdminDefaultsVarPopFields>;
  varSamp?: Maybe<PositionAdminDefaultsVarSampFields>;
  variance?: Maybe<PositionAdminDefaultsVarianceFields>;
};


/** aggregate fields of "position_admin_defaults" */
export type PositionAdminDefaultsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<PositionAdminDefaultsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type PositionAdminDefaultsAvgFields = {
  __typename?: 'PositionAdminDefaultsAvgFields';
  defaultAdminPercentage?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "position_admin_defaults". All fields are combined with a logical 'AND'. */
export type PositionAdminDefaultsBoolExp = {
  _and?: InputMaybe<Array<PositionAdminDefaultsBoolExp>>;
  _not?: InputMaybe<PositionAdminDefaultsBoolExp>;
  _or?: InputMaybe<Array<PositionAdminDefaultsBoolExp>>;
  defaultAdminPercentage?: InputMaybe<NumericComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  position?: InputMaybe<UserPositionComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedBy?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "position_admin_defaults" */
export type PositionAdminDefaultsConstraint =
  /** unique or primary key constraint on columns "position" */
  | 'position_admin_defaults_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "position_admin_defaults" */
export type PositionAdminDefaultsIncInput = {
  defaultAdminPercentage?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "position_admin_defaults" */
export type PositionAdminDefaultsInsertInput = {
  defaultAdminPercentage?: InputMaybe<Scalars['numeric']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['user_position']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type PositionAdminDefaultsMaxFields = {
  __typename?: 'PositionAdminDefaultsMaxFields';
  defaultAdminPercentage?: Maybe<Scalars['numeric']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type PositionAdminDefaultsMinFields = {
  __typename?: 'PositionAdminDefaultsMinFields';
  defaultAdminPercentage?: Maybe<Scalars['numeric']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "position_admin_defaults" */
export type PositionAdminDefaultsMutationResponse = {
  __typename?: 'PositionAdminDefaultsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PositionAdminDefaults>;
};

/** on_conflict condition type for table "position_admin_defaults" */
export type PositionAdminDefaultsOnConflict = {
  constraint: PositionAdminDefaultsConstraint;
  updateColumns?: Array<PositionAdminDefaultsUpdateColumn>;
  where?: InputMaybe<PositionAdminDefaultsBoolExp>;
};

/** Ordering options when selecting data from "position_admin_defaults". */
export type PositionAdminDefaultsOrderBy = {
  defaultAdminPercentage?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: position_admin_defaults */
export type PositionAdminDefaultsPkColumnsInput = {
  position: Scalars['user_position']['input'];
};

/** select columns of table "position_admin_defaults" */
export type PositionAdminDefaultsSelectColumn =
  /** column name */
  | 'defaultAdminPercentage'
  /** column name */
  | 'description'
  /** column name */
  | 'position'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  | '%future added value';

/** input type for updating data in table "position_admin_defaults" */
export type PositionAdminDefaultsSetInput = {
  defaultAdminPercentage?: InputMaybe<Scalars['numeric']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['user_position']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type PositionAdminDefaultsStddevFields = {
  __typename?: 'PositionAdminDefaultsStddevFields';
  defaultAdminPercentage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type PositionAdminDefaultsStddevPopFields = {
  __typename?: 'PositionAdminDefaultsStddevPopFields';
  defaultAdminPercentage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type PositionAdminDefaultsStddevSampFields = {
  __typename?: 'PositionAdminDefaultsStddevSampFields';
  defaultAdminPercentage?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "position_admin_defaults" */
export type PositionAdminDefaultsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: PositionAdminDefaultsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type PositionAdminDefaultsStreamCursorValueInput = {
  defaultAdminPercentage?: InputMaybe<Scalars['numeric']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['user_position']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type PositionAdminDefaultsSumFields = {
  __typename?: 'PositionAdminDefaultsSumFields';
  defaultAdminPercentage?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "position_admin_defaults" */
export type PositionAdminDefaultsUpdateColumn =
  /** column name */
  | 'defaultAdminPercentage'
  /** column name */
  | 'description'
  /** column name */
  | 'position'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  | '%future added value';

export type PositionAdminDefaultsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PositionAdminDefaultsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PositionAdminDefaultsSetInput>;
  /** filter the rows which have to be updated */
  where: PositionAdminDefaultsBoolExp;
};

/** aggregate varPop on columns */
export type PositionAdminDefaultsVarPopFields = {
  __typename?: 'PositionAdminDefaultsVarPopFields';
  defaultAdminPercentage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type PositionAdminDefaultsVarSampFields = {
  __typename?: 'PositionAdminDefaultsVarSampFields';
  defaultAdminPercentage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type PositionAdminDefaultsVarianceFields = {
  __typename?: 'PositionAdminDefaultsVarianceFields';
  defaultAdminPercentage?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "quote_analytics" */
export type QuoteAnalytics = {
  __typename?: 'QuoteAnalytics';
  clientName?: Maybe<Scalars['String']['output']>;
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  convertedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByName?: Maybe<Scalars['String']['output']>;
  daysInPipeline?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lineItemsCount?: Maybe<Scalars['bigint']['output']>;
  pipelineStatus?: Maybe<Scalars['String']['output']>;
  quoteNumber?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  validUntil?: Maybe<Scalars['date']['output']>;
};

/** aggregated selection of "quote_analytics" */
export type QuoteAnalyticsAggregate = {
  __typename?: 'QuoteAnalyticsAggregate';
  aggregate?: Maybe<QuoteAnalyticsAggregateFields>;
  nodes: Array<QuoteAnalytics>;
};

/** aggregate fields of "quote_analytics" */
export type QuoteAnalyticsAggregateFields = {
  __typename?: 'QuoteAnalyticsAggregateFields';
  avg?: Maybe<QuoteAnalyticsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<QuoteAnalyticsMaxFields>;
  min?: Maybe<QuoteAnalyticsMinFields>;
  stddev?: Maybe<QuoteAnalyticsStddevFields>;
  stddevPop?: Maybe<QuoteAnalyticsStddevPopFields>;
  stddevSamp?: Maybe<QuoteAnalyticsStddevSampFields>;
  sum?: Maybe<QuoteAnalyticsSumFields>;
  varPop?: Maybe<QuoteAnalyticsVarPopFields>;
  varSamp?: Maybe<QuoteAnalyticsVarSampFields>;
  variance?: Maybe<QuoteAnalyticsVarianceFields>;
};


/** aggregate fields of "quote_analytics" */
export type QuoteAnalyticsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<QuoteAnalyticsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type QuoteAnalyticsAvgFields = {
  __typename?: 'QuoteAnalyticsAvgFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  daysInPipeline?: Maybe<Scalars['Float']['output']>;
  lineItemsCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "quote_analytics". All fields are combined with a logical 'AND'. */
export type QuoteAnalyticsBoolExp = {
  _and?: InputMaybe<Array<QuoteAnalyticsBoolExp>>;
  _not?: InputMaybe<QuoteAnalyticsBoolExp>;
  _or?: InputMaybe<Array<QuoteAnalyticsBoolExp>>;
  clientName?: InputMaybe<StringComparisonExp>;
  conversionValue?: InputMaybe<NumericComparisonExp>;
  convertedAt?: InputMaybe<TimestamptzComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdByName?: InputMaybe<StringComparisonExp>;
  daysInPipeline?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lineItemsCount?: InputMaybe<BigintComparisonExp>;
  pipelineStatus?: InputMaybe<StringComparisonExp>;
  quoteNumber?: InputMaybe<StringComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  totalAmount?: InputMaybe<NumericComparisonExp>;
  validUntil?: InputMaybe<DateComparisonExp>;
};

/** aggregate max on columns */
export type QuoteAnalyticsMaxFields = {
  __typename?: 'QuoteAnalyticsMaxFields';
  clientName?: Maybe<Scalars['String']['output']>;
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  convertedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByName?: Maybe<Scalars['String']['output']>;
  daysInPipeline?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lineItemsCount?: Maybe<Scalars['bigint']['output']>;
  pipelineStatus?: Maybe<Scalars['String']['output']>;
  quoteNumber?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  validUntil?: Maybe<Scalars['date']['output']>;
};

/** aggregate min on columns */
export type QuoteAnalyticsMinFields = {
  __typename?: 'QuoteAnalyticsMinFields';
  clientName?: Maybe<Scalars['String']['output']>;
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  convertedAt?: Maybe<Scalars['timestamptz']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdByName?: Maybe<Scalars['String']['output']>;
  daysInPipeline?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lineItemsCount?: Maybe<Scalars['bigint']['output']>;
  pipelineStatus?: Maybe<Scalars['String']['output']>;
  quoteNumber?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  validUntil?: Maybe<Scalars['date']['output']>;
};

/** Ordering options when selecting data from "quote_analytics". */
export type QuoteAnalyticsOrderBy = {
  clientName?: InputMaybe<OrderBy>;
  conversionValue?: InputMaybe<OrderBy>;
  convertedAt?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdByName?: InputMaybe<OrderBy>;
  daysInPipeline?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lineItemsCount?: InputMaybe<OrderBy>;
  pipelineStatus?: InputMaybe<OrderBy>;
  quoteNumber?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  validUntil?: InputMaybe<OrderBy>;
};

/** select columns of table "quote_analytics" */
export type QuoteAnalyticsSelectColumn =
  /** column name */
  | 'clientName'
  /** column name */
  | 'conversionValue'
  /** column name */
  | 'convertedAt'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdByName'
  /** column name */
  | 'daysInPipeline'
  /** column name */
  | 'id'
  /** column name */
  | 'lineItemsCount'
  /** column name */
  | 'pipelineStatus'
  /** column name */
  | 'quoteNumber'
  /** column name */
  | 'status'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'validUntil'
  | '%future added value';

/** aggregate stddev on columns */
export type QuoteAnalyticsStddevFields = {
  __typename?: 'QuoteAnalyticsStddevFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  daysInPipeline?: Maybe<Scalars['Float']['output']>;
  lineItemsCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type QuoteAnalyticsStddevPopFields = {
  __typename?: 'QuoteAnalyticsStddevPopFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  daysInPipeline?: Maybe<Scalars['Float']['output']>;
  lineItemsCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type QuoteAnalyticsStddevSampFields = {
  __typename?: 'QuoteAnalyticsStddevSampFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  daysInPipeline?: Maybe<Scalars['Float']['output']>;
  lineItemsCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "quote_analytics" */
export type QuoteAnalyticsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: QuoteAnalyticsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type QuoteAnalyticsStreamCursorValueInput = {
  clientName?: InputMaybe<Scalars['String']['input']>;
  conversionValue?: InputMaybe<Scalars['numeric']['input']>;
  convertedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdByName?: InputMaybe<Scalars['String']['input']>;
  daysInPipeline?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lineItemsCount?: InputMaybe<Scalars['bigint']['input']>;
  pipelineStatus?: InputMaybe<Scalars['String']['input']>;
  quoteNumber?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  validUntil?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type QuoteAnalyticsSumFields = {
  __typename?: 'QuoteAnalyticsSumFields';
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  daysInPipeline?: Maybe<Scalars['numeric']['output']>;
  lineItemsCount?: Maybe<Scalars['bigint']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type QuoteAnalyticsVarPopFields = {
  __typename?: 'QuoteAnalyticsVarPopFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  daysInPipeline?: Maybe<Scalars['Float']['output']>;
  lineItemsCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type QuoteAnalyticsVarSampFields = {
  __typename?: 'QuoteAnalyticsVarSampFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  daysInPipeline?: Maybe<Scalars['Float']['output']>;
  lineItemsCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type QuoteAnalyticsVarianceFields = {
  __typename?: 'QuoteAnalyticsVarianceFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  daysInPipeline?: Maybe<Scalars['Float']['output']>;
  lineItemsCount?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "quote_conversions" */
export type QuoteConversions = {
  __typename?: 'QuoteConversions';
  /** An object relationship */
  client: Clients;
  clientId: Scalars['uuid']['output'];
  conversionDate: Scalars['timestamptz']['output'];
  conversionNotes?: Maybe<Scalars['String']['output']>;
  createdBy: Scalars['uuid']['output'];
  /** An object relationship */
  createdByUser: Users;
  id: Scalars['uuid']['output'];
  /** An object relationship */
  quote: Quotes;
  quoteId: Scalars['uuid']['output'];
  serviceAgreementsCreated?: Maybe<Scalars['jsonb']['output']>;
  totalValue: Scalars['numeric']['output'];
};


/** columns and relationships of "quote_conversions" */
export type QuoteConversionsServiceAgreementsCreatedArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "quote_conversions" */
export type QuoteConversionsAggregate = {
  __typename?: 'QuoteConversionsAggregate';
  aggregate?: Maybe<QuoteConversionsAggregateFields>;
  nodes: Array<QuoteConversions>;
};

export type QuoteConversionsAggregateBoolExp = {
  count?: InputMaybe<QuoteConversionsAggregateBoolExpCount>;
};

/** aggregate fields of "quote_conversions" */
export type QuoteConversionsAggregateFields = {
  __typename?: 'QuoteConversionsAggregateFields';
  avg?: Maybe<QuoteConversionsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<QuoteConversionsMaxFields>;
  min?: Maybe<QuoteConversionsMinFields>;
  stddev?: Maybe<QuoteConversionsStddevFields>;
  stddevPop?: Maybe<QuoteConversionsStddevPopFields>;
  stddevSamp?: Maybe<QuoteConversionsStddevSampFields>;
  sum?: Maybe<QuoteConversionsSumFields>;
  varPop?: Maybe<QuoteConversionsVarPopFields>;
  varSamp?: Maybe<QuoteConversionsVarSampFields>;
  variance?: Maybe<QuoteConversionsVarianceFields>;
};


/** aggregate fields of "quote_conversions" */
export type QuoteConversionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quote_conversions" */
export type QuoteConversionsAggregateOrderBy = {
  avg?: InputMaybe<QuoteConversionsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<QuoteConversionsMaxOrderBy>;
  min?: InputMaybe<QuoteConversionsMinOrderBy>;
  stddev?: InputMaybe<QuoteConversionsStddevOrderBy>;
  stddevPop?: InputMaybe<QuoteConversionsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<QuoteConversionsStddevSampOrderBy>;
  sum?: InputMaybe<QuoteConversionsSumOrderBy>;
  varPop?: InputMaybe<QuoteConversionsVarPopOrderBy>;
  varSamp?: InputMaybe<QuoteConversionsVarSampOrderBy>;
  variance?: InputMaybe<QuoteConversionsVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type QuoteConversionsAppendInput = {
  serviceAgreementsCreated?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "quote_conversions" */
export type QuoteConversionsArrRelInsertInput = {
  data: Array<QuoteConversionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<QuoteConversionsOnConflict>;
};

/** aggregate avg on columns */
export type QuoteConversionsAvgFields = {
  __typename?: 'QuoteConversionsAvgFields';
  totalValue?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quote_conversions" */
export type QuoteConversionsAvgOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quote_conversions". All fields are combined with a logical 'AND'. */
export type QuoteConversionsBoolExp = {
  _and?: InputMaybe<Array<QuoteConversionsBoolExp>>;
  _not?: InputMaybe<QuoteConversionsBoolExp>;
  _or?: InputMaybe<Array<QuoteConversionsBoolExp>>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  conversionDate?: InputMaybe<TimestamptzComparisonExp>;
  conversionNotes?: InputMaybe<StringComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  quote?: InputMaybe<QuotesBoolExp>;
  quoteId?: InputMaybe<UuidComparisonExp>;
  serviceAgreementsCreated?: InputMaybe<JsonbComparisonExp>;
  totalValue?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "quote_conversions" */
export type QuoteConversionsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'quote_conversions_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type QuoteConversionsDeleteAtPathInput = {
  serviceAgreementsCreated?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type QuoteConversionsDeleteElemInput = {
  serviceAgreementsCreated?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type QuoteConversionsDeleteKeyInput = {
  serviceAgreementsCreated?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "quote_conversions" */
export type QuoteConversionsIncInput = {
  totalValue?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "quote_conversions" */
export type QuoteConversionsInsertInput = {
  client?: InputMaybe<ClientsObjRelInsertInput>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  conversionDate?: InputMaybe<Scalars['timestamptz']['input']>;
  conversionNotes?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  quote?: InputMaybe<QuotesObjRelInsertInput>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  serviceAgreementsCreated?: InputMaybe<Scalars['jsonb']['input']>;
  totalValue?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate max on columns */
export type QuoteConversionsMaxFields = {
  __typename?: 'QuoteConversionsMaxFields';
  clientId?: Maybe<Scalars['uuid']['output']>;
  conversionDate?: Maybe<Scalars['timestamptz']['output']>;
  conversionNotes?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  quoteId?: Maybe<Scalars['uuid']['output']>;
  totalValue?: Maybe<Scalars['numeric']['output']>;
};

/** order by max() on columns of table "quote_conversions" */
export type QuoteConversionsMaxOrderBy = {
  clientId?: InputMaybe<OrderBy>;
  conversionDate?: InputMaybe<OrderBy>;
  conversionNotes?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  totalValue?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type QuoteConversionsMinFields = {
  __typename?: 'QuoteConversionsMinFields';
  clientId?: Maybe<Scalars['uuid']['output']>;
  conversionDate?: Maybe<Scalars['timestamptz']['output']>;
  conversionNotes?: Maybe<Scalars['String']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  quoteId?: Maybe<Scalars['uuid']['output']>;
  totalValue?: Maybe<Scalars['numeric']['output']>;
};

/** order by min() on columns of table "quote_conversions" */
export type QuoteConversionsMinOrderBy = {
  clientId?: InputMaybe<OrderBy>;
  conversionDate?: InputMaybe<OrderBy>;
  conversionNotes?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  totalValue?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quote_conversions" */
export type QuoteConversionsMutationResponse = {
  __typename?: 'QuoteConversionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<QuoteConversions>;
};

/** on_conflict condition type for table "quote_conversions" */
export type QuoteConversionsOnConflict = {
  constraint: QuoteConversionsConstraint;
  updateColumns?: Array<QuoteConversionsUpdateColumn>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};

/** Ordering options when selecting data from "quote_conversions". */
export type QuoteConversionsOrderBy = {
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  conversionDate?: InputMaybe<OrderBy>;
  conversionNotes?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  id?: InputMaybe<OrderBy>;
  quote?: InputMaybe<QuotesOrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  serviceAgreementsCreated?: InputMaybe<OrderBy>;
  totalValue?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: quote_conversions */
export type QuoteConversionsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type QuoteConversionsPrependInput = {
  serviceAgreementsCreated?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "quote_conversions" */
export type QuoteConversionsSelectColumn =
  /** column name */
  | 'clientId'
  /** column name */
  | 'conversionDate'
  /** column name */
  | 'conversionNotes'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'id'
  /** column name */
  | 'quoteId'
  /** column name */
  | 'serviceAgreementsCreated'
  /** column name */
  | 'totalValue'
  | '%future added value';

/** input type for updating data in table "quote_conversions" */
export type QuoteConversionsSetInput = {
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  conversionDate?: InputMaybe<Scalars['timestamptz']['input']>;
  conversionNotes?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  serviceAgreementsCreated?: InputMaybe<Scalars['jsonb']['input']>;
  totalValue?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate stddev on columns */
export type QuoteConversionsStddevFields = {
  __typename?: 'QuoteConversionsStddevFields';
  totalValue?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quote_conversions" */
export type QuoteConversionsStddevOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type QuoteConversionsStddevPopFields = {
  __typename?: 'QuoteConversionsStddevPopFields';
  totalValue?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "quote_conversions" */
export type QuoteConversionsStddevPopOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type QuoteConversionsStddevSampFields = {
  __typename?: 'QuoteConversionsStddevSampFields';
  totalValue?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "quote_conversions" */
export type QuoteConversionsStddevSampOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quote_conversions" */
export type QuoteConversionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: QuoteConversionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type QuoteConversionsStreamCursorValueInput = {
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  conversionDate?: InputMaybe<Scalars['timestamptz']['input']>;
  conversionNotes?: InputMaybe<Scalars['String']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  serviceAgreementsCreated?: InputMaybe<Scalars['jsonb']['input']>;
  totalValue?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type QuoteConversionsSumFields = {
  __typename?: 'QuoteConversionsSumFields';
  totalValue?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "quote_conversions" */
export type QuoteConversionsSumOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** update columns of table "quote_conversions" */
export type QuoteConversionsUpdateColumn =
  /** column name */
  | 'clientId'
  /** column name */
  | 'conversionDate'
  /** column name */
  | 'conversionNotes'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'id'
  /** column name */
  | 'quoteId'
  /** column name */
  | 'serviceAgreementsCreated'
  /** column name */
  | 'totalValue'
  | '%future added value';

export type QuoteConversionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<QuoteConversionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<QuoteConversionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<QuoteConversionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<QuoteConversionsDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<QuoteConversionsIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<QuoteConversionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<QuoteConversionsSetInput>;
  /** filter the rows which have to be updated */
  where: QuoteConversionsBoolExp;
};

/** aggregate varPop on columns */
export type QuoteConversionsVarPopFields = {
  __typename?: 'QuoteConversionsVarPopFields';
  totalValue?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "quote_conversions" */
export type QuoteConversionsVarPopOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type QuoteConversionsVarSampFields = {
  __typename?: 'QuoteConversionsVarSampFields';
  totalValue?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "quote_conversions" */
export type QuoteConversionsVarSampOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type QuoteConversionsVarianceFields = {
  __typename?: 'QuoteConversionsVarianceFields';
  totalValue?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quote_conversions" */
export type QuoteConversionsVarianceOrderBy = {
  totalValue?: InputMaybe<OrderBy>;
};

/** columns and relationships of "quote_line_items" */
export type QuoteLineItems = {
  __typename?: 'QuoteLineItems';
  createdAt: Scalars['timestamptz']['output'];
  description: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Int']['output'];
  /** An object relationship */
  quote: Quotes;
  quoteId: Scalars['uuid']['output'];
  /** An object relationship */
  service: Services;
  serviceId: Scalars['uuid']['output'];
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitRate: Scalars['numeric']['output'];
};

/** aggregated selection of "quote_line_items" */
export type QuoteLineItemsAggregate = {
  __typename?: 'QuoteLineItemsAggregate';
  aggregate?: Maybe<QuoteLineItemsAggregateFields>;
  nodes: Array<QuoteLineItems>;
};

export type QuoteLineItemsAggregateBoolExp = {
  count?: InputMaybe<QuoteLineItemsAggregateBoolExpCount>;
};

/** aggregate fields of "quote_line_items" */
export type QuoteLineItemsAggregateFields = {
  __typename?: 'QuoteLineItemsAggregateFields';
  avg?: Maybe<QuoteLineItemsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<QuoteLineItemsMaxFields>;
  min?: Maybe<QuoteLineItemsMinFields>;
  stddev?: Maybe<QuoteLineItemsStddevFields>;
  stddevPop?: Maybe<QuoteLineItemsStddevPopFields>;
  stddevSamp?: Maybe<QuoteLineItemsStddevSampFields>;
  sum?: Maybe<QuoteLineItemsSumFields>;
  varPop?: Maybe<QuoteLineItemsVarPopFields>;
  varSamp?: Maybe<QuoteLineItemsVarSampFields>;
  variance?: Maybe<QuoteLineItemsVarianceFields>;
};


/** aggregate fields of "quote_line_items" */
export type QuoteLineItemsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quote_line_items" */
export type QuoteLineItemsAggregateOrderBy = {
  avg?: InputMaybe<QuoteLineItemsAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<QuoteLineItemsMaxOrderBy>;
  min?: InputMaybe<QuoteLineItemsMinOrderBy>;
  stddev?: InputMaybe<QuoteLineItemsStddevOrderBy>;
  stddevPop?: InputMaybe<QuoteLineItemsStddevPopOrderBy>;
  stddevSamp?: InputMaybe<QuoteLineItemsStddevSampOrderBy>;
  sum?: InputMaybe<QuoteLineItemsSumOrderBy>;
  varPop?: InputMaybe<QuoteLineItemsVarPopOrderBy>;
  varSamp?: InputMaybe<QuoteLineItemsVarSampOrderBy>;
  variance?: InputMaybe<QuoteLineItemsVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quote_line_items" */
export type QuoteLineItemsArrRelInsertInput = {
  data: Array<QuoteLineItemsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<QuoteLineItemsOnConflict>;
};

/** aggregate avg on columns */
export type QuoteLineItemsAvgFields = {
  __typename?: 'QuoteLineItemsAvgFields';
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitRate?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quote_line_items" */
export type QuoteLineItemsAvgOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quote_line_items". All fields are combined with a logical 'AND'. */
export type QuoteLineItemsBoolExp = {
  _and?: InputMaybe<Array<QuoteLineItemsBoolExp>>;
  _not?: InputMaybe<QuoteLineItemsBoolExp>;
  _or?: InputMaybe<Array<QuoteLineItemsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  notes?: InputMaybe<StringComparisonExp>;
  quantity?: InputMaybe<IntComparisonExp>;
  quote?: InputMaybe<QuotesBoolExp>;
  quoteId?: InputMaybe<UuidComparisonExp>;
  service?: InputMaybe<ServicesBoolExp>;
  serviceId?: InputMaybe<UuidComparisonExp>;
  totalAmount?: InputMaybe<NumericComparisonExp>;
  unitRate?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "quote_line_items" */
export type QuoteLineItemsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'quote_line_items_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "quote_line_items" */
export type QuoteLineItemsIncInput = {
  quantity?: InputMaybe<Scalars['Int']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "quote_line_items" */
export type QuoteLineItemsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quote?: InputMaybe<QuotesObjRelInsertInput>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  service?: InputMaybe<ServicesObjRelInsertInput>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate max on columns */
export type QuoteLineItemsMaxFields = {
  __typename?: 'QuoteLineItemsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  quoteId?: Maybe<Scalars['uuid']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitRate?: Maybe<Scalars['numeric']['output']>;
};

/** order by max() on columns of table "quote_line_items" */
export type QuoteLineItemsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type QuoteLineItemsMinFields = {
  __typename?: 'QuoteLineItemsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  quoteId?: Maybe<Scalars['uuid']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitRate?: Maybe<Scalars['numeric']['output']>;
};

/** order by min() on columns of table "quote_line_items" */
export type QuoteLineItemsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quote_line_items" */
export type QuoteLineItemsMutationResponse = {
  __typename?: 'QuoteLineItemsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<QuoteLineItems>;
};

/** on_conflict condition type for table "quote_line_items" */
export type QuoteLineItemsOnConflict = {
  constraint: QuoteLineItemsConstraint;
  updateColumns?: Array<QuoteLineItemsUpdateColumn>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};

/** Ordering options when selecting data from "quote_line_items". */
export type QuoteLineItemsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  quantity?: InputMaybe<OrderBy>;
  quote?: InputMaybe<QuotesOrderBy>;
  quoteId?: InputMaybe<OrderBy>;
  service?: InputMaybe<ServicesOrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: quote_line_items */
export type QuoteLineItemsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "quote_line_items" */
export type QuoteLineItemsSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'quantity'
  /** column name */
  | 'quoteId'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'unitRate'
  | '%future added value';

/** input type for updating data in table "quote_line_items" */
export type QuoteLineItemsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate stddev on columns */
export type QuoteLineItemsStddevFields = {
  __typename?: 'QuoteLineItemsStddevFields';
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quote_line_items" */
export type QuoteLineItemsStddevOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type QuoteLineItemsStddevPopFields = {
  __typename?: 'QuoteLineItemsStddevPopFields';
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "quote_line_items" */
export type QuoteLineItemsStddevPopOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type QuoteLineItemsStddevSampFields = {
  __typename?: 'QuoteLineItemsStddevSampFields';
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "quote_line_items" */
export type QuoteLineItemsStddevSampOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quote_line_items" */
export type QuoteLineItemsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: QuoteLineItemsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type QuoteLineItemsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quoteId?: InputMaybe<Scalars['uuid']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  unitRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type QuoteLineItemsSumFields = {
  __typename?: 'QuoteLineItemsSumFields';
  quantity?: Maybe<Scalars['Int']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  unitRate?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "quote_line_items" */
export type QuoteLineItemsSumOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** update columns of table "quote_line_items" */
export type QuoteLineItemsUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'quantity'
  /** column name */
  | 'quoteId'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'unitRate'
  | '%future added value';

export type QuoteLineItemsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<QuoteLineItemsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<QuoteLineItemsSetInput>;
  /** filter the rows which have to be updated */
  where: QuoteLineItemsBoolExp;
};

/** aggregate varPop on columns */
export type QuoteLineItemsVarPopFields = {
  __typename?: 'QuoteLineItemsVarPopFields';
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "quote_line_items" */
export type QuoteLineItemsVarPopOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type QuoteLineItemsVarSampFields = {
  __typename?: 'QuoteLineItemsVarSampFields';
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "quote_line_items" */
export type QuoteLineItemsVarSampOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type QuoteLineItemsVarianceFields = {
  __typename?: 'QuoteLineItemsVarianceFields';
  quantity?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  unitRate?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quote_line_items" */
export type QuoteLineItemsVarianceOrderBy = {
  quantity?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  unitRate?: InputMaybe<OrderBy>;
};

/** columns and relationships of "quote_templates" */
export type QuoteTemplates = {
  __typename?: 'QuoteTemplates';
  category?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['uuid']['output'];
  /** An object relationship */
  createdByUser: Users;
  description?: Maybe<Scalars['String']['output']>;
  estimatedTotal?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['uuid']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isPublic?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  serviceBundle: Scalars['jsonb']['output'];
  targetClientSize?: Maybe<Scalars['String']['output']>;
  targetIndustry?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "quote_templates" */
export type QuoteTemplatesServiceBundleArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "quote_templates" */
export type QuoteTemplatesAggregate = {
  __typename?: 'QuoteTemplatesAggregate';
  aggregate?: Maybe<QuoteTemplatesAggregateFields>;
  nodes: Array<QuoteTemplates>;
};

export type QuoteTemplatesAggregateBoolExp = {
  bool_and?: InputMaybe<QuoteTemplatesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<QuoteTemplatesAggregateBoolExpBool_Or>;
  count?: InputMaybe<QuoteTemplatesAggregateBoolExpCount>;
};

/** aggregate fields of "quote_templates" */
export type QuoteTemplatesAggregateFields = {
  __typename?: 'QuoteTemplatesAggregateFields';
  avg?: Maybe<QuoteTemplatesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<QuoteTemplatesMaxFields>;
  min?: Maybe<QuoteTemplatesMinFields>;
  stddev?: Maybe<QuoteTemplatesStddevFields>;
  stddevPop?: Maybe<QuoteTemplatesStddevPopFields>;
  stddevSamp?: Maybe<QuoteTemplatesStddevSampFields>;
  sum?: Maybe<QuoteTemplatesSumFields>;
  varPop?: Maybe<QuoteTemplatesVarPopFields>;
  varSamp?: Maybe<QuoteTemplatesVarSampFields>;
  variance?: Maybe<QuoteTemplatesVarianceFields>;
};


/** aggregate fields of "quote_templates" */
export type QuoteTemplatesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quote_templates" */
export type QuoteTemplatesAggregateOrderBy = {
  avg?: InputMaybe<QuoteTemplatesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<QuoteTemplatesMaxOrderBy>;
  min?: InputMaybe<QuoteTemplatesMinOrderBy>;
  stddev?: InputMaybe<QuoteTemplatesStddevOrderBy>;
  stddevPop?: InputMaybe<QuoteTemplatesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<QuoteTemplatesStddevSampOrderBy>;
  sum?: InputMaybe<QuoteTemplatesSumOrderBy>;
  varPop?: InputMaybe<QuoteTemplatesVarPopOrderBy>;
  varSamp?: InputMaybe<QuoteTemplatesVarSampOrderBy>;
  variance?: InputMaybe<QuoteTemplatesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type QuoteTemplatesAppendInput = {
  serviceBundle?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "quote_templates" */
export type QuoteTemplatesArrRelInsertInput = {
  data: Array<QuoteTemplatesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<QuoteTemplatesOnConflict>;
};

/** aggregate avg on columns */
export type QuoteTemplatesAvgFields = {
  __typename?: 'QuoteTemplatesAvgFields';
  estimatedTotal?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quote_templates" */
export type QuoteTemplatesAvgOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quote_templates". All fields are combined with a logical 'AND'. */
export type QuoteTemplatesBoolExp = {
  _and?: InputMaybe<Array<QuoteTemplatesBoolExp>>;
  _not?: InputMaybe<QuoteTemplatesBoolExp>;
  _or?: InputMaybe<Array<QuoteTemplatesBoolExp>>;
  category?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  description?: InputMaybe<StringComparisonExp>;
  estimatedTotal?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isPublic?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  serviceBundle?: InputMaybe<JsonbComparisonExp>;
  targetClientSize?: InputMaybe<StringComparisonExp>;
  targetIndustry?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "quote_templates" */
export type QuoteTemplatesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'quote_templates_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type QuoteTemplatesDeleteAtPathInput = {
  serviceBundle?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type QuoteTemplatesDeleteElemInput = {
  serviceBundle?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type QuoteTemplatesDeleteKeyInput = {
  serviceBundle?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "quote_templates" */
export type QuoteTemplatesIncInput = {
  estimatedTotal?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "quote_templates" */
export type QuoteTemplatesInsertInput = {
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  estimatedTotal?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  serviceBundle?: InputMaybe<Scalars['jsonb']['input']>;
  targetClientSize?: InputMaybe<Scalars['String']['input']>;
  targetIndustry?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type QuoteTemplatesMaxFields = {
  __typename?: 'QuoteTemplatesMaxFields';
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  estimatedTotal?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  targetClientSize?: Maybe<Scalars['String']['output']>;
  targetIndustry?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "quote_templates" */
export type QuoteTemplatesMaxOrderBy = {
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  estimatedTotal?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  targetClientSize?: InputMaybe<OrderBy>;
  targetIndustry?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type QuoteTemplatesMinFields = {
  __typename?: 'QuoteTemplatesMinFields';
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  estimatedTotal?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  targetClientSize?: Maybe<Scalars['String']['output']>;
  targetIndustry?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "quote_templates" */
export type QuoteTemplatesMinOrderBy = {
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  estimatedTotal?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  targetClientSize?: InputMaybe<OrderBy>;
  targetIndustry?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quote_templates" */
export type QuoteTemplatesMutationResponse = {
  __typename?: 'QuoteTemplatesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<QuoteTemplates>;
};

/** on_conflict condition type for table "quote_templates" */
export type QuoteTemplatesOnConflict = {
  constraint: QuoteTemplatesConstraint;
  updateColumns?: Array<QuoteTemplatesUpdateColumn>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};

/** Ordering options when selecting data from "quote_templates". */
export type QuoteTemplatesOrderBy = {
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  description?: InputMaybe<OrderBy>;
  estimatedTotal?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isPublic?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  serviceBundle?: InputMaybe<OrderBy>;
  targetClientSize?: InputMaybe<OrderBy>;
  targetIndustry?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: quote_templates */
export type QuoteTemplatesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type QuoteTemplatesPrependInput = {
  serviceBundle?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "quote_templates" */
export type QuoteTemplatesSelectColumn =
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'description'
  /** column name */
  | 'estimatedTotal'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isPublic'
  /** column name */
  | 'name'
  /** column name */
  | 'serviceBundle'
  /** column name */
  | 'targetClientSize'
  /** column name */
  | 'targetIndustry'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "quoteTemplatesAggregateBoolExpBool_andArgumentsColumns" columns of table "quote_templates" */
export type QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isPublic'
  | '%future added value';

/** select "quoteTemplatesAggregateBoolExpBool_orArgumentsColumns" columns of table "quote_templates" */
export type QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isPublic'
  | '%future added value';

/** input type for updating data in table "quote_templates" */
export type QuoteTemplatesSetInput = {
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  estimatedTotal?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  serviceBundle?: InputMaybe<Scalars['jsonb']['input']>;
  targetClientSize?: InputMaybe<Scalars['String']['input']>;
  targetIndustry?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type QuoteTemplatesStddevFields = {
  __typename?: 'QuoteTemplatesStddevFields';
  estimatedTotal?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quote_templates" */
export type QuoteTemplatesStddevOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type QuoteTemplatesStddevPopFields = {
  __typename?: 'QuoteTemplatesStddevPopFields';
  estimatedTotal?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "quote_templates" */
export type QuoteTemplatesStddevPopOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type QuoteTemplatesStddevSampFields = {
  __typename?: 'QuoteTemplatesStddevSampFields';
  estimatedTotal?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "quote_templates" */
export type QuoteTemplatesStddevSampOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quote_templates" */
export type QuoteTemplatesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: QuoteTemplatesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type QuoteTemplatesStreamCursorValueInput = {
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  estimatedTotal?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  serviceBundle?: InputMaybe<Scalars['jsonb']['input']>;
  targetClientSize?: InputMaybe<Scalars['String']['input']>;
  targetIndustry?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type QuoteTemplatesSumFields = {
  __typename?: 'QuoteTemplatesSumFields';
  estimatedTotal?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "quote_templates" */
export type QuoteTemplatesSumOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** update columns of table "quote_templates" */
export type QuoteTemplatesUpdateColumn =
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'description'
  /** column name */
  | 'estimatedTotal'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isPublic'
  /** column name */
  | 'name'
  /** column name */
  | 'serviceBundle'
  /** column name */
  | 'targetClientSize'
  /** column name */
  | 'targetIndustry'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type QuoteTemplatesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<QuoteTemplatesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<QuoteTemplatesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<QuoteTemplatesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<QuoteTemplatesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<QuoteTemplatesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<QuoteTemplatesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<QuoteTemplatesSetInput>;
  /** filter the rows which have to be updated */
  where: QuoteTemplatesBoolExp;
};

/** aggregate varPop on columns */
export type QuoteTemplatesVarPopFields = {
  __typename?: 'QuoteTemplatesVarPopFields';
  estimatedTotal?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "quote_templates" */
export type QuoteTemplatesVarPopOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type QuoteTemplatesVarSampFields = {
  __typename?: 'QuoteTemplatesVarSampFields';
  estimatedTotal?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "quote_templates" */
export type QuoteTemplatesVarSampOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type QuoteTemplatesVarianceFields = {
  __typename?: 'QuoteTemplatesVarianceFields';
  estimatedTotal?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quote_templates" */
export type QuoteTemplatesVarianceOrderBy = {
  estimatedTotal?: InputMaybe<OrderBy>;
};

/** columns and relationships of "quotes" */
export type Quotes = {
  __typename?: 'Quotes';
  /** An array relationship */
  billingItems: Array<BillingItems>;
  /** An aggregate relationship */
  billingItemsAggregate: BillingItemsAggregate;
  /** An object relationship */
  client?: Maybe<Clients>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  /** An array relationship */
  conversions: Array<QuoteConversions>;
  /** An aggregate relationship */
  conversionsAggregate: QuoteConversionsAggregate;
  convertedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  convertedToClient?: Maybe<Clients>;
  convertedToClientId?: Maybe<Scalars['uuid']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy: Scalars['uuid']['output'];
  /** An object relationship */
  createdByUser: Users;
  id: Scalars['uuid']['output'];
  /** An array relationship */
  lineItems: Array<QuoteLineItems>;
  /** An aggregate relationship */
  lineItemsAggregate: QuoteLineItemsAggregate;
  notes?: Maybe<Scalars['String']['output']>;
  prospectCompany?: Maybe<Scalars['String']['output']>;
  prospectEmail?: Maybe<Scalars['String']['output']>;
  prospectName?: Maybe<Scalars['String']['output']>;
  prospectPhone?: Maybe<Scalars['String']['output']>;
  quoteNumber: Scalars['String']['output'];
  status: Scalars['String']['output'];
  termsConditions?: Maybe<Scalars['String']['output']>;
  totalAmount: Scalars['numeric']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  validUntil?: Maybe<Scalars['date']['output']>;
};


/** columns and relationships of "quotes" */
export type QuotesBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "quotes" */
export type QuotesBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "quotes" */
export type QuotesConversionsArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


/** columns and relationships of "quotes" */
export type QuotesConversionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


/** columns and relationships of "quotes" */
export type QuotesLineItemsArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


/** columns and relationships of "quotes" */
export type QuotesLineItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};

/** aggregated selection of "quotes" */
export type QuotesAggregate = {
  __typename?: 'QuotesAggregate';
  aggregate?: Maybe<QuotesAggregateFields>;
  nodes: Array<Quotes>;
};

export type QuotesAggregateBoolExp = {
  count?: InputMaybe<QuotesAggregateBoolExpCount>;
};

/** aggregate fields of "quotes" */
export type QuotesAggregateFields = {
  __typename?: 'QuotesAggregateFields';
  avg?: Maybe<QuotesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<QuotesMaxFields>;
  min?: Maybe<QuotesMinFields>;
  stddev?: Maybe<QuotesStddevFields>;
  stddevPop?: Maybe<QuotesStddevPopFields>;
  stddevSamp?: Maybe<QuotesStddevSampFields>;
  sum?: Maybe<QuotesSumFields>;
  varPop?: Maybe<QuotesVarPopFields>;
  varSamp?: Maybe<QuotesVarSampFields>;
  variance?: Maybe<QuotesVarianceFields>;
};


/** aggregate fields of "quotes" */
export type QuotesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<QuotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "quotes" */
export type QuotesAggregateOrderBy = {
  avg?: InputMaybe<QuotesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<QuotesMaxOrderBy>;
  min?: InputMaybe<QuotesMinOrderBy>;
  stddev?: InputMaybe<QuotesStddevOrderBy>;
  stddevPop?: InputMaybe<QuotesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<QuotesStddevSampOrderBy>;
  sum?: InputMaybe<QuotesSumOrderBy>;
  varPop?: InputMaybe<QuotesVarPopOrderBy>;
  varSamp?: InputMaybe<QuotesVarSampOrderBy>;
  variance?: InputMaybe<QuotesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "quotes" */
export type QuotesArrRelInsertInput = {
  data: Array<QuotesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<QuotesOnConflict>;
};

/** aggregate avg on columns */
export type QuotesAvgFields = {
  __typename?: 'QuotesAvgFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "quotes" */
export type QuotesAvgOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "quotes". All fields are combined with a logical 'AND'. */
export type QuotesBoolExp = {
  _and?: InputMaybe<Array<QuotesBoolExp>>;
  _not?: InputMaybe<QuotesBoolExp>;
  _or?: InputMaybe<Array<QuotesBoolExp>>;
  billingItems?: InputMaybe<BillingItemsBoolExp>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  conversionValue?: InputMaybe<NumericComparisonExp>;
  conversions?: InputMaybe<QuoteConversionsBoolExp>;
  conversionsAggregate?: InputMaybe<QuoteConversionsAggregateBoolExp>;
  convertedAt?: InputMaybe<TimestamptzComparisonExp>;
  convertedToClient?: InputMaybe<ClientsBoolExp>;
  convertedToClientId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  lineItems?: InputMaybe<QuoteLineItemsBoolExp>;
  lineItemsAggregate?: InputMaybe<QuoteLineItemsAggregateBoolExp>;
  notes?: InputMaybe<StringComparisonExp>;
  prospectCompany?: InputMaybe<StringComparisonExp>;
  prospectEmail?: InputMaybe<StringComparisonExp>;
  prospectName?: InputMaybe<StringComparisonExp>;
  prospectPhone?: InputMaybe<StringComparisonExp>;
  quoteNumber?: InputMaybe<StringComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  termsConditions?: InputMaybe<StringComparisonExp>;
  totalAmount?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  validUntil?: InputMaybe<DateComparisonExp>;
};

/** unique or primary key constraints on table "quotes" */
export type QuotesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'quotes_pkey'
  /** unique or primary key constraint on columns "quote_number" */
  | 'quotes_quote_number_key'
  | '%future added value';

/** input type for incrementing numeric columns in table "quotes" */
export type QuotesIncInput = {
  conversionValue?: InputMaybe<Scalars['numeric']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "quotes" */
export type QuotesInsertInput = {
  billingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  conversionValue?: InputMaybe<Scalars['numeric']['input']>;
  conversions?: InputMaybe<QuoteConversionsArrRelInsertInput>;
  convertedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  convertedToClient?: InputMaybe<ClientsObjRelInsertInput>;
  convertedToClientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lineItems?: InputMaybe<QuoteLineItemsArrRelInsertInput>;
  notes?: InputMaybe<Scalars['String']['input']>;
  prospectCompany?: InputMaybe<Scalars['String']['input']>;
  prospectEmail?: InputMaybe<Scalars['String']['input']>;
  prospectName?: InputMaybe<Scalars['String']['input']>;
  prospectPhone?: InputMaybe<Scalars['String']['input']>;
  quoteNumber?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  termsConditions?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  validUntil?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate max on columns */
export type QuotesMaxFields = {
  __typename?: 'QuotesMaxFields';
  clientId?: Maybe<Scalars['uuid']['output']>;
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  convertedAt?: Maybe<Scalars['timestamptz']['output']>;
  convertedToClientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  prospectCompany?: Maybe<Scalars['String']['output']>;
  prospectEmail?: Maybe<Scalars['String']['output']>;
  prospectName?: Maybe<Scalars['String']['output']>;
  prospectPhone?: Maybe<Scalars['String']['output']>;
  quoteNumber?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  termsConditions?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  validUntil?: Maybe<Scalars['date']['output']>;
};

/** order by max() on columns of table "quotes" */
export type QuotesMaxOrderBy = {
  clientId?: InputMaybe<OrderBy>;
  conversionValue?: InputMaybe<OrderBy>;
  convertedAt?: InputMaybe<OrderBy>;
  convertedToClientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  prospectCompany?: InputMaybe<OrderBy>;
  prospectEmail?: InputMaybe<OrderBy>;
  prospectName?: InputMaybe<OrderBy>;
  prospectPhone?: InputMaybe<OrderBy>;
  quoteNumber?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  termsConditions?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  validUntil?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type QuotesMinFields = {
  __typename?: 'QuotesMinFields';
  clientId?: Maybe<Scalars['uuid']['output']>;
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  convertedAt?: Maybe<Scalars['timestamptz']['output']>;
  convertedToClientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  prospectCompany?: Maybe<Scalars['String']['output']>;
  prospectEmail?: Maybe<Scalars['String']['output']>;
  prospectName?: Maybe<Scalars['String']['output']>;
  prospectPhone?: Maybe<Scalars['String']['output']>;
  quoteNumber?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  termsConditions?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  validUntil?: Maybe<Scalars['date']['output']>;
};

/** order by min() on columns of table "quotes" */
export type QuotesMinOrderBy = {
  clientId?: InputMaybe<OrderBy>;
  conversionValue?: InputMaybe<OrderBy>;
  convertedAt?: InputMaybe<OrderBy>;
  convertedToClientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  prospectCompany?: InputMaybe<OrderBy>;
  prospectEmail?: InputMaybe<OrderBy>;
  prospectName?: InputMaybe<OrderBy>;
  prospectPhone?: InputMaybe<OrderBy>;
  quoteNumber?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  termsConditions?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  validUntil?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "quotes" */
export type QuotesMutationResponse = {
  __typename?: 'QuotesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Quotes>;
};

/** input type for inserting object relation for remote table "quotes" */
export type QuotesObjRelInsertInput = {
  data: QuotesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<QuotesOnConflict>;
};

/** on_conflict condition type for table "quotes" */
export type QuotesOnConflict = {
  constraint: QuotesConstraint;
  updateColumns?: Array<QuotesUpdateColumn>;
  where?: InputMaybe<QuotesBoolExp>;
};

/** Ordering options when selecting data from "quotes". */
export type QuotesOrderBy = {
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  conversionValue?: InputMaybe<OrderBy>;
  conversionsAggregate?: InputMaybe<QuoteConversionsAggregateOrderBy>;
  convertedAt?: InputMaybe<OrderBy>;
  convertedToClient?: InputMaybe<ClientsOrderBy>;
  convertedToClientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  id?: InputMaybe<OrderBy>;
  lineItemsAggregate?: InputMaybe<QuoteLineItemsAggregateOrderBy>;
  notes?: InputMaybe<OrderBy>;
  prospectCompany?: InputMaybe<OrderBy>;
  prospectEmail?: InputMaybe<OrderBy>;
  prospectName?: InputMaybe<OrderBy>;
  prospectPhone?: InputMaybe<OrderBy>;
  quoteNumber?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  termsConditions?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  validUntil?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: quotes */
export type QuotesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "quotes" */
export type QuotesSelectColumn =
  /** column name */
  | 'clientId'
  /** column name */
  | 'conversionValue'
  /** column name */
  | 'convertedAt'
  /** column name */
  | 'convertedToClientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'prospectCompany'
  /** column name */
  | 'prospectEmail'
  /** column name */
  | 'prospectName'
  /** column name */
  | 'prospectPhone'
  /** column name */
  | 'quoteNumber'
  /** column name */
  | 'status'
  /** column name */
  | 'termsConditions'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'validUntil'
  | '%future added value';

/** input type for updating data in table "quotes" */
export type QuotesSetInput = {
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  conversionValue?: InputMaybe<Scalars['numeric']['input']>;
  convertedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  convertedToClientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  prospectCompany?: InputMaybe<Scalars['String']['input']>;
  prospectEmail?: InputMaybe<Scalars['String']['input']>;
  prospectName?: InputMaybe<Scalars['String']['input']>;
  prospectPhone?: InputMaybe<Scalars['String']['input']>;
  quoteNumber?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  termsConditions?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  validUntil?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate stddev on columns */
export type QuotesStddevFields = {
  __typename?: 'QuotesStddevFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "quotes" */
export type QuotesStddevOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type QuotesStddevPopFields = {
  __typename?: 'QuotesStddevPopFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "quotes" */
export type QuotesStddevPopOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type QuotesStddevSampFields = {
  __typename?: 'QuotesStddevSampFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "quotes" */
export type QuotesStddevSampOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "quotes" */
export type QuotesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: QuotesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type QuotesStreamCursorValueInput = {
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  conversionValue?: InputMaybe<Scalars['numeric']['input']>;
  convertedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  convertedToClientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  prospectCompany?: InputMaybe<Scalars['String']['input']>;
  prospectEmail?: InputMaybe<Scalars['String']['input']>;
  prospectName?: InputMaybe<Scalars['String']['input']>;
  prospectPhone?: InputMaybe<Scalars['String']['input']>;
  quoteNumber?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  termsConditions?: InputMaybe<Scalars['String']['input']>;
  totalAmount?: InputMaybe<Scalars['numeric']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  validUntil?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type QuotesSumFields = {
  __typename?: 'QuotesSumFields';
  conversionValue?: Maybe<Scalars['numeric']['output']>;
  totalAmount?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "quotes" */
export type QuotesSumOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** update columns of table "quotes" */
export type QuotesUpdateColumn =
  /** column name */
  | 'clientId'
  /** column name */
  | 'conversionValue'
  /** column name */
  | 'convertedAt'
  /** column name */
  | 'convertedToClientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'prospectCompany'
  /** column name */
  | 'prospectEmail'
  /** column name */
  | 'prospectName'
  /** column name */
  | 'prospectPhone'
  /** column name */
  | 'quoteNumber'
  /** column name */
  | 'status'
  /** column name */
  | 'termsConditions'
  /** column name */
  | 'totalAmount'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'validUntil'
  | '%future added value';

export type QuotesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<QuotesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<QuotesSetInput>;
  /** filter the rows which have to be updated */
  where: QuotesBoolExp;
};

/** aggregate varPop on columns */
export type QuotesVarPopFields = {
  __typename?: 'QuotesVarPopFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "quotes" */
export type QuotesVarPopOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type QuotesVarSampFields = {
  __typename?: 'QuotesVarSampFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "quotes" */
export type QuotesVarSampOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type QuotesVarianceFields = {
  __typename?: 'QuotesVarianceFields';
  conversionValue?: Maybe<Scalars['Float']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "quotes" */
export type QuotesVarianceOrderBy = {
  conversionValue?: InputMaybe<OrderBy>;
  totalAmount?: InputMaybe<OrderBy>;
};

/** columns and relationships of "rate_limits" */
export type RateLimits = {
  __typename?: 'RateLimits';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  limitExceededCount: Scalars['Int']['output'];
  requestCount: Scalars['Int']['output'];
  serviceId: Scalars['String']['output'];
  windowDurationMinutes: Scalars['Int']['output'];
  windowStart: Scalars['timestamptz']['output'];
};

/** aggregated selection of "rate_limits" */
export type RateLimitsAggregate = {
  __typename?: 'RateLimitsAggregate';
  aggregate?: Maybe<RateLimitsAggregateFields>;
  nodes: Array<RateLimits>;
};

/** aggregate fields of "rate_limits" */
export type RateLimitsAggregateFields = {
  __typename?: 'RateLimitsAggregateFields';
  avg?: Maybe<RateLimitsAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<RateLimitsMaxFields>;
  min?: Maybe<RateLimitsMinFields>;
  stddev?: Maybe<RateLimitsStddevFields>;
  stddevPop?: Maybe<RateLimitsStddevPopFields>;
  stddevSamp?: Maybe<RateLimitsStddevSampFields>;
  sum?: Maybe<RateLimitsSumFields>;
  varPop?: Maybe<RateLimitsVarPopFields>;
  varSamp?: Maybe<RateLimitsVarSampFields>;
  variance?: Maybe<RateLimitsVarianceFields>;
};


/** aggregate fields of "rate_limits" */
export type RateLimitsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RateLimitsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type RateLimitsAvgFields = {
  __typename?: 'RateLimitsAvgFields';
  limitExceededCount?: Maybe<Scalars['Float']['output']>;
  requestCount?: Maybe<Scalars['Float']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rate_limits". All fields are combined with a logical 'AND'. */
export type RateLimitsBoolExp = {
  _and?: InputMaybe<Array<RateLimitsBoolExp>>;
  _not?: InputMaybe<RateLimitsBoolExp>;
  _or?: InputMaybe<Array<RateLimitsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  limitExceededCount?: InputMaybe<IntComparisonExp>;
  requestCount?: InputMaybe<IntComparisonExp>;
  serviceId?: InputMaybe<StringComparisonExp>;
  windowDurationMinutes?: InputMaybe<IntComparisonExp>;
  windowStart?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "rate_limits" */
export type RateLimitsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'rate_limits_pkey'
  /** unique or primary key constraint on columns "service_id", "window_start" */
  | 'rate_limits_service_id_window_start_key'
  | '%future added value';

/** input type for incrementing numeric columns in table "rate_limits" */
export type RateLimitsIncInput = {
  limitExceededCount?: InputMaybe<Scalars['Int']['input']>;
  requestCount?: InputMaybe<Scalars['Int']['input']>;
  windowDurationMinutes?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rate_limits" */
export type RateLimitsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  limitExceededCount?: InputMaybe<Scalars['Int']['input']>;
  requestCount?: InputMaybe<Scalars['Int']['input']>;
  serviceId?: InputMaybe<Scalars['String']['input']>;
  windowDurationMinutes?: InputMaybe<Scalars['Int']['input']>;
  windowStart?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type RateLimitsMaxFields = {
  __typename?: 'RateLimitsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  limitExceededCount?: Maybe<Scalars['Int']['output']>;
  requestCount?: Maybe<Scalars['Int']['output']>;
  serviceId?: Maybe<Scalars['String']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Int']['output']>;
  windowStart?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type RateLimitsMinFields = {
  __typename?: 'RateLimitsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  limitExceededCount?: Maybe<Scalars['Int']['output']>;
  requestCount?: Maybe<Scalars['Int']['output']>;
  serviceId?: Maybe<Scalars['String']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Int']['output']>;
  windowStart?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rate_limits" */
export type RateLimitsMutationResponse = {
  __typename?: 'RateLimitsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<RateLimits>;
};

/** on_conflict condition type for table "rate_limits" */
export type RateLimitsOnConflict = {
  constraint: RateLimitsConstraint;
  updateColumns?: Array<RateLimitsUpdateColumn>;
  where?: InputMaybe<RateLimitsBoolExp>;
};

/** Ordering options when selecting data from "rate_limits". */
export type RateLimitsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  limitExceededCount?: InputMaybe<OrderBy>;
  requestCount?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  windowDurationMinutes?: InputMaybe<OrderBy>;
  windowStart?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: rate_limits */
export type RateLimitsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "rate_limits" */
export type RateLimitsSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'limitExceededCount'
  /** column name */
  | 'requestCount'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'windowDurationMinutes'
  /** column name */
  | 'windowStart'
  | '%future added value';

/** input type for updating data in table "rate_limits" */
export type RateLimitsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  limitExceededCount?: InputMaybe<Scalars['Int']['input']>;
  requestCount?: InputMaybe<Scalars['Int']['input']>;
  serviceId?: InputMaybe<Scalars['String']['input']>;
  windowDurationMinutes?: InputMaybe<Scalars['Int']['input']>;
  windowStart?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type RateLimitsStddevFields = {
  __typename?: 'RateLimitsStddevFields';
  limitExceededCount?: Maybe<Scalars['Float']['output']>;
  requestCount?: Maybe<Scalars['Float']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type RateLimitsStddevPopFields = {
  __typename?: 'RateLimitsStddevPopFields';
  limitExceededCount?: Maybe<Scalars['Float']['output']>;
  requestCount?: Maybe<Scalars['Float']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type RateLimitsStddevSampFields = {
  __typename?: 'RateLimitsStddevSampFields';
  limitExceededCount?: Maybe<Scalars['Float']['output']>;
  requestCount?: Maybe<Scalars['Float']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rate_limits" */
export type RateLimitsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: RateLimitsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RateLimitsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  limitExceededCount?: InputMaybe<Scalars['Int']['input']>;
  requestCount?: InputMaybe<Scalars['Int']['input']>;
  serviceId?: InputMaybe<Scalars['String']['input']>;
  windowDurationMinutes?: InputMaybe<Scalars['Int']['input']>;
  windowStart?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type RateLimitsSumFields = {
  __typename?: 'RateLimitsSumFields';
  limitExceededCount?: Maybe<Scalars['Int']['output']>;
  requestCount?: Maybe<Scalars['Int']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rate_limits" */
export type RateLimitsUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'limitExceededCount'
  /** column name */
  | 'requestCount'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'windowDurationMinutes'
  /** column name */
  | 'windowStart'
  | '%future added value';

export type RateLimitsUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<RateLimitsIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RateLimitsSetInput>;
  /** filter the rows which have to be updated */
  where: RateLimitsBoolExp;
};

/** aggregate varPop on columns */
export type RateLimitsVarPopFields = {
  __typename?: 'RateLimitsVarPopFields';
  limitExceededCount?: Maybe<Scalars['Float']['output']>;
  requestCount?: Maybe<Scalars['Float']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type RateLimitsVarSampFields = {
  __typename?: 'RateLimitsVarSampFields';
  limitExceededCount?: Maybe<Scalars['Float']['output']>;
  requestCount?: Maybe<Scalars['Float']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type RateLimitsVarianceFields = {
  __typename?: 'RateLimitsVarianceFields';
  limitExceededCount?: Maybe<Scalars['Float']['output']>;
  requestCount?: Maybe<Scalars['Float']['output']>;
  windowDurationMinutes?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "resources" */
export type Resources = {
  __typename?: 'Resources';
  createdAt: Scalars['timestamptz']['output'];
  description?: Maybe<Scalars['String']['output']>;
  displayName: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  permissions: Array<Permissions>;
  /** An aggregate relationship */
  permissionsAggregate: PermissionsAggregate;
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "resources" */
export type ResourcesPermissionsArgs = {
  distinctOn?: InputMaybe<Array<PermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  where?: InputMaybe<PermissionsBoolExp>;
};


/** columns and relationships of "resources" */
export type ResourcesPermissionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  where?: InputMaybe<PermissionsBoolExp>;
};

/** aggregated selection of "resources" */
export type ResourcesAggregate = {
  __typename?: 'ResourcesAggregate';
  aggregate?: Maybe<ResourcesAggregateFields>;
  nodes: Array<Resources>;
};

/** aggregate fields of "resources" */
export type ResourcesAggregateFields = {
  __typename?: 'ResourcesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<ResourcesMaxFields>;
  min?: Maybe<ResourcesMinFields>;
};


/** aggregate fields of "resources" */
export type ResourcesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ResourcesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "resources". All fields are combined with a logical 'AND'. */
export type ResourcesBoolExp = {
  _and?: InputMaybe<Array<ResourcesBoolExp>>;
  _not?: InputMaybe<ResourcesBoolExp>;
  _or?: InputMaybe<Array<ResourcesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  displayName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  permissions?: InputMaybe<PermissionsBoolExp>;
  permissionsAggregate?: InputMaybe<PermissionsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "resources" */
export type ResourcesConstraint =
  /** unique or primary key constraint on columns "name" */
  | 'resources_name_key'
  /** unique or primary key constraint on columns "id" */
  | 'resources_pkey'
  | '%future added value';

/** input type for inserting data into table "resources" */
export type ResourcesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<PermissionsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ResourcesMaxFields = {
  __typename?: 'ResourcesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type ResourcesMinFields = {
  __typename?: 'ResourcesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "resources" */
export type ResourcesMutationResponse = {
  __typename?: 'ResourcesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Resources>;
};

/** input type for inserting object relation for remote table "resources" */
export type ResourcesObjRelInsertInput = {
  data: ResourcesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<ResourcesOnConflict>;
};

/** on_conflict condition type for table "resources" */
export type ResourcesOnConflict = {
  constraint: ResourcesConstraint;
  updateColumns?: Array<ResourcesUpdateColumn>;
  where?: InputMaybe<ResourcesBoolExp>;
};

/** Ordering options when selecting data from "resources". */
export type ResourcesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  displayName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  permissionsAggregate?: InputMaybe<PermissionsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: resources */
export type ResourcesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "resources" */
export type ResourcesSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'displayName'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "resources" */
export type ResourcesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "resources" */
export type ResourcesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ResourcesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ResourcesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "resources" */
export type ResourcesUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'displayName'
  /** column name */
  | 'id'
  /** column name */
  | 'name'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type ResourcesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ResourcesSetInput>;
  /** filter the rows which have to be updated */
  where: ResourcesBoolExp;
};

/** columns and relationships of "role_permissions" */
export type RolePermissions = {
  __typename?: 'RolePermissions';
  conditions?: Maybe<Scalars['jsonb']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  /** An object relationship */
  permission: Permissions;
  permissionId: Scalars['uuid']['output'];
  /** An object relationship */
  role: Roles;
  roleId: Scalars['uuid']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};


/** columns and relationships of "role_permissions" */
export type RolePermissionsConditionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "role_permissions" */
export type RolePermissionsAggregate = {
  __typename?: 'RolePermissionsAggregate';
  aggregate?: Maybe<RolePermissionsAggregateFields>;
  nodes: Array<RolePermissions>;
};

export type RolePermissionsAggregateBoolExp = {
  count?: InputMaybe<RolePermissionsAggregateBoolExpCount>;
};

/** aggregate fields of "role_permissions" */
export type RolePermissionsAggregateFields = {
  __typename?: 'RolePermissionsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<RolePermissionsMaxFields>;
  min?: Maybe<RolePermissionsMinFields>;
};


/** aggregate fields of "role_permissions" */
export type RolePermissionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "role_permissions" */
export type RolePermissionsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<RolePermissionsMaxOrderBy>;
  min?: InputMaybe<RolePermissionsMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type RolePermissionsAppendInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "role_permissions" */
export type RolePermissionsArrRelInsertInput = {
  data: Array<RolePermissionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<RolePermissionsOnConflict>;
};

/** Boolean expression to filter rows from the table "role_permissions". All fields are combined with a logical 'AND'. */
export type RolePermissionsBoolExp = {
  _and?: InputMaybe<Array<RolePermissionsBoolExp>>;
  _not?: InputMaybe<RolePermissionsBoolExp>;
  _or?: InputMaybe<Array<RolePermissionsBoolExp>>;
  conditions?: InputMaybe<JsonbComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  permission?: InputMaybe<PermissionsBoolExp>;
  permissionId?: InputMaybe<UuidComparisonExp>;
  role?: InputMaybe<RolesBoolExp>;
  roleId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "role_permissions" */
export type RolePermissionsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'role_permissions_pkey'
  /** unique or primary key constraint on columns "permission_id", "role_id" */
  | 'role_permissions_role_id_permission_id_key'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type RolePermissionsDeleteAtPathInput = {
  conditions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type RolePermissionsDeleteElemInput = {
  conditions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type RolePermissionsDeleteKeyInput = {
  conditions?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "role_permissions" */
export type RolePermissionsInsertInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  permission?: InputMaybe<PermissionsObjRelInsertInput>;
  permissionId?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<RolesObjRelInsertInput>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type RolePermissionsMaxFields = {
  __typename?: 'RolePermissionsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  permissionId?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "role_permissions" */
export type RolePermissionsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  permissionId?: InputMaybe<OrderBy>;
  roleId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type RolePermissionsMinFields = {
  __typename?: 'RolePermissionsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  permissionId?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "role_permissions" */
export type RolePermissionsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  permissionId?: InputMaybe<OrderBy>;
  roleId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "role_permissions" */
export type RolePermissionsMutationResponse = {
  __typename?: 'RolePermissionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<RolePermissions>;
};

/** on_conflict condition type for table "role_permissions" */
export type RolePermissionsOnConflict = {
  constraint: RolePermissionsConstraint;
  updateColumns?: Array<RolePermissionsUpdateColumn>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};

/** Ordering options when selecting data from "role_permissions". */
export type RolePermissionsOrderBy = {
  conditions?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  permission?: InputMaybe<PermissionsOrderBy>;
  permissionId?: InputMaybe<OrderBy>;
  role?: InputMaybe<RolesOrderBy>;
  roleId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: role_permissions */
export type RolePermissionsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type RolePermissionsPrependInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "role_permissions" */
export type RolePermissionsSelectColumn =
  /** column name */
  | 'conditions'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'permissionId'
  /** column name */
  | 'roleId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "role_permissions" */
export type RolePermissionsSetInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  permissionId?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "role_permissions" */
export type RolePermissionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: RolePermissionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RolePermissionsStreamCursorValueInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  permissionId?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "role_permissions" */
export type RolePermissionsUpdateColumn =
  /** column name */
  | 'conditions'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'permissionId'
  /** column name */
  | 'roleId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type RolePermissionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<RolePermissionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<RolePermissionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<RolePermissionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<RolePermissionsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<RolePermissionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RolePermissionsSetInput>;
  /** filter the rows which have to be updated */
  where: RolePermissionsBoolExp;
};

/** columns and relationships of "roles" */
export type Roles = {
  __typename?: 'Roles';
  createdAt: Scalars['timestamptz']['output'];
  description?: Maybe<Scalars['String']['output']>;
  displayName: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  isSystemRole: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  priority: Scalars['Int']['output'];
  /** An array relationship */
  rolePermissions: Array<RolePermissions>;
  /** An aggregate relationship */
  rolePermissionsAggregate: RolePermissionsAggregate;
  updatedAt: Scalars['timestamptz']['output'];
  /** An array relationship */
  userRoles: Array<UserRoles>;
  /** An aggregate relationship */
  userRolesAggregate: UserRolesAggregate;
};


/** columns and relationships of "roles" */
export type RolesRolePermissionsArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


/** columns and relationships of "roles" */
export type RolesRolePermissionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


/** columns and relationships of "roles" */
export type RolesUserRolesArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


/** columns and relationships of "roles" */
export type RolesUserRolesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};

/** aggregated selection of "roles" */
export type RolesAggregate = {
  __typename?: 'RolesAggregate';
  aggregate?: Maybe<RolesAggregateFields>;
  nodes: Array<Roles>;
};

/** aggregate fields of "roles" */
export type RolesAggregateFields = {
  __typename?: 'RolesAggregateFields';
  avg?: Maybe<RolesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<RolesMaxFields>;
  min?: Maybe<RolesMinFields>;
  stddev?: Maybe<RolesStddevFields>;
  stddevPop?: Maybe<RolesStddevPopFields>;
  stddevSamp?: Maybe<RolesStddevSampFields>;
  sum?: Maybe<RolesSumFields>;
  varPop?: Maybe<RolesVarPopFields>;
  varSamp?: Maybe<RolesVarSampFields>;
  variance?: Maybe<RolesVarianceFields>;
};


/** aggregate fields of "roles" */
export type RolesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<RolesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type RolesAvgFields = {
  __typename?: 'RolesAvgFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'. */
export type RolesBoolExp = {
  _and?: InputMaybe<Array<RolesBoolExp>>;
  _not?: InputMaybe<RolesBoolExp>;
  _or?: InputMaybe<Array<RolesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  displayName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isSystemRole?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  rolePermissions?: InputMaybe<RolePermissionsBoolExp>;
  rolePermissionsAggregate?: InputMaybe<RolePermissionsAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  userRoles?: InputMaybe<UserRolesBoolExp>;
  userRolesAggregate?: InputMaybe<UserRolesAggregateBoolExp>;
};

/** unique or primary key constraints on table "roles" */
export type RolesConstraint =
  /** unique or primary key constraint on columns "name" */
  | 'roles_name_key'
  /** unique or primary key constraint on columns "id" */
  | 'roles_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "roles" */
export type RolesIncInput = {
  priority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "roles" */
export type RolesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isSystemRole?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  rolePermissions?: InputMaybe<RolePermissionsArrRelInsertInput>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userRoles?: InputMaybe<UserRolesArrRelInsertInput>;
};

/** aggregate max on columns */
export type RolesMaxFields = {
  __typename?: 'RolesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  priority?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type RolesMinFields = {
  __typename?: 'RolesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  priority?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "roles" */
export type RolesMutationResponse = {
  __typename?: 'RolesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Roles>;
};

/** input type for inserting object relation for remote table "roles" */
export type RolesObjRelInsertInput = {
  data: RolesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<RolesOnConflict>;
};

/** on_conflict condition type for table "roles" */
export type RolesOnConflict = {
  constraint: RolesConstraint;
  updateColumns?: Array<RolesUpdateColumn>;
  where?: InputMaybe<RolesBoolExp>;
};

/** Ordering options when selecting data from "roles". */
export type RolesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  displayName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isSystemRole?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  rolePermissionsAggregate?: InputMaybe<RolePermissionsAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userRolesAggregate?: InputMaybe<UserRolesAggregateOrderBy>;
};

/** primary key columns input for table: roles */
export type RolesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "roles" */
export type RolesSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'displayName'
  /** column name */
  | 'id'
  /** column name */
  | 'isSystemRole'
  /** column name */
  | 'name'
  /** column name */
  | 'priority'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "roles" */
export type RolesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isSystemRole?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type RolesStddevFields = {
  __typename?: 'RolesStddevFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type RolesStddevPopFields = {
  __typename?: 'RolesStddevPopFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type RolesStddevSampFields = {
  __typename?: 'RolesStddevSampFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "roles" */
export type RolesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: RolesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type RolesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isSystemRole?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type RolesSumFields = {
  __typename?: 'RolesSumFields';
  priority?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "roles" */
export type RolesUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'displayName'
  /** column name */
  | 'id'
  /** column name */
  | 'isSystemRole'
  /** column name */
  | 'name'
  /** column name */
  | 'priority'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type RolesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<RolesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<RolesSetInput>;
  /** filter the rows which have to be updated */
  where: RolesBoolExp;
};

/** aggregate varPop on columns */
export type RolesVarPopFields = {
  __typename?: 'RolesVarPopFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type RolesVarSampFields = {
  __typename?: 'RolesVarSampFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type RolesVarianceFields = {
  __typename?: 'RolesVarianceFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "security_alerts" */
export type SecurityAlerts = {
  __typename?: 'SecurityAlerts';
  alertType: Scalars['String']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  ipAddress?: Maybe<Scalars['inet']['output']>;
  isResolved?: Maybe<Scalars['Boolean']['output']>;
  metadata?: Maybe<Scalars['jsonb']['output']>;
  resolutionNotes?: Maybe<Scalars['String']['output']>;
  resolvedAt?: Maybe<Scalars['timestamptz']['output']>;
  resolvedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  resolvedByUser?: Maybe<Users>;
  severity?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  /** An object relationship */
  user?: Maybe<Users>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "security_alerts" */
export type SecurityAlertsMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "security_alerts" */
export type SecurityAlertsAggregate = {
  __typename?: 'SecurityAlertsAggregate';
  aggregate?: Maybe<SecurityAlertsAggregateFields>;
  nodes: Array<SecurityAlerts>;
};

export type SecurityAlertsAggregateBoolExp = {
  bool_and?: InputMaybe<SecurityAlertsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<SecurityAlertsAggregateBoolExpBool_Or>;
  count?: InputMaybe<SecurityAlertsAggregateBoolExpCount>;
};

/** aggregate fields of "security_alerts" */
export type SecurityAlertsAggregateFields = {
  __typename?: 'SecurityAlertsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<SecurityAlertsMaxFields>;
  min?: Maybe<SecurityAlertsMinFields>;
};


/** aggregate fields of "security_alerts" */
export type SecurityAlertsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "security_alerts" */
export type SecurityAlertsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<SecurityAlertsMaxOrderBy>;
  min?: InputMaybe<SecurityAlertsMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SecurityAlertsAppendInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "security_alerts" */
export type SecurityAlertsArrRelInsertInput = {
  data: Array<SecurityAlertsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<SecurityAlertsOnConflict>;
};

/** Boolean expression to filter rows from the table "security_alerts". All fields are combined with a logical 'AND'. */
export type SecurityAlertsBoolExp = {
  _and?: InputMaybe<Array<SecurityAlertsBoolExp>>;
  _not?: InputMaybe<SecurityAlertsBoolExp>;
  _or?: InputMaybe<Array<SecurityAlertsBoolExp>>;
  alertType?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ipAddress?: InputMaybe<InetComparisonExp>;
  isResolved?: InputMaybe<BooleanComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  resolutionNotes?: InputMaybe<StringComparisonExp>;
  resolvedAt?: InputMaybe<TimestamptzComparisonExp>;
  resolvedBy?: InputMaybe<UuidComparisonExp>;
  resolvedByUser?: InputMaybe<UsersBoolExp>;
  severity?: InputMaybe<StringComparisonExp>;
  title?: InputMaybe<StringComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userAgent?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "security_alerts" */
export type SecurityAlertsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'security_alerts_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SecurityAlertsDeleteAtPathInput = {
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SecurityAlertsDeleteElemInput = {
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SecurityAlertsDeleteKeyInput = {
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "security_alerts" */
export type SecurityAlertsInsertInput = {
  alertType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  isResolved?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  resolutionNotes?: InputMaybe<Scalars['String']['input']>;
  resolvedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  resolvedBy?: InputMaybe<Scalars['uuid']['input']>;
  resolvedByUser?: InputMaybe<UsersObjRelInsertInput>;
  severity?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SecurityAlertsMaxFields = {
  __typename?: 'SecurityAlertsMaxFields';
  alertType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  resolutionNotes?: Maybe<Scalars['String']['output']>;
  resolvedAt?: Maybe<Scalars['timestamptz']['output']>;
  resolvedBy?: Maybe<Scalars['uuid']['output']>;
  severity?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "security_alerts" */
export type SecurityAlertsMaxOrderBy = {
  alertType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  resolutionNotes?: InputMaybe<OrderBy>;
  resolvedAt?: InputMaybe<OrderBy>;
  resolvedBy?: InputMaybe<OrderBy>;
  severity?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type SecurityAlertsMinFields = {
  __typename?: 'SecurityAlertsMinFields';
  alertType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  resolutionNotes?: Maybe<Scalars['String']['output']>;
  resolvedAt?: Maybe<Scalars['timestamptz']['output']>;
  resolvedBy?: Maybe<Scalars['uuid']['output']>;
  severity?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "security_alerts" */
export type SecurityAlertsMinOrderBy = {
  alertType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  resolutionNotes?: InputMaybe<OrderBy>;
  resolvedAt?: InputMaybe<OrderBy>;
  resolvedBy?: InputMaybe<OrderBy>;
  severity?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "security_alerts" */
export type SecurityAlertsMutationResponse = {
  __typename?: 'SecurityAlertsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SecurityAlerts>;
};

/** on_conflict condition type for table "security_alerts" */
export type SecurityAlertsOnConflict = {
  constraint: SecurityAlertsConstraint;
  updateColumns?: Array<SecurityAlertsUpdateColumn>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};

/** Ordering options when selecting data from "security_alerts". */
export type SecurityAlertsOrderBy = {
  alertType?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ipAddress?: InputMaybe<OrderBy>;
  isResolved?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  resolutionNotes?: InputMaybe<OrderBy>;
  resolvedAt?: InputMaybe<OrderBy>;
  resolvedBy?: InputMaybe<OrderBy>;
  resolvedByUser?: InputMaybe<UsersOrderBy>;
  severity?: InputMaybe<OrderBy>;
  title?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: security_alerts */
export type SecurityAlertsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SecurityAlertsPrependInput = {
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "security_alerts" */
export type SecurityAlertsSelectColumn =
  /** column name */
  | 'alertType'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'isResolved'
  /** column name */
  | 'metadata'
  /** column name */
  | 'resolutionNotes'
  /** column name */
  | 'resolvedAt'
  /** column name */
  | 'resolvedBy'
  /** column name */
  | 'severity'
  /** column name */
  | 'title'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userId'
  | '%future added value';

/** select "securityAlertsAggregateBoolExpBool_andArgumentsColumns" columns of table "security_alerts" */
export type SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isResolved'
  | '%future added value';

/** select "securityAlertsAggregateBoolExpBool_orArgumentsColumns" columns of table "security_alerts" */
export type SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isResolved'
  | '%future added value';

/** input type for updating data in table "security_alerts" */
export type SecurityAlertsSetInput = {
  alertType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  isResolved?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  resolutionNotes?: InputMaybe<Scalars['String']['input']>;
  resolvedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  resolvedBy?: InputMaybe<Scalars['uuid']['input']>;
  severity?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "security_alerts" */
export type SecurityAlertsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SecurityAlertsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SecurityAlertsStreamCursorValueInput = {
  alertType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  isResolved?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  resolutionNotes?: InputMaybe<Scalars['String']['input']>;
  resolvedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  resolvedBy?: InputMaybe<Scalars['uuid']['input']>;
  severity?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "security_alerts" */
export type SecurityAlertsUpdateColumn =
  /** column name */
  | 'alertType'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'isResolved'
  /** column name */
  | 'metadata'
  /** column name */
  | 'resolutionNotes'
  /** column name */
  | 'resolvedAt'
  /** column name */
  | 'resolvedBy'
  /** column name */
  | 'severity'
  /** column name */
  | 'title'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userId'
  | '%future added value';

export type SecurityAlertsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SecurityAlertsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<SecurityAlertsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<SecurityAlertsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<SecurityAlertsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SecurityAlertsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SecurityAlertsSetInput>;
  /** filter the rows which have to be updated */
  where: SecurityAlertsBoolExp;
};

/** columns and relationships of "security_settings" */
export type SecuritySettings = {
  __typename?: 'SecuritySettings';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  isSystemWide?: Maybe<Scalars['Boolean']['output']>;
  settingKey: Scalars['String']['output'];
  settingValue: Scalars['jsonb']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  updatedByUser?: Maybe<Users>;
  /** An object relationship */
  user?: Maybe<Users>;
  userId?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "security_settings" */
export type SecuritySettingsSettingValueArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "security_settings" */
export type SecuritySettingsAggregate = {
  __typename?: 'SecuritySettingsAggregate';
  aggregate?: Maybe<SecuritySettingsAggregateFields>;
  nodes: Array<SecuritySettings>;
};

export type SecuritySettingsAggregateBoolExp = {
  bool_and?: InputMaybe<SecuritySettingsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<SecuritySettingsAggregateBoolExpBool_Or>;
  count?: InputMaybe<SecuritySettingsAggregateBoolExpCount>;
};

/** aggregate fields of "security_settings" */
export type SecuritySettingsAggregateFields = {
  __typename?: 'SecuritySettingsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<SecuritySettingsMaxFields>;
  min?: Maybe<SecuritySettingsMinFields>;
};


/** aggregate fields of "security_settings" */
export type SecuritySettingsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "security_settings" */
export type SecuritySettingsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<SecuritySettingsMaxOrderBy>;
  min?: InputMaybe<SecuritySettingsMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SecuritySettingsAppendInput = {
  settingValue?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "security_settings" */
export type SecuritySettingsArrRelInsertInput = {
  data: Array<SecuritySettingsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<SecuritySettingsOnConflict>;
};

/** Boolean expression to filter rows from the table "security_settings". All fields are combined with a logical 'AND'. */
export type SecuritySettingsBoolExp = {
  _and?: InputMaybe<Array<SecuritySettingsBoolExp>>;
  _not?: InputMaybe<SecuritySettingsBoolExp>;
  _or?: InputMaybe<Array<SecuritySettingsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isSystemWide?: InputMaybe<BooleanComparisonExp>;
  settingKey?: InputMaybe<StringComparisonExp>;
  settingValue?: InputMaybe<JsonbComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedBy?: InputMaybe<UuidComparisonExp>;
  updatedByUser?: InputMaybe<UsersBoolExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "security_settings" */
export type SecuritySettingsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'security_settings_pkey'
  /** unique or primary key constraint on columns "user_id", "setting_key" */
  | 'security_settings_user_id_setting_key_key'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SecuritySettingsDeleteAtPathInput = {
  settingValue?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SecuritySettingsDeleteElemInput = {
  settingValue?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SecuritySettingsDeleteKeyInput = {
  settingValue?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "security_settings" */
export type SecuritySettingsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isSystemWide?: InputMaybe<Scalars['Boolean']['input']>;
  settingKey?: InputMaybe<Scalars['String']['input']>;
  settingValue?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  updatedByUser?: InputMaybe<UsersObjRelInsertInput>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SecuritySettingsMaxFields = {
  __typename?: 'SecuritySettingsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  settingKey?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "security_settings" */
export type SecuritySettingsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  settingKey?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type SecuritySettingsMinFields = {
  __typename?: 'SecuritySettingsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  settingKey?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "security_settings" */
export type SecuritySettingsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  settingKey?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "security_settings" */
export type SecuritySettingsMutationResponse = {
  __typename?: 'SecuritySettingsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SecuritySettings>;
};

/** on_conflict condition type for table "security_settings" */
export type SecuritySettingsOnConflict = {
  constraint: SecuritySettingsConstraint;
  updateColumns?: Array<SecuritySettingsUpdateColumn>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};

/** Ordering options when selecting data from "security_settings". */
export type SecuritySettingsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isSystemWide?: InputMaybe<OrderBy>;
  settingKey?: InputMaybe<OrderBy>;
  settingValue?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
  updatedByUser?: InputMaybe<UsersOrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: security_settings */
export type SecuritySettingsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SecuritySettingsPrependInput = {
  settingValue?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "security_settings" */
export type SecuritySettingsSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'isSystemWide'
  /** column name */
  | 'settingKey'
  /** column name */
  | 'settingValue'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  /** column name */
  | 'userId'
  | '%future added value';

/** select "securitySettingsAggregateBoolExpBool_andArgumentsColumns" columns of table "security_settings" */
export type SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isSystemWide'
  | '%future added value';

/** select "securitySettingsAggregateBoolExpBool_orArgumentsColumns" columns of table "security_settings" */
export type SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isSystemWide'
  | '%future added value';

/** input type for updating data in table "security_settings" */
export type SecuritySettingsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isSystemWide?: InputMaybe<Scalars['Boolean']['input']>;
  settingKey?: InputMaybe<Scalars['String']['input']>;
  settingValue?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "security_settings" */
export type SecuritySettingsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SecuritySettingsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SecuritySettingsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isSystemWide?: InputMaybe<Scalars['Boolean']['input']>;
  settingKey?: InputMaybe<Scalars['String']['input']>;
  settingValue?: InputMaybe<Scalars['jsonb']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "security_settings" */
export type SecuritySettingsUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'isSystemWide'
  /** column name */
  | 'settingKey'
  /** column name */
  | 'settingValue'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  /** column name */
  | 'userId'
  | '%future added value';

export type SecuritySettingsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SecuritySettingsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<SecuritySettingsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<SecuritySettingsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<SecuritySettingsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SecuritySettingsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SecuritySettingsSetInput>;
  /** filter the rows which have to be updated */
  where: SecuritySettingsBoolExp;
};

/** Dynamic pricing rules for services */
export type ServicePricingRules = {
  __typename?: 'ServicePricingRules';
  conditions: Scalars['jsonb']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  createdByUser?: Maybe<Users>;
  effectiveFrom?: Maybe<Scalars['timestamptz']['output']>;
  effectiveUntil?: Maybe<Scalars['timestamptz']['output']>;
  id: Scalars['uuid']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  pricingAdjustment: Scalars['jsonb']['output'];
  priority?: Maybe<Scalars['Int']['output']>;
  ruleName: Scalars['String']['output'];
  ruleType: Scalars['String']['output'];
  /** An object relationship */
  service: Services;
  serviceId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** Dynamic pricing rules for services */
export type ServicePricingRulesConditionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Dynamic pricing rules for services */
export type ServicePricingRulesPricingAdjustmentArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "service_pricing_rules" */
export type ServicePricingRulesAggregate = {
  __typename?: 'ServicePricingRulesAggregate';
  aggregate?: Maybe<ServicePricingRulesAggregateFields>;
  nodes: Array<ServicePricingRules>;
};

export type ServicePricingRulesAggregateBoolExp = {
  bool_and?: InputMaybe<ServicePricingRulesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<ServicePricingRulesAggregateBoolExpBool_Or>;
  count?: InputMaybe<ServicePricingRulesAggregateBoolExpCount>;
};

/** aggregate fields of "service_pricing_rules" */
export type ServicePricingRulesAggregateFields = {
  __typename?: 'ServicePricingRulesAggregateFields';
  avg?: Maybe<ServicePricingRulesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ServicePricingRulesMaxFields>;
  min?: Maybe<ServicePricingRulesMinFields>;
  stddev?: Maybe<ServicePricingRulesStddevFields>;
  stddevPop?: Maybe<ServicePricingRulesStddevPopFields>;
  stddevSamp?: Maybe<ServicePricingRulesStddevSampFields>;
  sum?: Maybe<ServicePricingRulesSumFields>;
  varPop?: Maybe<ServicePricingRulesVarPopFields>;
  varSamp?: Maybe<ServicePricingRulesVarSampFields>;
  variance?: Maybe<ServicePricingRulesVarianceFields>;
};


/** aggregate fields of "service_pricing_rules" */
export type ServicePricingRulesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "service_pricing_rules" */
export type ServicePricingRulesAggregateOrderBy = {
  avg?: InputMaybe<ServicePricingRulesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ServicePricingRulesMaxOrderBy>;
  min?: InputMaybe<ServicePricingRulesMinOrderBy>;
  stddev?: InputMaybe<ServicePricingRulesStddevOrderBy>;
  stddevPop?: InputMaybe<ServicePricingRulesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ServicePricingRulesStddevSampOrderBy>;
  sum?: InputMaybe<ServicePricingRulesSumOrderBy>;
  varPop?: InputMaybe<ServicePricingRulesVarPopOrderBy>;
  varSamp?: InputMaybe<ServicePricingRulesVarSampOrderBy>;
  variance?: InputMaybe<ServicePricingRulesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ServicePricingRulesAppendInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  pricingAdjustment?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "service_pricing_rules" */
export type ServicePricingRulesArrRelInsertInput = {
  data: Array<ServicePricingRulesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ServicePricingRulesOnConflict>;
};

/** aggregate avg on columns */
export type ServicePricingRulesAvgFields = {
  __typename?: 'ServicePricingRulesAvgFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "service_pricing_rules" */
export type ServicePricingRulesAvgOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_pricing_rules". All fields are combined with a logical 'AND'. */
export type ServicePricingRulesBoolExp = {
  _and?: InputMaybe<Array<ServicePricingRulesBoolExp>>;
  _not?: InputMaybe<ServicePricingRulesBoolExp>;
  _or?: InputMaybe<Array<ServicePricingRulesBoolExp>>;
  conditions?: InputMaybe<JsonbComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  effectiveFrom?: InputMaybe<TimestamptzComparisonExp>;
  effectiveUntil?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  pricingAdjustment?: InputMaybe<JsonbComparisonExp>;
  priority?: InputMaybe<IntComparisonExp>;
  ruleName?: InputMaybe<StringComparisonExp>;
  ruleType?: InputMaybe<StringComparisonExp>;
  service?: InputMaybe<ServicesBoolExp>;
  serviceId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "service_pricing_rules" */
export type ServicePricingRulesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'service_pricing_rules_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ServicePricingRulesDeleteAtPathInput = {
  conditions?: InputMaybe<Array<Scalars['String']['input']>>;
  pricingAdjustment?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ServicePricingRulesDeleteElemInput = {
  conditions?: InputMaybe<Scalars['Int']['input']>;
  pricingAdjustment?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ServicePricingRulesDeleteKeyInput = {
  conditions?: InputMaybe<Scalars['String']['input']>;
  pricingAdjustment?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "service_pricing_rules" */
export type ServicePricingRulesIncInput = {
  priority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "service_pricing_rules" */
export type ServicePricingRulesInsertInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  effectiveFrom?: InputMaybe<Scalars['timestamptz']['input']>;
  effectiveUntil?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  pricingAdjustment?: InputMaybe<Scalars['jsonb']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  ruleName?: InputMaybe<Scalars['String']['input']>;
  ruleType?: InputMaybe<Scalars['String']['input']>;
  service?: InputMaybe<ServicesObjRelInsertInput>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type ServicePricingRulesMaxFields = {
  __typename?: 'ServicePricingRulesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  effectiveFrom?: Maybe<Scalars['timestamptz']['output']>;
  effectiveUntil?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  priority?: Maybe<Scalars['Int']['output']>;
  ruleName?: Maybe<Scalars['String']['output']>;
  ruleType?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "service_pricing_rules" */
export type ServicePricingRulesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  effectiveFrom?: InputMaybe<OrderBy>;
  effectiveUntil?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  ruleName?: InputMaybe<OrderBy>;
  ruleType?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ServicePricingRulesMinFields = {
  __typename?: 'ServicePricingRulesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  effectiveFrom?: Maybe<Scalars['timestamptz']['output']>;
  effectiveUntil?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  priority?: Maybe<Scalars['Int']['output']>;
  ruleName?: Maybe<Scalars['String']['output']>;
  ruleType?: Maybe<Scalars['String']['output']>;
  serviceId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "service_pricing_rules" */
export type ServicePricingRulesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  effectiveFrom?: InputMaybe<OrderBy>;
  effectiveUntil?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  ruleName?: InputMaybe<OrderBy>;
  ruleType?: InputMaybe<OrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_pricing_rules" */
export type ServicePricingRulesMutationResponse = {
  __typename?: 'ServicePricingRulesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ServicePricingRules>;
};

/** on_conflict condition type for table "service_pricing_rules" */
export type ServicePricingRulesOnConflict = {
  constraint: ServicePricingRulesConstraint;
  updateColumns?: Array<ServicePricingRulesUpdateColumn>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};

/** Ordering options when selecting data from "service_pricing_rules". */
export type ServicePricingRulesOrderBy = {
  conditions?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  effectiveFrom?: InputMaybe<OrderBy>;
  effectiveUntil?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  pricingAdjustment?: InputMaybe<OrderBy>;
  priority?: InputMaybe<OrderBy>;
  ruleName?: InputMaybe<OrderBy>;
  ruleType?: InputMaybe<OrderBy>;
  service?: InputMaybe<ServicesOrderBy>;
  serviceId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: service_pricing_rules */
export type ServicePricingRulesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ServicePricingRulesPrependInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  pricingAdjustment?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "service_pricing_rules" */
export type ServicePricingRulesSelectColumn =
  /** column name */
  | 'conditions'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'effectiveFrom'
  /** column name */
  | 'effectiveUntil'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'pricingAdjustment'
  /** column name */
  | 'priority'
  /** column name */
  | 'ruleName'
  /** column name */
  | 'ruleType'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** select "servicePricingRulesAggregateBoolExpBool_andArgumentsColumns" columns of table "service_pricing_rules" */
export type ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isActive'
  | '%future added value';

/** select "servicePricingRulesAggregateBoolExpBool_orArgumentsColumns" columns of table "service_pricing_rules" */
export type ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isActive'
  | '%future added value';

/** input type for updating data in table "service_pricing_rules" */
export type ServicePricingRulesSetInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  effectiveFrom?: InputMaybe<Scalars['timestamptz']['input']>;
  effectiveUntil?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  pricingAdjustment?: InputMaybe<Scalars['jsonb']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  ruleName?: InputMaybe<Scalars['String']['input']>;
  ruleType?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type ServicePricingRulesStddevFields = {
  __typename?: 'ServicePricingRulesStddevFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "service_pricing_rules" */
export type ServicePricingRulesStddevOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ServicePricingRulesStddevPopFields = {
  __typename?: 'ServicePricingRulesStddevPopFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "service_pricing_rules" */
export type ServicePricingRulesStddevPopOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ServicePricingRulesStddevSampFields = {
  __typename?: 'ServicePricingRulesStddevSampFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "service_pricing_rules" */
export type ServicePricingRulesStddevSampOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "service_pricing_rules" */
export type ServicePricingRulesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ServicePricingRulesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicePricingRulesStreamCursorValueInput = {
  conditions?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  effectiveFrom?: InputMaybe<Scalars['timestamptz']['input']>;
  effectiveUntil?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  pricingAdjustment?: InputMaybe<Scalars['jsonb']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  ruleName?: InputMaybe<Scalars['String']['input']>;
  ruleType?: InputMaybe<Scalars['String']['input']>;
  serviceId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type ServicePricingRulesSumFields = {
  __typename?: 'ServicePricingRulesSumFields';
  priority?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "service_pricing_rules" */
export type ServicePricingRulesSumOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** update columns of table "service_pricing_rules" */
export type ServicePricingRulesUpdateColumn =
  /** column name */
  | 'conditions'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'effectiveFrom'
  /** column name */
  | 'effectiveUntil'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'pricingAdjustment'
  /** column name */
  | 'priority'
  /** column name */
  | 'ruleName'
  /** column name */
  | 'ruleType'
  /** column name */
  | 'serviceId'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type ServicePricingRulesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<ServicePricingRulesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<ServicePricingRulesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<ServicePricingRulesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<ServicePricingRulesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ServicePricingRulesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<ServicePricingRulesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ServicePricingRulesSetInput>;
  /** filter the rows which have to be updated */
  where: ServicePricingRulesBoolExp;
};

/** aggregate varPop on columns */
export type ServicePricingRulesVarPopFields = {
  __typename?: 'ServicePricingRulesVarPopFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "service_pricing_rules" */
export type ServicePricingRulesVarPopOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ServicePricingRulesVarSampFields = {
  __typename?: 'ServicePricingRulesVarSampFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "service_pricing_rules" */
export type ServicePricingRulesVarSampOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ServicePricingRulesVarianceFields = {
  __typename?: 'ServicePricingRulesVarianceFields';
  priority?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "service_pricing_rules" */
export type ServicePricingRulesVarianceOrderBy = {
  priority?: InputMaybe<OrderBy>;
};

/** Reusable service bundles and templates */
export type ServiceTemplates = {
  __typename?: 'ServiceTemplates';
  bundleDiscountPercentage?: Maybe<Scalars['numeric']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  createdByUser?: Maybe<Users>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  isPublic?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: Maybe<Scalars['String']['output']>;
  services: Scalars['jsonb']['output'];
  targetClientTypes?: Maybe<Array<Scalars['String']['output']>>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  updatedByUser?: Maybe<Users>;
};


/** Reusable service bundles and templates */
export type ServiceTemplatesServicesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "service_templates" */
export type ServiceTemplatesAggregate = {
  __typename?: 'ServiceTemplatesAggregate';
  aggregate?: Maybe<ServiceTemplatesAggregateFields>;
  nodes: Array<ServiceTemplates>;
};

export type ServiceTemplatesAggregateBoolExp = {
  bool_and?: InputMaybe<ServiceTemplatesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<ServiceTemplatesAggregateBoolExpBool_Or>;
  count?: InputMaybe<ServiceTemplatesAggregateBoolExpCount>;
};

/** aggregate fields of "service_templates" */
export type ServiceTemplatesAggregateFields = {
  __typename?: 'ServiceTemplatesAggregateFields';
  avg?: Maybe<ServiceTemplatesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ServiceTemplatesMaxFields>;
  min?: Maybe<ServiceTemplatesMinFields>;
  stddev?: Maybe<ServiceTemplatesStddevFields>;
  stddevPop?: Maybe<ServiceTemplatesStddevPopFields>;
  stddevSamp?: Maybe<ServiceTemplatesStddevSampFields>;
  sum?: Maybe<ServiceTemplatesSumFields>;
  varPop?: Maybe<ServiceTemplatesVarPopFields>;
  varSamp?: Maybe<ServiceTemplatesVarSampFields>;
  variance?: Maybe<ServiceTemplatesVarianceFields>;
};


/** aggregate fields of "service_templates" */
export type ServiceTemplatesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "service_templates" */
export type ServiceTemplatesAggregateOrderBy = {
  avg?: InputMaybe<ServiceTemplatesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ServiceTemplatesMaxOrderBy>;
  min?: InputMaybe<ServiceTemplatesMinOrderBy>;
  stddev?: InputMaybe<ServiceTemplatesStddevOrderBy>;
  stddevPop?: InputMaybe<ServiceTemplatesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ServiceTemplatesStddevSampOrderBy>;
  sum?: InputMaybe<ServiceTemplatesSumOrderBy>;
  varPop?: InputMaybe<ServiceTemplatesVarPopOrderBy>;
  varSamp?: InputMaybe<ServiceTemplatesVarSampOrderBy>;
  variance?: InputMaybe<ServiceTemplatesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ServiceTemplatesAppendInput = {
  services?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "service_templates" */
export type ServiceTemplatesArrRelInsertInput = {
  data: Array<ServiceTemplatesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ServiceTemplatesOnConflict>;
};

/** aggregate avg on columns */
export type ServiceTemplatesAvgFields = {
  __typename?: 'ServiceTemplatesAvgFields';
  bundleDiscountPercentage?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "service_templates" */
export type ServiceTemplatesAvgOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "service_templates". All fields are combined with a logical 'AND'. */
export type ServiceTemplatesBoolExp = {
  _and?: InputMaybe<Array<ServiceTemplatesBoolExp>>;
  _not?: InputMaybe<ServiceTemplatesBoolExp>;
  _or?: InputMaybe<Array<ServiceTemplatesBoolExp>>;
  bundleDiscountPercentage?: InputMaybe<NumericComparisonExp>;
  category?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isPublic?: InputMaybe<BooleanComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  pricingStrategy?: InputMaybe<StringComparisonExp>;
  services?: InputMaybe<JsonbComparisonExp>;
  targetClientTypes?: InputMaybe<StringArrayComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedBy?: InputMaybe<UuidComparisonExp>;
  updatedByUser?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "service_templates" */
export type ServiceTemplatesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'service_templates_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ServiceTemplatesDeleteAtPathInput = {
  services?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ServiceTemplatesDeleteElemInput = {
  services?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ServiceTemplatesDeleteKeyInput = {
  services?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "service_templates" */
export type ServiceTemplatesIncInput = {
  bundleDiscountPercentage?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "service_templates" */
export type ServiceTemplatesInsertInput = {
  bundleDiscountPercentage?: InputMaybe<Scalars['numeric']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: InputMaybe<Scalars['String']['input']>;
  services?: InputMaybe<Scalars['jsonb']['input']>;
  targetClientTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  updatedByUser?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type ServiceTemplatesMaxFields = {
  __typename?: 'ServiceTemplatesMaxFields';
  bundleDiscountPercentage?: Maybe<Scalars['numeric']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: Maybe<Scalars['String']['output']>;
  targetClientTypes?: Maybe<Array<Scalars['String']['output']>>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "service_templates" */
export type ServiceTemplatesMaxOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: InputMaybe<OrderBy>;
  targetClientTypes?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ServiceTemplatesMinFields = {
  __typename?: 'ServiceTemplatesMinFields';
  bundleDiscountPercentage?: Maybe<Scalars['numeric']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: Maybe<Scalars['String']['output']>;
  targetClientTypes?: Maybe<Array<Scalars['String']['output']>>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "service_templates" */
export type ServiceTemplatesMinOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: InputMaybe<OrderBy>;
  targetClientTypes?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "service_templates" */
export type ServiceTemplatesMutationResponse = {
  __typename?: 'ServiceTemplatesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ServiceTemplates>;
};

/** on_conflict condition type for table "service_templates" */
export type ServiceTemplatesOnConflict = {
  constraint: ServiceTemplatesConstraint;
  updateColumns?: Array<ServiceTemplatesUpdateColumn>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};

/** Ordering options when selecting data from "service_templates". */
export type ServiceTemplatesOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isPublic?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  pricingStrategy?: InputMaybe<OrderBy>;
  services?: InputMaybe<OrderBy>;
  targetClientTypes?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
  updatedByUser?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: service_templates */
export type ServiceTemplatesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ServiceTemplatesPrependInput = {
  services?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "service_templates" */
export type ServiceTemplatesSelectColumn =
  /** column name */
  | 'bundleDiscountPercentage'
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'isPublic'
  /** column name */
  | 'name'
  /** column name */
  | 'pricingStrategy'
  /** column name */
  | 'services'
  /** column name */
  | 'targetClientTypes'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  | '%future added value';

/** select "serviceTemplatesAggregateBoolExpBool_andArgumentsColumns" columns of table "service_templates" */
export type ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isPublic'
  | '%future added value';

/** select "serviceTemplatesAggregateBoolExpBool_orArgumentsColumns" columns of table "service_templates" */
export type ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isPublic'
  | '%future added value';

/** input type for updating data in table "service_templates" */
export type ServiceTemplatesSetInput = {
  bundleDiscountPercentage?: InputMaybe<Scalars['numeric']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: InputMaybe<Scalars['String']['input']>;
  services?: InputMaybe<Scalars['jsonb']['input']>;
  targetClientTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type ServiceTemplatesStddevFields = {
  __typename?: 'ServiceTemplatesStddevFields';
  bundleDiscountPercentage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "service_templates" */
export type ServiceTemplatesStddevOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ServiceTemplatesStddevPopFields = {
  __typename?: 'ServiceTemplatesStddevPopFields';
  bundleDiscountPercentage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "service_templates" */
export type ServiceTemplatesStddevPopOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ServiceTemplatesStddevSampFields = {
  __typename?: 'ServiceTemplatesStddevSampFields';
  bundleDiscountPercentage?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "service_templates" */
export type ServiceTemplatesStddevSampOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "service_templates" */
export type ServiceTemplatesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ServiceTemplatesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServiceTemplatesStreamCursorValueInput = {
  bundleDiscountPercentage?: InputMaybe<Scalars['numeric']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isPublic?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** How to calculate template price: sum (add all), fixed (set price), tiered (based on rules) */
  pricingStrategy?: InputMaybe<Scalars['String']['input']>;
  services?: InputMaybe<Scalars['jsonb']['input']>;
  targetClientTypes?: InputMaybe<Array<Scalars['String']['input']>>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type ServiceTemplatesSumFields = {
  __typename?: 'ServiceTemplatesSumFields';
  bundleDiscountPercentage?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "service_templates" */
export type ServiceTemplatesSumOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** update columns of table "service_templates" */
export type ServiceTemplatesUpdateColumn =
  /** column name */
  | 'bundleDiscountPercentage'
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'isPublic'
  /** column name */
  | 'name'
  /** column name */
  | 'pricingStrategy'
  /** column name */
  | 'services'
  /** column name */
  | 'targetClientTypes'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  | '%future added value';

export type ServiceTemplatesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<ServiceTemplatesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<ServiceTemplatesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<ServiceTemplatesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<ServiceTemplatesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ServiceTemplatesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<ServiceTemplatesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ServiceTemplatesSetInput>;
  /** filter the rows which have to be updated */
  where: ServiceTemplatesBoolExp;
};

/** aggregate varPop on columns */
export type ServiceTemplatesVarPopFields = {
  __typename?: 'ServiceTemplatesVarPopFields';
  bundleDiscountPercentage?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "service_templates" */
export type ServiceTemplatesVarPopOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ServiceTemplatesVarSampFields = {
  __typename?: 'ServiceTemplatesVarSampFields';
  bundleDiscountPercentage?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "service_templates" */
export type ServiceTemplatesVarSampOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ServiceTemplatesVarianceFields = {
  __typename?: 'ServiceTemplatesVarianceFields';
  bundleDiscountPercentage?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "service_templates" */
export type ServiceTemplatesVarianceOrderBy = {
  bundleDiscountPercentage?: InputMaybe<OrderBy>;
};

/** Core services catalog with proper referential integrity */
export type Services = {
  __typename?: 'Services';
  /** An array relationship */
  billingItems: Array<BillingItems>;
  /** An aggregate relationship */
  billingItemsAggregate: BillingItemsAggregate;
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: Maybe<Scalars['billing_tier_level']['output']>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit: Scalars['String']['output'];
  category: Scalars['String']['output'];
  /** An array relationship */
  clientAgreements: Array<ClientServiceAgreements>;
  /** An aggregate relationship */
  clientAgreementsAggregate: ClientServiceAgreementsAggregate;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  createdByUser?: Maybe<Users>;
  currency: Scalars['String']['output'];
  defaultRate: Scalars['numeric']['output'];
  dependencies?: Maybe<Scalars['jsonb']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isTemplate?: Maybe<Scalars['Boolean']['output']>;
  metadata?: Maybe<Scalars['jsonb']['output']>;
  name: Scalars['String']['output'];
  /** An array relationship */
  payrollServiceAgreementsForService: Array<PayrollServiceAgreements>;
  /** An aggregate relationship */
  payrollServiceAgreementsForServiceAggregate: PayrollServiceAgreementsAggregate;
  /** JSONB field for complex pricing logic */
  pricingRules?: Maybe<Scalars['jsonb']['output']>;
  /** An array relationship */
  quoteLineItems: Array<QuoteLineItems>;
  /** An aggregate relationship */
  quoteLineItemsAggregate: QuoteLineItemsAggregate;
  requiresMonthlyCompletion?: Maybe<Scalars['Boolean']['output']>;
  requiresPayrollCompletion?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  servicePricingRules: Array<ServicePricingRules>;
  /** An aggregate relationship */
  servicePricingRulesAggregate: ServicePricingRulesAggregate;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType: Scalars['String']['output'];
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  updatedByUser?: Maybe<Users>;
};


/** Core services catalog with proper referential integrity */
export type ServicesBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesClientAgreementsArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesClientAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesDependenciesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Core services catalog with proper referential integrity */
export type ServicesMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Core services catalog with proper referential integrity */
export type ServicesPayrollServiceAgreementsForServiceArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesPayrollServiceAgreementsForServiceAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesPricingRulesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** Core services catalog with proper referential integrity */
export type ServicesQuoteLineItemsArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesQuoteLineItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesServicePricingRulesArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


/** Core services catalog with proper referential integrity */
export type ServicesServicePricingRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};

/** aggregated selection of "services" */
export type ServicesAggregate = {
  __typename?: 'ServicesAggregate';
  aggregate?: Maybe<ServicesAggregateFields>;
  nodes: Array<Services>;
};

export type ServicesAggregateBoolExp = {
  bool_and?: InputMaybe<ServicesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<ServicesAggregateBoolExpBool_Or>;
  count?: InputMaybe<ServicesAggregateBoolExpCount>;
};

/** aggregate fields of "services" */
export type ServicesAggregateFields = {
  __typename?: 'ServicesAggregateFields';
  avg?: Maybe<ServicesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ServicesMaxFields>;
  min?: Maybe<ServicesMinFields>;
  stddev?: Maybe<ServicesStddevFields>;
  stddevPop?: Maybe<ServicesStddevPopFields>;
  stddevSamp?: Maybe<ServicesStddevSampFields>;
  sum?: Maybe<ServicesSumFields>;
  varPop?: Maybe<ServicesVarPopFields>;
  varSamp?: Maybe<ServicesVarSampFields>;
  variance?: Maybe<ServicesVarianceFields>;
};


/** aggregate fields of "services" */
export type ServicesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<ServicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "services" */
export type ServicesAggregateOrderBy = {
  avg?: InputMaybe<ServicesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<ServicesMaxOrderBy>;
  min?: InputMaybe<ServicesMinOrderBy>;
  stddev?: InputMaybe<ServicesStddevOrderBy>;
  stddevPop?: InputMaybe<ServicesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<ServicesStddevSampOrderBy>;
  sum?: InputMaybe<ServicesSumOrderBy>;
  varPop?: InputMaybe<ServicesVarPopOrderBy>;
  varSamp?: InputMaybe<ServicesVarSampOrderBy>;
  variance?: InputMaybe<ServicesVarianceOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ServicesAppendInput = {
  dependencies?: InputMaybe<Scalars['jsonb']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "services" */
export type ServicesArrRelInsertInput = {
  data: Array<ServicesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<ServicesOnConflict>;
};

/** aggregate avg on columns */
export type ServicesAvgFields = {
  __typename?: 'ServicesAvgFields';
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "services" */
export type ServicesAvgOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'. */
export type ServicesBoolExp = {
  _and?: InputMaybe<Array<ServicesBoolExp>>;
  _not?: InputMaybe<ServicesBoolExp>;
  _or?: InputMaybe<Array<ServicesBoolExp>>;
  billingItems?: InputMaybe<BillingItemsBoolExp>;
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  billingTier?: InputMaybe<BillingTierLevelComparisonExp>;
  billingUnit?: InputMaybe<StringComparisonExp>;
  category?: InputMaybe<StringComparisonExp>;
  clientAgreements?: InputMaybe<ClientServiceAgreementsBoolExp>;
  clientAgreementsAggregate?: InputMaybe<ClientServiceAgreementsAggregateBoolExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  createdByUser?: InputMaybe<UsersBoolExp>;
  currency?: InputMaybe<StringComparisonExp>;
  defaultRate?: InputMaybe<NumericComparisonExp>;
  dependencies?: InputMaybe<JsonbComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isTemplate?: InputMaybe<BooleanComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  name?: InputMaybe<StringComparisonExp>;
  payrollServiceAgreementsForService?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  payrollServiceAgreementsForServiceAggregate?: InputMaybe<PayrollServiceAgreementsAggregateBoolExp>;
  pricingRules?: InputMaybe<JsonbComparisonExp>;
  quoteLineItems?: InputMaybe<QuoteLineItemsBoolExp>;
  quoteLineItemsAggregate?: InputMaybe<QuoteLineItemsAggregateBoolExp>;
  requiresMonthlyCompletion?: InputMaybe<BooleanComparisonExp>;
  requiresPayrollCompletion?: InputMaybe<BooleanComparisonExp>;
  servicePricingRules?: InputMaybe<ServicePricingRulesBoolExp>;
  servicePricingRulesAggregate?: InputMaybe<ServicePricingRulesAggregateBoolExp>;
  serviceType?: InputMaybe<StringComparisonExp>;
  tierPriority?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedBy?: InputMaybe<UuidComparisonExp>;
  updatedByUser?: InputMaybe<UsersBoolExp>;
};

/** unique or primary key constraints on table "services" */
export type ServicesConstraint =
  /** unique or primary key constraint on columns "name" */
  | 'services_name_key'
  /** unique or primary key constraint on columns "id" */
  | 'services_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ServicesDeleteAtPathInput = {
  dependencies?: InputMaybe<Array<Scalars['String']['input']>>;
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ServicesDeleteElemInput = {
  dependencies?: InputMaybe<Scalars['Int']['input']>;
  metadata?: InputMaybe<Scalars['Int']['input']>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ServicesDeleteKeyInput = {
  dependencies?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Scalars['String']['input']>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "services" */
export type ServicesIncInput = {
  defaultRate?: InputMaybe<Scalars['numeric']['input']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "services" */
export type ServicesInsertInput = {
  billingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: InputMaybe<Scalars['billing_tier_level']['input']>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  clientAgreements?: InputMaybe<ClientServiceAgreementsArrRelInsertInput>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  createdByUser?: InputMaybe<UsersObjRelInsertInput>;
  currency?: InputMaybe<Scalars['String']['input']>;
  defaultRate?: InputMaybe<Scalars['numeric']['input']>;
  dependencies?: InputMaybe<Scalars['jsonb']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  payrollServiceAgreementsForService?: InputMaybe<PayrollServiceAgreementsArrRelInsertInput>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Scalars['jsonb']['input']>;
  quoteLineItems?: InputMaybe<QuoteLineItemsArrRelInsertInput>;
  requiresMonthlyCompletion?: InputMaybe<Scalars['Boolean']['input']>;
  requiresPayrollCompletion?: InputMaybe<Scalars['Boolean']['input']>;
  servicePricingRules?: InputMaybe<ServicePricingRulesArrRelInsertInput>;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType?: InputMaybe<Scalars['String']['input']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  updatedByUser?: InputMaybe<UsersObjRelInsertInput>;
};

/** aggregate max on columns */
export type ServicesMaxFields = {
  __typename?: 'ServicesMaxFields';
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: Maybe<Scalars['billing_tier_level']['output']>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  defaultRate?: Maybe<Scalars['numeric']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType?: Maybe<Scalars['String']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "services" */
export type ServicesMaxOrderBy = {
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: InputMaybe<OrderBy>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  defaultRate?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type ServicesMinFields = {
  __typename?: 'ServicesMinFields';
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: Maybe<Scalars['billing_tier_level']['output']>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  defaultRate?: Maybe<Scalars['numeric']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType?: Maybe<Scalars['String']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "services" */
export type ServicesMinOrderBy = {
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: InputMaybe<OrderBy>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  currency?: InputMaybe<OrderBy>;
  defaultRate?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "services" */
export type ServicesMutationResponse = {
  __typename?: 'ServicesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Services>;
};

/** input type for inserting object relation for remote table "services" */
export type ServicesObjRelInsertInput = {
  data: ServicesInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<ServicesOnConflict>;
};

/** on_conflict condition type for table "services" */
export type ServicesOnConflict = {
  constraint: ServicesConstraint;
  updateColumns?: Array<ServicesUpdateColumn>;
  where?: InputMaybe<ServicesBoolExp>;
};

/** Ordering options when selecting data from "services". */
export type ServicesOrderBy = {
  billingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  billingTier?: InputMaybe<OrderBy>;
  billingUnit?: InputMaybe<OrderBy>;
  category?: InputMaybe<OrderBy>;
  clientAgreementsAggregate?: InputMaybe<ClientServiceAgreementsAggregateOrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  createdByUser?: InputMaybe<UsersOrderBy>;
  currency?: InputMaybe<OrderBy>;
  defaultRate?: InputMaybe<OrderBy>;
  dependencies?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isTemplate?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  name?: InputMaybe<OrderBy>;
  payrollServiceAgreementsForServiceAggregate?: InputMaybe<PayrollServiceAgreementsAggregateOrderBy>;
  pricingRules?: InputMaybe<OrderBy>;
  quoteLineItemsAggregate?: InputMaybe<QuoteLineItemsAggregateOrderBy>;
  requiresMonthlyCompletion?: InputMaybe<OrderBy>;
  requiresPayrollCompletion?: InputMaybe<OrderBy>;
  servicePricingRulesAggregate?: InputMaybe<ServicePricingRulesAggregateOrderBy>;
  serviceType?: InputMaybe<OrderBy>;
  tierPriority?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedBy?: InputMaybe<OrderBy>;
  updatedByUser?: InputMaybe<UsersOrderBy>;
};

/** primary key columns input for table: services */
export type ServicesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ServicesPrependInput = {
  dependencies?: InputMaybe<Scalars['jsonb']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "services" */
export type ServicesSelectColumn =
  /** column name */
  | 'billingTier'
  /** column name */
  | 'billingUnit'
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'currency'
  /** column name */
  | 'defaultRate'
  /** column name */
  | 'dependencies'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isTemplate'
  /** column name */
  | 'metadata'
  /** column name */
  | 'name'
  /** column name */
  | 'pricingRules'
  /** column name */
  | 'requiresMonthlyCompletion'
  /** column name */
  | 'requiresPayrollCompletion'
  /** column name */
  | 'serviceType'
  /** column name */
  | 'tierPriority'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  | '%future added value';

/** select "servicesAggregateBoolExpBool_andArgumentsColumns" columns of table "services" */
export type ServicesSelectColumnServicesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isTemplate'
  /** column name */
  | 'requiresMonthlyCompletion'
  /** column name */
  | 'requiresPayrollCompletion'
  | '%future added value';

/** select "servicesAggregateBoolExpBool_orArgumentsColumns" columns of table "services" */
export type ServicesSelectColumnServicesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isTemplate'
  /** column name */
  | 'requiresMonthlyCompletion'
  /** column name */
  | 'requiresPayrollCompletion'
  | '%future added value';

/** input type for updating data in table "services" */
export type ServicesSetInput = {
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: InputMaybe<Scalars['billing_tier_level']['input']>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  defaultRate?: InputMaybe<Scalars['numeric']['input']>;
  dependencies?: InputMaybe<Scalars['jsonb']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Scalars['jsonb']['input']>;
  requiresMonthlyCompletion?: InputMaybe<Scalars['Boolean']['input']>;
  requiresPayrollCompletion?: InputMaybe<Scalars['Boolean']['input']>;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType?: InputMaybe<Scalars['String']['input']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type ServicesStddevFields = {
  __typename?: 'ServicesStddevFields';
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "services" */
export type ServicesStddevOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type ServicesStddevPopFields = {
  __typename?: 'ServicesStddevPopFields';
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "services" */
export type ServicesStddevPopOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type ServicesStddevSampFields = {
  __typename?: 'ServicesStddevSampFields';
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "services" */
export type ServicesStddevSampOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "services" */
export type ServicesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: ServicesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type ServicesStreamCursorValueInput = {
  /** Billing tier: payroll_date, payroll, or client_monthly */
  billingTier?: InputMaybe<Scalars['billing_tier_level']['input']>;
  /** How this service is billed: Per Payroll, Per Employee, Per Hour, etc. */
  billingUnit?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  defaultRate?: InputMaybe<Scalars['numeric']['input']>;
  dependencies?: InputMaybe<Scalars['jsonb']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** JSONB field for complex pricing logic */
  pricingRules?: InputMaybe<Scalars['jsonb']['input']>;
  requiresMonthlyCompletion?: InputMaybe<Scalars['Boolean']['input']>;
  requiresPayrollCompletion?: InputMaybe<Scalars['Boolean']['input']>;
  /** standard: regular service, template: reusable template, custom: client-specific */
  serviceType?: InputMaybe<Scalars['String']['input']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type ServicesSumFields = {
  __typename?: 'ServicesSumFields';
  defaultRate?: Maybe<Scalars['numeric']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "services" */
export type ServicesSumOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** update columns of table "services" */
export type ServicesUpdateColumn =
  /** column name */
  | 'billingTier'
  /** column name */
  | 'billingUnit'
  /** column name */
  | 'category'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'currency'
  /** column name */
  | 'defaultRate'
  /** column name */
  | 'dependencies'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isTemplate'
  /** column name */
  | 'metadata'
  /** column name */
  | 'name'
  /** column name */
  | 'pricingRules'
  /** column name */
  | 'requiresMonthlyCompletion'
  /** column name */
  | 'requiresPayrollCompletion'
  /** column name */
  | 'serviceType'
  /** column name */
  | 'tierPriority'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'updatedBy'
  | '%future added value';

export type ServicesUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<ServicesAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<ServicesDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<ServicesDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<ServicesDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ServicesIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<ServicesPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ServicesSetInput>;
  /** filter the rows which have to be updated */
  where: ServicesBoolExp;
};

/** aggregate varPop on columns */
export type ServicesVarPopFields = {
  __typename?: 'ServicesVarPopFields';
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "services" */
export type ServicesVarPopOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type ServicesVarSampFields = {
  __typename?: 'ServicesVarSampFields';
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "services" */
export type ServicesVarSampOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type ServicesVarianceFields = {
  __typename?: 'ServicesVarianceFields';
  defaultRate?: Maybe<Scalars['Float']['output']>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "services" */
export type ServicesVarianceOrderBy = {
  defaultRate?: InputMaybe<OrderBy>;
  /** Priority within tier (lower number = higher priority) */
  tierPriority?: InputMaybe<OrderBy>;
};

/** columns and relationships of "staff_billing_performance" */
export type StaffBillingPerformance = {
  __typename?: 'StaffBillingPerformance';
  averageProfitMargin?: Maybe<Scalars['numeric']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  totalActualRevenue?: Maybe<Scalars['numeric']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  totalHoursLogged?: Maybe<Scalars['numeric']['output']>;
  totalPayrolls?: Maybe<Scalars['bigint']['output']>;
};

/** aggregated selection of "staff_billing_performance" */
export type StaffBillingPerformanceAggregate = {
  __typename?: 'StaffBillingPerformanceAggregate';
  aggregate?: Maybe<StaffBillingPerformanceAggregateFields>;
  nodes: Array<StaffBillingPerformance>;
};

/** aggregate fields of "staff_billing_performance" */
export type StaffBillingPerformanceAggregateFields = {
  __typename?: 'StaffBillingPerformanceAggregateFields';
  avg?: Maybe<StaffBillingPerformanceAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<StaffBillingPerformanceMaxFields>;
  min?: Maybe<StaffBillingPerformanceMinFields>;
  stddev?: Maybe<StaffBillingPerformanceStddevFields>;
  stddevPop?: Maybe<StaffBillingPerformanceStddevPopFields>;
  stddevSamp?: Maybe<StaffBillingPerformanceStddevSampFields>;
  sum?: Maybe<StaffBillingPerformanceSumFields>;
  varPop?: Maybe<StaffBillingPerformanceVarPopFields>;
  varSamp?: Maybe<StaffBillingPerformanceVarSampFields>;
  variance?: Maybe<StaffBillingPerformanceVarianceFields>;
};


/** aggregate fields of "staff_billing_performance" */
export type StaffBillingPerformanceAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<StaffBillingPerformanceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type StaffBillingPerformanceAvgFields = {
  __typename?: 'StaffBillingPerformanceAvgFields';
  averageProfitMargin?: Maybe<Scalars['Float']['output']>;
  totalActualRevenue?: Maybe<Scalars['Float']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['Float']['output']>;
  totalHoursLogged?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "staff_billing_performance". All fields are combined with a logical 'AND'. */
export type StaffBillingPerformanceBoolExp = {
  _and?: InputMaybe<Array<StaffBillingPerformanceBoolExp>>;
  _not?: InputMaybe<StaffBillingPerformanceBoolExp>;
  _or?: InputMaybe<Array<StaffBillingPerformanceBoolExp>>;
  averageProfitMargin?: InputMaybe<NumericComparisonExp>;
  staffName?: InputMaybe<StringComparisonExp>;
  staffUserId?: InputMaybe<UuidComparisonExp>;
  totalActualRevenue?: InputMaybe<NumericComparisonExp>;
  totalEstimatedRevenue?: InputMaybe<NumericComparisonExp>;
  totalHoursLogged?: InputMaybe<NumericComparisonExp>;
  totalPayrolls?: InputMaybe<BigintComparisonExp>;
};

/** aggregate max on columns */
export type StaffBillingPerformanceMaxFields = {
  __typename?: 'StaffBillingPerformanceMaxFields';
  averageProfitMargin?: Maybe<Scalars['numeric']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  totalActualRevenue?: Maybe<Scalars['numeric']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  totalHoursLogged?: Maybe<Scalars['numeric']['output']>;
  totalPayrolls?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate min on columns */
export type StaffBillingPerformanceMinFields = {
  __typename?: 'StaffBillingPerformanceMinFields';
  averageProfitMargin?: Maybe<Scalars['numeric']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  totalActualRevenue?: Maybe<Scalars['numeric']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  totalHoursLogged?: Maybe<Scalars['numeric']['output']>;
  totalPayrolls?: Maybe<Scalars['bigint']['output']>;
};

/** Ordering options when selecting data from "staff_billing_performance". */
export type StaffBillingPerformanceOrderBy = {
  averageProfitMargin?: InputMaybe<OrderBy>;
  staffName?: InputMaybe<OrderBy>;
  staffUserId?: InputMaybe<OrderBy>;
  totalActualRevenue?: InputMaybe<OrderBy>;
  totalEstimatedRevenue?: InputMaybe<OrderBy>;
  totalHoursLogged?: InputMaybe<OrderBy>;
  totalPayrolls?: InputMaybe<OrderBy>;
};

/** select columns of table "staff_billing_performance" */
export type StaffBillingPerformanceSelectColumn =
  /** column name */
  | 'averageProfitMargin'
  /** column name */
  | 'staffName'
  /** column name */
  | 'staffUserId'
  /** column name */
  | 'totalActualRevenue'
  /** column name */
  | 'totalEstimatedRevenue'
  /** column name */
  | 'totalHoursLogged'
  /** column name */
  | 'totalPayrolls'
  | '%future added value';

/** aggregate stddev on columns */
export type StaffBillingPerformanceStddevFields = {
  __typename?: 'StaffBillingPerformanceStddevFields';
  averageProfitMargin?: Maybe<Scalars['Float']['output']>;
  totalActualRevenue?: Maybe<Scalars['Float']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['Float']['output']>;
  totalHoursLogged?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type StaffBillingPerformanceStddevPopFields = {
  __typename?: 'StaffBillingPerformanceStddevPopFields';
  averageProfitMargin?: Maybe<Scalars['Float']['output']>;
  totalActualRevenue?: Maybe<Scalars['Float']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['Float']['output']>;
  totalHoursLogged?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type StaffBillingPerformanceStddevSampFields = {
  __typename?: 'StaffBillingPerformanceStddevSampFields';
  averageProfitMargin?: Maybe<Scalars['Float']['output']>;
  totalActualRevenue?: Maybe<Scalars['Float']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['Float']['output']>;
  totalHoursLogged?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "staff_billing_performance" */
export type StaffBillingPerformanceStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: StaffBillingPerformanceStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type StaffBillingPerformanceStreamCursorValueInput = {
  averageProfitMargin?: InputMaybe<Scalars['numeric']['input']>;
  staffName?: InputMaybe<Scalars['String']['input']>;
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  totalActualRevenue?: InputMaybe<Scalars['numeric']['input']>;
  totalEstimatedRevenue?: InputMaybe<Scalars['numeric']['input']>;
  totalHoursLogged?: InputMaybe<Scalars['numeric']['input']>;
  totalPayrolls?: InputMaybe<Scalars['bigint']['input']>;
};

/** aggregate sum on columns */
export type StaffBillingPerformanceSumFields = {
  __typename?: 'StaffBillingPerformanceSumFields';
  averageProfitMargin?: Maybe<Scalars['numeric']['output']>;
  totalActualRevenue?: Maybe<Scalars['numeric']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['numeric']['output']>;
  totalHoursLogged?: Maybe<Scalars['numeric']['output']>;
  totalPayrolls?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate varPop on columns */
export type StaffBillingPerformanceVarPopFields = {
  __typename?: 'StaffBillingPerformanceVarPopFields';
  averageProfitMargin?: Maybe<Scalars['Float']['output']>;
  totalActualRevenue?: Maybe<Scalars['Float']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['Float']['output']>;
  totalHoursLogged?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type StaffBillingPerformanceVarSampFields = {
  __typename?: 'StaffBillingPerformanceVarSampFields';
  averageProfitMargin?: Maybe<Scalars['Float']['output']>;
  totalActualRevenue?: Maybe<Scalars['Float']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['Float']['output']>;
  totalHoursLogged?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type StaffBillingPerformanceVarianceFields = {
  __typename?: 'StaffBillingPerformanceVarianceFields';
  averageProfitMargin?: Maybe<Scalars['Float']['output']>;
  totalActualRevenue?: Maybe<Scalars['Float']['output']>;
  totalEstimatedRevenue?: Maybe<Scalars['Float']['output']>;
  totalHoursLogged?: Maybe<Scalars['Float']['output']>;
  totalPayrolls?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringArrayComparisonExp = {
  /** is the array contained in the given array value */
  _containedIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the array contain the given value */
  _contains?: InputMaybe<Array<Scalars['String']['input']>>;
  _eq?: InputMaybe<Array<Scalars['String']['input']>>;
  _gt?: InputMaybe<Array<Scalars['String']['input']>>;
  _gte?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Array<Scalars['String']['input']>>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Array<Scalars['String']['input']>>;
  _lte?: InputMaybe<Array<Scalars['String']['input']>>;
  _neq?: InputMaybe<Array<Scalars['String']['input']>>;
  _nin?: InputMaybe<Array<Array<Scalars['String']['input']>>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type StringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "system_configuration" */
export type SystemConfiguration = {
  __typename?: 'SystemConfiguration';
  configKey: Scalars['String']['output'];
  configType: Scalars['String']['output'];
  configValue: Scalars['jsonb']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  isActive: Scalars['Boolean']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "system_configuration" */
export type SystemConfigurationConfigValueArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "system_configuration" */
export type SystemConfigurationAggregate = {
  __typename?: 'SystemConfigurationAggregate';
  aggregate?: Maybe<SystemConfigurationAggregateFields>;
  nodes: Array<SystemConfiguration>;
};

/** aggregate fields of "system_configuration" */
export type SystemConfigurationAggregateFields = {
  __typename?: 'SystemConfigurationAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<SystemConfigurationMaxFields>;
  min?: Maybe<SystemConfigurationMinFields>;
};


/** aggregate fields of "system_configuration" */
export type SystemConfigurationAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SystemConfigurationSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SystemConfigurationAppendInput = {
  configValue?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "system_configuration". All fields are combined with a logical 'AND'. */
export type SystemConfigurationBoolExp = {
  _and?: InputMaybe<Array<SystemConfigurationBoolExp>>;
  _not?: InputMaybe<SystemConfigurationBoolExp>;
  _or?: InputMaybe<Array<SystemConfigurationBoolExp>>;
  configKey?: InputMaybe<StringComparisonExp>;
  configType?: InputMaybe<StringComparisonExp>;
  configValue?: InputMaybe<JsonbComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "system_configuration" */
export type SystemConfigurationConstraint =
  /** unique or primary key constraint on columns "config_key" */
  | 'system_configuration_config_key_key'
  /** unique or primary key constraint on columns "id" */
  | 'system_configuration_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SystemConfigurationDeleteAtPathInput = {
  configValue?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SystemConfigurationDeleteElemInput = {
  configValue?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SystemConfigurationDeleteKeyInput = {
  configValue?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "system_configuration" */
export type SystemConfigurationInsertInput = {
  configKey?: InputMaybe<Scalars['String']['input']>;
  configType?: InputMaybe<Scalars['String']['input']>;
  configValue?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type SystemConfigurationMaxFields = {
  __typename?: 'SystemConfigurationMaxFields';
  configKey?: Maybe<Scalars['String']['output']>;
  configType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type SystemConfigurationMinFields = {
  __typename?: 'SystemConfigurationMinFields';
  configKey?: Maybe<Scalars['String']['output']>;
  configType?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "system_configuration" */
export type SystemConfigurationMutationResponse = {
  __typename?: 'SystemConfigurationMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SystemConfiguration>;
};

/** on_conflict condition type for table "system_configuration" */
export type SystemConfigurationOnConflict = {
  constraint: SystemConfigurationConstraint;
  updateColumns?: Array<SystemConfigurationUpdateColumn>;
  where?: InputMaybe<SystemConfigurationBoolExp>;
};

/** Ordering options when selecting data from "system_configuration". */
export type SystemConfigurationOrderBy = {
  configKey?: InputMaybe<OrderBy>;
  configType?: InputMaybe<OrderBy>;
  configValue?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: system_configuration */
export type SystemConfigurationPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SystemConfigurationPrependInput = {
  configValue?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "system_configuration" */
export type SystemConfigurationSelectColumn =
  /** column name */
  | 'configKey'
  /** column name */
  | 'configType'
  /** column name */
  | 'configValue'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "system_configuration" */
export type SystemConfigurationSetInput = {
  configKey?: InputMaybe<Scalars['String']['input']>;
  configType?: InputMaybe<Scalars['String']['input']>;
  configValue?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "system_configuration" */
export type SystemConfigurationStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SystemConfigurationStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SystemConfigurationStreamCursorValueInput = {
  configKey?: InputMaybe<Scalars['String']['input']>;
  configType?: InputMaybe<Scalars['String']['input']>;
  configValue?: InputMaybe<Scalars['jsonb']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "system_configuration" */
export type SystemConfigurationUpdateColumn =
  /** column name */
  | 'configKey'
  /** column name */
  | 'configType'
  /** column name */
  | 'configValue'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'id'
  /** column name */
  | 'isActive'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type SystemConfigurationUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SystemConfigurationAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<SystemConfigurationDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<SystemConfigurationDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<SystemConfigurationDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SystemConfigurationPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SystemConfigurationSetInput>;
  /** filter the rows which have to be updated */
  where: SystemConfigurationBoolExp;
};

/** columns and relationships of "system_health" */
export type SystemHealth = {
  __typename?: 'SystemHealth';
  activeUsers?: Maybe<Scalars['Int']['output']>;
  alerts?: Maybe<Scalars['jsonb']['output']>;
  apiResponseTime?: Maybe<Scalars['Int']['output']>;
  cpuUsage?: Maybe<Scalars['numeric']['output']>;
  databaseResponseTime?: Maybe<Scalars['Int']['output']>;
  diskUsage?: Maybe<Scalars['numeric']['output']>;
  errorRate?: Maybe<Scalars['numeric']['output']>;
  id: Scalars['uuid']['output'];
  memoryUsage?: Maybe<Scalars['numeric']['output']>;
  metadata?: Maybe<Scalars['jsonb']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "system_health" */
export type SystemHealthAlertsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "system_health" */
export type SystemHealthMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "system_health" */
export type SystemHealthAggregate = {
  __typename?: 'SystemHealthAggregate';
  aggregate?: Maybe<SystemHealthAggregateFields>;
  nodes: Array<SystemHealth>;
};

/** aggregate fields of "system_health" */
export type SystemHealthAggregateFields = {
  __typename?: 'SystemHealthAggregateFields';
  avg?: Maybe<SystemHealthAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<SystemHealthMaxFields>;
  min?: Maybe<SystemHealthMinFields>;
  stddev?: Maybe<SystemHealthStddevFields>;
  stddevPop?: Maybe<SystemHealthStddevPopFields>;
  stddevSamp?: Maybe<SystemHealthStddevSampFields>;
  sum?: Maybe<SystemHealthSumFields>;
  varPop?: Maybe<SystemHealthVarPopFields>;
  varSamp?: Maybe<SystemHealthVarSampFields>;
  variance?: Maybe<SystemHealthVarianceFields>;
};


/** aggregate fields of "system_health" */
export type SystemHealthAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<SystemHealthSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type SystemHealthAppendInput = {
  alerts?: InputMaybe<Scalars['jsonb']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type SystemHealthAvgFields = {
  __typename?: 'SystemHealthAvgFields';
  activeUsers?: Maybe<Scalars['Float']['output']>;
  apiResponseTime?: Maybe<Scalars['Float']['output']>;
  cpuUsage?: Maybe<Scalars['Float']['output']>;
  databaseResponseTime?: Maybe<Scalars['Float']['output']>;
  diskUsage?: Maybe<Scalars['Float']['output']>;
  errorRate?: Maybe<Scalars['Float']['output']>;
  memoryUsage?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "system_health". All fields are combined with a logical 'AND'. */
export type SystemHealthBoolExp = {
  _and?: InputMaybe<Array<SystemHealthBoolExp>>;
  _not?: InputMaybe<SystemHealthBoolExp>;
  _or?: InputMaybe<Array<SystemHealthBoolExp>>;
  activeUsers?: InputMaybe<IntComparisonExp>;
  alerts?: InputMaybe<JsonbComparisonExp>;
  apiResponseTime?: InputMaybe<IntComparisonExp>;
  cpuUsage?: InputMaybe<NumericComparisonExp>;
  databaseResponseTime?: InputMaybe<IntComparisonExp>;
  diskUsage?: InputMaybe<NumericComparisonExp>;
  errorRate?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  memoryUsage?: InputMaybe<NumericComparisonExp>;
  metadata?: InputMaybe<JsonbComparisonExp>;
  status?: InputMaybe<StringComparisonExp>;
  timestamp?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "system_health" */
export type SystemHealthConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'system_health_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type SystemHealthDeleteAtPathInput = {
  alerts?: InputMaybe<Array<Scalars['String']['input']>>;
  metadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type SystemHealthDeleteElemInput = {
  alerts?: InputMaybe<Scalars['Int']['input']>;
  metadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type SystemHealthDeleteKeyInput = {
  alerts?: InputMaybe<Scalars['String']['input']>;
  metadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "system_health" */
export type SystemHealthIncInput = {
  activeUsers?: InputMaybe<Scalars['Int']['input']>;
  apiResponseTime?: InputMaybe<Scalars['Int']['input']>;
  cpuUsage?: InputMaybe<Scalars['numeric']['input']>;
  databaseResponseTime?: InputMaybe<Scalars['Int']['input']>;
  diskUsage?: InputMaybe<Scalars['numeric']['input']>;
  errorRate?: InputMaybe<Scalars['numeric']['input']>;
  memoryUsage?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "system_health" */
export type SystemHealthInsertInput = {
  activeUsers?: InputMaybe<Scalars['Int']['input']>;
  alerts?: InputMaybe<Scalars['jsonb']['input']>;
  apiResponseTime?: InputMaybe<Scalars['Int']['input']>;
  cpuUsage?: InputMaybe<Scalars['numeric']['input']>;
  databaseResponseTime?: InputMaybe<Scalars['Int']['input']>;
  diskUsage?: InputMaybe<Scalars['numeric']['input']>;
  errorRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  memoryUsage?: InputMaybe<Scalars['numeric']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type SystemHealthMaxFields = {
  __typename?: 'SystemHealthMaxFields';
  activeUsers?: Maybe<Scalars['Int']['output']>;
  apiResponseTime?: Maybe<Scalars['Int']['output']>;
  cpuUsage?: Maybe<Scalars['numeric']['output']>;
  databaseResponseTime?: Maybe<Scalars['Int']['output']>;
  diskUsage?: Maybe<Scalars['numeric']['output']>;
  errorRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  memoryUsage?: Maybe<Scalars['numeric']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type SystemHealthMinFields = {
  __typename?: 'SystemHealthMinFields';
  activeUsers?: Maybe<Scalars['Int']['output']>;
  apiResponseTime?: Maybe<Scalars['Int']['output']>;
  cpuUsage?: Maybe<Scalars['numeric']['output']>;
  databaseResponseTime?: Maybe<Scalars['Int']['output']>;
  diskUsage?: Maybe<Scalars['numeric']['output']>;
  errorRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  memoryUsage?: Maybe<Scalars['numeric']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "system_health" */
export type SystemHealthMutationResponse = {
  __typename?: 'SystemHealthMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SystemHealth>;
};

/** on_conflict condition type for table "system_health" */
export type SystemHealthOnConflict = {
  constraint: SystemHealthConstraint;
  updateColumns?: Array<SystemHealthUpdateColumn>;
  where?: InputMaybe<SystemHealthBoolExp>;
};

/** Ordering options when selecting data from "system_health". */
export type SystemHealthOrderBy = {
  activeUsers?: InputMaybe<OrderBy>;
  alerts?: InputMaybe<OrderBy>;
  apiResponseTime?: InputMaybe<OrderBy>;
  cpuUsage?: InputMaybe<OrderBy>;
  databaseResponseTime?: InputMaybe<OrderBy>;
  diskUsage?: InputMaybe<OrderBy>;
  errorRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  memoryUsage?: InputMaybe<OrderBy>;
  metadata?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  timestamp?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: system_health */
export type SystemHealthPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type SystemHealthPrependInput = {
  alerts?: InputMaybe<Scalars['jsonb']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "system_health" */
export type SystemHealthSelectColumn =
  /** column name */
  | 'activeUsers'
  /** column name */
  | 'alerts'
  /** column name */
  | 'apiResponseTime'
  /** column name */
  | 'cpuUsage'
  /** column name */
  | 'databaseResponseTime'
  /** column name */
  | 'diskUsage'
  /** column name */
  | 'errorRate'
  /** column name */
  | 'id'
  /** column name */
  | 'memoryUsage'
  /** column name */
  | 'metadata'
  /** column name */
  | 'status'
  /** column name */
  | 'timestamp'
  | '%future added value';

/** input type for updating data in table "system_health" */
export type SystemHealthSetInput = {
  activeUsers?: InputMaybe<Scalars['Int']['input']>;
  alerts?: InputMaybe<Scalars['jsonb']['input']>;
  apiResponseTime?: InputMaybe<Scalars['Int']['input']>;
  cpuUsage?: InputMaybe<Scalars['numeric']['input']>;
  databaseResponseTime?: InputMaybe<Scalars['Int']['input']>;
  diskUsage?: InputMaybe<Scalars['numeric']['input']>;
  errorRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  memoryUsage?: InputMaybe<Scalars['numeric']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type SystemHealthStddevFields = {
  __typename?: 'SystemHealthStddevFields';
  activeUsers?: Maybe<Scalars['Float']['output']>;
  apiResponseTime?: Maybe<Scalars['Float']['output']>;
  cpuUsage?: Maybe<Scalars['Float']['output']>;
  databaseResponseTime?: Maybe<Scalars['Float']['output']>;
  diskUsage?: Maybe<Scalars['Float']['output']>;
  errorRate?: Maybe<Scalars['Float']['output']>;
  memoryUsage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type SystemHealthStddevPopFields = {
  __typename?: 'SystemHealthStddevPopFields';
  activeUsers?: Maybe<Scalars['Float']['output']>;
  apiResponseTime?: Maybe<Scalars['Float']['output']>;
  cpuUsage?: Maybe<Scalars['Float']['output']>;
  databaseResponseTime?: Maybe<Scalars['Float']['output']>;
  diskUsage?: Maybe<Scalars['Float']['output']>;
  errorRate?: Maybe<Scalars['Float']['output']>;
  memoryUsage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type SystemHealthStddevSampFields = {
  __typename?: 'SystemHealthStddevSampFields';
  activeUsers?: Maybe<Scalars['Float']['output']>;
  apiResponseTime?: Maybe<Scalars['Float']['output']>;
  cpuUsage?: Maybe<Scalars['Float']['output']>;
  databaseResponseTime?: Maybe<Scalars['Float']['output']>;
  diskUsage?: Maybe<Scalars['Float']['output']>;
  errorRate?: Maybe<Scalars['Float']['output']>;
  memoryUsage?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "system_health" */
export type SystemHealthStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: SystemHealthStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type SystemHealthStreamCursorValueInput = {
  activeUsers?: InputMaybe<Scalars['Int']['input']>;
  alerts?: InputMaybe<Scalars['jsonb']['input']>;
  apiResponseTime?: InputMaybe<Scalars['Int']['input']>;
  cpuUsage?: InputMaybe<Scalars['numeric']['input']>;
  databaseResponseTime?: InputMaybe<Scalars['Int']['input']>;
  diskUsage?: InputMaybe<Scalars['numeric']['input']>;
  errorRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  memoryUsage?: InputMaybe<Scalars['numeric']['input']>;
  metadata?: InputMaybe<Scalars['jsonb']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type SystemHealthSumFields = {
  __typename?: 'SystemHealthSumFields';
  activeUsers?: Maybe<Scalars['Int']['output']>;
  apiResponseTime?: Maybe<Scalars['Int']['output']>;
  cpuUsage?: Maybe<Scalars['numeric']['output']>;
  databaseResponseTime?: Maybe<Scalars['Int']['output']>;
  diskUsage?: Maybe<Scalars['numeric']['output']>;
  errorRate?: Maybe<Scalars['numeric']['output']>;
  memoryUsage?: Maybe<Scalars['numeric']['output']>;
};

/** update columns of table "system_health" */
export type SystemHealthUpdateColumn =
  /** column name */
  | 'activeUsers'
  /** column name */
  | 'alerts'
  /** column name */
  | 'apiResponseTime'
  /** column name */
  | 'cpuUsage'
  /** column name */
  | 'databaseResponseTime'
  /** column name */
  | 'diskUsage'
  /** column name */
  | 'errorRate'
  /** column name */
  | 'id'
  /** column name */
  | 'memoryUsage'
  /** column name */
  | 'metadata'
  /** column name */
  | 'status'
  /** column name */
  | 'timestamp'
  | '%future added value';

export type SystemHealthUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<SystemHealthAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<SystemHealthDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<SystemHealthDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<SystemHealthDeleteKeyInput>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<SystemHealthIncInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<SystemHealthPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SystemHealthSetInput>;
  /** filter the rows which have to be updated */
  where: SystemHealthBoolExp;
};

/** aggregate varPop on columns */
export type SystemHealthVarPopFields = {
  __typename?: 'SystemHealthVarPopFields';
  activeUsers?: Maybe<Scalars['Float']['output']>;
  apiResponseTime?: Maybe<Scalars['Float']['output']>;
  cpuUsage?: Maybe<Scalars['Float']['output']>;
  databaseResponseTime?: Maybe<Scalars['Float']['output']>;
  diskUsage?: Maybe<Scalars['Float']['output']>;
  errorRate?: Maybe<Scalars['Float']['output']>;
  memoryUsage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type SystemHealthVarSampFields = {
  __typename?: 'SystemHealthVarSampFields';
  activeUsers?: Maybe<Scalars['Float']['output']>;
  apiResponseTime?: Maybe<Scalars['Float']['output']>;
  cpuUsage?: Maybe<Scalars['Float']['output']>;
  databaseResponseTime?: Maybe<Scalars['Float']['output']>;
  diskUsage?: Maybe<Scalars['Float']['output']>;
  errorRate?: Maybe<Scalars['Float']['output']>;
  memoryUsage?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type SystemHealthVarianceFields = {
  __typename?: 'SystemHealthVarianceFields';
  activeUsers?: Maybe<Scalars['Float']['output']>;
  apiResponseTime?: Maybe<Scalars['Float']['output']>;
  cpuUsage?: Maybe<Scalars['Float']['output']>;
  databaseResponseTime?: Maybe<Scalars['Float']['output']>;
  diskUsage?: Maybe<Scalars['Float']['output']>;
  errorRate?: Maybe<Scalars['Float']['output']>;
  memoryUsage?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "team_capacity_by_position" */
export type TeamCapacityByPosition = {
  __typename?: 'TeamCapacityByPosition';
  avgAdminPercentage?: Maybe<Scalars['numeric']['output']>;
  consultantCount?: Maybe<Scalars['bigint']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  totalAdminHours?: Maybe<Scalars['numeric']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['numeric']['output']>;
  totalWorkHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregated selection of "team_capacity_by_position" */
export type TeamCapacityByPositionAggregate = {
  __typename?: 'TeamCapacityByPositionAggregate';
  aggregate?: Maybe<TeamCapacityByPositionAggregateFields>;
  nodes: Array<TeamCapacityByPosition>;
};

/** aggregate fields of "team_capacity_by_position" */
export type TeamCapacityByPositionAggregateFields = {
  __typename?: 'TeamCapacityByPositionAggregateFields';
  avg?: Maybe<TeamCapacityByPositionAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TeamCapacityByPositionMaxFields>;
  min?: Maybe<TeamCapacityByPositionMinFields>;
  stddev?: Maybe<TeamCapacityByPositionStddevFields>;
  stddevPop?: Maybe<TeamCapacityByPositionStddevPopFields>;
  stddevSamp?: Maybe<TeamCapacityByPositionStddevSampFields>;
  sum?: Maybe<TeamCapacityByPositionSumFields>;
  varPop?: Maybe<TeamCapacityByPositionVarPopFields>;
  varSamp?: Maybe<TeamCapacityByPositionVarSampFields>;
  variance?: Maybe<TeamCapacityByPositionVarianceFields>;
};


/** aggregate fields of "team_capacity_by_position" */
export type TeamCapacityByPositionAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TeamCapacityByPositionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type TeamCapacityByPositionAvgFields = {
  __typename?: 'TeamCapacityByPositionAvgFields';
  avgAdminPercentage?: Maybe<Scalars['Float']['output']>;
  consultantCount?: Maybe<Scalars['Float']['output']>;
  totalAdminHours?: Maybe<Scalars['Float']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['Float']['output']>;
  totalWorkHours?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "team_capacity_by_position". All fields are combined with a logical 'AND'. */
export type TeamCapacityByPositionBoolExp = {
  _and?: InputMaybe<Array<TeamCapacityByPositionBoolExp>>;
  _not?: InputMaybe<TeamCapacityByPositionBoolExp>;
  _or?: InputMaybe<Array<TeamCapacityByPositionBoolExp>>;
  avgAdminPercentage?: InputMaybe<NumericComparisonExp>;
  consultantCount?: InputMaybe<BigintComparisonExp>;
  position?: InputMaybe<UserPositionComparisonExp>;
  totalAdminHours?: InputMaybe<NumericComparisonExp>;
  totalPayrollCapacity?: InputMaybe<NumericComparisonExp>;
  totalWorkHours?: InputMaybe<NumericComparisonExp>;
};

/** aggregate max on columns */
export type TeamCapacityByPositionMaxFields = {
  __typename?: 'TeamCapacityByPositionMaxFields';
  avgAdminPercentage?: Maybe<Scalars['numeric']['output']>;
  consultantCount?: Maybe<Scalars['bigint']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  totalAdminHours?: Maybe<Scalars['numeric']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['numeric']['output']>;
  totalWorkHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate min on columns */
export type TeamCapacityByPositionMinFields = {
  __typename?: 'TeamCapacityByPositionMinFields';
  avgAdminPercentage?: Maybe<Scalars['numeric']['output']>;
  consultantCount?: Maybe<Scalars['bigint']['output']>;
  position?: Maybe<Scalars['user_position']['output']>;
  totalAdminHours?: Maybe<Scalars['numeric']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['numeric']['output']>;
  totalWorkHours?: Maybe<Scalars['numeric']['output']>;
};

/** Ordering options when selecting data from "team_capacity_by_position". */
export type TeamCapacityByPositionOrderBy = {
  avgAdminPercentage?: InputMaybe<OrderBy>;
  consultantCount?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  totalAdminHours?: InputMaybe<OrderBy>;
  totalPayrollCapacity?: InputMaybe<OrderBy>;
  totalWorkHours?: InputMaybe<OrderBy>;
};

/** select columns of table "team_capacity_by_position" */
export type TeamCapacityByPositionSelectColumn =
  /** column name */
  | 'avgAdminPercentage'
  /** column name */
  | 'consultantCount'
  /** column name */
  | 'position'
  /** column name */
  | 'totalAdminHours'
  /** column name */
  | 'totalPayrollCapacity'
  /** column name */
  | 'totalWorkHours'
  | '%future added value';

/** aggregate stddev on columns */
export type TeamCapacityByPositionStddevFields = {
  __typename?: 'TeamCapacityByPositionStddevFields';
  avgAdminPercentage?: Maybe<Scalars['Float']['output']>;
  consultantCount?: Maybe<Scalars['Float']['output']>;
  totalAdminHours?: Maybe<Scalars['Float']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['Float']['output']>;
  totalWorkHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type TeamCapacityByPositionStddevPopFields = {
  __typename?: 'TeamCapacityByPositionStddevPopFields';
  avgAdminPercentage?: Maybe<Scalars['Float']['output']>;
  consultantCount?: Maybe<Scalars['Float']['output']>;
  totalAdminHours?: Maybe<Scalars['Float']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['Float']['output']>;
  totalWorkHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type TeamCapacityByPositionStddevSampFields = {
  __typename?: 'TeamCapacityByPositionStddevSampFields';
  avgAdminPercentage?: Maybe<Scalars['Float']['output']>;
  consultantCount?: Maybe<Scalars['Float']['output']>;
  totalAdminHours?: Maybe<Scalars['Float']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['Float']['output']>;
  totalWorkHours?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "team_capacity_by_position" */
export type TeamCapacityByPositionStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TeamCapacityByPositionStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TeamCapacityByPositionStreamCursorValueInput = {
  avgAdminPercentage?: InputMaybe<Scalars['numeric']['input']>;
  consultantCount?: InputMaybe<Scalars['bigint']['input']>;
  position?: InputMaybe<Scalars['user_position']['input']>;
  totalAdminHours?: InputMaybe<Scalars['numeric']['input']>;
  totalPayrollCapacity?: InputMaybe<Scalars['numeric']['input']>;
  totalWorkHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type TeamCapacityByPositionSumFields = {
  __typename?: 'TeamCapacityByPositionSumFields';
  avgAdminPercentage?: Maybe<Scalars['numeric']['output']>;
  consultantCount?: Maybe<Scalars['bigint']['output']>;
  totalAdminHours?: Maybe<Scalars['numeric']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['numeric']['output']>;
  totalWorkHours?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type TeamCapacityByPositionVarPopFields = {
  __typename?: 'TeamCapacityByPositionVarPopFields';
  avgAdminPercentage?: Maybe<Scalars['Float']['output']>;
  consultantCount?: Maybe<Scalars['Float']['output']>;
  totalAdminHours?: Maybe<Scalars['Float']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['Float']['output']>;
  totalWorkHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type TeamCapacityByPositionVarSampFields = {
  __typename?: 'TeamCapacityByPositionVarSampFields';
  avgAdminPercentage?: Maybe<Scalars['Float']['output']>;
  consultantCount?: Maybe<Scalars['Float']['output']>;
  totalAdminHours?: Maybe<Scalars['Float']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['Float']['output']>;
  totalWorkHours?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type TeamCapacityByPositionVarianceFields = {
  __typename?: 'TeamCapacityByPositionVarianceFields';
  avgAdminPercentage?: Maybe<Scalars['Float']['output']>;
  consultantCount?: Maybe<Scalars['Float']['output']>;
  totalAdminHours?: Maybe<Scalars['Float']['output']>;
  totalPayrollCapacity?: Maybe<Scalars['Float']['output']>;
  totalWorkHours?: Maybe<Scalars['Float']['output']>;
};

/** Time tracking for profitability analysis */
export type TimeEntries = {
  __typename?: 'TimeEntries';
  /** An object relationship */
  billingItem?: Maybe<BillingItems>;
  /** Billing item this time relates to */
  billingItemId?: Maybe<Scalars['uuid']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  billingRate?: Maybe<Scalars['numeric']['output']>;
  /** An object relationship */
  client: Clients;
  /** Client this work was for */
  clientId: Scalars['uuid']['output'];
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of work performed */
  description?: Maybe<Scalars['String']['output']>;
  /** Hours spent on this work */
  hoursSpent: Scalars['numeric']['output'];
  id: Scalars['uuid']['output'];
  isBillable?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  payroll?: Maybe<Payrolls>;
  /** An object relationship */
  payrollDate?: Maybe<PayrollDates>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  /** Specific payroll job this relates to */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  staffUser: Users;
  /** Staff member who worked on this */
  staffUserId: Scalars['uuid']['output'];
  timeUnits?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Date the work was performed */
  workDate: Scalars['date']['output'];
};

/** aggregated selection of "time_entries" */
export type TimeEntriesAggregate = {
  __typename?: 'TimeEntriesAggregate';
  aggregate?: Maybe<TimeEntriesAggregateFields>;
  nodes: Array<TimeEntries>;
};

export type TimeEntriesAggregateBoolExp = {
  bool_and?: InputMaybe<TimeEntriesAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<TimeEntriesAggregateBoolExpBool_Or>;
  count?: InputMaybe<TimeEntriesAggregateBoolExpCount>;
};

/** aggregate fields of "time_entries" */
export type TimeEntriesAggregateFields = {
  __typename?: 'TimeEntriesAggregateFields';
  avg?: Maybe<TimeEntriesAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TimeEntriesMaxFields>;
  min?: Maybe<TimeEntriesMinFields>;
  stddev?: Maybe<TimeEntriesStddevFields>;
  stddevPop?: Maybe<TimeEntriesStddevPopFields>;
  stddevSamp?: Maybe<TimeEntriesStddevSampFields>;
  sum?: Maybe<TimeEntriesSumFields>;
  varPop?: Maybe<TimeEntriesVarPopFields>;
  varSamp?: Maybe<TimeEntriesVarSampFields>;
  variance?: Maybe<TimeEntriesVarianceFields>;
};


/** aggregate fields of "time_entries" */
export type TimeEntriesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "time_entries" */
export type TimeEntriesAggregateOrderBy = {
  avg?: InputMaybe<TimeEntriesAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<TimeEntriesMaxOrderBy>;
  min?: InputMaybe<TimeEntriesMinOrderBy>;
  stddev?: InputMaybe<TimeEntriesStddevOrderBy>;
  stddevPop?: InputMaybe<TimeEntriesStddevPopOrderBy>;
  stddevSamp?: InputMaybe<TimeEntriesStddevSampOrderBy>;
  sum?: InputMaybe<TimeEntriesSumOrderBy>;
  varPop?: InputMaybe<TimeEntriesVarPopOrderBy>;
  varSamp?: InputMaybe<TimeEntriesVarSampOrderBy>;
  variance?: InputMaybe<TimeEntriesVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "time_entries" */
export type TimeEntriesArrRelInsertInput = {
  data: Array<TimeEntriesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<TimeEntriesOnConflict>;
};

/** aggregate avg on columns */
export type TimeEntriesAvgFields = {
  __typename?: 'TimeEntriesAvgFields';
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "time_entries" */
export type TimeEntriesAvgOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "time_entries". All fields are combined with a logical 'AND'. */
export type TimeEntriesBoolExp = {
  _and?: InputMaybe<Array<TimeEntriesBoolExp>>;
  _not?: InputMaybe<TimeEntriesBoolExp>;
  _or?: InputMaybe<Array<TimeEntriesBoolExp>>;
  billingItem?: InputMaybe<BillingItemsBoolExp>;
  billingItemId?: InputMaybe<UuidComparisonExp>;
  billingNotes?: InputMaybe<StringComparisonExp>;
  billingRate?: InputMaybe<NumericComparisonExp>;
  client?: InputMaybe<ClientsBoolExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  hoursSpent?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBillable?: InputMaybe<BooleanComparisonExp>;
  payroll?: InputMaybe<PayrollsBoolExp>;
  payrollDate?: InputMaybe<PayrollDatesBoolExp>;
  payrollDateId?: InputMaybe<UuidComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  staffUser?: InputMaybe<UsersBoolExp>;
  staffUserId?: InputMaybe<UuidComparisonExp>;
  timeUnits?: InputMaybe<IntComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  workDate?: InputMaybe<DateComparisonExp>;
};

/** unique or primary key constraints on table "time_entries" */
export type TimeEntriesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'time_entries_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "time_entries" */
export type TimeEntriesIncInput = {
  billingRate?: InputMaybe<Scalars['numeric']['input']>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<Scalars['numeric']['input']>;
  timeUnits?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "time_entries" */
export type TimeEntriesInsertInput = {
  billingItem?: InputMaybe<BillingItemsObjRelInsertInput>;
  /** Billing item this time relates to */
  billingItemId?: InputMaybe<Scalars['uuid']['input']>;
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  billingRate?: InputMaybe<Scalars['numeric']['input']>;
  client?: InputMaybe<ClientsObjRelInsertInput>;
  /** Client this work was for */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of work performed */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isBillable?: InputMaybe<Scalars['Boolean']['input']>;
  payroll?: InputMaybe<PayrollsObjRelInsertInput>;
  payrollDate?: InputMaybe<PayrollDatesObjRelInsertInput>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  /** Specific payroll job this relates to */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  staffUser?: InputMaybe<UsersObjRelInsertInput>;
  /** Staff member who worked on this */
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  timeUnits?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date the work was performed */
  workDate?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate max on columns */
export type TimeEntriesMaxFields = {
  __typename?: 'TimeEntriesMaxFields';
  /** Billing item this time relates to */
  billingItemId?: Maybe<Scalars['uuid']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  billingRate?: Maybe<Scalars['numeric']['output']>;
  /** Client this work was for */
  clientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of work performed */
  description?: Maybe<Scalars['String']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  /** Specific payroll job this relates to */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  /** Staff member who worked on this */
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  timeUnits?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Date the work was performed */
  workDate?: Maybe<Scalars['date']['output']>;
};

/** order by max() on columns of table "time_entries" */
export type TimeEntriesMaxOrderBy = {
  /** Billing item this time relates to */
  billingItemId?: InputMaybe<OrderBy>;
  billingNotes?: InputMaybe<OrderBy>;
  billingRate?: InputMaybe<OrderBy>;
  /** Client this work was for */
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Description of work performed */
  description?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: InputMaybe<OrderBy>;
  /** Specific payroll job this relates to */
  payrollId?: InputMaybe<OrderBy>;
  /** Staff member who worked on this */
  staffUserId?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** Date the work was performed */
  workDate?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type TimeEntriesMinFields = {
  __typename?: 'TimeEntriesMinFields';
  /** Billing item this time relates to */
  billingItemId?: Maybe<Scalars['uuid']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  billingRate?: Maybe<Scalars['numeric']['output']>;
  /** Client this work was for */
  clientId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Description of work performed */
  description?: Maybe<Scalars['String']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: Maybe<Scalars['uuid']['output']>;
  /** Specific payroll job this relates to */
  payrollId?: Maybe<Scalars['uuid']['output']>;
  /** Staff member who worked on this */
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  timeUnits?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** Date the work was performed */
  workDate?: Maybe<Scalars['date']['output']>;
};

/** order by min() on columns of table "time_entries" */
export type TimeEntriesMinOrderBy = {
  /** Billing item this time relates to */
  billingItemId?: InputMaybe<OrderBy>;
  billingNotes?: InputMaybe<OrderBy>;
  billingRate?: InputMaybe<OrderBy>;
  /** Client this work was for */
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  /** Description of work performed */
  description?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: InputMaybe<OrderBy>;
  /** Specific payroll job this relates to */
  payrollId?: InputMaybe<OrderBy>;
  /** Staff member who worked on this */
  staffUserId?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  /** Date the work was performed */
  workDate?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "time_entries" */
export type TimeEntriesMutationResponse = {
  __typename?: 'TimeEntriesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TimeEntries>;
};

/** on_conflict condition type for table "time_entries" */
export type TimeEntriesOnConflict = {
  constraint: TimeEntriesConstraint;
  updateColumns?: Array<TimeEntriesUpdateColumn>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};

/** Ordering options when selecting data from "time_entries". */
export type TimeEntriesOrderBy = {
  billingItem?: InputMaybe<BillingItemsOrderBy>;
  billingItemId?: InputMaybe<OrderBy>;
  billingNotes?: InputMaybe<OrderBy>;
  billingRate?: InputMaybe<OrderBy>;
  client?: InputMaybe<ClientsOrderBy>;
  clientId?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  hoursSpent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isBillable?: InputMaybe<OrderBy>;
  payroll?: InputMaybe<PayrollsOrderBy>;
  payrollDate?: InputMaybe<PayrollDatesOrderBy>;
  payrollDateId?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  staffUser?: InputMaybe<UsersOrderBy>;
  staffUserId?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  workDate?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: time_entries */
export type TimeEntriesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "time_entries" */
export type TimeEntriesSelectColumn =
  /** column name */
  | 'billingItemId'
  /** column name */
  | 'billingNotes'
  /** column name */
  | 'billingRate'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'hoursSpent'
  /** column name */
  | 'id'
  /** column name */
  | 'isBillable'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'staffUserId'
  /** column name */
  | 'timeUnits'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'workDate'
  | '%future added value';

/** select "timeEntriesAggregateBoolExpBool_andArgumentsColumns" columns of table "time_entries" */
export type TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isBillable'
  | '%future added value';

/** select "timeEntriesAggregateBoolExpBool_orArgumentsColumns" columns of table "time_entries" */
export type TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isBillable'
  | '%future added value';

/** input type for updating data in table "time_entries" */
export type TimeEntriesSetInput = {
  /** Billing item this time relates to */
  billingItemId?: InputMaybe<Scalars['uuid']['input']>;
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  billingRate?: InputMaybe<Scalars['numeric']['input']>;
  /** Client this work was for */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of work performed */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isBillable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  /** Specific payroll job this relates to */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  /** Staff member who worked on this */
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  timeUnits?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date the work was performed */
  workDate?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate stddev on columns */
export type TimeEntriesStddevFields = {
  __typename?: 'TimeEntriesStddevFields';
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "time_entries" */
export type TimeEntriesStddevOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type TimeEntriesStddevPopFields = {
  __typename?: 'TimeEntriesStddevPopFields';
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "time_entries" */
export type TimeEntriesStddevPopOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type TimeEntriesStddevSampFields = {
  __typename?: 'TimeEntriesStddevSampFields';
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "time_entries" */
export type TimeEntriesStddevSampOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "time_entries" */
export type TimeEntriesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TimeEntriesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimeEntriesStreamCursorValueInput = {
  /** Billing item this time relates to */
  billingItemId?: InputMaybe<Scalars['uuid']['input']>;
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  billingRate?: InputMaybe<Scalars['numeric']['input']>;
  /** Client this work was for */
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Description of work performed */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isBillable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Links time entry to a specific payroll date/EFT cycle instead of just the overall payroll. Enables date-specific time tracking. */
  payrollDateId?: InputMaybe<Scalars['uuid']['input']>;
  /** Specific payroll job this relates to */
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  /** Staff member who worked on this */
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  timeUnits?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** Date the work was performed */
  workDate?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type TimeEntriesSumFields = {
  __typename?: 'TimeEntriesSumFields';
  billingRate?: Maybe<Scalars['numeric']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['numeric']['output']>;
  timeUnits?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "time_entries" */
export type TimeEntriesSumOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** update columns of table "time_entries" */
export type TimeEntriesUpdateColumn =
  /** column name */
  | 'billingItemId'
  /** column name */
  | 'billingNotes'
  /** column name */
  | 'billingRate'
  /** column name */
  | 'clientId'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'description'
  /** column name */
  | 'hoursSpent'
  /** column name */
  | 'id'
  /** column name */
  | 'isBillable'
  /** column name */
  | 'payrollDateId'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'staffUserId'
  /** column name */
  | 'timeUnits'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'workDate'
  | '%future added value';

export type TimeEntriesUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TimeEntriesIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TimeEntriesSetInput>;
  /** filter the rows which have to be updated */
  where: TimeEntriesBoolExp;
};

/** aggregate varPop on columns */
export type TimeEntriesVarPopFields = {
  __typename?: 'TimeEntriesVarPopFields';
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "time_entries" */
export type TimeEntriesVarPopOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type TimeEntriesVarSampFields = {
  __typename?: 'TimeEntriesVarSampFields';
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "time_entries" */
export type TimeEntriesVarSampOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type TimeEntriesVarianceFields = {
  __typename?: 'TimeEntriesVarianceFields';
  billingRate?: Maybe<Scalars['Float']['output']>;
  /** Hours spent on this work */
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "time_entries" */
export type TimeEntriesVarianceOrderBy = {
  billingRate?: InputMaybe<OrderBy>;
  /** Hours spent on this work */
  hoursSpent?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
};

/** columns and relationships of "time_tracking_summary" */
export type TimeTrackingSummary = {
  __typename?: 'TimeTrackingSummary';
  billableAmount?: Maybe<Scalars['numeric']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  billingRate?: Maybe<Scalars['numeric']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  hoursSpent?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  isBillable?: Maybe<Scalars['Boolean']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  timeUnits?: Maybe<Scalars['Int']['output']>;
  workDate?: Maybe<Scalars['date']['output']>;
};

/** aggregated selection of "time_tracking_summary" */
export type TimeTrackingSummaryAggregate = {
  __typename?: 'TimeTrackingSummaryAggregate';
  aggregate?: Maybe<TimeTrackingSummaryAggregateFields>;
  nodes: Array<TimeTrackingSummary>;
};

/** aggregate fields of "time_tracking_summary" */
export type TimeTrackingSummaryAggregateFields = {
  __typename?: 'TimeTrackingSummaryAggregateFields';
  avg?: Maybe<TimeTrackingSummaryAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TimeTrackingSummaryMaxFields>;
  min?: Maybe<TimeTrackingSummaryMinFields>;
  stddev?: Maybe<TimeTrackingSummaryStddevFields>;
  stddevPop?: Maybe<TimeTrackingSummaryStddevPopFields>;
  stddevSamp?: Maybe<TimeTrackingSummaryStddevSampFields>;
  sum?: Maybe<TimeTrackingSummarySumFields>;
  varPop?: Maybe<TimeTrackingSummaryVarPopFields>;
  varSamp?: Maybe<TimeTrackingSummaryVarSampFields>;
  variance?: Maybe<TimeTrackingSummaryVarianceFields>;
};


/** aggregate fields of "time_tracking_summary" */
export type TimeTrackingSummaryAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<TimeTrackingSummarySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type TimeTrackingSummaryAvgFields = {
  __typename?: 'TimeTrackingSummaryAvgFields';
  billableAmount?: Maybe<Scalars['Float']['output']>;
  billingRate?: Maybe<Scalars['Float']['output']>;
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "time_tracking_summary". All fields are combined with a logical 'AND'. */
export type TimeTrackingSummaryBoolExp = {
  _and?: InputMaybe<Array<TimeTrackingSummaryBoolExp>>;
  _not?: InputMaybe<TimeTrackingSummaryBoolExp>;
  _or?: InputMaybe<Array<TimeTrackingSummaryBoolExp>>;
  billableAmount?: InputMaybe<NumericComparisonExp>;
  billingNotes?: InputMaybe<StringComparisonExp>;
  billingRate?: InputMaybe<NumericComparisonExp>;
  clientId?: InputMaybe<UuidComparisonExp>;
  clientName?: InputMaybe<StringComparisonExp>;
  description?: InputMaybe<StringComparisonExp>;
  hoursSpent?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  isBillable?: InputMaybe<BooleanComparisonExp>;
  payrollId?: InputMaybe<UuidComparisonExp>;
  payrollName?: InputMaybe<StringComparisonExp>;
  staffName?: InputMaybe<StringComparisonExp>;
  staffUserId?: InputMaybe<UuidComparisonExp>;
  timeUnits?: InputMaybe<IntComparisonExp>;
  workDate?: InputMaybe<DateComparisonExp>;
};

/** aggregate max on columns */
export type TimeTrackingSummaryMaxFields = {
  __typename?: 'TimeTrackingSummaryMaxFields';
  billableAmount?: Maybe<Scalars['numeric']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  billingRate?: Maybe<Scalars['numeric']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  hoursSpent?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  timeUnits?: Maybe<Scalars['Int']['output']>;
  workDate?: Maybe<Scalars['date']['output']>;
};

/** aggregate min on columns */
export type TimeTrackingSummaryMinFields = {
  __typename?: 'TimeTrackingSummaryMinFields';
  billableAmount?: Maybe<Scalars['numeric']['output']>;
  billingNotes?: Maybe<Scalars['String']['output']>;
  billingRate?: Maybe<Scalars['numeric']['output']>;
  clientId?: Maybe<Scalars['uuid']['output']>;
  clientName?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  hoursSpent?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  payrollId?: Maybe<Scalars['uuid']['output']>;
  payrollName?: Maybe<Scalars['String']['output']>;
  staffName?: Maybe<Scalars['String']['output']>;
  staffUserId?: Maybe<Scalars['uuid']['output']>;
  timeUnits?: Maybe<Scalars['Int']['output']>;
  workDate?: Maybe<Scalars['date']['output']>;
};

/** Ordering options when selecting data from "time_tracking_summary". */
export type TimeTrackingSummaryOrderBy = {
  billableAmount?: InputMaybe<OrderBy>;
  billingNotes?: InputMaybe<OrderBy>;
  billingRate?: InputMaybe<OrderBy>;
  clientId?: InputMaybe<OrderBy>;
  clientName?: InputMaybe<OrderBy>;
  description?: InputMaybe<OrderBy>;
  hoursSpent?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  isBillable?: InputMaybe<OrderBy>;
  payrollId?: InputMaybe<OrderBy>;
  payrollName?: InputMaybe<OrderBy>;
  staffName?: InputMaybe<OrderBy>;
  staffUserId?: InputMaybe<OrderBy>;
  timeUnits?: InputMaybe<OrderBy>;
  workDate?: InputMaybe<OrderBy>;
};

/** select columns of table "time_tracking_summary" */
export type TimeTrackingSummarySelectColumn =
  /** column name */
  | 'billableAmount'
  /** column name */
  | 'billingNotes'
  /** column name */
  | 'billingRate'
  /** column name */
  | 'clientId'
  /** column name */
  | 'clientName'
  /** column name */
  | 'description'
  /** column name */
  | 'hoursSpent'
  /** column name */
  | 'id'
  /** column name */
  | 'isBillable'
  /** column name */
  | 'payrollId'
  /** column name */
  | 'payrollName'
  /** column name */
  | 'staffName'
  /** column name */
  | 'staffUserId'
  /** column name */
  | 'timeUnits'
  /** column name */
  | 'workDate'
  | '%future added value';

/** aggregate stddev on columns */
export type TimeTrackingSummaryStddevFields = {
  __typename?: 'TimeTrackingSummaryStddevFields';
  billableAmount?: Maybe<Scalars['Float']['output']>;
  billingRate?: Maybe<Scalars['Float']['output']>;
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type TimeTrackingSummaryStddevPopFields = {
  __typename?: 'TimeTrackingSummaryStddevPopFields';
  billableAmount?: Maybe<Scalars['Float']['output']>;
  billingRate?: Maybe<Scalars['Float']['output']>;
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type TimeTrackingSummaryStddevSampFields = {
  __typename?: 'TimeTrackingSummaryStddevSampFields';
  billableAmount?: Maybe<Scalars['Float']['output']>;
  billingRate?: Maybe<Scalars['Float']['output']>;
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "time_tracking_summary" */
export type TimeTrackingSummaryStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: TimeTrackingSummaryStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type TimeTrackingSummaryStreamCursorValueInput = {
  billableAmount?: InputMaybe<Scalars['numeric']['input']>;
  billingNotes?: InputMaybe<Scalars['String']['input']>;
  billingRate?: InputMaybe<Scalars['numeric']['input']>;
  clientId?: InputMaybe<Scalars['uuid']['input']>;
  clientName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  hoursSpent?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  isBillable?: InputMaybe<Scalars['Boolean']['input']>;
  payrollId?: InputMaybe<Scalars['uuid']['input']>;
  payrollName?: InputMaybe<Scalars['String']['input']>;
  staffName?: InputMaybe<Scalars['String']['input']>;
  staffUserId?: InputMaybe<Scalars['uuid']['input']>;
  timeUnits?: InputMaybe<Scalars['Int']['input']>;
  workDate?: InputMaybe<Scalars['date']['input']>;
};

/** aggregate sum on columns */
export type TimeTrackingSummarySumFields = {
  __typename?: 'TimeTrackingSummarySumFields';
  billableAmount?: Maybe<Scalars['numeric']['output']>;
  billingRate?: Maybe<Scalars['numeric']['output']>;
  hoursSpent?: Maybe<Scalars['numeric']['output']>;
  timeUnits?: Maybe<Scalars['Int']['output']>;
};

/** aggregate varPop on columns */
export type TimeTrackingSummaryVarPopFields = {
  __typename?: 'TimeTrackingSummaryVarPopFields';
  billableAmount?: Maybe<Scalars['Float']['output']>;
  billingRate?: Maybe<Scalars['Float']['output']>;
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type TimeTrackingSummaryVarSampFields = {
  __typename?: 'TimeTrackingSummaryVarSampFields';
  billableAmount?: Maybe<Scalars['Float']['output']>;
  billingRate?: Maybe<Scalars['Float']['output']>;
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type TimeTrackingSummaryVarianceFields = {
  __typename?: 'TimeTrackingSummaryVarianceFields';
  billableAmount?: Maybe<Scalars['Float']['output']>;
  billingRate?: Maybe<Scalars['Float']['output']>;
  hoursSpent?: Maybe<Scalars['Float']['output']>;
  timeUnits?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type TimestampComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamp']['input']>;
  _gt?: InputMaybe<Scalars['timestamp']['input']>;
  _gte?: InputMaybe<Scalars['timestamp']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamp']['input']>;
  _lte?: InputMaybe<Scalars['timestamp']['input']>;
  _neq?: InputMaybe<Scalars['timestamp']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type TimestamptzComparisonExp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** User favorite templates for quick access */
export type UserEmailTemplateFavorites = {
  __typename?: 'UserEmailTemplateFavorites';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  emailTemplate: EmailTemplates;
  id: Scalars['uuid']['output'];
  templateId: Scalars['uuid']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "user_email_template_favorites" */
export type UserEmailTemplateFavoritesAggregate = {
  __typename?: 'UserEmailTemplateFavoritesAggregate';
  aggregate?: Maybe<UserEmailTemplateFavoritesAggregateFields>;
  nodes: Array<UserEmailTemplateFavorites>;
};

export type UserEmailTemplateFavoritesAggregateBoolExp = {
  count?: InputMaybe<UserEmailTemplateFavoritesAggregateBoolExpCount>;
};

/** aggregate fields of "user_email_template_favorites" */
export type UserEmailTemplateFavoritesAggregateFields = {
  __typename?: 'UserEmailTemplateFavoritesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<UserEmailTemplateFavoritesMaxFields>;
  min?: Maybe<UserEmailTemplateFavoritesMinFields>;
};


/** aggregate fields of "user_email_template_favorites" */
export type UserEmailTemplateFavoritesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserEmailTemplateFavoritesMaxOrderBy>;
  min?: InputMaybe<UserEmailTemplateFavoritesMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesArrRelInsertInput = {
  data: Array<UserEmailTemplateFavoritesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserEmailTemplateFavoritesOnConflict>;
};

/** Boolean expression to filter rows from the table "user_email_template_favorites". All fields are combined with a logical 'AND'. */
export type UserEmailTemplateFavoritesBoolExp = {
  _and?: InputMaybe<Array<UserEmailTemplateFavoritesBoolExp>>;
  _not?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
  _or?: InputMaybe<Array<UserEmailTemplateFavoritesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  emailTemplate?: InputMaybe<EmailTemplatesBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  templateId?: InputMaybe<UuidComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'user_email_template_favorites_pkey'
  /** unique or primary key constraint on columns "user_id", "template_id" */
  | 'user_email_template_favorites_user_id_template_id_key'
  | '%future added value';

/** input type for inserting data into table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  emailTemplate?: InputMaybe<EmailTemplatesObjRelInsertInput>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type UserEmailTemplateFavoritesMaxFields = {
  __typename?: 'UserEmailTemplateFavoritesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  templateId?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserEmailTemplateFavoritesMinFields = {
  __typename?: 'UserEmailTemplateFavoritesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  templateId?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesMutationResponse = {
  __typename?: 'UserEmailTemplateFavoritesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserEmailTemplateFavorites>;
};

/** on_conflict condition type for table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesOnConflict = {
  constraint: UserEmailTemplateFavoritesConstraint;
  updateColumns?: Array<UserEmailTemplateFavoritesUpdateColumn>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};

/** Ordering options when selecting data from "user_email_template_favorites". */
export type UserEmailTemplateFavoritesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  emailTemplate?: InputMaybe<EmailTemplatesOrderBy>;
  id?: InputMaybe<OrderBy>;
  templateId?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_email_template_favorites */
export type UserEmailTemplateFavoritesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'templateId'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserEmailTemplateFavoritesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserEmailTemplateFavoritesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  templateId?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_email_template_favorites" */
export type UserEmailTemplateFavoritesUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'templateId'
  /** column name */
  | 'userId'
  | '%future added value';

export type UserEmailTemplateFavoritesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserEmailTemplateFavoritesSetInput>;
  /** filter the rows which have to be updated */
  where: UserEmailTemplateFavoritesBoolExp;
};

/** Stores invitation metadata for two-stage user invitation flow with role-based access control */
export type UserInvitations = {
  __typename?: 'UserInvitations';
  acceptedAt?: Maybe<Scalars['timestamptz']['output']>;
  acceptedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  acceptedByUser?: Maybe<Users>;
  clerkInvitationId?: Maybe<Scalars['String']['output']>;
  clerkTicket?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  email: Scalars['String']['output'];
  expiresAt: Scalars['timestamptz']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  invitationMetadata?: Maybe<Scalars['jsonb']['output']>;
  invitationStatus: Scalars['invitation_status_enum']['output'];
  invitedAt: Scalars['timestamptz']['output'];
  invitedBy: Scalars['uuid']['output'];
  /** An object relationship */
  invitedByUser: Users;
  invitedRole: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  managerId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  managerUser?: Maybe<Users>;
  revokeReason?: Maybe<Scalars['String']['output']>;
  revokedAt?: Maybe<Scalars['timestamptz']['output']>;
  revokedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  revokedByUser?: Maybe<Users>;
  status: Scalars['String']['output'];
  updatedAt: Scalars['timestamptz']['output'];
};


/** Stores invitation metadata for two-stage user invitation flow with role-based access control */
export type UserInvitationsInvitationMetadataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "user_invitations" */
export type UserInvitationsAggregate = {
  __typename?: 'UserInvitationsAggregate';
  aggregate?: Maybe<UserInvitationsAggregateFields>;
  nodes: Array<UserInvitations>;
};

export type UserInvitationsAggregateBoolExp = {
  count?: InputMaybe<UserInvitationsAggregateBoolExpCount>;
};

/** aggregate fields of "user_invitations" */
export type UserInvitationsAggregateFields = {
  __typename?: 'UserInvitationsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<UserInvitationsMaxFields>;
  min?: Maybe<UserInvitationsMinFields>;
};


/** aggregate fields of "user_invitations" */
export type UserInvitationsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_invitations" */
export type UserInvitationsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserInvitationsMaxOrderBy>;
  min?: InputMaybe<UserInvitationsMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type UserInvitationsAppendInput = {
  invitationMetadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "user_invitations" */
export type UserInvitationsArrRelInsertInput = {
  data: Array<UserInvitationsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserInvitationsOnConflict>;
};

/** Boolean expression to filter rows from the table "user_invitations". All fields are combined with a logical 'AND'. */
export type UserInvitationsBoolExp = {
  _and?: InputMaybe<Array<UserInvitationsBoolExp>>;
  _not?: InputMaybe<UserInvitationsBoolExp>;
  _or?: InputMaybe<Array<UserInvitationsBoolExp>>;
  acceptedAt?: InputMaybe<TimestamptzComparisonExp>;
  acceptedBy?: InputMaybe<UuidComparisonExp>;
  acceptedByUser?: InputMaybe<UsersBoolExp>;
  clerkInvitationId?: InputMaybe<StringComparisonExp>;
  clerkTicket?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  expiresAt?: InputMaybe<TimestamptzComparisonExp>;
  firstName?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  invitationMetadata?: InputMaybe<JsonbComparisonExp>;
  invitationStatus?: InputMaybe<InvitationStatusEnumComparisonExp>;
  invitedAt?: InputMaybe<TimestamptzComparisonExp>;
  invitedBy?: InputMaybe<UuidComparisonExp>;
  invitedByUser?: InputMaybe<UsersBoolExp>;
  invitedRole?: InputMaybe<StringComparisonExp>;
  lastName?: InputMaybe<StringComparisonExp>;
  managerId?: InputMaybe<UuidComparisonExp>;
  managerUser?: InputMaybe<UsersBoolExp>;
  revokeReason?: InputMaybe<StringComparisonExp>;
  revokedAt?: InputMaybe<TimestamptzComparisonExp>;
  revokedBy?: InputMaybe<UuidComparisonExp>;
  revokedByUser?: InputMaybe<UsersBoolExp>;
  status?: InputMaybe<StringComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
};

/** unique or primary key constraints on table "user_invitations" */
export type UserInvitationsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'user_invitations_pkey'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type UserInvitationsDeleteAtPathInput = {
  invitationMetadata?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type UserInvitationsDeleteElemInput = {
  invitationMetadata?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type UserInvitationsDeleteKeyInput = {
  invitationMetadata?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "user_invitations" */
export type UserInvitationsInsertInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  acceptedBy?: InputMaybe<Scalars['uuid']['input']>;
  acceptedByUser?: InputMaybe<UsersObjRelInsertInput>;
  clerkInvitationId?: InputMaybe<Scalars['String']['input']>;
  clerkTicket?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invitationMetadata?: InputMaybe<Scalars['jsonb']['input']>;
  invitationStatus?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  invitedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  invitedBy?: InputMaybe<Scalars['uuid']['input']>;
  invitedByUser?: InputMaybe<UsersObjRelInsertInput>;
  invitedRole?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  managerId?: InputMaybe<Scalars['uuid']['input']>;
  managerUser?: InputMaybe<UsersObjRelInsertInput>;
  revokeReason?: InputMaybe<Scalars['String']['input']>;
  revokedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  revokedBy?: InputMaybe<Scalars['uuid']['input']>;
  revokedByUser?: InputMaybe<UsersObjRelInsertInput>;
  status?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type UserInvitationsMaxFields = {
  __typename?: 'UserInvitationsMaxFields';
  acceptedAt?: Maybe<Scalars['timestamptz']['output']>;
  acceptedBy?: Maybe<Scalars['uuid']['output']>;
  clerkInvitationId?: Maybe<Scalars['String']['output']>;
  clerkTicket?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invitationStatus?: Maybe<Scalars['invitation_status_enum']['output']>;
  invitedAt?: Maybe<Scalars['timestamptz']['output']>;
  invitedBy?: Maybe<Scalars['uuid']['output']>;
  invitedRole?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  managerId?: Maybe<Scalars['uuid']['output']>;
  revokeReason?: Maybe<Scalars['String']['output']>;
  revokedAt?: Maybe<Scalars['timestamptz']['output']>;
  revokedBy?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "user_invitations" */
export type UserInvitationsMaxOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  acceptedBy?: InputMaybe<OrderBy>;
  clerkInvitationId?: InputMaybe<OrderBy>;
  clerkTicket?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationStatus?: InputMaybe<OrderBy>;
  invitedAt?: InputMaybe<OrderBy>;
  invitedBy?: InputMaybe<OrderBy>;
  invitedRole?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  managerId?: InputMaybe<OrderBy>;
  revokeReason?: InputMaybe<OrderBy>;
  revokedAt?: InputMaybe<OrderBy>;
  revokedBy?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserInvitationsMinFields = {
  __typename?: 'UserInvitationsMinFields';
  acceptedAt?: Maybe<Scalars['timestamptz']['output']>;
  acceptedBy?: Maybe<Scalars['uuid']['output']>;
  clerkInvitationId?: Maybe<Scalars['String']['output']>;
  clerkTicket?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  invitationStatus?: Maybe<Scalars['invitation_status_enum']['output']>;
  invitedAt?: Maybe<Scalars['timestamptz']['output']>;
  invitedBy?: Maybe<Scalars['uuid']['output']>;
  invitedRole?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  managerId?: Maybe<Scalars['uuid']['output']>;
  revokeReason?: Maybe<Scalars['String']['output']>;
  revokedAt?: Maybe<Scalars['timestamptz']['output']>;
  revokedBy?: Maybe<Scalars['uuid']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "user_invitations" */
export type UserInvitationsMinOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  acceptedBy?: InputMaybe<OrderBy>;
  clerkInvitationId?: InputMaybe<OrderBy>;
  clerkTicket?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationStatus?: InputMaybe<OrderBy>;
  invitedAt?: InputMaybe<OrderBy>;
  invitedBy?: InputMaybe<OrderBy>;
  invitedRole?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  managerId?: InputMaybe<OrderBy>;
  revokeReason?: InputMaybe<OrderBy>;
  revokedAt?: InputMaybe<OrderBy>;
  revokedBy?: InputMaybe<OrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_invitations" */
export type UserInvitationsMutationResponse = {
  __typename?: 'UserInvitationsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserInvitations>;
};

/** on_conflict condition type for table "user_invitations" */
export type UserInvitationsOnConflict = {
  constraint: UserInvitationsConstraint;
  updateColumns?: Array<UserInvitationsUpdateColumn>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};

/** Ordering options when selecting data from "user_invitations". */
export type UserInvitationsOrderBy = {
  acceptedAt?: InputMaybe<OrderBy>;
  acceptedBy?: InputMaybe<OrderBy>;
  acceptedByUser?: InputMaybe<UsersOrderBy>;
  clerkInvitationId?: InputMaybe<OrderBy>;
  clerkTicket?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  invitationMetadata?: InputMaybe<OrderBy>;
  invitationStatus?: InputMaybe<OrderBy>;
  invitedAt?: InputMaybe<OrderBy>;
  invitedBy?: InputMaybe<OrderBy>;
  invitedByUser?: InputMaybe<UsersOrderBy>;
  invitedRole?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  managerId?: InputMaybe<OrderBy>;
  managerUser?: InputMaybe<UsersOrderBy>;
  revokeReason?: InputMaybe<OrderBy>;
  revokedAt?: InputMaybe<OrderBy>;
  revokedBy?: InputMaybe<OrderBy>;
  revokedByUser?: InputMaybe<UsersOrderBy>;
  status?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_invitations */
export type UserInvitationsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type UserInvitationsPrependInput = {
  invitationMetadata?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "user_invitations" */
export type UserInvitationsSelectColumn =
  /** column name */
  | 'acceptedAt'
  /** column name */
  | 'acceptedBy'
  /** column name */
  | 'clerkInvitationId'
  /** column name */
  | 'clerkTicket'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'email'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'firstName'
  /** column name */
  | 'id'
  /** column name */
  | 'invitationMetadata'
  /** column name */
  | 'invitationStatus'
  /** column name */
  | 'invitedAt'
  /** column name */
  | 'invitedBy'
  /** column name */
  | 'invitedRole'
  /** column name */
  | 'lastName'
  /** column name */
  | 'managerId'
  /** column name */
  | 'revokeReason'
  /** column name */
  | 'revokedAt'
  /** column name */
  | 'revokedBy'
  /** column name */
  | 'status'
  /** column name */
  | 'updatedAt'
  | '%future added value';

/** input type for updating data in table "user_invitations" */
export type UserInvitationsSetInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  acceptedBy?: InputMaybe<Scalars['uuid']['input']>;
  clerkInvitationId?: InputMaybe<Scalars['String']['input']>;
  clerkTicket?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invitationMetadata?: InputMaybe<Scalars['jsonb']['input']>;
  invitationStatus?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  invitedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  invitedBy?: InputMaybe<Scalars['uuid']['input']>;
  invitedRole?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  managerId?: InputMaybe<Scalars['uuid']['input']>;
  revokeReason?: InputMaybe<Scalars['String']['input']>;
  revokedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  revokedBy?: InputMaybe<Scalars['uuid']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "user_invitations" */
export type UserInvitationsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserInvitationsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserInvitationsStreamCursorValueInput = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  acceptedBy?: InputMaybe<Scalars['uuid']['input']>;
  clerkInvitationId?: InputMaybe<Scalars['String']['input']>;
  clerkTicket?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  invitationMetadata?: InputMaybe<Scalars['jsonb']['input']>;
  invitationStatus?: InputMaybe<Scalars['invitation_status_enum']['input']>;
  invitedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  invitedBy?: InputMaybe<Scalars['uuid']['input']>;
  invitedRole?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  managerId?: InputMaybe<Scalars['uuid']['input']>;
  revokeReason?: InputMaybe<Scalars['String']['input']>;
  revokedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  revokedBy?: InputMaybe<Scalars['uuid']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "user_invitations" */
export type UserInvitationsUpdateColumn =
  /** column name */
  | 'acceptedAt'
  /** column name */
  | 'acceptedBy'
  /** column name */
  | 'clerkInvitationId'
  /** column name */
  | 'clerkTicket'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'email'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'firstName'
  /** column name */
  | 'id'
  /** column name */
  | 'invitationMetadata'
  /** column name */
  | 'invitationStatus'
  /** column name */
  | 'invitedAt'
  /** column name */
  | 'invitedBy'
  /** column name */
  | 'invitedRole'
  /** column name */
  | 'lastName'
  /** column name */
  | 'managerId'
  /** column name */
  | 'revokeReason'
  /** column name */
  | 'revokedAt'
  /** column name */
  | 'revokedBy'
  /** column name */
  | 'status'
  /** column name */
  | 'updatedAt'
  | '%future added value';

export type UserInvitationsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<UserInvitationsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<UserInvitationsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<UserInvitationsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<UserInvitationsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<UserInvitationsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserInvitationsSetInput>;
  /** filter the rows which have to be updated */
  where: UserInvitationsBoolExp;
};

/** Boolean expression to compare columns of type "user_position". All fields are combined with logical 'AND'. */
export type UserPositionComparisonExp = {
  _eq?: InputMaybe<Scalars['user_position']['input']>;
  _gt?: InputMaybe<Scalars['user_position']['input']>;
  _gte?: InputMaybe<Scalars['user_position']['input']>;
  _in?: InputMaybe<Array<Scalars['user_position']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['user_position']['input']>;
  _lte?: InputMaybe<Scalars['user_position']['input']>;
  _neq?: InputMaybe<Scalars['user_position']['input']>;
  _nin?: InputMaybe<Array<Scalars['user_position']['input']>>;
};

/** User productivity and profitability metrics */
export type UserProductivityAnalysis = {
  __typename?: 'UserProductivityAnalysis';
  billingCategory?: Maybe<Scalars['String']['output']>;
  computedName?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['numeric']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['bigint']['output']>;
  profitGenerated30d?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour30d?: Maybe<Scalars['numeric']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost30d?: Maybe<Scalars['numeric']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['numeric']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "user_productivity_analysis" */
export type UserProductivityAnalysisAggregate = {
  __typename?: 'UserProductivityAnalysisAggregate';
  aggregate?: Maybe<UserProductivityAnalysisAggregateFields>;
  nodes: Array<UserProductivityAnalysis>;
};

/** aggregate fields of "user_productivity_analysis" */
export type UserProductivityAnalysisAggregateFields = {
  __typename?: 'UserProductivityAnalysisAggregateFields';
  avg?: Maybe<UserProductivityAnalysisAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserProductivityAnalysisMaxFields>;
  min?: Maybe<UserProductivityAnalysisMinFields>;
  stddev?: Maybe<UserProductivityAnalysisStddevFields>;
  stddevPop?: Maybe<UserProductivityAnalysisStddevPopFields>;
  stddevSamp?: Maybe<UserProductivityAnalysisStddevSampFields>;
  sum?: Maybe<UserProductivityAnalysisSumFields>;
  varPop?: Maybe<UserProductivityAnalysisVarPopFields>;
  varSamp?: Maybe<UserProductivityAnalysisVarSampFields>;
  variance?: Maybe<UserProductivityAnalysisVarianceFields>;
};


/** aggregate fields of "user_productivity_analysis" */
export type UserProductivityAnalysisAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserProductivityAnalysisSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type UserProductivityAnalysisAvgFields = {
  __typename?: 'UserProductivityAnalysisAvgFields';
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['Float']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['Float']['output']>;
  profitGenerated30d?: Maybe<Scalars['Float']['output']>;
  revenuePerHour30d?: Maybe<Scalars['Float']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['Float']['output']>;
  totalInternalCost30d?: Maybe<Scalars['Float']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "user_productivity_analysis". All fields are combined with a logical 'AND'. */
export type UserProductivityAnalysisBoolExp = {
  _and?: InputMaybe<Array<UserProductivityAnalysisBoolExp>>;
  _not?: InputMaybe<UserProductivityAnalysisBoolExp>;
  _or?: InputMaybe<Array<UserProductivityAnalysisBoolExp>>;
  billingCategory?: InputMaybe<StringComparisonExp>;
  computedName?: InputMaybe<StringComparisonExp>;
  costCenter?: InputMaybe<StringComparisonExp>;
  defaultHourlyRate?: InputMaybe<NumericComparisonExp>;
  efficiencyRatio30d?: InputMaybe<NumericComparisonExp>;
  firstName?: InputMaybe<StringComparisonExp>;
  lastName?: InputMaybe<StringComparisonExp>;
  payrollDatesWorked30d?: InputMaybe<BigintComparisonExp>;
  profitGenerated30d?: InputMaybe<NumericComparisonExp>;
  revenuePerHour30d?: InputMaybe<NumericComparisonExp>;
  totalHoursLast30Days?: InputMaybe<NumericComparisonExp>;
  totalInternalCost30d?: InputMaybe<NumericComparisonExp>;
  totalRevenueGenerated30d?: InputMaybe<NumericComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** aggregate max on columns */
export type UserProductivityAnalysisMaxFields = {
  __typename?: 'UserProductivityAnalysisMaxFields';
  billingCategory?: Maybe<Scalars['String']['output']>;
  computedName?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['numeric']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['bigint']['output']>;
  profitGenerated30d?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour30d?: Maybe<Scalars['numeric']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost30d?: Maybe<Scalars['numeric']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['numeric']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type UserProductivityAnalysisMinFields = {
  __typename?: 'UserProductivityAnalysisMinFields';
  billingCategory?: Maybe<Scalars['String']['output']>;
  computedName?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['numeric']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['bigint']['output']>;
  profitGenerated30d?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour30d?: Maybe<Scalars['numeric']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost30d?: Maybe<Scalars['numeric']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['numeric']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** Ordering options when selecting data from "user_productivity_analysis". */
export type UserProductivityAnalysisOrderBy = {
  billingCategory?: InputMaybe<OrderBy>;
  computedName?: InputMaybe<OrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  defaultHourlyRate?: InputMaybe<OrderBy>;
  efficiencyRatio30d?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  payrollDatesWorked30d?: InputMaybe<OrderBy>;
  profitGenerated30d?: InputMaybe<OrderBy>;
  revenuePerHour30d?: InputMaybe<OrderBy>;
  totalHoursLast30Days?: InputMaybe<OrderBy>;
  totalInternalCost30d?: InputMaybe<OrderBy>;
  totalRevenueGenerated30d?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "user_productivity_analysis" */
export type UserProductivityAnalysisSelectColumn =
  /** column name */
  | 'billingCategory'
  /** column name */
  | 'computedName'
  /** column name */
  | 'costCenter'
  /** column name */
  | 'defaultHourlyRate'
  /** column name */
  | 'efficiencyRatio30d'
  /** column name */
  | 'firstName'
  /** column name */
  | 'lastName'
  /** column name */
  | 'payrollDatesWorked30d'
  /** column name */
  | 'profitGenerated30d'
  /** column name */
  | 'revenuePerHour30d'
  /** column name */
  | 'totalHoursLast30Days'
  /** column name */
  | 'totalInternalCost30d'
  /** column name */
  | 'totalRevenueGenerated30d'
  /** column name */
  | 'userId'
  | '%future added value';

/** aggregate stddev on columns */
export type UserProductivityAnalysisStddevFields = {
  __typename?: 'UserProductivityAnalysisStddevFields';
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['Float']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['Float']['output']>;
  profitGenerated30d?: Maybe<Scalars['Float']['output']>;
  revenuePerHour30d?: Maybe<Scalars['Float']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['Float']['output']>;
  totalInternalCost30d?: Maybe<Scalars['Float']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevPop on columns */
export type UserProductivityAnalysisStddevPopFields = {
  __typename?: 'UserProductivityAnalysisStddevPopFields';
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['Float']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['Float']['output']>;
  profitGenerated30d?: Maybe<Scalars['Float']['output']>;
  revenuePerHour30d?: Maybe<Scalars['Float']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['Float']['output']>;
  totalInternalCost30d?: Maybe<Scalars['Float']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddevSamp on columns */
export type UserProductivityAnalysisStddevSampFields = {
  __typename?: 'UserProductivityAnalysisStddevSampFields';
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['Float']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['Float']['output']>;
  profitGenerated30d?: Maybe<Scalars['Float']['output']>;
  revenuePerHour30d?: Maybe<Scalars['Float']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['Float']['output']>;
  totalInternalCost30d?: Maybe<Scalars['Float']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "user_productivity_analysis" */
export type UserProductivityAnalysisStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserProductivityAnalysisStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserProductivityAnalysisStreamCursorValueInput = {
  billingCategory?: InputMaybe<Scalars['String']['input']>;
  computedName?: InputMaybe<Scalars['String']['input']>;
  costCenter?: InputMaybe<Scalars['String']['input']>;
  defaultHourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  efficiencyRatio30d?: InputMaybe<Scalars['numeric']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  payrollDatesWorked30d?: InputMaybe<Scalars['bigint']['input']>;
  profitGenerated30d?: InputMaybe<Scalars['numeric']['input']>;
  revenuePerHour30d?: InputMaybe<Scalars['numeric']['input']>;
  totalHoursLast30Days?: InputMaybe<Scalars['numeric']['input']>;
  totalInternalCost30d?: InputMaybe<Scalars['numeric']['input']>;
  totalRevenueGenerated30d?: InputMaybe<Scalars['numeric']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type UserProductivityAnalysisSumFields = {
  __typename?: 'UserProductivityAnalysisSumFields';
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['numeric']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['bigint']['output']>;
  profitGenerated30d?: Maybe<Scalars['numeric']['output']>;
  revenuePerHour30d?: Maybe<Scalars['numeric']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['numeric']['output']>;
  totalInternalCost30d?: Maybe<Scalars['numeric']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['numeric']['output']>;
};

/** aggregate varPop on columns */
export type UserProductivityAnalysisVarPopFields = {
  __typename?: 'UserProductivityAnalysisVarPopFields';
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['Float']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['Float']['output']>;
  profitGenerated30d?: Maybe<Scalars['Float']['output']>;
  revenuePerHour30d?: Maybe<Scalars['Float']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['Float']['output']>;
  totalInternalCost30d?: Maybe<Scalars['Float']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['Float']['output']>;
};

/** aggregate varSamp on columns */
export type UserProductivityAnalysisVarSampFields = {
  __typename?: 'UserProductivityAnalysisVarSampFields';
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['Float']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['Float']['output']>;
  profitGenerated30d?: Maybe<Scalars['Float']['output']>;
  revenuePerHour30d?: Maybe<Scalars['Float']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['Float']['output']>;
  totalInternalCost30d?: Maybe<Scalars['Float']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type UserProductivityAnalysisVarianceFields = {
  __typename?: 'UserProductivityAnalysisVarianceFields';
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
  efficiencyRatio30d?: Maybe<Scalars['Float']['output']>;
  payrollDatesWorked30d?: Maybe<Scalars['Float']['output']>;
  profitGenerated30d?: Maybe<Scalars['Float']['output']>;
  revenuePerHour30d?: Maybe<Scalars['Float']['output']>;
  totalHoursLast30Days?: Maybe<Scalars['Float']['output']>;
  totalInternalCost30d?: Maybe<Scalars['Float']['output']>;
  totalRevenueGenerated30d?: Maybe<Scalars['Float']['output']>;
};

/** Historical tracking of user hourly rates for accurate cost analysis */
export type UserRateHistory = {
  __typename?: 'UserRateHistory';
  billingCategory?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  effectiveFrom: Scalars['date']['output'];
  effectiveTo?: Maybe<Scalars['date']['output']>;
  hourlyRate: Scalars['numeric']['output'];
  id: Scalars['uuid']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  rateHistoryByUser?: Maybe<Users>;
  rateType?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "user_rate_history" */
export type UserRateHistoryAggregate = {
  __typename?: 'UserRateHistoryAggregate';
  aggregate?: Maybe<UserRateHistoryAggregateFields>;
  nodes: Array<UserRateHistory>;
};

export type UserRateHistoryAggregateBoolExp = {
  count?: InputMaybe<UserRateHistoryAggregateBoolExpCount>;
};

/** aggregate fields of "user_rate_history" */
export type UserRateHistoryAggregateFields = {
  __typename?: 'UserRateHistoryAggregateFields';
  avg?: Maybe<UserRateHistoryAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UserRateHistoryMaxFields>;
  min?: Maybe<UserRateHistoryMinFields>;
  stddev?: Maybe<UserRateHistoryStddevFields>;
  stddevPop?: Maybe<UserRateHistoryStddevPopFields>;
  stddevSamp?: Maybe<UserRateHistoryStddevSampFields>;
  sum?: Maybe<UserRateHistorySumFields>;
  varPop?: Maybe<UserRateHistoryVarPopFields>;
  varSamp?: Maybe<UserRateHistoryVarSampFields>;
  variance?: Maybe<UserRateHistoryVarianceFields>;
};


/** aggregate fields of "user_rate_history" */
export type UserRateHistoryAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_rate_history" */
export type UserRateHistoryAggregateOrderBy = {
  avg?: InputMaybe<UserRateHistoryAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserRateHistoryMaxOrderBy>;
  min?: InputMaybe<UserRateHistoryMinOrderBy>;
  stddev?: InputMaybe<UserRateHistoryStddevOrderBy>;
  stddevPop?: InputMaybe<UserRateHistoryStddevPopOrderBy>;
  stddevSamp?: InputMaybe<UserRateHistoryStddevSampOrderBy>;
  sum?: InputMaybe<UserRateHistorySumOrderBy>;
  varPop?: InputMaybe<UserRateHistoryVarPopOrderBy>;
  varSamp?: InputMaybe<UserRateHistoryVarSampOrderBy>;
  variance?: InputMaybe<UserRateHistoryVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "user_rate_history" */
export type UserRateHistoryArrRelInsertInput = {
  data: Array<UserRateHistoryInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserRateHistoryOnConflict>;
};

/** aggregate avg on columns */
export type UserRateHistoryAvgFields = {
  __typename?: 'UserRateHistoryAvgFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_rate_history" */
export type UserRateHistoryAvgOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "user_rate_history". All fields are combined with a logical 'AND'. */
export type UserRateHistoryBoolExp = {
  _and?: InputMaybe<Array<UserRateHistoryBoolExp>>;
  _not?: InputMaybe<UserRateHistoryBoolExp>;
  _or?: InputMaybe<Array<UserRateHistoryBoolExp>>;
  billingCategory?: InputMaybe<StringComparisonExp>;
  costCenter?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBy?: InputMaybe<UuidComparisonExp>;
  effectiveFrom?: InputMaybe<DateComparisonExp>;
  effectiveTo?: InputMaybe<DateComparisonExp>;
  hourlyRate?: InputMaybe<NumericComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  notes?: InputMaybe<StringComparisonExp>;
  rateHistoryByUser?: InputMaybe<UsersBoolExp>;
  rateType?: InputMaybe<StringComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_rate_history" */
export type UserRateHistoryConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'user_rate_history_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "user_rate_history" */
export type UserRateHistoryIncInput = {
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "user_rate_history" */
export type UserRateHistoryInsertInput = {
  billingCategory?: InputMaybe<Scalars['String']['input']>;
  costCenter?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  effectiveFrom?: InputMaybe<Scalars['date']['input']>;
  effectiveTo?: InputMaybe<Scalars['date']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  rateHistoryByUser?: InputMaybe<UsersObjRelInsertInput>;
  rateType?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type UserRateHistoryMaxFields = {
  __typename?: 'UserRateHistoryMaxFields';
  billingCategory?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  effectiveFrom?: Maybe<Scalars['date']['output']>;
  effectiveTo?: Maybe<Scalars['date']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  rateType?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_rate_history" */
export type UserRateHistoryMaxOrderBy = {
  billingCategory?: InputMaybe<OrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  effectiveFrom?: InputMaybe<OrderBy>;
  effectiveTo?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  rateType?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserRateHistoryMinFields = {
  __typename?: 'UserRateHistoryMinFields';
  billingCategory?: Maybe<Scalars['String']['output']>;
  costCenter?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  effectiveFrom?: Maybe<Scalars['date']['output']>;
  effectiveTo?: Maybe<Scalars['date']['output']>;
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  rateType?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_rate_history" */
export type UserRateHistoryMinOrderBy = {
  billingCategory?: InputMaybe<OrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  effectiveFrom?: InputMaybe<OrderBy>;
  effectiveTo?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  rateType?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_rate_history" */
export type UserRateHistoryMutationResponse = {
  __typename?: 'UserRateHistoryMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserRateHistory>;
};

/** on_conflict condition type for table "user_rate_history" */
export type UserRateHistoryOnConflict = {
  constraint: UserRateHistoryConstraint;
  updateColumns?: Array<UserRateHistoryUpdateColumn>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};

/** Ordering options when selecting data from "user_rate_history". */
export type UserRateHistoryOrderBy = {
  billingCategory?: InputMaybe<OrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBy?: InputMaybe<OrderBy>;
  effectiveFrom?: InputMaybe<OrderBy>;
  effectiveTo?: InputMaybe<OrderBy>;
  hourlyRate?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  notes?: InputMaybe<OrderBy>;
  rateHistoryByUser?: InputMaybe<UsersOrderBy>;
  rateType?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_rate_history */
export type UserRateHistoryPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "user_rate_history" */
export type UserRateHistorySelectColumn =
  /** column name */
  | 'billingCategory'
  /** column name */
  | 'costCenter'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'effectiveFrom'
  /** column name */
  | 'effectiveTo'
  /** column name */
  | 'hourlyRate'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'rateType'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "user_rate_history" */
export type UserRateHistorySetInput = {
  billingCategory?: InputMaybe<Scalars['String']['input']>;
  costCenter?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  effectiveFrom?: InputMaybe<Scalars['date']['input']>;
  effectiveTo?: InputMaybe<Scalars['date']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  rateType?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type UserRateHistoryStddevFields = {
  __typename?: 'UserRateHistoryStddevFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_rate_history" */
export type UserRateHistoryStddevOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type UserRateHistoryStddevPopFields = {
  __typename?: 'UserRateHistoryStddevPopFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "user_rate_history" */
export type UserRateHistoryStddevPopOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type UserRateHistoryStddevSampFields = {
  __typename?: 'UserRateHistoryStddevSampFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "user_rate_history" */
export type UserRateHistoryStddevSampOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "user_rate_history" */
export type UserRateHistoryStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserRateHistoryStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserRateHistoryStreamCursorValueInput = {
  billingCategory?: InputMaybe<Scalars['String']['input']>;
  costCenter?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  effectiveFrom?: InputMaybe<Scalars['date']['input']>;
  effectiveTo?: InputMaybe<Scalars['date']['input']>;
  hourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  rateType?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type UserRateHistorySumFields = {
  __typename?: 'UserRateHistorySumFields';
  hourlyRate?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "user_rate_history" */
export type UserRateHistorySumOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** update columns of table "user_rate_history" */
export type UserRateHistoryUpdateColumn =
  /** column name */
  | 'billingCategory'
  /** column name */
  | 'costCenter'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'createdBy'
  /** column name */
  | 'effectiveFrom'
  /** column name */
  | 'effectiveTo'
  /** column name */
  | 'hourlyRate'
  /** column name */
  | 'id'
  /** column name */
  | 'notes'
  /** column name */
  | 'rateType'
  /** column name */
  | 'userId'
  | '%future added value';

export type UserRateHistoryUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UserRateHistoryIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserRateHistorySetInput>;
  /** filter the rows which have to be updated */
  where: UserRateHistoryBoolExp;
};

/** aggregate varPop on columns */
export type UserRateHistoryVarPopFields = {
  __typename?: 'UserRateHistoryVarPopFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "user_rate_history" */
export type UserRateHistoryVarPopOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type UserRateHistoryVarSampFields = {
  __typename?: 'UserRateHistoryVarSampFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "user_rate_history" */
export type UserRateHistoryVarSampOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type UserRateHistoryVarianceFields = {
  __typename?: 'UserRateHistoryVarianceFields';
  hourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_rate_history" */
export type UserRateHistoryVarianceOrderBy = {
  hourlyRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "user_role". All fields are combined with logical 'AND'. */
export type UserRoleComparisonExp = {
  _eq?: InputMaybe<Scalars['user_role']['input']>;
  _gt?: InputMaybe<Scalars['user_role']['input']>;
  _gte?: InputMaybe<Scalars['user_role']['input']>;
  _in?: InputMaybe<Array<Scalars['user_role']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['user_role']['input']>;
  _lte?: InputMaybe<Scalars['user_role']['input']>;
  _neq?: InputMaybe<Scalars['user_role']['input']>;
  _nin?: InputMaybe<Array<Scalars['user_role']['input']>>;
};

/** columns and relationships of "user_roles" */
export type UserRoles = {
  __typename?: 'UserRoles';
  createdAt: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  /** An object relationship */
  role: Roles;
  roleId: Scalars['uuid']['output'];
  updatedAt: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "user_roles" */
export type UserRolesAggregate = {
  __typename?: 'UserRolesAggregate';
  aggregate?: Maybe<UserRolesAggregateFields>;
  nodes: Array<UserRoles>;
};

export type UserRolesAggregateBoolExp = {
  count?: InputMaybe<UserRolesAggregateBoolExpCount>;
};

/** aggregate fields of "user_roles" */
export type UserRolesAggregateFields = {
  __typename?: 'UserRolesAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<UserRolesMaxFields>;
  min?: Maybe<UserRolesMinFields>;
};


/** aggregate fields of "user_roles" */
export type UserRolesAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserRolesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_roles" */
export type UserRolesAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserRolesMaxOrderBy>;
  min?: InputMaybe<UserRolesMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_roles" */
export type UserRolesArrRelInsertInput = {
  data: Array<UserRolesInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserRolesOnConflict>;
};

/** Boolean expression to filter rows from the table "user_roles". All fields are combined with a logical 'AND'. */
export type UserRolesBoolExp = {
  _and?: InputMaybe<Array<UserRolesBoolExp>>;
  _not?: InputMaybe<UserRolesBoolExp>;
  _or?: InputMaybe<Array<UserRolesBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  role?: InputMaybe<RolesBoolExp>;
  roleId?: InputMaybe<UuidComparisonExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_roles" */
export type UserRolesConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'user_roles_pkey'
  /** unique or primary key constraint on columns "user_id", "role_id" */
  | 'user_roles_user_id_role_id_key'
  | '%future added value';

/** input type for inserting data into table "user_roles" */
export type UserRolesInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<RolesObjRelInsertInput>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type UserRolesMaxFields = {
  __typename?: 'UserRolesMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_roles" */
export type UserRolesMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  roleId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserRolesMinFields = {
  __typename?: 'UserRolesMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_roles" */
export type UserRolesMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  roleId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_roles" */
export type UserRolesMutationResponse = {
  __typename?: 'UserRolesMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserRoles>;
};

/** on_conflict condition type for table "user_roles" */
export type UserRolesOnConflict = {
  constraint: UserRolesConstraint;
  updateColumns?: Array<UserRolesUpdateColumn>;
  where?: InputMaybe<UserRolesBoolExp>;
};

/** Ordering options when selecting data from "user_roles". */
export type UserRolesOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  role?: InputMaybe<RolesOrderBy>;
  roleId?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_roles */
export type UserRolesPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "user_roles" */
export type UserRolesSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'roleId'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "user_roles" */
export type UserRolesSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_roles" */
export type UserRolesStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserRolesStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserRolesStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_roles" */
export type UserRolesUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'roleId'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  | '%future added value';

export type UserRolesUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserRolesSetInput>;
  /** filter the rows which have to be updated */
  where: UserRolesBoolExp;
};

/** columns and relationships of "user_sessions" */
export type UserSessions = {
  __typename?: 'UserSessions';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  expiresAt: Scalars['timestamptz']['output'];
  id: Scalars['uuid']['output'];
  ipAddress?: Maybe<Scalars['inet']['output']>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  lastActivity?: Maybe<Scalars['timestamptz']['output']>;
  locationData?: Maybe<Scalars['jsonb']['output']>;
  logoutReason?: Maybe<Scalars['String']['output']>;
  sessionToken: Scalars['String']['output'];
  /** An object relationship */
  user: Users;
  userAgent?: Maybe<Scalars['String']['output']>;
  userId: Scalars['uuid']['output'];
};


/** columns and relationships of "user_sessions" */
export type UserSessionsLocationDataArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "user_sessions" */
export type UserSessionsAggregate = {
  __typename?: 'UserSessionsAggregate';
  aggregate?: Maybe<UserSessionsAggregateFields>;
  nodes: Array<UserSessions>;
};

export type UserSessionsAggregateBoolExp = {
  bool_and?: InputMaybe<UserSessionsAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<UserSessionsAggregateBoolExpBool_Or>;
  count?: InputMaybe<UserSessionsAggregateBoolExpCount>;
};

/** aggregate fields of "user_sessions" */
export type UserSessionsAggregateFields = {
  __typename?: 'UserSessionsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<UserSessionsMaxFields>;
  min?: Maybe<UserSessionsMinFields>;
};


/** aggregate fields of "user_sessions" */
export type UserSessionsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserSessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_sessions" */
export type UserSessionsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserSessionsMaxOrderBy>;
  min?: InputMaybe<UserSessionsMinOrderBy>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type UserSessionsAppendInput = {
  locationData?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "user_sessions" */
export type UserSessionsArrRelInsertInput = {
  data: Array<UserSessionsInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UserSessionsOnConflict>;
};

/** Boolean expression to filter rows from the table "user_sessions". All fields are combined with a logical 'AND'. */
export type UserSessionsBoolExp = {
  _and?: InputMaybe<Array<UserSessionsBoolExp>>;
  _not?: InputMaybe<UserSessionsBoolExp>;
  _or?: InputMaybe<Array<UserSessionsBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  expiresAt?: InputMaybe<TimestamptzComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  ipAddress?: InputMaybe<InetComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  lastActivity?: InputMaybe<TimestamptzComparisonExp>;
  locationData?: InputMaybe<JsonbComparisonExp>;
  logoutReason?: InputMaybe<StringComparisonExp>;
  sessionToken?: InputMaybe<StringComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userAgent?: InputMaybe<StringComparisonExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** unique or primary key constraints on table "user_sessions" */
export type UserSessionsConstraint =
  /** unique or primary key constraint on columns "id" */
  | 'user_sessions_pkey'
  /** unique or primary key constraint on columns "session_token" */
  | 'user_sessions_session_token_key'
  | '%future added value';

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type UserSessionsDeleteAtPathInput = {
  locationData?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type UserSessionsDeleteElemInput = {
  locationData?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type UserSessionsDeleteKeyInput = {
  locationData?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "user_sessions" */
export type UserSessionsInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lastActivity?: InputMaybe<Scalars['timestamptz']['input']>;
  locationData?: InputMaybe<Scalars['jsonb']['input']>;
  logoutReason?: InputMaybe<Scalars['String']['input']>;
  sessionToken?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type UserSessionsMaxFields = {
  __typename?: 'UserSessionsMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastActivity?: Maybe<Scalars['timestamptz']['output']>;
  logoutReason?: Maybe<Scalars['String']['output']>;
  sessionToken?: Maybe<Scalars['String']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_sessions" */
export type UserSessionsMaxOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastActivity?: InputMaybe<OrderBy>;
  logoutReason?: InputMaybe<OrderBy>;
  sessionToken?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserSessionsMinFields = {
  __typename?: 'UserSessionsMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  expiresAt?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastActivity?: Maybe<Scalars['timestamptz']['output']>;
  logoutReason?: Maybe<Scalars['String']['output']>;
  sessionToken?: Maybe<Scalars['String']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_sessions" */
export type UserSessionsMinOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  lastActivity?: InputMaybe<OrderBy>;
  logoutReason?: InputMaybe<OrderBy>;
  sessionToken?: InputMaybe<OrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_sessions" */
export type UserSessionsMutationResponse = {
  __typename?: 'UserSessionsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserSessions>;
};

/** on_conflict condition type for table "user_sessions" */
export type UserSessionsOnConflict = {
  constraint: UserSessionsConstraint;
  updateColumns?: Array<UserSessionsUpdateColumn>;
  where?: InputMaybe<UserSessionsBoolExp>;
};

/** Ordering options when selecting data from "user_sessions". */
export type UserSessionsOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  expiresAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  ipAddress?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  lastActivity?: InputMaybe<OrderBy>;
  locationData?: InputMaybe<OrderBy>;
  logoutReason?: InputMaybe<OrderBy>;
  sessionToken?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userAgent?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: user_sessions */
export type UserSessionsPkColumnsInput = {
  id: Scalars['uuid']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type UserSessionsPrependInput = {
  locationData?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "user_sessions" */
export type UserSessionsSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'isActive'
  /** column name */
  | 'lastActivity'
  /** column name */
  | 'locationData'
  /** column name */
  | 'logoutReason'
  /** column name */
  | 'sessionToken'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userId'
  | '%future added value';

/** select "userSessionsAggregateBoolExpBool_andArgumentsColumns" columns of table "user_sessions" */
export type UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isActive'
  | '%future added value';

/** select "userSessionsAggregateBoolExpBool_orArgumentsColumns" columns of table "user_sessions" */
export type UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isActive'
  | '%future added value';

/** input type for updating data in table "user_sessions" */
export type UserSessionsSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lastActivity?: InputMaybe<Scalars['timestamptz']['input']>;
  locationData?: InputMaybe<Scalars['jsonb']['input']>;
  logoutReason?: InputMaybe<Scalars['String']['input']>;
  sessionToken?: InputMaybe<Scalars['String']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_sessions" */
export type UserSessionsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserSessionsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserSessionsStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  ipAddress?: InputMaybe<Scalars['inet']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lastActivity?: InputMaybe<Scalars['timestamptz']['input']>;
  locationData?: InputMaybe<Scalars['jsonb']['input']>;
  logoutReason?: InputMaybe<Scalars['String']['input']>;
  sessionToken?: InputMaybe<Scalars['String']['input']>;
  userAgent?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_sessions" */
export type UserSessionsUpdateColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'expiresAt'
  /** column name */
  | 'id'
  /** column name */
  | 'ipAddress'
  /** column name */
  | 'isActive'
  /** column name */
  | 'lastActivity'
  /** column name */
  | 'locationData'
  /** column name */
  | 'logoutReason'
  /** column name */
  | 'sessionToken'
  /** column name */
  | 'userAgent'
  /** column name */
  | 'userId'
  | '%future added value';

export type UserSessionsUpdates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<UserSessionsAppendInput>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _deleteAtPath?: InputMaybe<UserSessionsDeleteAtPathInput>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _deleteElem?: InputMaybe<UserSessionsDeleteElemInput>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _deleteKey?: InputMaybe<UserSessionsDeleteKeyInput>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<UserSessionsPrependInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserSessionsSetInput>;
  /** filter the rows which have to be updated */
  where: UserSessionsBoolExp;
};

/** columns and relationships of "user_skills" */
export type UserSkills = {
  __typename?: 'UserSkills';
  proficiencyLevel?: Maybe<Scalars['String']['output']>;
  skillName?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "user_skills" */
export type UserSkillsAggregate = {
  __typename?: 'UserSkillsAggregate';
  aggregate?: Maybe<UserSkillsAggregateFields>;
  nodes: Array<UserSkills>;
};

export type UserSkillsAggregateBoolExp = {
  count?: InputMaybe<UserSkillsAggregateBoolExpCount>;
};

/** aggregate fields of "user_skills" */
export type UserSkillsAggregateFields = {
  __typename?: 'UserSkillsAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<UserSkillsMaxFields>;
  min?: Maybe<UserSkillsMinFields>;
};


/** aggregate fields of "user_skills" */
export type UserSkillsAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UserSkillsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_skills" */
export type UserSkillsAggregateOrderBy = {
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UserSkillsMaxOrderBy>;
  min?: InputMaybe<UserSkillsMinOrderBy>;
};

/** input type for inserting array relation for remote table "user_skills" */
export type UserSkillsArrRelInsertInput = {
  data: Array<UserSkillsInsertInput>;
};

/** Boolean expression to filter rows from the table "user_skills". All fields are combined with a logical 'AND'. */
export type UserSkillsBoolExp = {
  _and?: InputMaybe<Array<UserSkillsBoolExp>>;
  _not?: InputMaybe<UserSkillsBoolExp>;
  _or?: InputMaybe<Array<UserSkillsBoolExp>>;
  proficiencyLevel?: InputMaybe<StringComparisonExp>;
  skillName?: InputMaybe<StringComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
};

/** input type for inserting data into table "user_skills" */
export type UserSkillsInsertInput = {
  proficiencyLevel?: InputMaybe<Scalars['String']['input']>;
  skillName?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type UserSkillsMaxFields = {
  __typename?: 'UserSkillsMaxFields';
  proficiencyLevel?: Maybe<Scalars['String']['output']>;
  skillName?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_skills" */
export type UserSkillsMaxOrderBy = {
  proficiencyLevel?: InputMaybe<OrderBy>;
  skillName?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UserSkillsMinFields = {
  __typename?: 'UserSkillsMinFields';
  proficiencyLevel?: Maybe<Scalars['String']['output']>;
  skillName?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_skills" */
export type UserSkillsMinOrderBy = {
  proficiencyLevel?: InputMaybe<OrderBy>;
  skillName?: InputMaybe<OrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "user_skills" */
export type UserSkillsMutationResponse = {
  __typename?: 'UserSkillsMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserSkills>;
};

/** Ordering options when selecting data from "user_skills". */
export type UserSkillsOrderBy = {
  proficiencyLevel?: InputMaybe<OrderBy>;
  skillName?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
};

/** select columns of table "user_skills" */
export type UserSkillsSelectColumn =
  /** column name */
  | 'proficiencyLevel'
  /** column name */
  | 'skillName'
  /** column name */
  | 'userId'
  | '%future added value';

/** input type for updating data in table "user_skills" */
export type UserSkillsSetInput = {
  proficiencyLevel?: InputMaybe<Scalars['String']['input']>;
  skillName?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_skills" */
export type UserSkillsStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UserSkillsStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UserSkillsStreamCursorValueInput = {
  proficiencyLevel?: InputMaybe<Scalars['String']['input']>;
  skillName?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

export type UserSkillsUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserSkillsSetInput>;
  /** filter the rows which have to be updated */
  where: UserSkillsBoolExp;
};

/** Boolean expression to compare columns of type "user_status_enum". All fields are combined with logical 'AND'. */
export type UserStatusEnumComparisonExp = {
  _eq?: InputMaybe<Scalars['user_status_enum']['input']>;
  _gt?: InputMaybe<Scalars['user_status_enum']['input']>;
  _gte?: InputMaybe<Scalars['user_status_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['user_status_enum']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['user_status_enum']['input']>;
  _lte?: InputMaybe<Scalars['user_status_enum']['input']>;
  _neq?: InputMaybe<Scalars['user_status_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['user_status_enum']['input']>>;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'Users';
  /** An array relationship */
  acceptedInvitations: Array<UserInvitations>;
  /** An aggregate relationship */
  acceptedInvitationsAggregate: UserInvitationsAggregate;
  /** User address or location */
  address?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  approvedBillingItems: Array<BillingItems>;
  /** An aggregate relationship */
  approvedBillingItemsAggregate: BillingItemsAggregate;
  /** An array relationship */
  approvedEmailTemplates: Array<EmailTemplates>;
  /** An aggregate relationship */
  approvedEmailTemplatesAggregate: EmailTemplatesAggregate;
  /** An array relationship */
  assignmentChanges: Array<PayrollAssignmentAudit>;
  /** An aggregate relationship */
  assignmentChangesAggregate: PayrollAssignmentAuditAggregate;
  /** An array relationship */
  assignmentsMade: Array<PayrollAssignments>;
  /** An aggregate relationship */
  assignmentsMadeAggregate: PayrollAssignmentsAggregate;
  /** An array relationship */
  authoredNotes: Array<Notes>;
  /** An aggregate relationship */
  authoredNotesAggregate: NotesAggregate;
  /** An array relationship */
  backupPayrollAssignments: Array<Payrolls>;
  /** An aggregate relationship */
  backupPayrollAssignmentsAggregate: PayrollsAggregate;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: Maybe<Scalars['String']['output']>;
  /** User biography or description */
  bio?: Maybe<Scalars['String']['output']>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: Maybe<Scalars['String']['output']>;
  computedName?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  confirmedBillingItems: Array<BillingItems>;
  /** An aggregate relationship */
  confirmedBillingItemsAggregate: BillingItemsAggregate;
  /** An array relationship */
  consultantAssignments: Array<PayrollAssignments>;
  /** An aggregate relationship */
  consultantAssignmentsAggregate: PayrollAssignmentsAggregate;
  /** Cost center for internal accounting */
  costCenter?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the user was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  createdBillingEventLogs: Array<BillingEventLog>;
  /** An aggregate relationship */
  createdBillingEventLogsAggregate: BillingEventLogAggregate;
  /** An array relationship */
  createdClientServiceAgreements: Array<ClientServiceAgreements>;
  /** An aggregate relationship */
  createdClientServiceAgreementsAggregate: ClientServiceAgreementsAggregate;
  /** An array relationship */
  createdEmailTemplates: Array<EmailTemplates>;
  /** An aggregate relationship */
  createdEmailTemplatesAggregate: EmailTemplatesAggregate;
  /** An array relationship */
  createdPermissionOverrides: Array<PermissionOverrides>;
  /** An aggregate relationship */
  createdPermissionOverridesAggregate: PermissionOverridesAggregate;
  /** An array relationship */
  createdServicePricingRules: Array<ServicePricingRules>;
  /** An aggregate relationship */
  createdServicePricingRulesAggregate: ServicePricingRulesAggregate;
  /** An array relationship */
  createdServiceTemplates: Array<ServiceTemplates>;
  /** An aggregate relationship */
  createdServiceTemplatesAggregate: ServiceTemplatesAggregate;
  /** An array relationship */
  createdServices: Array<Services>;
  /** An aggregate relationship */
  createdServicesAggregate: ServicesAggregate;
  /** An array relationship */
  dataBackups: Array<DataBackups>;
  /** An aggregate relationship */
  dataBackupsAggregate: DataBackupsAggregate;
  deactivatedAt?: Maybe<Scalars['timestamptz']['output']>;
  deactivatedBy?: Maybe<Scalars['String']['output']>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
  /** User's email address (unique) */
  email: Scalars['String']['output'];
  /** An array relationship */
  emailDrafts: Array<EmailDrafts>;
  /** An aggregate relationship */
  emailDraftsAggregate: EmailDraftsAggregate;
  /** An array relationship */
  emailTemplateFavorites: Array<UserEmailTemplateFavorites>;
  /** An aggregate relationship */
  emailTemplateFavoritesAggregate: UserEmailTemplateFavoritesAggregate;
  firstName: Scalars['String']['output'];
  /** An array relationship */
  fromConsultantAudits: Array<PayrollAssignmentAudit>;
  /** An aggregate relationship */
  fromConsultantAuditsAggregate: PayrollAssignmentAuditAggregate;
  /** Unique identifier for the user */
  id: Scalars['uuid']['output'];
  /** URL to the user's profile image */
  image?: Maybe<Scalars['String']['output']>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  /** Whether the user is a staff member (vs. external user) */
  isStaff?: Maybe<Scalars['Boolean']['output']>;
  lastName: Scalars['String']['output'];
  /** An array relationship */
  leaveRecords: Array<Leave>;
  /** An aggregate relationship */
  leaveRecordsAggregate: LeaveAggregate;
  /** An array relationship */
  managedInvitations: Array<UserInvitations>;
  /** An aggregate relationship */
  managedInvitationsAggregate: UserInvitationsAggregate;
  /** An array relationship */
  managedPayrolls: Array<Payrolls>;
  /** An aggregate relationship */
  managedPayrollsAggregate: PayrollsAggregate;
  /** An array relationship */
  managedTeamMembers: Array<Users>;
  /** An aggregate relationship */
  managedTeamMembersAggregate: UsersAggregate;
  /** An array relationship */
  managedUsers: Array<Users>;
  /** An aggregate relationship */
  managedUsersAggregate: UsersAggregate;
  /** An object relationship */
  manager?: Maybe<Users>;
  /** Reference to the user's manager */
  managerId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  originalConsultantAssignments: Array<PayrollAssignments>;
  /** An aggregate relationship */
  originalConsultantAssignmentsAggregate: PayrollAssignmentsAggregate;
  /** An array relationship */
  payrollDateTimeEntries: Array<PayrollDateTimeEntries>;
  /** An aggregate relationship */
  payrollDateTimeEntriesAggregate: PayrollDateTimeEntriesAggregate;
  /** An array relationship */
  payrollDates: Array<PayrollDates>;
  /** An aggregate relationship */
  payrollDatesAggregate: PayrollDatesAggregate;
  /** An array relationship */
  payrollServiceAgreementsCreatedBy: Array<PayrollServiceAgreements>;
  /** An aggregate relationship */
  payrollServiceAgreementsCreatedByAggregate: PayrollServiceAgreementsAggregate;
  /** An array relationship */
  payrollServiceAgreementsGeneratedBy: Array<PayrollServiceAgreements>;
  /** An aggregate relationship */
  payrollServiceAgreementsGeneratedByAggregate: PayrollServiceAgreementsAggregate;
  /** An array relationship */
  permissionAuditLogs: Array<PermissionAuditLog>;
  /** An aggregate relationship */
  permissionAuditLogsAggregate: PermissionAuditLogAggregate;
  /** An array relationship */
  permissionOverrides: Array<PermissionOverrides>;
  /** An aggregate relationship */
  permissionOverridesAggregate: PermissionOverridesAggregate;
  /** User contact phone number */
  phone?: Maybe<Scalars['String']['output']>;
  /** Organizational position affecting admin time allocation */
  position?: Maybe<Scalars['user_position']['output']>;
  /** An array relationship */
  primaryPayrollAssignments: Array<Payrolls>;
  /** An aggregate relationship */
  primaryPayrollAssignmentsAggregate: PayrollsAggregate;
  /** An array relationship */
  quoteConversions: Array<QuoteConversions>;
  /** An aggregate relationship */
  quoteConversionsAggregate: QuoteConversionsAggregate;
  /** An array relationship */
  quoteTemplates: Array<QuoteTemplates>;
  /** An aggregate relationship */
  quoteTemplatesAggregate: QuoteTemplatesAggregate;
  /** An array relationship */
  quotes: Array<Quotes>;
  /** An aggregate relationship */
  quotesAggregate: QuotesAggregate;
  rateEffectiveFrom?: Maybe<Scalars['date']['output']>;
  /** An array relationship */
  resolvedSecurityAlerts: Array<SecurityAlerts>;
  /** An aggregate relationship */
  resolvedSecurityAlertsAggregate: SecurityAlertsAggregate;
  /** An array relationship */
  revokedInvitations: Array<UserInvitations>;
  /** An aggregate relationship */
  revokedInvitationsAggregate: UserInvitationsAggregate;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role: Scalars['user_role']['output'];
  /** An array relationship */
  roleAssignments: Array<UserRoles>;
  /** An aggregate relationship */
  roleAssignmentsAggregate: UserRolesAggregate;
  /** An array relationship */
  securityAlerts: Array<SecurityAlerts>;
  /** An aggregate relationship */
  securityAlertsAggregate: SecurityAlertsAggregate;
  /** An array relationship */
  securitySettings: Array<SecuritySettings>;
  /** An aggregate relationship */
  securitySettingsAggregate: SecuritySettingsAggregate;
  /** An array relationship */
  sentEmails: Array<EmailSendLogs>;
  /** An aggregate relationship */
  sentEmailsAggregate: EmailSendLogsAggregate;
  /** An array relationship */
  sentInvitations: Array<UserInvitations>;
  /** An aggregate relationship */
  sentInvitationsAggregate: UserInvitationsAggregate;
  /** An array relationship */
  skills: Array<UserSkills>;
  /** An aggregate relationship */
  skillsAggregate: UserSkillsAggregate;
  /** An array relationship */
  staffBillingItems: Array<BillingItems>;
  /** An aggregate relationship */
  staffBillingItemsAggregate: BillingItemsAggregate;
  /** Current user status - must be consistent with isActive field */
  status: Scalars['user_status_enum']['output'];
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: Maybe<Scalars['String']['output']>;
  /** Timestamp when status was last changed */
  statusChangedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User ID who changed the status */
  statusChangedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  statusChangedByUser?: Maybe<Users>;
  /** An array relationship */
  targetedPermissionAuditLogs: Array<PermissionAuditLog>;
  /** An aggregate relationship */
  targetedPermissionAuditLogsAggregate: PermissionAuditLogAggregate;
  /** An array relationship */
  timeEntries: Array<TimeEntries>;
  /** An aggregate relationship */
  timeEntriesAggregate: TimeEntriesAggregate;
  /** An array relationship */
  toConsultantAudits: Array<PayrollAssignmentAudit>;
  /** An aggregate relationship */
  toConsultantAuditsAggregate: PayrollAssignmentAuditAggregate;
  /** Timestamp when the user was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  updatedSecuritySettings: Array<SecuritySettings>;
  /** An aggregate relationship */
  updatedSecuritySettingsAggregate: SecuritySettingsAggregate;
  /** An array relationship */
  updatedServiceTemplates: Array<ServiceTemplates>;
  /** An aggregate relationship */
  updatedServiceTemplatesAggregate: ServiceTemplatesAggregate;
  /** An array relationship */
  updatedServices: Array<Services>;
  /** An aggregate relationship */
  updatedServicesAggregate: ServicesAggregate;
  /** An array relationship */
  uploadedFiles: Array<Files>;
  /** An aggregate relationship */
  uploadedFilesAggregate: FilesAggregate;
  /** An array relationship */
  userRateHistories: Array<UserRateHistory>;
  /** An aggregate relationship */
  userRateHistoriesAggregate: UserRateHistoryAggregate;
  /** An array relationship */
  userRateHistoriesCreatedBy: Array<UserRateHistory>;
  /** An aggregate relationship */
  userRateHistoriesCreatedByAggregate: UserRateHistoryAggregate;
  /** An array relationship */
  userSessions: Array<UserSessions>;
  /** An aggregate relationship */
  userSessionsAggregate: UserSessionsAggregate;
  /** User's unique username for login */
  username?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  usersWithStatusChanges: Array<Users>;
  /** An aggregate relationship */
  usersWithStatusChangesAggregate: UsersAggregate;
  /** An array relationship */
  workSchedules: Array<WorkSchedule>;
  /** An aggregate relationship */
  workSchedulesAggregate: WorkScheduleAggregate;
};


/** columns and relationships of "users" */
export type UsersAcceptedInvitationsArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAcceptedInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersApprovedBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersApprovedBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersApprovedEmailTemplatesArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersApprovedEmailTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAssignmentChangesArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAssignmentChangesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAssignmentsMadeArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAssignmentsMadeAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAuthoredNotesArgs = {
  distinctOn?: InputMaybe<Array<NotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
  where?: InputMaybe<NotesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersAuthoredNotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
  where?: InputMaybe<NotesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersBackupPayrollAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersBackupPayrollAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersConfirmedBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersConfirmedBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersConsultantAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersConsultantAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedBillingEventLogsArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedBillingEventLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedClientServiceAgreementsArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedClientServiceAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedEmailTemplatesArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedEmailTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedPermissionOverridesArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedPermissionOverridesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedServicePricingRulesArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedServicePricingRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedServiceTemplatesArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedServiceTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedServicesArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersCreatedServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersDataBackupsArgs = {
  distinctOn?: InputMaybe<Array<DataBackupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataBackupsOrderBy>>;
  where?: InputMaybe<DataBackupsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersDataBackupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DataBackupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataBackupsOrderBy>>;
  where?: InputMaybe<DataBackupsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersEmailDraftsArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersEmailDraftsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersEmailTemplateFavoritesArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersEmailTemplateFavoritesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFromConsultantAuditsArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "users" */
export type UsersFromConsultantAuditsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "users" */
export type UsersLeaveRecordsArgs = {
  distinctOn?: InputMaybe<Array<LeaveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeaveOrderBy>>;
  where?: InputMaybe<LeaveBoolExp>;
};


/** columns and relationships of "users" */
export type UsersLeaveRecordsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LeaveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeaveOrderBy>>;
  where?: InputMaybe<LeaveBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedInvitationsArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedPayrollsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedTeamMembersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedTeamMembersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersManagedUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersOriginalConsultantAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersOriginalConsultantAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollDateTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollDateTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollDatesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollDatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollServiceAgreementsCreatedByArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollServiceAgreementsCreatedByAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollServiceAgreementsGeneratedByArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPayrollServiceAgreementsGeneratedByAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPermissionAuditLogsArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPermissionAuditLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPermissionOverridesArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPermissionOverridesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPrimaryPayrollAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersPrimaryPayrollAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersQuoteConversionsArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersQuoteConversionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersQuoteTemplatesArgs = {
  distinctOn?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteTemplatesOrderBy>>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersQuoteTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteTemplatesOrderBy>>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersQuotesArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersQuotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersResolvedSecurityAlertsArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersResolvedSecurityAlertsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersRevokedInvitationsArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersRevokedInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersRoleAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersRoleAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSecurityAlertsArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSecurityAlertsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSecuritySettingsArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSecuritySettingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSentEmailsArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSentEmailsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSentInvitationsArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSentInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSkillsArgs = {
  distinctOn?: InputMaybe<Array<UserSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSkillsOrderBy>>;
  where?: InputMaybe<UserSkillsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersSkillsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSkillsOrderBy>>;
  where?: InputMaybe<UserSkillsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersStaffBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersStaffBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersTargetedPermissionAuditLogsArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


/** columns and relationships of "users" */
export type UsersTargetedPermissionAuditLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


/** columns and relationships of "users" */
export type UsersTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersToConsultantAuditsArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "users" */
export type UsersToConsultantAuditsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUpdatedSecuritySettingsArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUpdatedSecuritySettingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUpdatedServiceTemplatesArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUpdatedServiceTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUpdatedServicesArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUpdatedServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUploadedFilesArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUploadedFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUserRateHistoriesArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUserRateHistoriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUserRateHistoriesCreatedByArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUserRateHistoriesCreatedByAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUserSessionsArgs = {
  distinctOn?: InputMaybe<Array<UserSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSessionsOrderBy>>;
  where?: InputMaybe<UserSessionsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUserSessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSessionsOrderBy>>;
  where?: InputMaybe<UserSessionsBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUsersWithStatusChangesArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersUsersWithStatusChangesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


/** columns and relationships of "users" */
export type UsersWorkSchedulesArgs = {
  distinctOn?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkScheduleOrderBy>>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};


/** columns and relationships of "users" */
export type UsersWorkSchedulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkScheduleOrderBy>>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};

/** aggregated selection of "users" */
export type UsersAggregate = {
  __typename?: 'UsersAggregate';
  aggregate?: Maybe<UsersAggregateFields>;
  nodes: Array<Users>;
};

export type UsersAggregateBoolExp = {
  bool_and?: InputMaybe<UsersAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<UsersAggregateBoolExpBool_Or>;
  count?: InputMaybe<UsersAggregateBoolExpCount>;
};

/** aggregate fields of "users" */
export type UsersAggregateFields = {
  __typename?: 'UsersAggregateFields';
  avg?: Maybe<UsersAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<UsersMaxFields>;
  min?: Maybe<UsersMinFields>;
  stddev?: Maybe<UsersStddevFields>;
  stddevPop?: Maybe<UsersStddevPopFields>;
  stddevSamp?: Maybe<UsersStddevSampFields>;
  sum?: Maybe<UsersSumFields>;
  varPop?: Maybe<UsersVarPopFields>;
  varSamp?: Maybe<UsersVarSampFields>;
  variance?: Maybe<UsersVarianceFields>;
};


/** aggregate fields of "users" */
export type UsersAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "users" */
export type UsersAggregateOrderBy = {
  avg?: InputMaybe<UsersAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<UsersMaxOrderBy>;
  min?: InputMaybe<UsersMinOrderBy>;
  stddev?: InputMaybe<UsersStddevOrderBy>;
  stddevPop?: InputMaybe<UsersStddevPopOrderBy>;
  stddevSamp?: InputMaybe<UsersStddevSampOrderBy>;
  sum?: InputMaybe<UsersSumOrderBy>;
  varPop?: InputMaybe<UsersVarPopOrderBy>;
  varSamp?: InputMaybe<UsersVarSampOrderBy>;
  variance?: InputMaybe<UsersVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "users" */
export type UsersArrRelInsertInput = {
  data: Array<UsersInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<UsersOnConflict>;
};

/** aggregate avg on columns */
export type UsersAvgFields = {
  __typename?: 'UsersAvgFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "users" */
export type UsersAvgOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type UsersBoolExp = {
  _and?: InputMaybe<Array<UsersBoolExp>>;
  _not?: InputMaybe<UsersBoolExp>;
  _or?: InputMaybe<Array<UsersBoolExp>>;
  acceptedInvitations?: InputMaybe<UserInvitationsBoolExp>;
  acceptedInvitationsAggregate?: InputMaybe<UserInvitationsAggregateBoolExp>;
  address?: InputMaybe<StringComparisonExp>;
  approvedBillingItems?: InputMaybe<BillingItemsBoolExp>;
  approvedBillingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  approvedEmailTemplates?: InputMaybe<EmailTemplatesBoolExp>;
  approvedEmailTemplatesAggregate?: InputMaybe<EmailTemplatesAggregateBoolExp>;
  assignmentChanges?: InputMaybe<PayrollAssignmentAuditBoolExp>;
  assignmentChangesAggregate?: InputMaybe<PayrollAssignmentAuditAggregateBoolExp>;
  assignmentsMade?: InputMaybe<PayrollAssignmentsBoolExp>;
  assignmentsMadeAggregate?: InputMaybe<PayrollAssignmentsAggregateBoolExp>;
  authoredNotes?: InputMaybe<NotesBoolExp>;
  authoredNotesAggregate?: InputMaybe<NotesAggregateBoolExp>;
  backupPayrollAssignments?: InputMaybe<PayrollsBoolExp>;
  backupPayrollAssignmentsAggregate?: InputMaybe<PayrollsAggregateBoolExp>;
  billingCategory?: InputMaybe<StringComparisonExp>;
  bio?: InputMaybe<StringComparisonExp>;
  clerkUserId?: InputMaybe<StringComparisonExp>;
  computedName?: InputMaybe<StringComparisonExp>;
  confirmedBillingItems?: InputMaybe<BillingItemsBoolExp>;
  confirmedBillingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  consultantAssignments?: InputMaybe<PayrollAssignmentsBoolExp>;
  consultantAssignmentsAggregate?: InputMaybe<PayrollAssignmentsAggregateBoolExp>;
  costCenter?: InputMaybe<StringComparisonExp>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  createdBillingEventLogs?: InputMaybe<BillingEventLogBoolExp>;
  createdBillingEventLogsAggregate?: InputMaybe<BillingEventLogAggregateBoolExp>;
  createdClientServiceAgreements?: InputMaybe<ClientServiceAgreementsBoolExp>;
  createdClientServiceAgreementsAggregate?: InputMaybe<ClientServiceAgreementsAggregateBoolExp>;
  createdEmailTemplates?: InputMaybe<EmailTemplatesBoolExp>;
  createdEmailTemplatesAggregate?: InputMaybe<EmailTemplatesAggregateBoolExp>;
  createdPermissionOverrides?: InputMaybe<PermissionOverridesBoolExp>;
  createdPermissionOverridesAggregate?: InputMaybe<PermissionOverridesAggregateBoolExp>;
  createdServicePricingRules?: InputMaybe<ServicePricingRulesBoolExp>;
  createdServicePricingRulesAggregate?: InputMaybe<ServicePricingRulesAggregateBoolExp>;
  createdServiceTemplates?: InputMaybe<ServiceTemplatesBoolExp>;
  createdServiceTemplatesAggregate?: InputMaybe<ServiceTemplatesAggregateBoolExp>;
  createdServices?: InputMaybe<ServicesBoolExp>;
  createdServicesAggregate?: InputMaybe<ServicesAggregateBoolExp>;
  dataBackups?: InputMaybe<DataBackupsBoolExp>;
  dataBackupsAggregate?: InputMaybe<DataBackupsAggregateBoolExp>;
  deactivatedAt?: InputMaybe<TimestamptzComparisonExp>;
  deactivatedBy?: InputMaybe<StringComparisonExp>;
  defaultAdminTimePercentage?: InputMaybe<NumericComparisonExp>;
  defaultHourlyRate?: InputMaybe<NumericComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  emailDrafts?: InputMaybe<EmailDraftsBoolExp>;
  emailDraftsAggregate?: InputMaybe<EmailDraftsAggregateBoolExp>;
  emailTemplateFavorites?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
  emailTemplateFavoritesAggregate?: InputMaybe<UserEmailTemplateFavoritesAggregateBoolExp>;
  firstName?: InputMaybe<StringComparisonExp>;
  fromConsultantAudits?: InputMaybe<PayrollAssignmentAuditBoolExp>;
  fromConsultantAuditsAggregate?: InputMaybe<PayrollAssignmentAuditAggregateBoolExp>;
  id?: InputMaybe<UuidComparisonExp>;
  image?: InputMaybe<StringComparisonExp>;
  isActive?: InputMaybe<BooleanComparisonExp>;
  isStaff?: InputMaybe<BooleanComparisonExp>;
  lastName?: InputMaybe<StringComparisonExp>;
  leaveRecords?: InputMaybe<LeaveBoolExp>;
  leaveRecordsAggregate?: InputMaybe<LeaveAggregateBoolExp>;
  managedInvitations?: InputMaybe<UserInvitationsBoolExp>;
  managedInvitationsAggregate?: InputMaybe<UserInvitationsAggregateBoolExp>;
  managedPayrolls?: InputMaybe<PayrollsBoolExp>;
  managedPayrollsAggregate?: InputMaybe<PayrollsAggregateBoolExp>;
  managedTeamMembers?: InputMaybe<UsersBoolExp>;
  managedTeamMembersAggregate?: InputMaybe<UsersAggregateBoolExp>;
  managedUsers?: InputMaybe<UsersBoolExp>;
  managedUsersAggregate?: InputMaybe<UsersAggregateBoolExp>;
  manager?: InputMaybe<UsersBoolExp>;
  managerId?: InputMaybe<UuidComparisonExp>;
  originalConsultantAssignments?: InputMaybe<PayrollAssignmentsBoolExp>;
  originalConsultantAssignmentsAggregate?: InputMaybe<PayrollAssignmentsAggregateBoolExp>;
  payrollDateTimeEntries?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
  payrollDateTimeEntriesAggregate?: InputMaybe<PayrollDateTimeEntriesAggregateBoolExp>;
  payrollDates?: InputMaybe<PayrollDatesBoolExp>;
  payrollDatesAggregate?: InputMaybe<PayrollDatesAggregateBoolExp>;
  payrollServiceAgreementsCreatedBy?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  payrollServiceAgreementsCreatedByAggregate?: InputMaybe<PayrollServiceAgreementsAggregateBoolExp>;
  payrollServiceAgreementsGeneratedBy?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  payrollServiceAgreementsGeneratedByAggregate?: InputMaybe<PayrollServiceAgreementsAggregateBoolExp>;
  permissionAuditLogs?: InputMaybe<PermissionAuditLogBoolExp>;
  permissionAuditLogsAggregate?: InputMaybe<PermissionAuditLogAggregateBoolExp>;
  permissionOverrides?: InputMaybe<PermissionOverridesBoolExp>;
  permissionOverridesAggregate?: InputMaybe<PermissionOverridesAggregateBoolExp>;
  phone?: InputMaybe<StringComparisonExp>;
  position?: InputMaybe<UserPositionComparisonExp>;
  primaryPayrollAssignments?: InputMaybe<PayrollsBoolExp>;
  primaryPayrollAssignmentsAggregate?: InputMaybe<PayrollsAggregateBoolExp>;
  quoteConversions?: InputMaybe<QuoteConversionsBoolExp>;
  quoteConversionsAggregate?: InputMaybe<QuoteConversionsAggregateBoolExp>;
  quoteTemplates?: InputMaybe<QuoteTemplatesBoolExp>;
  quoteTemplatesAggregate?: InputMaybe<QuoteTemplatesAggregateBoolExp>;
  quotes?: InputMaybe<QuotesBoolExp>;
  quotesAggregate?: InputMaybe<QuotesAggregateBoolExp>;
  rateEffectiveFrom?: InputMaybe<DateComparisonExp>;
  resolvedSecurityAlerts?: InputMaybe<SecurityAlertsBoolExp>;
  resolvedSecurityAlertsAggregate?: InputMaybe<SecurityAlertsAggregateBoolExp>;
  revokedInvitations?: InputMaybe<UserInvitationsBoolExp>;
  revokedInvitationsAggregate?: InputMaybe<UserInvitationsAggregateBoolExp>;
  role?: InputMaybe<UserRoleComparisonExp>;
  roleAssignments?: InputMaybe<UserRolesBoolExp>;
  roleAssignmentsAggregate?: InputMaybe<UserRolesAggregateBoolExp>;
  securityAlerts?: InputMaybe<SecurityAlertsBoolExp>;
  securityAlertsAggregate?: InputMaybe<SecurityAlertsAggregateBoolExp>;
  securitySettings?: InputMaybe<SecuritySettingsBoolExp>;
  securitySettingsAggregate?: InputMaybe<SecuritySettingsAggregateBoolExp>;
  sentEmails?: InputMaybe<EmailSendLogsBoolExp>;
  sentEmailsAggregate?: InputMaybe<EmailSendLogsAggregateBoolExp>;
  sentInvitations?: InputMaybe<UserInvitationsBoolExp>;
  sentInvitationsAggregate?: InputMaybe<UserInvitationsAggregateBoolExp>;
  skills?: InputMaybe<UserSkillsBoolExp>;
  skillsAggregate?: InputMaybe<UserSkillsAggregateBoolExp>;
  staffBillingItems?: InputMaybe<BillingItemsBoolExp>;
  staffBillingItemsAggregate?: InputMaybe<BillingItemsAggregateBoolExp>;
  status?: InputMaybe<UserStatusEnumComparisonExp>;
  statusChangeReason?: InputMaybe<StringComparisonExp>;
  statusChangedAt?: InputMaybe<TimestamptzComparisonExp>;
  statusChangedBy?: InputMaybe<UuidComparisonExp>;
  statusChangedByUser?: InputMaybe<UsersBoolExp>;
  targetedPermissionAuditLogs?: InputMaybe<PermissionAuditLogBoolExp>;
  targetedPermissionAuditLogsAggregate?: InputMaybe<PermissionAuditLogAggregateBoolExp>;
  timeEntries?: InputMaybe<TimeEntriesBoolExp>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateBoolExp>;
  toConsultantAudits?: InputMaybe<PayrollAssignmentAuditBoolExp>;
  toConsultantAuditsAggregate?: InputMaybe<PayrollAssignmentAuditAggregateBoolExp>;
  updatedAt?: InputMaybe<TimestamptzComparisonExp>;
  updatedSecuritySettings?: InputMaybe<SecuritySettingsBoolExp>;
  updatedSecuritySettingsAggregate?: InputMaybe<SecuritySettingsAggregateBoolExp>;
  updatedServiceTemplates?: InputMaybe<ServiceTemplatesBoolExp>;
  updatedServiceTemplatesAggregate?: InputMaybe<ServiceTemplatesAggregateBoolExp>;
  updatedServices?: InputMaybe<ServicesBoolExp>;
  updatedServicesAggregate?: InputMaybe<ServicesAggregateBoolExp>;
  uploadedFiles?: InputMaybe<FilesBoolExp>;
  uploadedFilesAggregate?: InputMaybe<FilesAggregateBoolExp>;
  userRateHistories?: InputMaybe<UserRateHistoryBoolExp>;
  userRateHistoriesAggregate?: InputMaybe<UserRateHistoryAggregateBoolExp>;
  userRateHistoriesCreatedBy?: InputMaybe<UserRateHistoryBoolExp>;
  userRateHistoriesCreatedByAggregate?: InputMaybe<UserRateHistoryAggregateBoolExp>;
  userSessions?: InputMaybe<UserSessionsBoolExp>;
  userSessionsAggregate?: InputMaybe<UserSessionsAggregateBoolExp>;
  username?: InputMaybe<StringComparisonExp>;
  usersWithStatusChanges?: InputMaybe<UsersBoolExp>;
  usersWithStatusChangesAggregate?: InputMaybe<UsersAggregateBoolExp>;
  workSchedules?: InputMaybe<WorkScheduleBoolExp>;
  workSchedulesAggregate?: InputMaybe<WorkScheduleAggregateBoolExp>;
};

/** unique or primary key constraints on table "users" */
export type UsersConstraint =
  /** unique or primary key constraint on columns "clerk_user_id" */
  | 'users_clerk_user_id_key'
  /** unique or primary key constraint on columns "email" */
  | 'users_email_key'
  /** unique or primary key constraint on columns "id" */
  | 'users_pkey'
  /** unique or primary key constraint on columns "username" */
  | 'users_username_key'
  | '%future added value';

/** input type for incrementing numeric columns in table "users" */
export type UsersIncInput = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<Scalars['numeric']['input']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "users" */
export type UsersInsertInput = {
  acceptedInvitations?: InputMaybe<UserInvitationsArrRelInsertInput>;
  /** User address or location */
  address?: InputMaybe<Scalars['String']['input']>;
  approvedBillingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  approvedEmailTemplates?: InputMaybe<EmailTemplatesArrRelInsertInput>;
  assignmentChanges?: InputMaybe<PayrollAssignmentAuditArrRelInsertInput>;
  assignmentsMade?: InputMaybe<PayrollAssignmentsArrRelInsertInput>;
  authoredNotes?: InputMaybe<NotesArrRelInsertInput>;
  backupPayrollAssignments?: InputMaybe<PayrollsArrRelInsertInput>;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: InputMaybe<Scalars['String']['input']>;
  /** User biography or description */
  bio?: InputMaybe<Scalars['String']['input']>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: InputMaybe<Scalars['String']['input']>;
  confirmedBillingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  consultantAssignments?: InputMaybe<PayrollAssignmentsArrRelInsertInput>;
  /** Cost center for internal accounting */
  costCenter?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the user was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBillingEventLogs?: InputMaybe<BillingEventLogArrRelInsertInput>;
  createdClientServiceAgreements?: InputMaybe<ClientServiceAgreementsArrRelInsertInput>;
  createdEmailTemplates?: InputMaybe<EmailTemplatesArrRelInsertInput>;
  createdPermissionOverrides?: InputMaybe<PermissionOverridesArrRelInsertInput>;
  createdServicePricingRules?: InputMaybe<ServicePricingRulesArrRelInsertInput>;
  createdServiceTemplates?: InputMaybe<ServiceTemplatesArrRelInsertInput>;
  createdServices?: InputMaybe<ServicesArrRelInsertInput>;
  dataBackups?: InputMaybe<DataBackupsArrRelInsertInput>;
  deactivatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deactivatedBy?: InputMaybe<Scalars['String']['input']>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<Scalars['numeric']['input']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  /** User's email address (unique) */
  email?: InputMaybe<Scalars['String']['input']>;
  emailDrafts?: InputMaybe<EmailDraftsArrRelInsertInput>;
  emailTemplateFavorites?: InputMaybe<UserEmailTemplateFavoritesArrRelInsertInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fromConsultantAudits?: InputMaybe<PayrollAssignmentAuditArrRelInsertInput>;
  /** Unique identifier for the user */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** URL to the user's profile image */
  image?: InputMaybe<Scalars['String']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is a staff member (vs. external user) */
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  leaveRecords?: InputMaybe<LeaveArrRelInsertInput>;
  managedInvitations?: InputMaybe<UserInvitationsArrRelInsertInput>;
  managedPayrolls?: InputMaybe<PayrollsArrRelInsertInput>;
  managedTeamMembers?: InputMaybe<UsersArrRelInsertInput>;
  managedUsers?: InputMaybe<UsersArrRelInsertInput>;
  manager?: InputMaybe<UsersObjRelInsertInput>;
  /** Reference to the user's manager */
  managerId?: InputMaybe<Scalars['uuid']['input']>;
  originalConsultantAssignments?: InputMaybe<PayrollAssignmentsArrRelInsertInput>;
  payrollDateTimeEntries?: InputMaybe<PayrollDateTimeEntriesArrRelInsertInput>;
  payrollDates?: InputMaybe<PayrollDatesArrRelInsertInput>;
  payrollServiceAgreementsCreatedBy?: InputMaybe<PayrollServiceAgreementsArrRelInsertInput>;
  payrollServiceAgreementsGeneratedBy?: InputMaybe<PayrollServiceAgreementsArrRelInsertInput>;
  permissionAuditLogs?: InputMaybe<PermissionAuditLogArrRelInsertInput>;
  permissionOverrides?: InputMaybe<PermissionOverridesArrRelInsertInput>;
  /** User contact phone number */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Organizational position affecting admin time allocation */
  position?: InputMaybe<Scalars['user_position']['input']>;
  primaryPayrollAssignments?: InputMaybe<PayrollsArrRelInsertInput>;
  quoteConversions?: InputMaybe<QuoteConversionsArrRelInsertInput>;
  quoteTemplates?: InputMaybe<QuoteTemplatesArrRelInsertInput>;
  quotes?: InputMaybe<QuotesArrRelInsertInput>;
  rateEffectiveFrom?: InputMaybe<Scalars['date']['input']>;
  resolvedSecurityAlerts?: InputMaybe<SecurityAlertsArrRelInsertInput>;
  revokedInvitations?: InputMaybe<UserInvitationsArrRelInsertInput>;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role?: InputMaybe<Scalars['user_role']['input']>;
  roleAssignments?: InputMaybe<UserRolesArrRelInsertInput>;
  securityAlerts?: InputMaybe<SecurityAlertsArrRelInsertInput>;
  securitySettings?: InputMaybe<SecuritySettingsArrRelInsertInput>;
  sentEmails?: InputMaybe<EmailSendLogsArrRelInsertInput>;
  sentInvitations?: InputMaybe<UserInvitationsArrRelInsertInput>;
  skills?: InputMaybe<UserSkillsArrRelInsertInput>;
  staffBillingItems?: InputMaybe<BillingItemsArrRelInsertInput>;
  /** Current user status - must be consistent with isActive field */
  status?: InputMaybe<Scalars['user_status_enum']['input']>;
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when status was last changed */
  statusChangedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User ID who changed the status */
  statusChangedBy?: InputMaybe<Scalars['uuid']['input']>;
  statusChangedByUser?: InputMaybe<UsersObjRelInsertInput>;
  targetedPermissionAuditLogs?: InputMaybe<PermissionAuditLogArrRelInsertInput>;
  timeEntries?: InputMaybe<TimeEntriesArrRelInsertInput>;
  toConsultantAudits?: InputMaybe<PayrollAssignmentAuditArrRelInsertInput>;
  /** Timestamp when the user was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedSecuritySettings?: InputMaybe<SecuritySettingsArrRelInsertInput>;
  updatedServiceTemplates?: InputMaybe<ServiceTemplatesArrRelInsertInput>;
  updatedServices?: InputMaybe<ServicesArrRelInsertInput>;
  uploadedFiles?: InputMaybe<FilesArrRelInsertInput>;
  userRateHistories?: InputMaybe<UserRateHistoryArrRelInsertInput>;
  userRateHistoriesCreatedBy?: InputMaybe<UserRateHistoryArrRelInsertInput>;
  userSessions?: InputMaybe<UserSessionsArrRelInsertInput>;
  /** User's unique username for login */
  username?: InputMaybe<Scalars['String']['input']>;
  usersWithStatusChanges?: InputMaybe<UsersArrRelInsertInput>;
  workSchedules?: InputMaybe<WorkScheduleArrRelInsertInput>;
};

/** aggregate max on columns */
export type UsersMaxFields = {
  __typename?: 'UsersMaxFields';
  /** User address or location */
  address?: Maybe<Scalars['String']['output']>;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: Maybe<Scalars['String']['output']>;
  /** User biography or description */
  bio?: Maybe<Scalars['String']['output']>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: Maybe<Scalars['String']['output']>;
  computedName?: Maybe<Scalars['String']['output']>;
  /** Cost center for internal accounting */
  costCenter?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the user was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  deactivatedAt?: Maybe<Scalars['timestamptz']['output']>;
  deactivatedBy?: Maybe<Scalars['String']['output']>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
  /** User's email address (unique) */
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the user */
  id?: Maybe<Scalars['uuid']['output']>;
  /** URL to the user's profile image */
  image?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  /** Reference to the user's manager */
  managerId?: Maybe<Scalars['uuid']['output']>;
  /** User contact phone number */
  phone?: Maybe<Scalars['String']['output']>;
  /** Organizational position affecting admin time allocation */
  position?: Maybe<Scalars['user_position']['output']>;
  rateEffectiveFrom?: Maybe<Scalars['date']['output']>;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role?: Maybe<Scalars['user_role']['output']>;
  /** Current user status - must be consistent with isActive field */
  status?: Maybe<Scalars['user_status_enum']['output']>;
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: Maybe<Scalars['String']['output']>;
  /** Timestamp when status was last changed */
  statusChangedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User ID who changed the status */
  statusChangedBy?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the user was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User's unique username for login */
  username?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "users" */
export type UsersMaxOrderBy = {
  /** User address or location */
  address?: InputMaybe<OrderBy>;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: InputMaybe<OrderBy>;
  /** User biography or description */
  bio?: InputMaybe<OrderBy>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: InputMaybe<OrderBy>;
  computedName?: InputMaybe<OrderBy>;
  /** Cost center for internal accounting */
  costCenter?: InputMaybe<OrderBy>;
  /** Timestamp when the user was created */
  createdAt?: InputMaybe<OrderBy>;
  deactivatedAt?: InputMaybe<OrderBy>;
  deactivatedBy?: InputMaybe<OrderBy>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
  /** User's email address (unique) */
  email?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  /** Unique identifier for the user */
  id?: InputMaybe<OrderBy>;
  /** URL to the user's profile image */
  image?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  /** Reference to the user's manager */
  managerId?: InputMaybe<OrderBy>;
  /** User contact phone number */
  phone?: InputMaybe<OrderBy>;
  /** Organizational position affecting admin time allocation */
  position?: InputMaybe<OrderBy>;
  rateEffectiveFrom?: InputMaybe<OrderBy>;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role?: InputMaybe<OrderBy>;
  /** Current user status - must be consistent with isActive field */
  status?: InputMaybe<OrderBy>;
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: InputMaybe<OrderBy>;
  /** Timestamp when status was last changed */
  statusChangedAt?: InputMaybe<OrderBy>;
  /** User ID who changed the status */
  statusChangedBy?: InputMaybe<OrderBy>;
  /** Timestamp when the user was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** User's unique username for login */
  username?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type UsersMinFields = {
  __typename?: 'UsersMinFields';
  /** User address or location */
  address?: Maybe<Scalars['String']['output']>;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: Maybe<Scalars['String']['output']>;
  /** User biography or description */
  bio?: Maybe<Scalars['String']['output']>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: Maybe<Scalars['String']['output']>;
  computedName?: Maybe<Scalars['String']['output']>;
  /** Cost center for internal accounting */
  costCenter?: Maybe<Scalars['String']['output']>;
  /** Timestamp when the user was created */
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  deactivatedAt?: Maybe<Scalars['timestamptz']['output']>;
  deactivatedBy?: Maybe<Scalars['String']['output']>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
  /** User's email address (unique) */
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  /** Unique identifier for the user */
  id?: Maybe<Scalars['uuid']['output']>;
  /** URL to the user's profile image */
  image?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  /** Reference to the user's manager */
  managerId?: Maybe<Scalars['uuid']['output']>;
  /** User contact phone number */
  phone?: Maybe<Scalars['String']['output']>;
  /** Organizational position affecting admin time allocation */
  position?: Maybe<Scalars['user_position']['output']>;
  rateEffectiveFrom?: Maybe<Scalars['date']['output']>;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role?: Maybe<Scalars['user_role']['output']>;
  /** Current user status - must be consistent with isActive field */
  status?: Maybe<Scalars['user_status_enum']['output']>;
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: Maybe<Scalars['String']['output']>;
  /** Timestamp when status was last changed */
  statusChangedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User ID who changed the status */
  statusChangedBy?: Maybe<Scalars['uuid']['output']>;
  /** Timestamp when the user was last updated */
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  /** User's unique username for login */
  username?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "users" */
export type UsersMinOrderBy = {
  /** User address or location */
  address?: InputMaybe<OrderBy>;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: InputMaybe<OrderBy>;
  /** User biography or description */
  bio?: InputMaybe<OrderBy>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: InputMaybe<OrderBy>;
  computedName?: InputMaybe<OrderBy>;
  /** Cost center for internal accounting */
  costCenter?: InputMaybe<OrderBy>;
  /** Timestamp when the user was created */
  createdAt?: InputMaybe<OrderBy>;
  deactivatedAt?: InputMaybe<OrderBy>;
  deactivatedBy?: InputMaybe<OrderBy>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
  /** User's email address (unique) */
  email?: InputMaybe<OrderBy>;
  firstName?: InputMaybe<OrderBy>;
  /** Unique identifier for the user */
  id?: InputMaybe<OrderBy>;
  /** URL to the user's profile image */
  image?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  /** Reference to the user's manager */
  managerId?: InputMaybe<OrderBy>;
  /** User contact phone number */
  phone?: InputMaybe<OrderBy>;
  /** Organizational position affecting admin time allocation */
  position?: InputMaybe<OrderBy>;
  rateEffectiveFrom?: InputMaybe<OrderBy>;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role?: InputMaybe<OrderBy>;
  /** Current user status - must be consistent with isActive field */
  status?: InputMaybe<OrderBy>;
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: InputMaybe<OrderBy>;
  /** Timestamp when status was last changed */
  statusChangedAt?: InputMaybe<OrderBy>;
  /** User ID who changed the status */
  statusChangedBy?: InputMaybe<OrderBy>;
  /** Timestamp when the user was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** User's unique username for login */
  username?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "users" */
export type UsersMutationResponse = {
  __typename?: 'UsersMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type UsersObjRelInsertInput = {
  data: UsersInsertInput;
  /** upsert condition */
  onConflict?: InputMaybe<UsersOnConflict>;
};

/** on_conflict condition type for table "users" */
export type UsersOnConflict = {
  constraint: UsersConstraint;
  updateColumns?: Array<UsersUpdateColumn>;
  where?: InputMaybe<UsersBoolExp>;
};

/** Ordering options when selecting data from "users". */
export type UsersOrderBy = {
  acceptedInvitationsAggregate?: InputMaybe<UserInvitationsAggregateOrderBy>;
  address?: InputMaybe<OrderBy>;
  approvedBillingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  approvedEmailTemplatesAggregate?: InputMaybe<EmailTemplatesAggregateOrderBy>;
  assignmentChangesAggregate?: InputMaybe<PayrollAssignmentAuditAggregateOrderBy>;
  assignmentsMadeAggregate?: InputMaybe<PayrollAssignmentsAggregateOrderBy>;
  authoredNotesAggregate?: InputMaybe<NotesAggregateOrderBy>;
  backupPayrollAssignmentsAggregate?: InputMaybe<PayrollsAggregateOrderBy>;
  billingCategory?: InputMaybe<OrderBy>;
  bio?: InputMaybe<OrderBy>;
  clerkUserId?: InputMaybe<OrderBy>;
  computedName?: InputMaybe<OrderBy>;
  confirmedBillingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  consultantAssignmentsAggregate?: InputMaybe<PayrollAssignmentsAggregateOrderBy>;
  costCenter?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  createdBillingEventLogsAggregate?: InputMaybe<BillingEventLogAggregateOrderBy>;
  createdClientServiceAgreementsAggregate?: InputMaybe<ClientServiceAgreementsAggregateOrderBy>;
  createdEmailTemplatesAggregate?: InputMaybe<EmailTemplatesAggregateOrderBy>;
  createdPermissionOverridesAggregate?: InputMaybe<PermissionOverridesAggregateOrderBy>;
  createdServicePricingRulesAggregate?: InputMaybe<ServicePricingRulesAggregateOrderBy>;
  createdServiceTemplatesAggregate?: InputMaybe<ServiceTemplatesAggregateOrderBy>;
  createdServicesAggregate?: InputMaybe<ServicesAggregateOrderBy>;
  dataBackupsAggregate?: InputMaybe<DataBackupsAggregateOrderBy>;
  deactivatedAt?: InputMaybe<OrderBy>;
  deactivatedBy?: InputMaybe<OrderBy>;
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  defaultHourlyRate?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  emailDraftsAggregate?: InputMaybe<EmailDraftsAggregateOrderBy>;
  emailTemplateFavoritesAggregate?: InputMaybe<UserEmailTemplateFavoritesAggregateOrderBy>;
  firstName?: InputMaybe<OrderBy>;
  fromConsultantAuditsAggregate?: InputMaybe<PayrollAssignmentAuditAggregateOrderBy>;
  id?: InputMaybe<OrderBy>;
  image?: InputMaybe<OrderBy>;
  isActive?: InputMaybe<OrderBy>;
  isStaff?: InputMaybe<OrderBy>;
  lastName?: InputMaybe<OrderBy>;
  leaveRecordsAggregate?: InputMaybe<LeaveAggregateOrderBy>;
  managedInvitationsAggregate?: InputMaybe<UserInvitationsAggregateOrderBy>;
  managedPayrollsAggregate?: InputMaybe<PayrollsAggregateOrderBy>;
  managedTeamMembersAggregate?: InputMaybe<UsersAggregateOrderBy>;
  managedUsersAggregate?: InputMaybe<UsersAggregateOrderBy>;
  manager?: InputMaybe<UsersOrderBy>;
  managerId?: InputMaybe<OrderBy>;
  originalConsultantAssignmentsAggregate?: InputMaybe<PayrollAssignmentsAggregateOrderBy>;
  payrollDateTimeEntriesAggregate?: InputMaybe<PayrollDateTimeEntriesAggregateOrderBy>;
  payrollDatesAggregate?: InputMaybe<PayrollDatesAggregateOrderBy>;
  payrollServiceAgreementsCreatedByAggregate?: InputMaybe<PayrollServiceAgreementsAggregateOrderBy>;
  payrollServiceAgreementsGeneratedByAggregate?: InputMaybe<PayrollServiceAgreementsAggregateOrderBy>;
  permissionAuditLogsAggregate?: InputMaybe<PermissionAuditLogAggregateOrderBy>;
  permissionOverridesAggregate?: InputMaybe<PermissionOverridesAggregateOrderBy>;
  phone?: InputMaybe<OrderBy>;
  position?: InputMaybe<OrderBy>;
  primaryPayrollAssignmentsAggregate?: InputMaybe<PayrollsAggregateOrderBy>;
  quoteConversionsAggregate?: InputMaybe<QuoteConversionsAggregateOrderBy>;
  quoteTemplatesAggregate?: InputMaybe<QuoteTemplatesAggregateOrderBy>;
  quotesAggregate?: InputMaybe<QuotesAggregateOrderBy>;
  rateEffectiveFrom?: InputMaybe<OrderBy>;
  resolvedSecurityAlertsAggregate?: InputMaybe<SecurityAlertsAggregateOrderBy>;
  revokedInvitationsAggregate?: InputMaybe<UserInvitationsAggregateOrderBy>;
  role?: InputMaybe<OrderBy>;
  roleAssignmentsAggregate?: InputMaybe<UserRolesAggregateOrderBy>;
  securityAlertsAggregate?: InputMaybe<SecurityAlertsAggregateOrderBy>;
  securitySettingsAggregate?: InputMaybe<SecuritySettingsAggregateOrderBy>;
  sentEmailsAggregate?: InputMaybe<EmailSendLogsAggregateOrderBy>;
  sentInvitationsAggregate?: InputMaybe<UserInvitationsAggregateOrderBy>;
  skillsAggregate?: InputMaybe<UserSkillsAggregateOrderBy>;
  staffBillingItemsAggregate?: InputMaybe<BillingItemsAggregateOrderBy>;
  status?: InputMaybe<OrderBy>;
  statusChangeReason?: InputMaybe<OrderBy>;
  statusChangedAt?: InputMaybe<OrderBy>;
  statusChangedBy?: InputMaybe<OrderBy>;
  statusChangedByUser?: InputMaybe<UsersOrderBy>;
  targetedPermissionAuditLogsAggregate?: InputMaybe<PermissionAuditLogAggregateOrderBy>;
  timeEntriesAggregate?: InputMaybe<TimeEntriesAggregateOrderBy>;
  toConsultantAuditsAggregate?: InputMaybe<PayrollAssignmentAuditAggregateOrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  updatedSecuritySettingsAggregate?: InputMaybe<SecuritySettingsAggregateOrderBy>;
  updatedServiceTemplatesAggregate?: InputMaybe<ServiceTemplatesAggregateOrderBy>;
  updatedServicesAggregate?: InputMaybe<ServicesAggregateOrderBy>;
  uploadedFilesAggregate?: InputMaybe<FilesAggregateOrderBy>;
  userRateHistoriesAggregate?: InputMaybe<UserRateHistoryAggregateOrderBy>;
  userRateHistoriesCreatedByAggregate?: InputMaybe<UserRateHistoryAggregateOrderBy>;
  userSessionsAggregate?: InputMaybe<UserSessionsAggregateOrderBy>;
  username?: InputMaybe<OrderBy>;
  usersWithStatusChangesAggregate?: InputMaybe<UsersAggregateOrderBy>;
  workSchedulesAggregate?: InputMaybe<WorkScheduleAggregateOrderBy>;
};

/** primary key columns input for table: users */
export type UsersPkColumnsInput = {
  /** Unique identifier for the user */
  id: Scalars['uuid']['input'];
};

/** columns and relationships of "users_role_backup" */
export type UsersRoleBackup = {
  __typename?: 'UsersRoleBackup';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  role?: Maybe<Scalars['user_role']['output']>;
};

/** aggregated selection of "users_role_backup" */
export type UsersRoleBackupAggregate = {
  __typename?: 'UsersRoleBackupAggregate';
  aggregate?: Maybe<UsersRoleBackupAggregateFields>;
  nodes: Array<UsersRoleBackup>;
};

/** aggregate fields of "users_role_backup" */
export type UsersRoleBackupAggregateFields = {
  __typename?: 'UsersRoleBackupAggregateFields';
  count: Scalars['Int']['output'];
  max?: Maybe<UsersRoleBackupMaxFields>;
  min?: Maybe<UsersRoleBackupMinFields>;
};


/** aggregate fields of "users_role_backup" */
export type UsersRoleBackupAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<UsersRoleBackupSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "users_role_backup". All fields are combined with a logical 'AND'. */
export type UsersRoleBackupBoolExp = {
  _and?: InputMaybe<Array<UsersRoleBackupBoolExp>>;
  _not?: InputMaybe<UsersRoleBackupBoolExp>;
  _or?: InputMaybe<Array<UsersRoleBackupBoolExp>>;
  createdAt?: InputMaybe<TimestamptzComparisonExp>;
  email?: InputMaybe<StringComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  role?: InputMaybe<UserRoleComparisonExp>;
};

/** input type for inserting data into table "users_role_backup" */
export type UsersRoleBackupInsertInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<Scalars['user_role']['input']>;
};

/** aggregate max on columns */
export type UsersRoleBackupMaxFields = {
  __typename?: 'UsersRoleBackupMaxFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  role?: Maybe<Scalars['user_role']['output']>;
};

/** aggregate min on columns */
export type UsersRoleBackupMinFields = {
  __typename?: 'UsersRoleBackupMinFields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  role?: Maybe<Scalars['user_role']['output']>;
};

/** response of any mutation on the table "users_role_backup" */
export type UsersRoleBackupMutationResponse = {
  __typename?: 'UsersRoleBackupMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UsersRoleBackup>;
};

/** Ordering options when selecting data from "users_role_backup". */
export type UsersRoleBackupOrderBy = {
  createdAt?: InputMaybe<OrderBy>;
  email?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  role?: InputMaybe<OrderBy>;
};

/** select columns of table "users_role_backup" */
export type UsersRoleBackupSelectColumn =
  /** column name */
  | 'createdAt'
  /** column name */
  | 'email'
  /** column name */
  | 'id'
  /** column name */
  | 'role'
  | '%future added value';

/** input type for updating data in table "users_role_backup" */
export type UsersRoleBackupSetInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<Scalars['user_role']['input']>;
};

/** Streaming cursor of the table "users_role_backup" */
export type UsersRoleBackupStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsersRoleBackupStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersRoleBackupStreamCursorValueInput = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<Scalars['user_role']['input']>;
};

export type UsersRoleBackupUpdates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersRoleBackupSetInput>;
  /** filter the rows which have to be updated */
  where: UsersRoleBackupBoolExp;
};

/** select columns of table "users" */
export type UsersSelectColumn =
  /** column name */
  | 'address'
  /** column name */
  | 'billingCategory'
  /** column name */
  | 'bio'
  /** column name */
  | 'clerkUserId'
  /** column name */
  | 'computedName'
  /** column name */
  | 'costCenter'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'deactivatedAt'
  /** column name */
  | 'deactivatedBy'
  /** column name */
  | 'defaultAdminTimePercentage'
  /** column name */
  | 'defaultHourlyRate'
  /** column name */
  | 'email'
  /** column name */
  | 'firstName'
  /** column name */
  | 'id'
  /** column name */
  | 'image'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isStaff'
  /** column name */
  | 'lastName'
  /** column name */
  | 'managerId'
  /** column name */
  | 'phone'
  /** column name */
  | 'position'
  /** column name */
  | 'rateEffectiveFrom'
  /** column name */
  | 'role'
  /** column name */
  | 'status'
  /** column name */
  | 'statusChangeReason'
  /** column name */
  | 'statusChangedAt'
  /** column name */
  | 'statusChangedBy'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'username'
  | '%future added value';

/** select "usersAggregateBoolExpBool_andArgumentsColumns" columns of table "users" */
export type UsersSelectColumnUsersAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isStaff'
  | '%future added value';

/** select "usersAggregateBoolExpBool_orArgumentsColumns" columns of table "users" */
export type UsersSelectColumnUsersAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'isActive'
  /** column name */
  | 'isStaff'
  | '%future added value';

/** input type for updating data in table "users" */
export type UsersSetInput = {
  /** User address or location */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: InputMaybe<Scalars['String']['input']>;
  /** User biography or description */
  bio?: InputMaybe<Scalars['String']['input']>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: InputMaybe<Scalars['String']['input']>;
  /** Cost center for internal accounting */
  costCenter?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the user was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deactivatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deactivatedBy?: InputMaybe<Scalars['String']['input']>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<Scalars['numeric']['input']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  /** User's email address (unique) */
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the user */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** URL to the user's profile image */
  image?: InputMaybe<Scalars['String']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is a staff member (vs. external user) */
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Reference to the user's manager */
  managerId?: InputMaybe<Scalars['uuid']['input']>;
  /** User contact phone number */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Organizational position affecting admin time allocation */
  position?: InputMaybe<Scalars['user_position']['input']>;
  rateEffectiveFrom?: InputMaybe<Scalars['date']['input']>;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role?: InputMaybe<Scalars['user_role']['input']>;
  /** Current user status - must be consistent with isActive field */
  status?: InputMaybe<Scalars['user_status_enum']['input']>;
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when status was last changed */
  statusChangedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User ID who changed the status */
  statusChangedBy?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the user was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User's unique username for login */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type UsersStddevFields = {
  __typename?: 'UsersStddevFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "users" */
export type UsersStddevOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type UsersStddevPopFields = {
  __typename?: 'UsersStddevPopFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "users" */
export type UsersStddevPopOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type UsersStddevSampFields = {
  __typename?: 'UsersStddevSampFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "users" */
export type UsersStddevSampOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "users" */
export type UsersStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: UsersStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type UsersStreamCursorValueInput = {
  /** User address or location */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Category for billing purposes (consultant, manager, etc.) */
  billingCategory?: InputMaybe<Scalars['String']['input']>;
  /** User biography or description */
  bio?: InputMaybe<Scalars['String']['input']>;
  /** External identifier from Clerk authentication service */
  clerkUserId?: InputMaybe<Scalars['String']['input']>;
  computedName?: InputMaybe<Scalars['String']['input']>;
  /** Cost center for internal accounting */
  costCenter?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when the user was created */
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deactivatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deactivatedBy?: InputMaybe<Scalars['String']['input']>;
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<Scalars['numeric']['input']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<Scalars['numeric']['input']>;
  /** User's email address (unique) */
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Unique identifier for the user */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** URL to the user's profile image */
  image?: InputMaybe<Scalars['String']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is a staff member (vs. external user) */
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Reference to the user's manager */
  managerId?: InputMaybe<Scalars['uuid']['input']>;
  /** User contact phone number */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Organizational position affecting admin time allocation */
  position?: InputMaybe<Scalars['user_position']['input']>;
  rateEffectiveFrom?: InputMaybe<Scalars['date']['input']>;
  /** User's system role (viewer, consultant, manager, org_admin) */
  role?: InputMaybe<Scalars['user_role']['input']>;
  /** Current user status - must be consistent with isActive field */
  status?: InputMaybe<Scalars['user_status_enum']['input']>;
  /** Reason for the status change (for audit purposes) */
  statusChangeReason?: InputMaybe<Scalars['String']['input']>;
  /** Timestamp when status was last changed */
  statusChangedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User ID who changed the status */
  statusChangedBy?: InputMaybe<Scalars['uuid']['input']>;
  /** Timestamp when the user was last updated */
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  /** User's unique username for login */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type UsersSumFields = {
  __typename?: 'UsersSumFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['numeric']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "users" */
export type UsersSumOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** update columns of table "users" */
export type UsersUpdateColumn =
  /** column name */
  | 'address'
  /** column name */
  | 'billingCategory'
  /** column name */
  | 'bio'
  /** column name */
  | 'clerkUserId'
  /** column name */
  | 'costCenter'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'deactivatedAt'
  /** column name */
  | 'deactivatedBy'
  /** column name */
  | 'defaultAdminTimePercentage'
  /** column name */
  | 'defaultHourlyRate'
  /** column name */
  | 'email'
  /** column name */
  | 'firstName'
  /** column name */
  | 'id'
  /** column name */
  | 'image'
  /** column name */
  | 'isActive'
  /** column name */
  | 'isStaff'
  /** column name */
  | 'lastName'
  /** column name */
  | 'managerId'
  /** column name */
  | 'phone'
  /** column name */
  | 'position'
  /** column name */
  | 'rateEffectiveFrom'
  /** column name */
  | 'role'
  /** column name */
  | 'status'
  /** column name */
  | 'statusChangeReason'
  /** column name */
  | 'statusChangedAt'
  /** column name */
  | 'statusChangedBy'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'username'
  | '%future added value';

export type UsersUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<UsersIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UsersSetInput>;
  /** filter the rows which have to be updated */
  where: UsersBoolExp;
};

/** aggregate varPop on columns */
export type UsersVarPopFields = {
  __typename?: 'UsersVarPopFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "users" */
export type UsersVarPopOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type UsersVarSampFields = {
  __typename?: 'UsersVarSampFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "users" */
export type UsersVarSampOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type UsersVarianceFields = {
  __typename?: 'UsersVarianceFields';
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: Maybe<Scalars['Float']['output']>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "users" */
export type UsersVarianceOrderBy = {
  /** Default admin time percentage for this user */
  defaultAdminTimePercentage?: InputMaybe<OrderBy>;
  /** Default hourly rate for cost calculations */
  defaultHourlyRate?: InputMaybe<OrderBy>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type UuidArrayComparisonExp = {
  /** is the array contained in the given array value */
  _containedIn?: InputMaybe<Array<Scalars['uuid']['input']>>;
  /** does the array contain the given value */
  _contains?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _eq?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _gt?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _gte?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _in?: InputMaybe<Array<Array<Scalars['uuid']['input']>>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _lte?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _neq?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _nin?: InputMaybe<Array<Array<Scalars['uuid']['input']>>>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type UuidComparisonExp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _isNull?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

/** columns and relationships of "work_schedule" */
export type WorkSchedule = {
  __typename?: 'WorkSchedule';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp when the schedule entry was created */
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Unique identifier for the work schedule entry */
  id: Scalars['uuid']['output'];
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** An object relationship */
  user: Users;
  /** Reference to the user this schedule belongs to */
  userId: Scalars['uuid']['output'];
  /** Whether to use position-based default admin time or custom override */
  usesDefaultAdminTime?: Maybe<Scalars['Boolean']['output']>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay: Scalars['String']['output'];
  /** Number of hours worked on this day */
  workHours: Scalars['numeric']['output'];
};

/** aggregated selection of "work_schedule" */
export type WorkScheduleAggregate = {
  __typename?: 'WorkScheduleAggregate';
  aggregate?: Maybe<WorkScheduleAggregateFields>;
  nodes: Array<WorkSchedule>;
};

export type WorkScheduleAggregateBoolExp = {
  bool_and?: InputMaybe<WorkScheduleAggregateBoolExpBool_And>;
  bool_or?: InputMaybe<WorkScheduleAggregateBoolExpBool_Or>;
  count?: InputMaybe<WorkScheduleAggregateBoolExpCount>;
};

/** aggregate fields of "work_schedule" */
export type WorkScheduleAggregateFields = {
  __typename?: 'WorkScheduleAggregateFields';
  avg?: Maybe<WorkScheduleAvgFields>;
  count: Scalars['Int']['output'];
  max?: Maybe<WorkScheduleMaxFields>;
  min?: Maybe<WorkScheduleMinFields>;
  stddev?: Maybe<WorkScheduleStddevFields>;
  stddevPop?: Maybe<WorkScheduleStddevPopFields>;
  stddevSamp?: Maybe<WorkScheduleStddevSampFields>;
  sum?: Maybe<WorkScheduleSumFields>;
  varPop?: Maybe<WorkScheduleVarPopFields>;
  varSamp?: Maybe<WorkScheduleVarSampFields>;
  variance?: Maybe<WorkScheduleVarianceFields>;
};


/** aggregate fields of "work_schedule" */
export type WorkScheduleAggregateFieldsCountArgs = {
  columns?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "work_schedule" */
export type WorkScheduleAggregateOrderBy = {
  avg?: InputMaybe<WorkScheduleAvgOrderBy>;
  count?: InputMaybe<OrderBy>;
  max?: InputMaybe<WorkScheduleMaxOrderBy>;
  min?: InputMaybe<WorkScheduleMinOrderBy>;
  stddev?: InputMaybe<WorkScheduleStddevOrderBy>;
  stddevPop?: InputMaybe<WorkScheduleStddevPopOrderBy>;
  stddevSamp?: InputMaybe<WorkScheduleStddevSampOrderBy>;
  sum?: InputMaybe<WorkScheduleSumOrderBy>;
  varPop?: InputMaybe<WorkScheduleVarPopOrderBy>;
  varSamp?: InputMaybe<WorkScheduleVarSampOrderBy>;
  variance?: InputMaybe<WorkScheduleVarianceOrderBy>;
};

/** input type for inserting array relation for remote table "work_schedule" */
export type WorkScheduleArrRelInsertInput = {
  data: Array<WorkScheduleInsertInput>;
  /** upsert condition */
  onConflict?: InputMaybe<WorkScheduleOnConflict>;
};

/** aggregate avg on columns */
export type WorkScheduleAvgFields = {
  __typename?: 'WorkScheduleAvgFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "work_schedule" */
export type WorkScheduleAvgOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** Boolean expression to filter rows from the table "work_schedule". All fields are combined with a logical 'AND'. */
export type WorkScheduleBoolExp = {
  _and?: InputMaybe<Array<WorkScheduleBoolExp>>;
  _not?: InputMaybe<WorkScheduleBoolExp>;
  _or?: InputMaybe<Array<WorkScheduleBoolExp>>;
  adminTimeHours?: InputMaybe<NumericComparisonExp>;
  createdAt?: InputMaybe<TimestampComparisonExp>;
  id?: InputMaybe<UuidComparisonExp>;
  payrollCapacityHours?: InputMaybe<NumericComparisonExp>;
  updatedAt?: InputMaybe<TimestampComparisonExp>;
  user?: InputMaybe<UsersBoolExp>;
  userId?: InputMaybe<UuidComparisonExp>;
  usesDefaultAdminTime?: InputMaybe<BooleanComparisonExp>;
  workDay?: InputMaybe<StringComparisonExp>;
  workHours?: InputMaybe<NumericComparisonExp>;
};

/** unique or primary key constraints on table "work_schedule" */
export type WorkScheduleConstraint =
  /** unique or primary key constraint on columns "user_id", "work_day" */
  | 'unique_user_work_day'
  /** unique or primary key constraint on columns "id" */
  | 'work_schedule_pkey'
  | '%future added value';

/** input type for incrementing numeric columns in table "work_schedule" */
export type WorkScheduleIncInput = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** input type for inserting data into table "work_schedule" */
export type WorkScheduleInsertInput = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp when the schedule entry was created */
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Unique identifier for the work schedule entry */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  user?: InputMaybe<UsersObjRelInsertInput>;
  /** Reference to the user this schedule belongs to */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether to use position-based default admin time or custom override */
  usesDefaultAdminTime?: InputMaybe<Scalars['Boolean']['input']>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay?: InputMaybe<Scalars['String']['input']>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate max on columns */
export type WorkScheduleMaxFields = {
  __typename?: 'WorkScheduleMaxFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp when the schedule entry was created */
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Unique identifier for the work schedule entry */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** Reference to the user this schedule belongs to */
  userId?: Maybe<Scalars['uuid']['output']>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay?: Maybe<Scalars['String']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** order by max() on columns of table "work_schedule" */
export type WorkScheduleMaxOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Timestamp when the schedule entry was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Unique identifier for the work schedule entry */
  id?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** Reference to the user this schedule belongs to */
  userId?: InputMaybe<OrderBy>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** aggregate min on columns */
export type WorkScheduleMinFields = {
  __typename?: 'WorkScheduleMinFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp when the schedule entry was created */
  createdAt?: Maybe<Scalars['timestamp']['output']>;
  /** Unique identifier for the work schedule entry */
  id?: Maybe<Scalars['uuid']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: Maybe<Scalars['timestamp']['output']>;
  /** Reference to the user this schedule belongs to */
  userId?: Maybe<Scalars['uuid']['output']>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay?: Maybe<Scalars['String']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** order by min() on columns of table "work_schedule" */
export type WorkScheduleMinOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Timestamp when the schedule entry was created */
  createdAt?: InputMaybe<OrderBy>;
  /** Unique identifier for the work schedule entry */
  id?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: InputMaybe<OrderBy>;
  /** Reference to the user this schedule belongs to */
  userId?: InputMaybe<OrderBy>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** response of any mutation on the table "work_schedule" */
export type WorkScheduleMutationResponse = {
  __typename?: 'WorkScheduleMutationResponse';
  /** number of rows affected by the mutation */
  affectedRows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<WorkSchedule>;
};

/** on_conflict condition type for table "work_schedule" */
export type WorkScheduleOnConflict = {
  constraint: WorkScheduleConstraint;
  updateColumns?: Array<WorkScheduleUpdateColumn>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};

/** Ordering options when selecting data from "work_schedule". */
export type WorkScheduleOrderBy = {
  adminTimeHours?: InputMaybe<OrderBy>;
  createdAt?: InputMaybe<OrderBy>;
  id?: InputMaybe<OrderBy>;
  payrollCapacityHours?: InputMaybe<OrderBy>;
  updatedAt?: InputMaybe<OrderBy>;
  user?: InputMaybe<UsersOrderBy>;
  userId?: InputMaybe<OrderBy>;
  usesDefaultAdminTime?: InputMaybe<OrderBy>;
  workDay?: InputMaybe<OrderBy>;
  workHours?: InputMaybe<OrderBy>;
};

/** primary key columns input for table: work_schedule */
export type WorkSchedulePkColumnsInput = {
  /** Unique identifier for the work schedule entry */
  id: Scalars['uuid']['input'];
};

/** select columns of table "work_schedule" */
export type WorkScheduleSelectColumn =
  /** column name */
  | 'adminTimeHours'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'payrollCapacityHours'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  /** column name */
  | 'usesDefaultAdminTime'
  /** column name */
  | 'workDay'
  /** column name */
  | 'workHours'
  | '%future added value';

/** select "workScheduleAggregateBoolExpBool_andArgumentsColumns" columns of table "work_schedule" */
export type WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_AndArgumentsColumns =
  /** column name */
  | 'usesDefaultAdminTime'
  | '%future added value';

/** select "workScheduleAggregateBoolExpBool_orArgumentsColumns" columns of table "work_schedule" */
export type WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_OrArgumentsColumns =
  /** column name */
  | 'usesDefaultAdminTime'
  | '%future added value';

/** input type for updating data in table "work_schedule" */
export type WorkScheduleSetInput = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp when the schedule entry was created */
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Unique identifier for the work schedule entry */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Reference to the user this schedule belongs to */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether to use position-based default admin time or custom override */
  usesDefaultAdminTime?: InputMaybe<Scalars['Boolean']['input']>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay?: InputMaybe<Scalars['String']['input']>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate stddev on columns */
export type WorkScheduleStddevFields = {
  __typename?: 'WorkScheduleStddevFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "work_schedule" */
export type WorkScheduleStddevOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** aggregate stddevPop on columns */
export type WorkScheduleStddevPopFields = {
  __typename?: 'WorkScheduleStddevPopFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevPop() on columns of table "work_schedule" */
export type WorkScheduleStddevPopOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** aggregate stddevSamp on columns */
export type WorkScheduleStddevSampFields = {
  __typename?: 'WorkScheduleStddevSampFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** order by stddevSamp() on columns of table "work_schedule" */
export type WorkScheduleStddevSampOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** Streaming cursor of the table "work_schedule" */
export type WorkScheduleStreamCursorInput = {
  /** Stream column input with initial value */
  initialValue: WorkScheduleStreamCursorValueInput;
  /** cursor ordering */
  ordering?: InputMaybe<CursorOrdering>;
};

/** Initial value of the column from where the streaming should start */
export type WorkScheduleStreamCursorValueInput = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp when the schedule entry was created */
  createdAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Unique identifier for the work schedule entry */
  id?: InputMaybe<Scalars['uuid']['input']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<Scalars['numeric']['input']>;
  /** Timestamp when the schedule entry was last updated */
  updatedAt?: InputMaybe<Scalars['timestamp']['input']>;
  /** Reference to the user this schedule belongs to */
  userId?: InputMaybe<Scalars['uuid']['input']>;
  /** Whether to use position-based default admin time or custom override */
  usesDefaultAdminTime?: InputMaybe<Scalars['Boolean']['input']>;
  /** Day of the week (Monday, Tuesday, etc.) */
  workDay?: InputMaybe<Scalars['String']['input']>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<Scalars['numeric']['input']>;
};

/** aggregate sum on columns */
export type WorkScheduleSumFields = {
  __typename?: 'WorkScheduleSumFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['numeric']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['numeric']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['numeric']['output']>;
};

/** order by sum() on columns of table "work_schedule" */
export type WorkScheduleSumOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** update columns of table "work_schedule" */
export type WorkScheduleUpdateColumn =
  /** column name */
  | 'adminTimeHours'
  /** column name */
  | 'createdAt'
  /** column name */
  | 'id'
  /** column name */
  | 'payrollCapacityHours'
  /** column name */
  | 'updatedAt'
  /** column name */
  | 'userId'
  /** column name */
  | 'usesDefaultAdminTime'
  /** column name */
  | 'workDay'
  /** column name */
  | 'workHours'
  | '%future added value';

export type WorkScheduleUpdates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<WorkScheduleIncInput>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<WorkScheduleSetInput>;
  /** filter the rows which have to be updated */
  where: WorkScheduleBoolExp;
};

/** aggregate varPop on columns */
export type WorkScheduleVarPopFields = {
  __typename?: 'WorkScheduleVarPopFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** order by varPop() on columns of table "work_schedule" */
export type WorkScheduleVarPopOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** aggregate varSamp on columns */
export type WorkScheduleVarSampFields = {
  __typename?: 'WorkScheduleVarSampFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** order by varSamp() on columns of table "work_schedule" */
export type WorkScheduleVarSampOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

/** aggregate variance on columns */
export type WorkScheduleVarianceFields = {
  __typename?: 'WorkScheduleVarianceFields';
  /** Hours allocated to administrative tasks */
  adminTimeHours?: Maybe<Scalars['Float']['output']>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: Maybe<Scalars['Float']['output']>;
  /** Number of hours worked on this day */
  workHours?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "work_schedule" */
export type WorkScheduleVarianceOrderBy = {
  /** Hours allocated to administrative tasks */
  adminTimeHours?: InputMaybe<OrderBy>;
  /** Hours available for payroll processing (work_hours - admin_time_hours) */
  payrollCapacityHours?: InputMaybe<OrderBy>;
  /** Number of hours worked on this day */
  workHours?: InputMaybe<OrderBy>;
};

export type _Service = {
  __typename?: '_Service';
  /** SDL representation of schema */
  sdl: Scalars['String']['output'];
};

export type AdjustmentRulesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<AdjustmentRulesBoolExp>;
  predicate: IntComparisonExp;
};

export type BillingEventLogAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingEventLogBoolExp>;
  predicate: IntComparisonExp;
};

export type BillingInvoiceAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingInvoiceBoolExp>;
  predicate: IntComparisonExp;
};

export type BillingInvoiceItemAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingInvoiceItemBoolExp>;
  predicate: IntComparisonExp;
};

export type BillingItemsAggregateBoolExpBool_And = {
  arguments: BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingItemsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type BillingItemsAggregateBoolExpBool_Or = {
  arguments: BillingItemsSelectColumnBillingItemsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingItemsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type BillingItemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<BillingItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingItemsBoolExp>;
  predicate: IntComparisonExp;
};

export type BillingPeriodsAggregateBoolExpBool_And = {
  arguments: BillingPeriodsSelectColumnBillingPeriodsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingPeriodsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type BillingPeriodsAggregateBoolExpBool_Or = {
  arguments: BillingPeriodsSelectColumnBillingPeriodsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingPeriodsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type BillingPeriodsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BillingPeriodsBoolExp>;
  predicate: IntComparisonExp;
};

export type ClientExternalSystemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClientExternalSystemsBoolExp>;
  predicate: IntComparisonExp;
};

export type ClientServiceAgreementsAggregateBoolExpBool_And = {
  arguments: ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClientServiceAgreementsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ClientServiceAgreementsAggregateBoolExpBool_Or = {
  arguments: ClientServiceAgreementsSelectColumnClientServiceAgreementsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClientServiceAgreementsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ClientServiceAgreementsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ClientServiceAgreementsBoolExp>;
  predicate: IntComparisonExp;
};

export type CreatePayrollVersionArgs = {
  p_created_by_user_id?: InputMaybe<Scalars['uuid']['input']>;
  p_go_live_date?: InputMaybe<Scalars['date']['input']>;
  p_new_backup_consultant_user_id?: InputMaybe<Scalars['uuid']['input']>;
  p_new_client_id?: InputMaybe<Scalars['uuid']['input']>;
  p_new_cycle_id?: InputMaybe<Scalars['uuid']['input']>;
  p_new_date_type_id?: InputMaybe<Scalars['uuid']['input']>;
  p_new_date_value?: InputMaybe<Scalars['Int']['input']>;
  p_new_manager_user_id?: InputMaybe<Scalars['uuid']['input']>;
  p_new_name?: InputMaybe<Scalars['String']['input']>;
  p_new_primary_consultant_user_id?: InputMaybe<Scalars['uuid']['input']>;
  p_original_payroll_id?: InputMaybe<Scalars['uuid']['input']>;
  p_version_reason?: InputMaybe<Scalars['String']['input']>;
};

export type CreatePayrollVersionSimpleArgs = {
  payroll_id?: InputMaybe<Scalars['uuid']['input']>;
  version_reason?: InputMaybe<Scalars['String']['input']>;
};

export type DataBackupsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<DataBackupsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DataBackupsBoolExp>;
  predicate: IntComparisonExp;
};

export type EmailDraftsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<EmailDraftsBoolExp>;
  predicate: IntComparisonExp;
};

export type EmailSendLogsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<EmailSendLogsBoolExp>;
  predicate: IntComparisonExp;
};

export type EmailTemplatesAggregateBoolExpBool_And = {
  arguments: EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<EmailTemplatesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EmailTemplatesAggregateBoolExpBool_Or = {
  arguments: EmailTemplatesSelectColumnEmailTemplatesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<EmailTemplatesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type EmailTemplatesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<EmailTemplatesBoolExp>;
  predicate: IntComparisonExp;
};

export type FilesAggregateBoolExpBool_And = {
  arguments: FilesSelectColumnFilesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FilesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type FilesAggregateBoolExpBool_Or = {
  arguments: FilesSelectColumnFilesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FilesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type FilesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<FilesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FilesBoolExp>;
  predicate: IntComparisonExp;
};

export type GeneratePayrollDatesArgs = {
  p_end_date?: InputMaybe<Scalars['date']['input']>;
  p_max_dates?: InputMaybe<Scalars['Int']['input']>;
  p_payroll_id?: InputMaybe<Scalars['uuid']['input']>;
  p_start_date?: InputMaybe<Scalars['date']['input']>;
};

export type GetLatestPayrollVersionArgs = {
  payroll_id?: InputMaybe<Scalars['uuid']['input']>;
};

export type GetPayrollVersionHistoryArgs = {
  payroll_id?: InputMaybe<Scalars['uuid']['input']>;
};

export type LeaveAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<LeaveSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<LeaveBoolExp>;
  predicate: IntComparisonExp;
};

export type MonthlyBillingCompletionAggregateBoolExpBool_And = {
  arguments: MonthlyBillingCompletionSelectColumnMonthlyBillingCompletionAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MonthlyBillingCompletionBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MonthlyBillingCompletionAggregateBoolExpBool_Or = {
  arguments: MonthlyBillingCompletionSelectColumnMonthlyBillingCompletionAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MonthlyBillingCompletionBoolExp>;
  predicate: BooleanComparisonExp;
};

export type MonthlyBillingCompletionAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MonthlyBillingCompletionBoolExp>;
  predicate: IntComparisonExp;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** execute VOLATILE function "activate_payroll_versions" which returns "payroll_activation_results" */
  activatePayrollVersions: Array<PayrollActivationResults>;
  /** execute VOLATILE function "create_payroll_version" which returns "payroll_version_results" */
  createPayrollVersion: Array<PayrollVersionResults>;
  /** execute VOLATILE function "create_payroll_version_simple" which returns "payroll_version_results" */
  createPayrollVersionSimple: Array<PayrollVersionResults>;
  /** delete data from the table: "adjustment_rules" */
  deleteAdjustmentRules?: Maybe<AdjustmentRulesMutationResponse>;
  /** delete single row from the table: "adjustment_rules" */
  deleteAdjustmentRulesByPk?: Maybe<AdjustmentRules>;
  /** delete data from the table: "app_settings" */
  deleteAppSettings?: Maybe<AppSettingsMutationResponse>;
  /** delete single row from the table: "app_settings" */
  deleteAppSettingsByPk?: Maybe<AppSettings>;
  /** delete data from the table: "audit.audit_log" */
  deleteAuditAuditLog?: Maybe<AuditAuditLogMutationResponse>;
  /** delete single row from the table: "audit.audit_log" */
  deleteAuditAuditLogByPk?: Maybe<AuditAuditLog>;
  /** delete data from the table: "audit.auth_events" */
  deleteAuditAuthEvents?: Maybe<AuditAuthEventsMutationResponse>;
  /** delete single row from the table: "audit.auth_events" */
  deleteAuditAuthEventsByPk?: Maybe<AuditAuthEvents>;
  /** delete data from the table: "audit.data_access_log" */
  deleteAuditDataAccessLog?: Maybe<AuditDataAccessLogMutationResponse>;
  /** delete single row from the table: "audit.data_access_log" */
  deleteAuditDataAccessLogByPk?: Maybe<AuditDataAccessLog>;
  /** delete data from the table: "audit.permission_changes" */
  deleteAuditPermissionChanges?: Maybe<AuditPermissionChangesMutationResponse>;
  /** delete single row from the table: "audit.permission_changes" */
  deleteAuditPermissionChangesByPk?: Maybe<AuditPermissionChanges>;
  /** delete data from the table: "audit.slow_queries" */
  deleteAuditSlowQueries?: Maybe<AuditSlowQueriesMutationResponse>;
  /** delete single row from the table: "audit.slow_queries" */
  deleteAuditSlowQueriesByPk?: Maybe<AuditSlowQueries>;
  /** delete data from the table: "audit.user_access_summary" */
  deleteAuditUserAccessSummary?: Maybe<AuditUserAccessSummaryMutationResponse>;
  /** delete data from the table: "billing_event_log" */
  deleteBillingEventLog?: Maybe<BillingEventLogMutationResponse>;
  /** delete single row from the table: "billing_event_log" */
  deleteBillingEventLogByPk?: Maybe<BillingEventLog>;
  /** delete data from the table: "billing_invoice" */
  deleteBillingInvoice?: Maybe<BillingInvoiceMutationResponse>;
  /** delete single row from the table: "billing_invoice" */
  deleteBillingInvoiceByPk?: Maybe<BillingInvoice>;
  /** delete data from the table: "billing_invoice_item" */
  deleteBillingInvoiceItem?: Maybe<BillingInvoiceItemMutationResponse>;
  /** delete single row from the table: "billing_invoice_item" */
  deleteBillingInvoiceItemByPk?: Maybe<BillingInvoiceItem>;
  /** delete data from the table: "billing_items" */
  deleteBillingItems?: Maybe<BillingItemsMutationResponse>;
  /** delete single row from the table: "billing_items" */
  deleteBillingItemsByPk?: Maybe<BillingItems>;
  /** delete data from the table: "billing_periods" */
  deleteBillingPeriods?: Maybe<BillingPeriodsMutationResponse>;
  /** delete single row from the table: "billing_periods" */
  deleteBillingPeriodsByPk?: Maybe<BillingPeriods>;
  /** delete data from the table: "client_external_systems" */
  deleteClientExternalSystems?: Maybe<ClientExternalSystemsMutationResponse>;
  /** delete single row from the table: "client_external_systems" */
  deleteClientExternalSystemsByPk?: Maybe<ClientExternalSystems>;
  /** delete data from the table: "client_service_agreements" */
  deleteClientServiceAgreements?: Maybe<ClientServiceAgreementsMutationResponse>;
  /** delete single row from the table: "client_service_agreements" */
  deleteClientServiceAgreementsByPk?: Maybe<ClientServiceAgreements>;
  /** delete data from the table: "clients" */
  deleteClients?: Maybe<ClientsMutationResponse>;
  /** delete single row from the table: "clients" */
  deleteClientsByPk?: Maybe<Clients>;
  /** delete data from the table: "data_backups" */
  deleteDataBackups?: Maybe<DataBackupsMutationResponse>;
  /** delete single row from the table: "data_backups" */
  deleteDataBackupsByPk?: Maybe<DataBackups>;
  /** delete data from the table: "email_drafts" */
  deleteEmailDrafts?: Maybe<EmailDraftsMutationResponse>;
  /** delete single row from the table: "email_drafts" */
  deleteEmailDraftsByPk?: Maybe<EmailDrafts>;
  /** delete data from the table: "email_send_logs" */
  deleteEmailSendLogs?: Maybe<EmailSendLogsMutationResponse>;
  /** delete single row from the table: "email_send_logs" */
  deleteEmailSendLogsByPk?: Maybe<EmailSendLogs>;
  /** delete data from the table: "email_templates" */
  deleteEmailTemplates?: Maybe<EmailTemplatesMutationResponse>;
  /** delete single row from the table: "email_templates" */
  deleteEmailTemplatesByPk?: Maybe<EmailTemplates>;
  /** delete data from the table: "external_systems" */
  deleteExternalSystems?: Maybe<ExternalSystemsMutationResponse>;
  /** delete single row from the table: "external_systems" */
  deleteExternalSystemsByPk?: Maybe<ExternalSystems>;
  /** delete data from the table: "feature_flags" */
  deleteFeatureFlags?: Maybe<FeatureFlagsMutationResponse>;
  /** delete single row from the table: "feature_flags" */
  deleteFeatureFlagsByPk?: Maybe<FeatureFlags>;
  /** delete data from the table: "files" */
  deleteFiles?: Maybe<FilesMutationResponse>;
  /** delete single row from the table: "files" */
  deleteFilesByPk?: Maybe<Files>;
  /** delete data from the table: "holidays" */
  deleteHolidays?: Maybe<HolidaysMutationResponse>;
  /** delete single row from the table: "holidays" */
  deleteHolidaysByPk?: Maybe<Holidays>;
  /** delete data from the table: "latest_payroll_version_results" */
  deleteLatestPayrollVersionResults?: Maybe<LatestPayrollVersionResultsMutationResponse>;
  /** delete single row from the table: "latest_payroll_version_results" */
  deleteLatestPayrollVersionResultsByPk?: Maybe<LatestPayrollVersionResults>;
  /** delete data from the table: "leave" */
  deleteLeave?: Maybe<LeaveMutationResponse>;
  /** delete single row from the table: "leave" */
  deleteLeaveByPk?: Maybe<Leave>;
  /** delete data from the table: "monthly_billing_completion" */
  deleteMonthlyBillingCompletion?: Maybe<MonthlyBillingCompletionMutationResponse>;
  /** delete single row from the table: "monthly_billing_completion" */
  deleteMonthlyBillingCompletionByPk?: Maybe<MonthlyBillingCompletion>;
  /** delete data from the table: "notes" */
  deleteNotes?: Maybe<NotesMutationResponse>;
  /** delete single row from the table: "notes" */
  deleteNotesByPk?: Maybe<Notes>;
  /** delete data from the table: "payroll_activation_results" */
  deletePayrollActivationResults?: Maybe<PayrollActivationResultsMutationResponse>;
  /** delete single row from the table: "payroll_activation_results" */
  deletePayrollActivationResultsByPk?: Maybe<PayrollActivationResults>;
  /** delete data from the table: "payroll_assignment_audit" */
  deletePayrollAssignmentAudit?: Maybe<PayrollAssignmentAuditMutationResponse>;
  /** delete single row from the table: "payroll_assignment_audit" */
  deletePayrollAssignmentAuditByPk?: Maybe<PayrollAssignmentAudit>;
  /** delete data from the table: "payroll_assignments" */
  deletePayrollAssignments?: Maybe<PayrollAssignmentsMutationResponse>;
  /** delete single row from the table: "payroll_assignments" */
  deletePayrollAssignmentsByPk?: Maybe<PayrollAssignments>;
  /** delete data from the table: "payroll_cycles" */
  deletePayrollCycles?: Maybe<PayrollCyclesMutationResponse>;
  /** delete single row from the table: "payroll_cycles" */
  deletePayrollCyclesByPk?: Maybe<PayrollCycles>;
  /** delete data from the table: "payroll_date_time_entries" */
  deletePayrollDateTimeEntries?: Maybe<PayrollDateTimeEntriesMutationResponse>;
  /** delete single row from the table: "payroll_date_time_entries" */
  deletePayrollDateTimeEntriesByPk?: Maybe<PayrollDateTimeEntries>;
  /** delete data from the table: "payroll_date_types" */
  deletePayrollDateTypes?: Maybe<PayrollDateTypesMutationResponse>;
  /** delete single row from the table: "payroll_date_types" */
  deletePayrollDateTypesByPk?: Maybe<PayrollDateTypes>;
  /** delete data from the table: "payroll_dates" */
  deletePayrollDates?: Maybe<PayrollDatesMutationResponse>;
  /** delete single row from the table: "payroll_dates" */
  deletePayrollDatesByPk?: Maybe<PayrollDates>;
  /** delete data from the table: "payroll_required_skills" */
  deletePayrollRequiredSkills?: Maybe<PayrollRequiredSkillsMutationResponse>;
  /** delete data from the table: "payroll_service_agreements" */
  deletePayrollServiceAgreements?: Maybe<PayrollServiceAgreementsMutationResponse>;
  /** delete single row from the table: "payroll_service_agreements" */
  deletePayrollServiceAgreementsByPk?: Maybe<PayrollServiceAgreements>;
  /** delete data from the table: "payroll_version_history_results" */
  deletePayrollVersionHistoryResults?: Maybe<PayrollVersionHistoryResultsMutationResponse>;
  /** delete single row from the table: "payroll_version_history_results" */
  deletePayrollVersionHistoryResultsByPk?: Maybe<PayrollVersionHistoryResults>;
  /** delete data from the table: "payroll_version_results" */
  deletePayrollVersionResults?: Maybe<PayrollVersionResultsMutationResponse>;
  /** delete single row from the table: "payroll_version_results" */
  deletePayrollVersionResultsByPk?: Maybe<PayrollVersionResults>;
  /** delete data from the table: "payrolls" */
  deletePayrolls?: Maybe<PayrollsMutationResponse>;
  /** delete single row from the table: "payrolls" */
  deletePayrollsByPk?: Maybe<Payrolls>;
  /** delete data from the table: "permission_audit_log" */
  deletePermissionAuditLog?: Maybe<PermissionAuditLogMutationResponse>;
  /** delete single row from the table: "permission_audit_log" */
  deletePermissionAuditLogByPk?: Maybe<PermissionAuditLog>;
  /** delete data from the table: "permission_overrides" */
  deletePermissionOverrides?: Maybe<PermissionOverridesMutationResponse>;
  /** delete single row from the table: "permission_overrides" */
  deletePermissionOverridesByPk?: Maybe<PermissionOverrides>;
  /** delete data from the table: "permissions" */
  deletePermissions?: Maybe<PermissionsMutationResponse>;
  /** delete single row from the table: "permissions" */
  deletePermissionsByPk?: Maybe<Permissions>;
  /** delete data from the table: "position_admin_defaults" */
  deletePositionAdminDefaults?: Maybe<PositionAdminDefaultsMutationResponse>;
  /** delete single row from the table: "position_admin_defaults" */
  deletePositionAdminDefaultsByPk?: Maybe<PositionAdminDefaults>;
  /** delete data from the table: "quote_conversions" */
  deleteQuoteConversions?: Maybe<QuoteConversionsMutationResponse>;
  /** delete single row from the table: "quote_conversions" */
  deleteQuoteConversionsByPk?: Maybe<QuoteConversions>;
  /** delete data from the table: "quote_line_items" */
  deleteQuoteLineItems?: Maybe<QuoteLineItemsMutationResponse>;
  /** delete single row from the table: "quote_line_items" */
  deleteQuoteLineItemsByPk?: Maybe<QuoteLineItems>;
  /** delete data from the table: "quote_templates" */
  deleteQuoteTemplates?: Maybe<QuoteTemplatesMutationResponse>;
  /** delete single row from the table: "quote_templates" */
  deleteQuoteTemplatesByPk?: Maybe<QuoteTemplates>;
  /** delete data from the table: "quotes" */
  deleteQuotes?: Maybe<QuotesMutationResponse>;
  /** delete single row from the table: "quotes" */
  deleteQuotesByPk?: Maybe<Quotes>;
  /** delete data from the table: "rate_limits" */
  deleteRateLimits?: Maybe<RateLimitsMutationResponse>;
  /** delete single row from the table: "rate_limits" */
  deleteRateLimitsByPk?: Maybe<RateLimits>;
  /** delete data from the table: "resources" */
  deleteResources?: Maybe<ResourcesMutationResponse>;
  /** delete single row from the table: "resources" */
  deleteResourcesByPk?: Maybe<Resources>;
  /** delete data from the table: "role_permissions" */
  deleteRolePermissions?: Maybe<RolePermissionsMutationResponse>;
  /** delete single row from the table: "role_permissions" */
  deleteRolePermissionsByPk?: Maybe<RolePermissions>;
  /** delete data from the table: "roles" */
  deleteRoles?: Maybe<RolesMutationResponse>;
  /** delete single row from the table: "roles" */
  deleteRolesByPk?: Maybe<Roles>;
  /** delete data from the table: "security_alerts" */
  deleteSecurityAlerts?: Maybe<SecurityAlertsMutationResponse>;
  /** delete single row from the table: "security_alerts" */
  deleteSecurityAlertsByPk?: Maybe<SecurityAlerts>;
  /** delete data from the table: "security_settings" */
  deleteSecuritySettings?: Maybe<SecuritySettingsMutationResponse>;
  /** delete single row from the table: "security_settings" */
  deleteSecuritySettingsByPk?: Maybe<SecuritySettings>;
  /** delete data from the table: "service_pricing_rules" */
  deleteServicePricingRules?: Maybe<ServicePricingRulesMutationResponse>;
  /** delete single row from the table: "service_pricing_rules" */
  deleteServicePricingRulesByPk?: Maybe<ServicePricingRules>;
  /** delete data from the table: "service_templates" */
  deleteServiceTemplates?: Maybe<ServiceTemplatesMutationResponse>;
  /** delete single row from the table: "service_templates" */
  deleteServiceTemplatesByPk?: Maybe<ServiceTemplates>;
  /** delete data from the table: "services" */
  deleteServices?: Maybe<ServicesMutationResponse>;
  /** delete single row from the table: "services" */
  deleteServicesByPk?: Maybe<Services>;
  /** delete data from the table: "system_configuration" */
  deleteSystemConfiguration?: Maybe<SystemConfigurationMutationResponse>;
  /** delete single row from the table: "system_configuration" */
  deleteSystemConfigurationByPk?: Maybe<SystemConfiguration>;
  /** delete data from the table: "system_health" */
  deleteSystemHealth?: Maybe<SystemHealthMutationResponse>;
  /** delete single row from the table: "system_health" */
  deleteSystemHealthByPk?: Maybe<SystemHealth>;
  /** delete data from the table: "time_entries" */
  deleteTimeEntries?: Maybe<TimeEntriesMutationResponse>;
  /** delete single row from the table: "time_entries" */
  deleteTimeEntriesByPk?: Maybe<TimeEntries>;
  /** delete data from the table: "user_email_template_favorites" */
  deleteUserEmailTemplateFavorites?: Maybe<UserEmailTemplateFavoritesMutationResponse>;
  /** delete single row from the table: "user_email_template_favorites" */
  deleteUserEmailTemplateFavoritesByPk?: Maybe<UserEmailTemplateFavorites>;
  /** delete data from the table: "user_invitations" */
  deleteUserInvitations?: Maybe<UserInvitationsMutationResponse>;
  /** delete single row from the table: "user_invitations" */
  deleteUserInvitationsByPk?: Maybe<UserInvitations>;
  /** delete data from the table: "user_rate_history" */
  deleteUserRateHistory?: Maybe<UserRateHistoryMutationResponse>;
  /** delete single row from the table: "user_rate_history" */
  deleteUserRateHistoryByPk?: Maybe<UserRateHistory>;
  /** delete data from the table: "user_roles" */
  deleteUserRoles?: Maybe<UserRolesMutationResponse>;
  /** delete single row from the table: "user_roles" */
  deleteUserRolesByPk?: Maybe<UserRoles>;
  /** delete data from the table: "user_sessions" */
  deleteUserSessions?: Maybe<UserSessionsMutationResponse>;
  /** delete single row from the table: "user_sessions" */
  deleteUserSessionsByPk?: Maybe<UserSessions>;
  /** delete data from the table: "user_skills" */
  deleteUserSkills?: Maybe<UserSkillsMutationResponse>;
  /** delete data from the table: "users" */
  deleteUsers?: Maybe<UsersMutationResponse>;
  /** delete single row from the table: "users" */
  deleteUsersByPk?: Maybe<Users>;
  /** delete data from the table: "users_role_backup" */
  deleteUsersRoleBackup?: Maybe<UsersRoleBackupMutationResponse>;
  /** delete data from the table: "work_schedule" */
  deleteWorkSchedule?: Maybe<WorkScheduleMutationResponse>;
  /** delete single row from the table: "work_schedule" */
  deleteWorkScheduleByPk?: Maybe<WorkSchedule>;
  /** execute VOLATILE function "generate_payroll_dates" which returns "payroll_dates" */
  generatePayrollDates: Array<PayrollDates>;
  /** insert data into the table: "adjustment_rules" */
  insertAdjustmentRules?: Maybe<AdjustmentRulesMutationResponse>;
  /** insert a single row into the table: "adjustment_rules" */
  insertAdjustmentRulesOne?: Maybe<AdjustmentRules>;
  /** insert data into the table: "app_settings" */
  insertAppSettings?: Maybe<AppSettingsMutationResponse>;
  /** insert a single row into the table: "app_settings" */
  insertAppSettingsOne?: Maybe<AppSettings>;
  /** insert data into the table: "audit.audit_log" */
  insertAuditAuditLog?: Maybe<AuditAuditLogMutationResponse>;
  /** insert a single row into the table: "audit.audit_log" */
  insertAuditAuditLogOne?: Maybe<AuditAuditLog>;
  /** insert data into the table: "audit.auth_events" */
  insertAuditAuthEvents?: Maybe<AuditAuthEventsMutationResponse>;
  /** insert a single row into the table: "audit.auth_events" */
  insertAuditAuthEventsOne?: Maybe<AuditAuthEvents>;
  /** insert data into the table: "audit.data_access_log" */
  insertAuditDataAccessLog?: Maybe<AuditDataAccessLogMutationResponse>;
  /** insert a single row into the table: "audit.data_access_log" */
  insertAuditDataAccessLogOne?: Maybe<AuditDataAccessLog>;
  /** insert data into the table: "audit.permission_changes" */
  insertAuditPermissionChanges?: Maybe<AuditPermissionChangesMutationResponse>;
  /** insert a single row into the table: "audit.permission_changes" */
  insertAuditPermissionChangesOne?: Maybe<AuditPermissionChanges>;
  /** insert data into the table: "audit.slow_queries" */
  insertAuditSlowQueries?: Maybe<AuditSlowQueriesMutationResponse>;
  /** insert a single row into the table: "audit.slow_queries" */
  insertAuditSlowQueriesOne?: Maybe<AuditSlowQueries>;
  /** insert data into the table: "audit.user_access_summary" */
  insertAuditUserAccessSummary?: Maybe<AuditUserAccessSummaryMutationResponse>;
  /** insert a single row into the table: "audit.user_access_summary" */
  insertAuditUserAccessSummaryOne?: Maybe<AuditUserAccessSummary>;
  /** insert data into the table: "billing_event_log" */
  insertBillingEventLog?: Maybe<BillingEventLogMutationResponse>;
  /** insert a single row into the table: "billing_event_log" */
  insertBillingEventLogOne?: Maybe<BillingEventLog>;
  /** insert data into the table: "billing_invoice" */
  insertBillingInvoice?: Maybe<BillingInvoiceMutationResponse>;
  /** insert data into the table: "billing_invoice_item" */
  insertBillingInvoiceItem?: Maybe<BillingInvoiceItemMutationResponse>;
  /** insert a single row into the table: "billing_invoice_item" */
  insertBillingInvoiceItemOne?: Maybe<BillingInvoiceItem>;
  /** insert a single row into the table: "billing_invoice" */
  insertBillingInvoiceOne?: Maybe<BillingInvoice>;
  /** insert data into the table: "billing_items" */
  insertBillingItems?: Maybe<BillingItemsMutationResponse>;
  /** insert a single row into the table: "billing_items" */
  insertBillingItemsOne?: Maybe<BillingItems>;
  /** insert data into the table: "billing_periods" */
  insertBillingPeriods?: Maybe<BillingPeriodsMutationResponse>;
  /** insert a single row into the table: "billing_periods" */
  insertBillingPeriodsOne?: Maybe<BillingPeriods>;
  /** insert data into the table: "client_external_systems" */
  insertClientExternalSystems?: Maybe<ClientExternalSystemsMutationResponse>;
  /** insert a single row into the table: "client_external_systems" */
  insertClientExternalSystemsOne?: Maybe<ClientExternalSystems>;
  /** insert data into the table: "client_service_agreements" */
  insertClientServiceAgreements?: Maybe<ClientServiceAgreementsMutationResponse>;
  /** insert a single row into the table: "client_service_agreements" */
  insertClientServiceAgreementsOne?: Maybe<ClientServiceAgreements>;
  /** insert data into the table: "clients" */
  insertClients?: Maybe<ClientsMutationResponse>;
  /** insert a single row into the table: "clients" */
  insertClientsOne?: Maybe<Clients>;
  /** insert data into the table: "data_backups" */
  insertDataBackups?: Maybe<DataBackupsMutationResponse>;
  /** insert a single row into the table: "data_backups" */
  insertDataBackupsOne?: Maybe<DataBackups>;
  /** insert data into the table: "email_drafts" */
  insertEmailDrafts?: Maybe<EmailDraftsMutationResponse>;
  /** insert a single row into the table: "email_drafts" */
  insertEmailDraftsOne?: Maybe<EmailDrafts>;
  /** insert data into the table: "email_send_logs" */
  insertEmailSendLogs?: Maybe<EmailSendLogsMutationResponse>;
  /** insert a single row into the table: "email_send_logs" */
  insertEmailSendLogsOne?: Maybe<EmailSendLogs>;
  /** insert data into the table: "email_templates" */
  insertEmailTemplates?: Maybe<EmailTemplatesMutationResponse>;
  /** insert a single row into the table: "email_templates" */
  insertEmailTemplatesOne?: Maybe<EmailTemplates>;
  /** insert data into the table: "external_systems" */
  insertExternalSystems?: Maybe<ExternalSystemsMutationResponse>;
  /** insert a single row into the table: "external_systems" */
  insertExternalSystemsOne?: Maybe<ExternalSystems>;
  /** insert data into the table: "feature_flags" */
  insertFeatureFlags?: Maybe<FeatureFlagsMutationResponse>;
  /** insert a single row into the table: "feature_flags" */
  insertFeatureFlagsOne?: Maybe<FeatureFlags>;
  /** insert data into the table: "files" */
  insertFiles?: Maybe<FilesMutationResponse>;
  /** insert a single row into the table: "files" */
  insertFilesOne?: Maybe<Files>;
  /** insert data into the table: "holidays" */
  insertHolidays?: Maybe<HolidaysMutationResponse>;
  /** insert a single row into the table: "holidays" */
  insertHolidaysOne?: Maybe<Holidays>;
  /** insert data into the table: "latest_payroll_version_results" */
  insertLatestPayrollVersionResults?: Maybe<LatestPayrollVersionResultsMutationResponse>;
  /** insert a single row into the table: "latest_payroll_version_results" */
  insertLatestPayrollVersionResultsOne?: Maybe<LatestPayrollVersionResults>;
  /** insert data into the table: "leave" */
  insertLeave?: Maybe<LeaveMutationResponse>;
  /** insert a single row into the table: "leave" */
  insertLeaveOne?: Maybe<Leave>;
  /** insert data into the table: "monthly_billing_completion" */
  insertMonthlyBillingCompletion?: Maybe<MonthlyBillingCompletionMutationResponse>;
  /** insert a single row into the table: "monthly_billing_completion" */
  insertMonthlyBillingCompletionOne?: Maybe<MonthlyBillingCompletion>;
  /** insert data into the table: "notes" */
  insertNotes?: Maybe<NotesMutationResponse>;
  /** insert a single row into the table: "notes" */
  insertNotesOne?: Maybe<Notes>;
  /** insert data into the table: "payroll_activation_results" */
  insertPayrollActivationResults?: Maybe<PayrollActivationResultsMutationResponse>;
  /** insert a single row into the table: "payroll_activation_results" */
  insertPayrollActivationResultsOne?: Maybe<PayrollActivationResults>;
  /** insert data into the table: "payroll_assignment_audit" */
  insertPayrollAssignmentAudit?: Maybe<PayrollAssignmentAuditMutationResponse>;
  /** insert a single row into the table: "payroll_assignment_audit" */
  insertPayrollAssignmentAuditOne?: Maybe<PayrollAssignmentAudit>;
  /** insert data into the table: "payroll_assignments" */
  insertPayrollAssignments?: Maybe<PayrollAssignmentsMutationResponse>;
  /** insert a single row into the table: "payroll_assignments" */
  insertPayrollAssignmentsOne?: Maybe<PayrollAssignments>;
  /** insert data into the table: "payroll_cycles" */
  insertPayrollCycles?: Maybe<PayrollCyclesMutationResponse>;
  /** insert a single row into the table: "payroll_cycles" */
  insertPayrollCyclesOne?: Maybe<PayrollCycles>;
  /** insert data into the table: "payroll_date_time_entries" */
  insertPayrollDateTimeEntries?: Maybe<PayrollDateTimeEntriesMutationResponse>;
  /** insert a single row into the table: "payroll_date_time_entries" */
  insertPayrollDateTimeEntriesOne?: Maybe<PayrollDateTimeEntries>;
  /** insert data into the table: "payroll_date_types" */
  insertPayrollDateTypes?: Maybe<PayrollDateTypesMutationResponse>;
  /** insert a single row into the table: "payroll_date_types" */
  insertPayrollDateTypesOne?: Maybe<PayrollDateTypes>;
  /** insert data into the table: "payroll_dates" */
  insertPayrollDates?: Maybe<PayrollDatesMutationResponse>;
  /** insert a single row into the table: "payroll_dates" */
  insertPayrollDatesOne?: Maybe<PayrollDates>;
  /** insert data into the table: "payroll_required_skills" */
  insertPayrollRequiredSkills?: Maybe<PayrollRequiredSkillsMutationResponse>;
  /** insert a single row into the table: "payroll_required_skills" */
  insertPayrollRequiredSkillsOne?: Maybe<PayrollRequiredSkills>;
  /** insert data into the table: "payroll_service_agreements" */
  insertPayrollServiceAgreements?: Maybe<PayrollServiceAgreementsMutationResponse>;
  /** insert a single row into the table: "payroll_service_agreements" */
  insertPayrollServiceAgreementsOne?: Maybe<PayrollServiceAgreements>;
  /** insert data into the table: "payroll_version_history_results" */
  insertPayrollVersionHistoryResults?: Maybe<PayrollVersionHistoryResultsMutationResponse>;
  /** insert a single row into the table: "payroll_version_history_results" */
  insertPayrollVersionHistoryResultsOne?: Maybe<PayrollVersionHistoryResults>;
  /** insert data into the table: "payroll_version_results" */
  insertPayrollVersionResults?: Maybe<PayrollVersionResultsMutationResponse>;
  /** insert a single row into the table: "payroll_version_results" */
  insertPayrollVersionResultsOne?: Maybe<PayrollVersionResults>;
  /** insert data into the table: "payrolls" */
  insertPayrolls?: Maybe<PayrollsMutationResponse>;
  /** insert a single row into the table: "payrolls" */
  insertPayrollsOne?: Maybe<Payrolls>;
  /** insert data into the table: "permission_audit_log" */
  insertPermissionAuditLog?: Maybe<PermissionAuditLogMutationResponse>;
  /** insert a single row into the table: "permission_audit_log" */
  insertPermissionAuditLogOne?: Maybe<PermissionAuditLog>;
  /** insert data into the table: "permission_overrides" */
  insertPermissionOverrides?: Maybe<PermissionOverridesMutationResponse>;
  /** insert a single row into the table: "permission_overrides" */
  insertPermissionOverridesOne?: Maybe<PermissionOverrides>;
  /** insert data into the table: "permissions" */
  insertPermissions?: Maybe<PermissionsMutationResponse>;
  /** insert a single row into the table: "permissions" */
  insertPermissionsOne?: Maybe<Permissions>;
  /** insert data into the table: "position_admin_defaults" */
  insertPositionAdminDefaults?: Maybe<PositionAdminDefaultsMutationResponse>;
  /** insert a single row into the table: "position_admin_defaults" */
  insertPositionAdminDefaultsOne?: Maybe<PositionAdminDefaults>;
  /** insert data into the table: "quote_conversions" */
  insertQuoteConversions?: Maybe<QuoteConversionsMutationResponse>;
  /** insert a single row into the table: "quote_conversions" */
  insertQuoteConversionsOne?: Maybe<QuoteConversions>;
  /** insert data into the table: "quote_line_items" */
  insertQuoteLineItems?: Maybe<QuoteLineItemsMutationResponse>;
  /** insert a single row into the table: "quote_line_items" */
  insertQuoteLineItemsOne?: Maybe<QuoteLineItems>;
  /** insert data into the table: "quote_templates" */
  insertQuoteTemplates?: Maybe<QuoteTemplatesMutationResponse>;
  /** insert a single row into the table: "quote_templates" */
  insertQuoteTemplatesOne?: Maybe<QuoteTemplates>;
  /** insert data into the table: "quotes" */
  insertQuotes?: Maybe<QuotesMutationResponse>;
  /** insert a single row into the table: "quotes" */
  insertQuotesOne?: Maybe<Quotes>;
  /** insert data into the table: "rate_limits" */
  insertRateLimits?: Maybe<RateLimitsMutationResponse>;
  /** insert a single row into the table: "rate_limits" */
  insertRateLimitsOne?: Maybe<RateLimits>;
  /** insert data into the table: "resources" */
  insertResources?: Maybe<ResourcesMutationResponse>;
  /** insert a single row into the table: "resources" */
  insertResourcesOne?: Maybe<Resources>;
  /** insert data into the table: "role_permissions" */
  insertRolePermissions?: Maybe<RolePermissionsMutationResponse>;
  /** insert a single row into the table: "role_permissions" */
  insertRolePermissionsOne?: Maybe<RolePermissions>;
  /** insert data into the table: "roles" */
  insertRoles?: Maybe<RolesMutationResponse>;
  /** insert a single row into the table: "roles" */
  insertRolesOne?: Maybe<Roles>;
  /** insert data into the table: "security_alerts" */
  insertSecurityAlerts?: Maybe<SecurityAlertsMutationResponse>;
  /** insert a single row into the table: "security_alerts" */
  insertSecurityAlertsOne?: Maybe<SecurityAlerts>;
  /** insert data into the table: "security_settings" */
  insertSecuritySettings?: Maybe<SecuritySettingsMutationResponse>;
  /** insert a single row into the table: "security_settings" */
  insertSecuritySettingsOne?: Maybe<SecuritySettings>;
  /** insert data into the table: "service_pricing_rules" */
  insertServicePricingRules?: Maybe<ServicePricingRulesMutationResponse>;
  /** insert a single row into the table: "service_pricing_rules" */
  insertServicePricingRulesOne?: Maybe<ServicePricingRules>;
  /** insert data into the table: "service_templates" */
  insertServiceTemplates?: Maybe<ServiceTemplatesMutationResponse>;
  /** insert a single row into the table: "service_templates" */
  insertServiceTemplatesOne?: Maybe<ServiceTemplates>;
  /** insert data into the table: "services" */
  insertServices?: Maybe<ServicesMutationResponse>;
  /** insert a single row into the table: "services" */
  insertServicesOne?: Maybe<Services>;
  /** insert data into the table: "system_configuration" */
  insertSystemConfiguration?: Maybe<SystemConfigurationMutationResponse>;
  /** insert a single row into the table: "system_configuration" */
  insertSystemConfigurationOne?: Maybe<SystemConfiguration>;
  /** insert data into the table: "system_health" */
  insertSystemHealth?: Maybe<SystemHealthMutationResponse>;
  /** insert a single row into the table: "system_health" */
  insertSystemHealthOne?: Maybe<SystemHealth>;
  /** insert data into the table: "time_entries" */
  insertTimeEntries?: Maybe<TimeEntriesMutationResponse>;
  /** insert a single row into the table: "time_entries" */
  insertTimeEntriesOne?: Maybe<TimeEntries>;
  /** insert data into the table: "user_email_template_favorites" */
  insertUserEmailTemplateFavorites?: Maybe<UserEmailTemplateFavoritesMutationResponse>;
  /** insert a single row into the table: "user_email_template_favorites" */
  insertUserEmailTemplateFavoritesOne?: Maybe<UserEmailTemplateFavorites>;
  /** insert data into the table: "user_invitations" */
  insertUserInvitations?: Maybe<UserInvitationsMutationResponse>;
  /** insert a single row into the table: "user_invitations" */
  insertUserInvitationsOne?: Maybe<UserInvitations>;
  /** insert data into the table: "user_rate_history" */
  insertUserRateHistory?: Maybe<UserRateHistoryMutationResponse>;
  /** insert a single row into the table: "user_rate_history" */
  insertUserRateHistoryOne?: Maybe<UserRateHistory>;
  /** insert data into the table: "user_roles" */
  insertUserRoles?: Maybe<UserRolesMutationResponse>;
  /** insert a single row into the table: "user_roles" */
  insertUserRolesOne?: Maybe<UserRoles>;
  /** insert data into the table: "user_sessions" */
  insertUserSessions?: Maybe<UserSessionsMutationResponse>;
  /** insert a single row into the table: "user_sessions" */
  insertUserSessionsOne?: Maybe<UserSessions>;
  /** insert data into the table: "user_skills" */
  insertUserSkills?: Maybe<UserSkillsMutationResponse>;
  /** insert a single row into the table: "user_skills" */
  insertUserSkillsOne?: Maybe<UserSkills>;
  /** insert data into the table: "users" */
  insertUsers?: Maybe<UsersMutationResponse>;
  /** insert a single row into the table: "users" */
  insertUsersOne?: Maybe<Users>;
  /** insert data into the table: "users_role_backup" */
  insertUsersRoleBackup?: Maybe<UsersRoleBackupMutationResponse>;
  /** insert a single row into the table: "users_role_backup" */
  insertUsersRoleBackupOne?: Maybe<UsersRoleBackup>;
  /** insert data into the table: "work_schedule" */
  insertWorkSchedule?: Maybe<WorkScheduleMutationResponse>;
  /** insert a single row into the table: "work_schedule" */
  insertWorkScheduleOne?: Maybe<WorkSchedule>;
  /** update data of the table: "adjustment_rules" */
  updateAdjustmentRules?: Maybe<AdjustmentRulesMutationResponse>;
  /** update single row of the table: "adjustment_rules" */
  updateAdjustmentRulesByPk?: Maybe<AdjustmentRules>;
  /** update multiples rows of table: "adjustment_rules" */
  updateAdjustmentRulesMany?: Maybe<Array<Maybe<AdjustmentRulesMutationResponse>>>;
  /** update data of the table: "app_settings" */
  updateAppSettings?: Maybe<AppSettingsMutationResponse>;
  /** update single row of the table: "app_settings" */
  updateAppSettingsByPk?: Maybe<AppSettings>;
  /** update multiples rows of table: "app_settings" */
  updateAppSettingsMany?: Maybe<Array<Maybe<AppSettingsMutationResponse>>>;
  /** update data of the table: "audit.audit_log" */
  updateAuditAuditLog?: Maybe<AuditAuditLogMutationResponse>;
  /** update single row of the table: "audit.audit_log" */
  updateAuditAuditLogByPk?: Maybe<AuditAuditLog>;
  /** update multiples rows of table: "audit.audit_log" */
  updateAuditAuditLogMany?: Maybe<Array<Maybe<AuditAuditLogMutationResponse>>>;
  /** update data of the table: "audit.auth_events" */
  updateAuditAuthEvents?: Maybe<AuditAuthEventsMutationResponse>;
  /** update single row of the table: "audit.auth_events" */
  updateAuditAuthEventsByPk?: Maybe<AuditAuthEvents>;
  /** update multiples rows of table: "audit.auth_events" */
  updateAuditAuthEventsMany?: Maybe<Array<Maybe<AuditAuthEventsMutationResponse>>>;
  /** update data of the table: "audit.data_access_log" */
  updateAuditDataAccessLog?: Maybe<AuditDataAccessLogMutationResponse>;
  /** update single row of the table: "audit.data_access_log" */
  updateAuditDataAccessLogByPk?: Maybe<AuditDataAccessLog>;
  /** update multiples rows of table: "audit.data_access_log" */
  updateAuditDataAccessLogMany?: Maybe<Array<Maybe<AuditDataAccessLogMutationResponse>>>;
  /** update data of the table: "audit.permission_changes" */
  updateAuditPermissionChanges?: Maybe<AuditPermissionChangesMutationResponse>;
  /** update single row of the table: "audit.permission_changes" */
  updateAuditPermissionChangesByPk?: Maybe<AuditPermissionChanges>;
  /** update multiples rows of table: "audit.permission_changes" */
  updateAuditPermissionChangesMany?: Maybe<Array<Maybe<AuditPermissionChangesMutationResponse>>>;
  /** update data of the table: "audit.slow_queries" */
  updateAuditSlowQueries?: Maybe<AuditSlowQueriesMutationResponse>;
  /** update single row of the table: "audit.slow_queries" */
  updateAuditSlowQueriesByPk?: Maybe<AuditSlowQueries>;
  /** update multiples rows of table: "audit.slow_queries" */
  updateAuditSlowQueriesMany?: Maybe<Array<Maybe<AuditSlowQueriesMutationResponse>>>;
  /** update data of the table: "audit.user_access_summary" */
  updateAuditUserAccessSummary?: Maybe<AuditUserAccessSummaryMutationResponse>;
  /** update multiples rows of table: "audit.user_access_summary" */
  updateAuditUserAccessSummaryMany?: Maybe<Array<Maybe<AuditUserAccessSummaryMutationResponse>>>;
  /** update data of the table: "billing_event_log" */
  updateBillingEventLog?: Maybe<BillingEventLogMutationResponse>;
  /** update single row of the table: "billing_event_log" */
  updateBillingEventLogByPk?: Maybe<BillingEventLog>;
  /** update multiples rows of table: "billing_event_log" */
  updateBillingEventLogMany?: Maybe<Array<Maybe<BillingEventLogMutationResponse>>>;
  /** update data of the table: "billing_invoice" */
  updateBillingInvoice?: Maybe<BillingInvoiceMutationResponse>;
  /** update single row of the table: "billing_invoice" */
  updateBillingInvoiceByPk?: Maybe<BillingInvoice>;
  /** update data of the table: "billing_invoice_item" */
  updateBillingInvoiceItem?: Maybe<BillingInvoiceItemMutationResponse>;
  /** update single row of the table: "billing_invoice_item" */
  updateBillingInvoiceItemByPk?: Maybe<BillingInvoiceItem>;
  /** update multiples rows of table: "billing_invoice_item" */
  updateBillingInvoiceItemMany?: Maybe<Array<Maybe<BillingInvoiceItemMutationResponse>>>;
  /** update multiples rows of table: "billing_invoice" */
  updateBillingInvoiceMany?: Maybe<Array<Maybe<BillingInvoiceMutationResponse>>>;
  /** update data of the table: "billing_items" */
  updateBillingItems?: Maybe<BillingItemsMutationResponse>;
  /** update single row of the table: "billing_items" */
  updateBillingItemsByPk?: Maybe<BillingItems>;
  /** update multiples rows of table: "billing_items" */
  updateBillingItemsMany?: Maybe<Array<Maybe<BillingItemsMutationResponse>>>;
  /** update data of the table: "billing_periods" */
  updateBillingPeriods?: Maybe<BillingPeriodsMutationResponse>;
  /** update single row of the table: "billing_periods" */
  updateBillingPeriodsByPk?: Maybe<BillingPeriods>;
  /** update multiples rows of table: "billing_periods" */
  updateBillingPeriodsMany?: Maybe<Array<Maybe<BillingPeriodsMutationResponse>>>;
  /** update data of the table: "client_external_systems" */
  updateClientExternalSystems?: Maybe<ClientExternalSystemsMutationResponse>;
  /** update single row of the table: "client_external_systems" */
  updateClientExternalSystemsByPk?: Maybe<ClientExternalSystems>;
  /** update multiples rows of table: "client_external_systems" */
  updateClientExternalSystemsMany?: Maybe<Array<Maybe<ClientExternalSystemsMutationResponse>>>;
  /** update data of the table: "client_service_agreements" */
  updateClientServiceAgreements?: Maybe<ClientServiceAgreementsMutationResponse>;
  /** update single row of the table: "client_service_agreements" */
  updateClientServiceAgreementsByPk?: Maybe<ClientServiceAgreements>;
  /** update multiples rows of table: "client_service_agreements" */
  updateClientServiceAgreementsMany?: Maybe<Array<Maybe<ClientServiceAgreementsMutationResponse>>>;
  /** update data of the table: "clients" */
  updateClients?: Maybe<ClientsMutationResponse>;
  /** update single row of the table: "clients" */
  updateClientsByPk?: Maybe<Clients>;
  /** update multiples rows of table: "clients" */
  updateClientsMany?: Maybe<Array<Maybe<ClientsMutationResponse>>>;
  /** update data of the table: "data_backups" */
  updateDataBackups?: Maybe<DataBackupsMutationResponse>;
  /** update single row of the table: "data_backups" */
  updateDataBackupsByPk?: Maybe<DataBackups>;
  /** update multiples rows of table: "data_backups" */
  updateDataBackupsMany?: Maybe<Array<Maybe<DataBackupsMutationResponse>>>;
  /** update data of the table: "email_drafts" */
  updateEmailDrafts?: Maybe<EmailDraftsMutationResponse>;
  /** update single row of the table: "email_drafts" */
  updateEmailDraftsByPk?: Maybe<EmailDrafts>;
  /** update multiples rows of table: "email_drafts" */
  updateEmailDraftsMany?: Maybe<Array<Maybe<EmailDraftsMutationResponse>>>;
  /** update data of the table: "email_send_logs" */
  updateEmailSendLogs?: Maybe<EmailSendLogsMutationResponse>;
  /** update single row of the table: "email_send_logs" */
  updateEmailSendLogsByPk?: Maybe<EmailSendLogs>;
  /** update multiples rows of table: "email_send_logs" */
  updateEmailSendLogsMany?: Maybe<Array<Maybe<EmailSendLogsMutationResponse>>>;
  /** update data of the table: "email_templates" */
  updateEmailTemplates?: Maybe<EmailTemplatesMutationResponse>;
  /** update single row of the table: "email_templates" */
  updateEmailTemplatesByPk?: Maybe<EmailTemplates>;
  /** update multiples rows of table: "email_templates" */
  updateEmailTemplatesMany?: Maybe<Array<Maybe<EmailTemplatesMutationResponse>>>;
  /** update data of the table: "external_systems" */
  updateExternalSystems?: Maybe<ExternalSystemsMutationResponse>;
  /** update single row of the table: "external_systems" */
  updateExternalSystemsByPk?: Maybe<ExternalSystems>;
  /** update multiples rows of table: "external_systems" */
  updateExternalSystemsMany?: Maybe<Array<Maybe<ExternalSystemsMutationResponse>>>;
  /** update data of the table: "feature_flags" */
  updateFeatureFlags?: Maybe<FeatureFlagsMutationResponse>;
  /** update single row of the table: "feature_flags" */
  updateFeatureFlagsByPk?: Maybe<FeatureFlags>;
  /** update multiples rows of table: "feature_flags" */
  updateFeatureFlagsMany?: Maybe<Array<Maybe<FeatureFlagsMutationResponse>>>;
  /** update data of the table: "files" */
  updateFiles?: Maybe<FilesMutationResponse>;
  /** update single row of the table: "files" */
  updateFilesByPk?: Maybe<Files>;
  /** update multiples rows of table: "files" */
  updateFilesMany?: Maybe<Array<Maybe<FilesMutationResponse>>>;
  /** update data of the table: "holidays" */
  updateHolidays?: Maybe<HolidaysMutationResponse>;
  /** update single row of the table: "holidays" */
  updateHolidaysByPk?: Maybe<Holidays>;
  /** update multiples rows of table: "holidays" */
  updateHolidaysMany?: Maybe<Array<Maybe<HolidaysMutationResponse>>>;
  /** update data of the table: "latest_payroll_version_results" */
  updateLatestPayrollVersionResults?: Maybe<LatestPayrollVersionResultsMutationResponse>;
  /** update single row of the table: "latest_payroll_version_results" */
  updateLatestPayrollVersionResultsByPk?: Maybe<LatestPayrollVersionResults>;
  /** update multiples rows of table: "latest_payroll_version_results" */
  updateLatestPayrollVersionResultsMany?: Maybe<Array<Maybe<LatestPayrollVersionResultsMutationResponse>>>;
  /** update data of the table: "leave" */
  updateLeave?: Maybe<LeaveMutationResponse>;
  /** update single row of the table: "leave" */
  updateLeaveByPk?: Maybe<Leave>;
  /** update multiples rows of table: "leave" */
  updateLeaveMany?: Maybe<Array<Maybe<LeaveMutationResponse>>>;
  /** update data of the table: "monthly_billing_completion" */
  updateMonthlyBillingCompletion?: Maybe<MonthlyBillingCompletionMutationResponse>;
  /** update single row of the table: "monthly_billing_completion" */
  updateMonthlyBillingCompletionByPk?: Maybe<MonthlyBillingCompletion>;
  /** update multiples rows of table: "monthly_billing_completion" */
  updateMonthlyBillingCompletionMany?: Maybe<Array<Maybe<MonthlyBillingCompletionMutationResponse>>>;
  /** update data of the table: "notes" */
  updateNotes?: Maybe<NotesMutationResponse>;
  /** update single row of the table: "notes" */
  updateNotesByPk?: Maybe<Notes>;
  /** update multiples rows of table: "notes" */
  updateNotesMany?: Maybe<Array<Maybe<NotesMutationResponse>>>;
  /** update data of the table: "payroll_activation_results" */
  updatePayrollActivationResults?: Maybe<PayrollActivationResultsMutationResponse>;
  /** update single row of the table: "payroll_activation_results" */
  updatePayrollActivationResultsByPk?: Maybe<PayrollActivationResults>;
  /** update multiples rows of table: "payroll_activation_results" */
  updatePayrollActivationResultsMany?: Maybe<Array<Maybe<PayrollActivationResultsMutationResponse>>>;
  /** update data of the table: "payroll_assignment_audit" */
  updatePayrollAssignmentAudit?: Maybe<PayrollAssignmentAuditMutationResponse>;
  /** update single row of the table: "payroll_assignment_audit" */
  updatePayrollAssignmentAuditByPk?: Maybe<PayrollAssignmentAudit>;
  /** update multiples rows of table: "payroll_assignment_audit" */
  updatePayrollAssignmentAuditMany?: Maybe<Array<Maybe<PayrollAssignmentAuditMutationResponse>>>;
  /** update data of the table: "payroll_assignments" */
  updatePayrollAssignments?: Maybe<PayrollAssignmentsMutationResponse>;
  /** update single row of the table: "payroll_assignments" */
  updatePayrollAssignmentsByPk?: Maybe<PayrollAssignments>;
  /** update multiples rows of table: "payroll_assignments" */
  updatePayrollAssignmentsMany?: Maybe<Array<Maybe<PayrollAssignmentsMutationResponse>>>;
  /** update data of the table: "payroll_cycles" */
  updatePayrollCycles?: Maybe<PayrollCyclesMutationResponse>;
  /** update single row of the table: "payroll_cycles" */
  updatePayrollCyclesByPk?: Maybe<PayrollCycles>;
  /** update multiples rows of table: "payroll_cycles" */
  updatePayrollCyclesMany?: Maybe<Array<Maybe<PayrollCyclesMutationResponse>>>;
  /** update data of the table: "payroll_date_time_entries" */
  updatePayrollDateTimeEntries?: Maybe<PayrollDateTimeEntriesMutationResponse>;
  /** update single row of the table: "payroll_date_time_entries" */
  updatePayrollDateTimeEntriesByPk?: Maybe<PayrollDateTimeEntries>;
  /** update multiples rows of table: "payroll_date_time_entries" */
  updatePayrollDateTimeEntriesMany?: Maybe<Array<Maybe<PayrollDateTimeEntriesMutationResponse>>>;
  /** update data of the table: "payroll_date_types" */
  updatePayrollDateTypes?: Maybe<PayrollDateTypesMutationResponse>;
  /** update single row of the table: "payroll_date_types" */
  updatePayrollDateTypesByPk?: Maybe<PayrollDateTypes>;
  /** update multiples rows of table: "payroll_date_types" */
  updatePayrollDateTypesMany?: Maybe<Array<Maybe<PayrollDateTypesMutationResponse>>>;
  /** update data of the table: "payroll_dates" */
  updatePayrollDates?: Maybe<PayrollDatesMutationResponse>;
  /** update single row of the table: "payroll_dates" */
  updatePayrollDatesByPk?: Maybe<PayrollDates>;
  /** update multiples rows of table: "payroll_dates" */
  updatePayrollDatesMany?: Maybe<Array<Maybe<PayrollDatesMutationResponse>>>;
  /** update data of the table: "payroll_required_skills" */
  updatePayrollRequiredSkills?: Maybe<PayrollRequiredSkillsMutationResponse>;
  /** update multiples rows of table: "payroll_required_skills" */
  updatePayrollRequiredSkillsMany?: Maybe<Array<Maybe<PayrollRequiredSkillsMutationResponse>>>;
  /** update data of the table: "payroll_service_agreements" */
  updatePayrollServiceAgreements?: Maybe<PayrollServiceAgreementsMutationResponse>;
  /** update single row of the table: "payroll_service_agreements" */
  updatePayrollServiceAgreementsByPk?: Maybe<PayrollServiceAgreements>;
  /** update multiples rows of table: "payroll_service_agreements" */
  updatePayrollServiceAgreementsMany?: Maybe<Array<Maybe<PayrollServiceAgreementsMutationResponse>>>;
  /** update data of the table: "payroll_version_history_results" */
  updatePayrollVersionHistoryResults?: Maybe<PayrollVersionHistoryResultsMutationResponse>;
  /** update single row of the table: "payroll_version_history_results" */
  updatePayrollVersionHistoryResultsByPk?: Maybe<PayrollVersionHistoryResults>;
  /** update multiples rows of table: "payroll_version_history_results" */
  updatePayrollVersionHistoryResultsMany?: Maybe<Array<Maybe<PayrollVersionHistoryResultsMutationResponse>>>;
  /** update data of the table: "payroll_version_results" */
  updatePayrollVersionResults?: Maybe<PayrollVersionResultsMutationResponse>;
  /** update single row of the table: "payroll_version_results" */
  updatePayrollVersionResultsByPk?: Maybe<PayrollVersionResults>;
  /** update multiples rows of table: "payroll_version_results" */
  updatePayrollVersionResultsMany?: Maybe<Array<Maybe<PayrollVersionResultsMutationResponse>>>;
  /** update data of the table: "payrolls" */
  updatePayrolls?: Maybe<PayrollsMutationResponse>;
  /** update single row of the table: "payrolls" */
  updatePayrollsByPk?: Maybe<Payrolls>;
  /** update multiples rows of table: "payrolls" */
  updatePayrollsMany?: Maybe<Array<Maybe<PayrollsMutationResponse>>>;
  /** update data of the table: "permission_audit_log" */
  updatePermissionAuditLog?: Maybe<PermissionAuditLogMutationResponse>;
  /** update single row of the table: "permission_audit_log" */
  updatePermissionAuditLogByPk?: Maybe<PermissionAuditLog>;
  /** update multiples rows of table: "permission_audit_log" */
  updatePermissionAuditLogMany?: Maybe<Array<Maybe<PermissionAuditLogMutationResponse>>>;
  /** update data of the table: "permission_overrides" */
  updatePermissionOverrides?: Maybe<PermissionOverridesMutationResponse>;
  /** update single row of the table: "permission_overrides" */
  updatePermissionOverridesByPk?: Maybe<PermissionOverrides>;
  /** update multiples rows of table: "permission_overrides" */
  updatePermissionOverridesMany?: Maybe<Array<Maybe<PermissionOverridesMutationResponse>>>;
  /** update data of the table: "permissions" */
  updatePermissions?: Maybe<PermissionsMutationResponse>;
  /** update single row of the table: "permissions" */
  updatePermissionsByPk?: Maybe<Permissions>;
  /** update multiples rows of table: "permissions" */
  updatePermissionsMany?: Maybe<Array<Maybe<PermissionsMutationResponse>>>;
  /** update data of the table: "position_admin_defaults" */
  updatePositionAdminDefaults?: Maybe<PositionAdminDefaultsMutationResponse>;
  /** update single row of the table: "position_admin_defaults" */
  updatePositionAdminDefaultsByPk?: Maybe<PositionAdminDefaults>;
  /** update multiples rows of table: "position_admin_defaults" */
  updatePositionAdminDefaultsMany?: Maybe<Array<Maybe<PositionAdminDefaultsMutationResponse>>>;
  /** update data of the table: "quote_conversions" */
  updateQuoteConversions?: Maybe<QuoteConversionsMutationResponse>;
  /** update single row of the table: "quote_conversions" */
  updateQuoteConversionsByPk?: Maybe<QuoteConversions>;
  /** update multiples rows of table: "quote_conversions" */
  updateQuoteConversionsMany?: Maybe<Array<Maybe<QuoteConversionsMutationResponse>>>;
  /** update data of the table: "quote_line_items" */
  updateQuoteLineItems?: Maybe<QuoteLineItemsMutationResponse>;
  /** update single row of the table: "quote_line_items" */
  updateQuoteLineItemsByPk?: Maybe<QuoteLineItems>;
  /** update multiples rows of table: "quote_line_items" */
  updateQuoteLineItemsMany?: Maybe<Array<Maybe<QuoteLineItemsMutationResponse>>>;
  /** update data of the table: "quote_templates" */
  updateQuoteTemplates?: Maybe<QuoteTemplatesMutationResponse>;
  /** update single row of the table: "quote_templates" */
  updateQuoteTemplatesByPk?: Maybe<QuoteTemplates>;
  /** update multiples rows of table: "quote_templates" */
  updateQuoteTemplatesMany?: Maybe<Array<Maybe<QuoteTemplatesMutationResponse>>>;
  /** update data of the table: "quotes" */
  updateQuotes?: Maybe<QuotesMutationResponse>;
  /** update single row of the table: "quotes" */
  updateQuotesByPk?: Maybe<Quotes>;
  /** update multiples rows of table: "quotes" */
  updateQuotesMany?: Maybe<Array<Maybe<QuotesMutationResponse>>>;
  /** update data of the table: "rate_limits" */
  updateRateLimits?: Maybe<RateLimitsMutationResponse>;
  /** update single row of the table: "rate_limits" */
  updateRateLimitsByPk?: Maybe<RateLimits>;
  /** update multiples rows of table: "rate_limits" */
  updateRateLimitsMany?: Maybe<Array<Maybe<RateLimitsMutationResponse>>>;
  /** update data of the table: "resources" */
  updateResources?: Maybe<ResourcesMutationResponse>;
  /** update single row of the table: "resources" */
  updateResourcesByPk?: Maybe<Resources>;
  /** update multiples rows of table: "resources" */
  updateResourcesMany?: Maybe<Array<Maybe<ResourcesMutationResponse>>>;
  /** update data of the table: "role_permissions" */
  updateRolePermissions?: Maybe<RolePermissionsMutationResponse>;
  /** update single row of the table: "role_permissions" */
  updateRolePermissionsByPk?: Maybe<RolePermissions>;
  /** update multiples rows of table: "role_permissions" */
  updateRolePermissionsMany?: Maybe<Array<Maybe<RolePermissionsMutationResponse>>>;
  /** update data of the table: "roles" */
  updateRoles?: Maybe<RolesMutationResponse>;
  /** update single row of the table: "roles" */
  updateRolesByPk?: Maybe<Roles>;
  /** update multiples rows of table: "roles" */
  updateRolesMany?: Maybe<Array<Maybe<RolesMutationResponse>>>;
  /** update data of the table: "security_alerts" */
  updateSecurityAlerts?: Maybe<SecurityAlertsMutationResponse>;
  /** update single row of the table: "security_alerts" */
  updateSecurityAlertsByPk?: Maybe<SecurityAlerts>;
  /** update multiples rows of table: "security_alerts" */
  updateSecurityAlertsMany?: Maybe<Array<Maybe<SecurityAlertsMutationResponse>>>;
  /** update data of the table: "security_settings" */
  updateSecuritySettings?: Maybe<SecuritySettingsMutationResponse>;
  /** update single row of the table: "security_settings" */
  updateSecuritySettingsByPk?: Maybe<SecuritySettings>;
  /** update multiples rows of table: "security_settings" */
  updateSecuritySettingsMany?: Maybe<Array<Maybe<SecuritySettingsMutationResponse>>>;
  /** update data of the table: "service_pricing_rules" */
  updateServicePricingRules?: Maybe<ServicePricingRulesMutationResponse>;
  /** update single row of the table: "service_pricing_rules" */
  updateServicePricingRulesByPk?: Maybe<ServicePricingRules>;
  /** update multiples rows of table: "service_pricing_rules" */
  updateServicePricingRulesMany?: Maybe<Array<Maybe<ServicePricingRulesMutationResponse>>>;
  /** update data of the table: "service_templates" */
  updateServiceTemplates?: Maybe<ServiceTemplatesMutationResponse>;
  /** update single row of the table: "service_templates" */
  updateServiceTemplatesByPk?: Maybe<ServiceTemplates>;
  /** update multiples rows of table: "service_templates" */
  updateServiceTemplatesMany?: Maybe<Array<Maybe<ServiceTemplatesMutationResponse>>>;
  /** update data of the table: "services" */
  updateServices?: Maybe<ServicesMutationResponse>;
  /** update single row of the table: "services" */
  updateServicesByPk?: Maybe<Services>;
  /** update multiples rows of table: "services" */
  updateServicesMany?: Maybe<Array<Maybe<ServicesMutationResponse>>>;
  /** update data of the table: "system_configuration" */
  updateSystemConfiguration?: Maybe<SystemConfigurationMutationResponse>;
  /** update single row of the table: "system_configuration" */
  updateSystemConfigurationByPk?: Maybe<SystemConfiguration>;
  /** update multiples rows of table: "system_configuration" */
  updateSystemConfigurationMany?: Maybe<Array<Maybe<SystemConfigurationMutationResponse>>>;
  /** update data of the table: "system_health" */
  updateSystemHealth?: Maybe<SystemHealthMutationResponse>;
  /** update single row of the table: "system_health" */
  updateSystemHealthByPk?: Maybe<SystemHealth>;
  /** update multiples rows of table: "system_health" */
  updateSystemHealthMany?: Maybe<Array<Maybe<SystemHealthMutationResponse>>>;
  /** update data of the table: "time_entries" */
  updateTimeEntries?: Maybe<TimeEntriesMutationResponse>;
  /** update single row of the table: "time_entries" */
  updateTimeEntriesByPk?: Maybe<TimeEntries>;
  /** update multiples rows of table: "time_entries" */
  updateTimeEntriesMany?: Maybe<Array<Maybe<TimeEntriesMutationResponse>>>;
  /** update data of the table: "user_email_template_favorites" */
  updateUserEmailTemplateFavorites?: Maybe<UserEmailTemplateFavoritesMutationResponse>;
  /** update single row of the table: "user_email_template_favorites" */
  updateUserEmailTemplateFavoritesByPk?: Maybe<UserEmailTemplateFavorites>;
  /** update multiples rows of table: "user_email_template_favorites" */
  updateUserEmailTemplateFavoritesMany?: Maybe<Array<Maybe<UserEmailTemplateFavoritesMutationResponse>>>;
  /** update data of the table: "user_invitations" */
  updateUserInvitations?: Maybe<UserInvitationsMutationResponse>;
  /** update single row of the table: "user_invitations" */
  updateUserInvitationsByPk?: Maybe<UserInvitations>;
  /** update multiples rows of table: "user_invitations" */
  updateUserInvitationsMany?: Maybe<Array<Maybe<UserInvitationsMutationResponse>>>;
  /** update data of the table: "user_rate_history" */
  updateUserRateHistory?: Maybe<UserRateHistoryMutationResponse>;
  /** update single row of the table: "user_rate_history" */
  updateUserRateHistoryByPk?: Maybe<UserRateHistory>;
  /** update multiples rows of table: "user_rate_history" */
  updateUserRateHistoryMany?: Maybe<Array<Maybe<UserRateHistoryMutationResponse>>>;
  /** update data of the table: "user_roles" */
  updateUserRoles?: Maybe<UserRolesMutationResponse>;
  /** update single row of the table: "user_roles" */
  updateUserRolesByPk?: Maybe<UserRoles>;
  /** update multiples rows of table: "user_roles" */
  updateUserRolesMany?: Maybe<Array<Maybe<UserRolesMutationResponse>>>;
  /** update data of the table: "user_sessions" */
  updateUserSessions?: Maybe<UserSessionsMutationResponse>;
  /** update single row of the table: "user_sessions" */
  updateUserSessionsByPk?: Maybe<UserSessions>;
  /** update multiples rows of table: "user_sessions" */
  updateUserSessionsMany?: Maybe<Array<Maybe<UserSessionsMutationResponse>>>;
  /** update data of the table: "user_skills" */
  updateUserSkills?: Maybe<UserSkillsMutationResponse>;
  /** update multiples rows of table: "user_skills" */
  updateUserSkillsMany?: Maybe<Array<Maybe<UserSkillsMutationResponse>>>;
  /** update data of the table: "users" */
  updateUsers?: Maybe<UsersMutationResponse>;
  /** update single row of the table: "users" */
  updateUsersByPk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  updateUsersMany?: Maybe<Array<Maybe<UsersMutationResponse>>>;
  /** update data of the table: "users_role_backup" */
  updateUsersRoleBackup?: Maybe<UsersRoleBackupMutationResponse>;
  /** update multiples rows of table: "users_role_backup" */
  updateUsersRoleBackupMany?: Maybe<Array<Maybe<UsersRoleBackupMutationResponse>>>;
  /** update data of the table: "work_schedule" */
  updateWorkSchedule?: Maybe<WorkScheduleMutationResponse>;
  /** update single row of the table: "work_schedule" */
  updateWorkScheduleByPk?: Maybe<WorkSchedule>;
  /** update multiples rows of table: "work_schedule" */
  updateWorkScheduleMany?: Maybe<Array<Maybe<WorkScheduleMutationResponse>>>;
};


/** mutation root */
export type Mutation_RootActivatePayrollVersionsArgs = {
  distinctOn?: InputMaybe<Array<PayrollActivationResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollActivationResultsOrderBy>>;
  where?: InputMaybe<PayrollActivationResultsBoolExp>;
};


/** mutation root */
export type Mutation_RootCreatePayrollVersionArgs = {
  args: CreatePayrollVersionArgs;
  distinctOn?: InputMaybe<Array<PayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};


/** mutation root */
export type Mutation_RootCreatePayrollVersionSimpleArgs = {
  args: CreatePayrollVersionSimpleArgs;
  distinctOn?: InputMaybe<Array<PayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};


/** mutation root */
export type Mutation_RootDeleteAdjustmentRulesArgs = {
  where: AdjustmentRulesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAdjustmentRulesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAppSettingsArgs = {
  where: AppSettingsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAppSettingsByPkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAuditAuditLogArgs = {
  where: AuditAuditLogBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAuditAuditLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAuditAuthEventsArgs = {
  where: AuditAuthEventsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAuditAuthEventsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAuditDataAccessLogArgs = {
  where: AuditDataAccessLogBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAuditDataAccessLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAuditPermissionChangesArgs = {
  where: AuditPermissionChangesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAuditPermissionChangesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAuditSlowQueriesArgs = {
  where: AuditSlowQueriesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteAuditSlowQueriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteAuditUserAccessSummaryArgs = {
  where: AuditUserAccessSummaryBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteBillingEventLogArgs = {
  where: BillingEventLogBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteBillingEventLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBillingInvoiceArgs = {
  where: BillingInvoiceBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteBillingInvoiceByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBillingInvoiceItemArgs = {
  where: BillingInvoiceItemBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteBillingInvoiceItemByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBillingItemsArgs = {
  where: BillingItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteBillingItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBillingPeriodsArgs = {
  where: BillingPeriodsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteBillingPeriodsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteClientExternalSystemsArgs = {
  where: ClientExternalSystemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteClientExternalSystemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteClientServiceAgreementsArgs = {
  where: ClientServiceAgreementsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteClientServiceAgreementsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteClientsArgs = {
  where: ClientsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteClientsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDataBackupsArgs = {
  where: DataBackupsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteDataBackupsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteEmailDraftsArgs = {
  where: EmailDraftsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEmailDraftsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteEmailSendLogsArgs = {
  where: EmailSendLogsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEmailSendLogsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteEmailTemplatesArgs = {
  where: EmailTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteEmailTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteExternalSystemsArgs = {
  where: ExternalSystemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteExternalSystemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteFeatureFlagsArgs = {
  where: FeatureFlagsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteFeatureFlagsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteFilesArgs = {
  where: FilesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteFilesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteHolidaysArgs = {
  where: HolidaysBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteHolidaysByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteLatestPayrollVersionResultsArgs = {
  where: LatestPayrollVersionResultsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLatestPayrollVersionResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteLeaveArgs = {
  where: LeaveBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteLeaveByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMonthlyBillingCompletionArgs = {
  where: MonthlyBillingCompletionBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteMonthlyBillingCompletionByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteNotesArgs = {
  where: NotesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteNotesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollActivationResultsArgs = {
  where: PayrollActivationResultsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollActivationResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollAssignmentAuditArgs = {
  where: PayrollAssignmentAuditBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollAssignmentAuditByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollAssignmentsArgs = {
  where: PayrollAssignmentsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollAssignmentsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollCyclesArgs = {
  where: PayrollCyclesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollCyclesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollDateTimeEntriesArgs = {
  where: PayrollDateTimeEntriesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollDateTimeEntriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollDateTypesArgs = {
  where: PayrollDateTypesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollDateTypesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollDatesArgs = {
  where: PayrollDatesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollDatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollRequiredSkillsArgs = {
  where: PayrollRequiredSkillsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollServiceAgreementsArgs = {
  where: PayrollServiceAgreementsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollServiceAgreementsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollVersionHistoryResultsArgs = {
  where: PayrollVersionHistoryResultsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollVersionHistoryResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollVersionResultsArgs = {
  where: PayrollVersionResultsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollVersionResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePayrollsArgs = {
  where: PayrollsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePayrollsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePermissionAuditLogArgs = {
  where: PermissionAuditLogBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePermissionAuditLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePermissionOverridesArgs = {
  where: PermissionOverridesBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePermissionOverridesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePermissionsArgs = {
  where: PermissionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePermissionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePositionAdminDefaultsArgs = {
  where: PositionAdminDefaultsBoolExp;
};


/** mutation root */
export type Mutation_RootDeletePositionAdminDefaultsByPkArgs = {
  position: Scalars['user_position']['input'];
};


/** mutation root */
export type Mutation_RootDeleteQuoteConversionsArgs = {
  where: QuoteConversionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteQuoteConversionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteQuoteLineItemsArgs = {
  where: QuoteLineItemsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteQuoteLineItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteQuoteTemplatesArgs = {
  where: QuoteTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteQuoteTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteQuotesArgs = {
  where: QuotesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteQuotesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteRateLimitsArgs = {
  where: RateLimitsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteRateLimitsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteResourcesArgs = {
  where: ResourcesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteResourcesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteRolePermissionsArgs = {
  where: RolePermissionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteRolePermissionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteRolesArgs = {
  where: RolesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteRolesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSecurityAlertsArgs = {
  where: SecurityAlertsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSecurityAlertsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSecuritySettingsArgs = {
  where: SecuritySettingsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSecuritySettingsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteServicePricingRulesArgs = {
  where: ServicePricingRulesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteServicePricingRulesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteServiceTemplatesArgs = {
  where: ServiceTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteServiceTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteServicesArgs = {
  where: ServicesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteServicesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSystemConfigurationArgs = {
  where: SystemConfigurationBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSystemConfigurationByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSystemHealthArgs = {
  where: SystemHealthBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteSystemHealthByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTimeEntriesArgs = {
  where: TimeEntriesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteTimeEntriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUserEmailTemplateFavoritesArgs = {
  where: UserEmailTemplateFavoritesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserEmailTemplateFavoritesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUserInvitationsArgs = {
  where: UserInvitationsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserInvitationsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUserRateHistoryArgs = {
  where: UserRateHistoryBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserRateHistoryByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUserRolesArgs = {
  where: UserRolesBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserRolesByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUserSessionsArgs = {
  where: UserSessionsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUserSessionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUserSkillsArgs = {
  where: UserSkillsBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsersArgs = {
  where: UsersBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteUsersRoleBackupArgs = {
  where: UsersRoleBackupBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteWorkScheduleArgs = {
  where: WorkScheduleBoolExp;
};


/** mutation root */
export type Mutation_RootDeleteWorkScheduleByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootGeneratePayrollDatesArgs = {
  args: GeneratePayrollDatesArgs;
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


/** mutation root */
export type Mutation_RootInsertAdjustmentRulesArgs = {
  objects: Array<AdjustmentRulesInsertInput>;
  onConflict?: InputMaybe<AdjustmentRulesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAdjustmentRulesOneArgs = {
  object: AdjustmentRulesInsertInput;
  onConflict?: InputMaybe<AdjustmentRulesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAppSettingsArgs = {
  objects: Array<AppSettingsInsertInput>;
  onConflict?: InputMaybe<AppSettingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAppSettingsOneArgs = {
  object: AppSettingsInsertInput;
  onConflict?: InputMaybe<AppSettingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditAuditLogArgs = {
  objects: Array<AuditAuditLogInsertInput>;
  onConflict?: InputMaybe<AuditAuditLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditAuditLogOneArgs = {
  object: AuditAuditLogInsertInput;
  onConflict?: InputMaybe<AuditAuditLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditAuthEventsArgs = {
  objects: Array<AuditAuthEventsInsertInput>;
  onConflict?: InputMaybe<AuditAuthEventsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditAuthEventsOneArgs = {
  object: AuditAuthEventsInsertInput;
  onConflict?: InputMaybe<AuditAuthEventsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditDataAccessLogArgs = {
  objects: Array<AuditDataAccessLogInsertInput>;
  onConflict?: InputMaybe<AuditDataAccessLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditDataAccessLogOneArgs = {
  object: AuditDataAccessLogInsertInput;
  onConflict?: InputMaybe<AuditDataAccessLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditPermissionChangesArgs = {
  objects: Array<AuditPermissionChangesInsertInput>;
  onConflict?: InputMaybe<AuditPermissionChangesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditPermissionChangesOneArgs = {
  object: AuditPermissionChangesInsertInput;
  onConflict?: InputMaybe<AuditPermissionChangesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditSlowQueriesArgs = {
  objects: Array<AuditSlowQueriesInsertInput>;
  onConflict?: InputMaybe<AuditSlowQueriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditSlowQueriesOneArgs = {
  object: AuditSlowQueriesInsertInput;
  onConflict?: InputMaybe<AuditSlowQueriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertAuditUserAccessSummaryArgs = {
  objects: Array<AuditUserAccessSummaryInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertAuditUserAccessSummaryOneArgs = {
  object: AuditUserAccessSummaryInsertInput;
};


/** mutation root */
export type Mutation_RootInsertBillingEventLogArgs = {
  objects: Array<BillingEventLogInsertInput>;
  onConflict?: InputMaybe<BillingEventLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingEventLogOneArgs = {
  object: BillingEventLogInsertInput;
  onConflict?: InputMaybe<BillingEventLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingInvoiceArgs = {
  objects: Array<BillingInvoiceInsertInput>;
  onConflict?: InputMaybe<BillingInvoiceOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingInvoiceItemArgs = {
  objects: Array<BillingInvoiceItemInsertInput>;
  onConflict?: InputMaybe<BillingInvoiceItemOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingInvoiceItemOneArgs = {
  object: BillingInvoiceItemInsertInput;
  onConflict?: InputMaybe<BillingInvoiceItemOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingInvoiceOneArgs = {
  object: BillingInvoiceInsertInput;
  onConflict?: InputMaybe<BillingInvoiceOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingItemsArgs = {
  objects: Array<BillingItemsInsertInput>;
  onConflict?: InputMaybe<BillingItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingItemsOneArgs = {
  object: BillingItemsInsertInput;
  onConflict?: InputMaybe<BillingItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingPeriodsArgs = {
  objects: Array<BillingPeriodsInsertInput>;
  onConflict?: InputMaybe<BillingPeriodsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingPeriodsOneArgs = {
  object: BillingPeriodsInsertInput;
  onConflict?: InputMaybe<BillingPeriodsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertClientExternalSystemsArgs = {
  objects: Array<ClientExternalSystemsInsertInput>;
  onConflict?: InputMaybe<ClientExternalSystemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertClientExternalSystemsOneArgs = {
  object: ClientExternalSystemsInsertInput;
  onConflict?: InputMaybe<ClientExternalSystemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertClientServiceAgreementsArgs = {
  objects: Array<ClientServiceAgreementsInsertInput>;
  onConflict?: InputMaybe<ClientServiceAgreementsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertClientServiceAgreementsOneArgs = {
  object: ClientServiceAgreementsInsertInput;
  onConflict?: InputMaybe<ClientServiceAgreementsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertClientsArgs = {
  objects: Array<ClientsInsertInput>;
  onConflict?: InputMaybe<ClientsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertClientsOneArgs = {
  object: ClientsInsertInput;
  onConflict?: InputMaybe<ClientsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDataBackupsArgs = {
  objects: Array<DataBackupsInsertInput>;
  onConflict?: InputMaybe<DataBackupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertDataBackupsOneArgs = {
  object: DataBackupsInsertInput;
  onConflict?: InputMaybe<DataBackupsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailDraftsArgs = {
  objects: Array<EmailDraftsInsertInput>;
  onConflict?: InputMaybe<EmailDraftsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailDraftsOneArgs = {
  object: EmailDraftsInsertInput;
  onConflict?: InputMaybe<EmailDraftsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailSendLogsArgs = {
  objects: Array<EmailSendLogsInsertInput>;
  onConflict?: InputMaybe<EmailSendLogsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailSendLogsOneArgs = {
  object: EmailSendLogsInsertInput;
  onConflict?: InputMaybe<EmailSendLogsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailTemplatesArgs = {
  objects: Array<EmailTemplatesInsertInput>;
  onConflict?: InputMaybe<EmailTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertEmailTemplatesOneArgs = {
  object: EmailTemplatesInsertInput;
  onConflict?: InputMaybe<EmailTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertExternalSystemsArgs = {
  objects: Array<ExternalSystemsInsertInput>;
  onConflict?: InputMaybe<ExternalSystemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertExternalSystemsOneArgs = {
  object: ExternalSystemsInsertInput;
  onConflict?: InputMaybe<ExternalSystemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFeatureFlagsArgs = {
  objects: Array<FeatureFlagsInsertInput>;
  onConflict?: InputMaybe<FeatureFlagsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFeatureFlagsOneArgs = {
  object: FeatureFlagsInsertInput;
  onConflict?: InputMaybe<FeatureFlagsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFilesArgs = {
  objects: Array<FilesInsertInput>;
  onConflict?: InputMaybe<FilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertFilesOneArgs = {
  object: FilesInsertInput;
  onConflict?: InputMaybe<FilesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertHolidaysArgs = {
  objects: Array<HolidaysInsertInput>;
  onConflict?: InputMaybe<HolidaysOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertHolidaysOneArgs = {
  object: HolidaysInsertInput;
  onConflict?: InputMaybe<HolidaysOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLatestPayrollVersionResultsArgs = {
  objects: Array<LatestPayrollVersionResultsInsertInput>;
  onConflict?: InputMaybe<LatestPayrollVersionResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLatestPayrollVersionResultsOneArgs = {
  object: LatestPayrollVersionResultsInsertInput;
  onConflict?: InputMaybe<LatestPayrollVersionResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLeaveArgs = {
  objects: Array<LeaveInsertInput>;
  onConflict?: InputMaybe<LeaveOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertLeaveOneArgs = {
  object: LeaveInsertInput;
  onConflict?: InputMaybe<LeaveOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMonthlyBillingCompletionArgs = {
  objects: Array<MonthlyBillingCompletionInsertInput>;
  onConflict?: InputMaybe<MonthlyBillingCompletionOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertMonthlyBillingCompletionOneArgs = {
  object: MonthlyBillingCompletionInsertInput;
  onConflict?: InputMaybe<MonthlyBillingCompletionOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertNotesArgs = {
  objects: Array<NotesInsertInput>;
  onConflict?: InputMaybe<NotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertNotesOneArgs = {
  object: NotesInsertInput;
  onConflict?: InputMaybe<NotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollActivationResultsArgs = {
  objects: Array<PayrollActivationResultsInsertInput>;
  onConflict?: InputMaybe<PayrollActivationResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollActivationResultsOneArgs = {
  object: PayrollActivationResultsInsertInput;
  onConflict?: InputMaybe<PayrollActivationResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollAssignmentAuditArgs = {
  objects: Array<PayrollAssignmentAuditInsertInput>;
  onConflict?: InputMaybe<PayrollAssignmentAuditOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollAssignmentAuditOneArgs = {
  object: PayrollAssignmentAuditInsertInput;
  onConflict?: InputMaybe<PayrollAssignmentAuditOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollAssignmentsArgs = {
  objects: Array<PayrollAssignmentsInsertInput>;
  onConflict?: InputMaybe<PayrollAssignmentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollAssignmentsOneArgs = {
  object: PayrollAssignmentsInsertInput;
  onConflict?: InputMaybe<PayrollAssignmentsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollCyclesArgs = {
  objects: Array<PayrollCyclesInsertInput>;
  onConflict?: InputMaybe<PayrollCyclesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollCyclesOneArgs = {
  object: PayrollCyclesInsertInput;
  onConflict?: InputMaybe<PayrollCyclesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollDateTimeEntriesArgs = {
  objects: Array<PayrollDateTimeEntriesInsertInput>;
  onConflict?: InputMaybe<PayrollDateTimeEntriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollDateTimeEntriesOneArgs = {
  object: PayrollDateTimeEntriesInsertInput;
  onConflict?: InputMaybe<PayrollDateTimeEntriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollDateTypesArgs = {
  objects: Array<PayrollDateTypesInsertInput>;
  onConflict?: InputMaybe<PayrollDateTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollDateTypesOneArgs = {
  object: PayrollDateTypesInsertInput;
  onConflict?: InputMaybe<PayrollDateTypesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollDatesArgs = {
  objects: Array<PayrollDatesInsertInput>;
  onConflict?: InputMaybe<PayrollDatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollDatesOneArgs = {
  object: PayrollDatesInsertInput;
  onConflict?: InputMaybe<PayrollDatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollRequiredSkillsArgs = {
  objects: Array<PayrollRequiredSkillsInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertPayrollRequiredSkillsOneArgs = {
  object: PayrollRequiredSkillsInsertInput;
};


/** mutation root */
export type Mutation_RootInsertPayrollServiceAgreementsArgs = {
  objects: Array<PayrollServiceAgreementsInsertInput>;
  onConflict?: InputMaybe<PayrollServiceAgreementsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollServiceAgreementsOneArgs = {
  object: PayrollServiceAgreementsInsertInput;
  onConflict?: InputMaybe<PayrollServiceAgreementsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollVersionHistoryResultsArgs = {
  objects: Array<PayrollVersionHistoryResultsInsertInput>;
  onConflict?: InputMaybe<PayrollVersionHistoryResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollVersionHistoryResultsOneArgs = {
  object: PayrollVersionHistoryResultsInsertInput;
  onConflict?: InputMaybe<PayrollVersionHistoryResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollVersionResultsArgs = {
  objects: Array<PayrollVersionResultsInsertInput>;
  onConflict?: InputMaybe<PayrollVersionResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollVersionResultsOneArgs = {
  object: PayrollVersionResultsInsertInput;
  onConflict?: InputMaybe<PayrollVersionResultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollsArgs = {
  objects: Array<PayrollsInsertInput>;
  onConflict?: InputMaybe<PayrollsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPayrollsOneArgs = {
  object: PayrollsInsertInput;
  onConflict?: InputMaybe<PayrollsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPermissionAuditLogArgs = {
  objects: Array<PermissionAuditLogInsertInput>;
  onConflict?: InputMaybe<PermissionAuditLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPermissionAuditLogOneArgs = {
  object: PermissionAuditLogInsertInput;
  onConflict?: InputMaybe<PermissionAuditLogOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPermissionOverridesArgs = {
  objects: Array<PermissionOverridesInsertInput>;
  onConflict?: InputMaybe<PermissionOverridesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPermissionOverridesOneArgs = {
  object: PermissionOverridesInsertInput;
  onConflict?: InputMaybe<PermissionOverridesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPermissionsArgs = {
  objects: Array<PermissionsInsertInput>;
  onConflict?: InputMaybe<PermissionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPermissionsOneArgs = {
  object: PermissionsInsertInput;
  onConflict?: InputMaybe<PermissionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPositionAdminDefaultsArgs = {
  objects: Array<PositionAdminDefaultsInsertInput>;
  onConflict?: InputMaybe<PositionAdminDefaultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertPositionAdminDefaultsOneArgs = {
  object: PositionAdminDefaultsInsertInput;
  onConflict?: InputMaybe<PositionAdminDefaultsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuoteConversionsArgs = {
  objects: Array<QuoteConversionsInsertInput>;
  onConflict?: InputMaybe<QuoteConversionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuoteConversionsOneArgs = {
  object: QuoteConversionsInsertInput;
  onConflict?: InputMaybe<QuoteConversionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuoteLineItemsArgs = {
  objects: Array<QuoteLineItemsInsertInput>;
  onConflict?: InputMaybe<QuoteLineItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuoteLineItemsOneArgs = {
  object: QuoteLineItemsInsertInput;
  onConflict?: InputMaybe<QuoteLineItemsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuoteTemplatesArgs = {
  objects: Array<QuoteTemplatesInsertInput>;
  onConflict?: InputMaybe<QuoteTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuoteTemplatesOneArgs = {
  object: QuoteTemplatesInsertInput;
  onConflict?: InputMaybe<QuoteTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuotesArgs = {
  objects: Array<QuotesInsertInput>;
  onConflict?: InputMaybe<QuotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertQuotesOneArgs = {
  object: QuotesInsertInput;
  onConflict?: InputMaybe<QuotesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRateLimitsArgs = {
  objects: Array<RateLimitsInsertInput>;
  onConflict?: InputMaybe<RateLimitsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRateLimitsOneArgs = {
  object: RateLimitsInsertInput;
  onConflict?: InputMaybe<RateLimitsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertResourcesArgs = {
  objects: Array<ResourcesInsertInput>;
  onConflict?: InputMaybe<ResourcesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertResourcesOneArgs = {
  object: ResourcesInsertInput;
  onConflict?: InputMaybe<ResourcesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRolePermissionsArgs = {
  objects: Array<RolePermissionsInsertInput>;
  onConflict?: InputMaybe<RolePermissionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRolePermissionsOneArgs = {
  object: RolePermissionsInsertInput;
  onConflict?: InputMaybe<RolePermissionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRolesArgs = {
  objects: Array<RolesInsertInput>;
  onConflict?: InputMaybe<RolesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertRolesOneArgs = {
  object: RolesInsertInput;
  onConflict?: InputMaybe<RolesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSecurityAlertsArgs = {
  objects: Array<SecurityAlertsInsertInput>;
  onConflict?: InputMaybe<SecurityAlertsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSecurityAlertsOneArgs = {
  object: SecurityAlertsInsertInput;
  onConflict?: InputMaybe<SecurityAlertsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSecuritySettingsArgs = {
  objects: Array<SecuritySettingsInsertInput>;
  onConflict?: InputMaybe<SecuritySettingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSecuritySettingsOneArgs = {
  object: SecuritySettingsInsertInput;
  onConflict?: InputMaybe<SecuritySettingsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertServicePricingRulesArgs = {
  objects: Array<ServicePricingRulesInsertInput>;
  onConflict?: InputMaybe<ServicePricingRulesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertServicePricingRulesOneArgs = {
  object: ServicePricingRulesInsertInput;
  onConflict?: InputMaybe<ServicePricingRulesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertServiceTemplatesArgs = {
  objects: Array<ServiceTemplatesInsertInput>;
  onConflict?: InputMaybe<ServiceTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertServiceTemplatesOneArgs = {
  object: ServiceTemplatesInsertInput;
  onConflict?: InputMaybe<ServiceTemplatesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertServicesArgs = {
  objects: Array<ServicesInsertInput>;
  onConflict?: InputMaybe<ServicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertServicesOneArgs = {
  object: ServicesInsertInput;
  onConflict?: InputMaybe<ServicesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSystemConfigurationArgs = {
  objects: Array<SystemConfigurationInsertInput>;
  onConflict?: InputMaybe<SystemConfigurationOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSystemConfigurationOneArgs = {
  object: SystemConfigurationInsertInput;
  onConflict?: InputMaybe<SystemConfigurationOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSystemHealthArgs = {
  objects: Array<SystemHealthInsertInput>;
  onConflict?: InputMaybe<SystemHealthOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertSystemHealthOneArgs = {
  object: SystemHealthInsertInput;
  onConflict?: InputMaybe<SystemHealthOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTimeEntriesArgs = {
  objects: Array<TimeEntriesInsertInput>;
  onConflict?: InputMaybe<TimeEntriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertTimeEntriesOneArgs = {
  object: TimeEntriesInsertInput;
  onConflict?: InputMaybe<TimeEntriesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserEmailTemplateFavoritesArgs = {
  objects: Array<UserEmailTemplateFavoritesInsertInput>;
  onConflict?: InputMaybe<UserEmailTemplateFavoritesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserEmailTemplateFavoritesOneArgs = {
  object: UserEmailTemplateFavoritesInsertInput;
  onConflict?: InputMaybe<UserEmailTemplateFavoritesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserInvitationsArgs = {
  objects: Array<UserInvitationsInsertInput>;
  onConflict?: InputMaybe<UserInvitationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserInvitationsOneArgs = {
  object: UserInvitationsInsertInput;
  onConflict?: InputMaybe<UserInvitationsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserRateHistoryArgs = {
  objects: Array<UserRateHistoryInsertInput>;
  onConflict?: InputMaybe<UserRateHistoryOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserRateHistoryOneArgs = {
  object: UserRateHistoryInsertInput;
  onConflict?: InputMaybe<UserRateHistoryOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserRolesArgs = {
  objects: Array<UserRolesInsertInput>;
  onConflict?: InputMaybe<UserRolesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserRolesOneArgs = {
  object: UserRolesInsertInput;
  onConflict?: InputMaybe<UserRolesOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserSessionsArgs = {
  objects: Array<UserSessionsInsertInput>;
  onConflict?: InputMaybe<UserSessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserSessionsOneArgs = {
  object: UserSessionsInsertInput;
  onConflict?: InputMaybe<UserSessionsOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUserSkillsArgs = {
  objects: Array<UserSkillsInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertUserSkillsOneArgs = {
  object: UserSkillsInsertInput;
};


/** mutation root */
export type Mutation_RootInsertUsersArgs = {
  objects: Array<UsersInsertInput>;
  onConflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersOneArgs = {
  object: UsersInsertInput;
  onConflict?: InputMaybe<UsersOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersRoleBackupArgs = {
  objects: Array<UsersRoleBackupInsertInput>;
};


/** mutation root */
export type Mutation_RootInsertUsersRoleBackupOneArgs = {
  object: UsersRoleBackupInsertInput;
};


/** mutation root */
export type Mutation_RootInsertWorkScheduleArgs = {
  objects: Array<WorkScheduleInsertInput>;
  onConflict?: InputMaybe<WorkScheduleOnConflict>;
};


/** mutation root */
export type Mutation_RootInsertWorkScheduleOneArgs = {
  object: WorkScheduleInsertInput;
  onConflict?: InputMaybe<WorkScheduleOnConflict>;
};


/** mutation root */
export type Mutation_RootUpdateAdjustmentRulesArgs = {
  _set?: InputMaybe<AdjustmentRulesSetInput>;
  where: AdjustmentRulesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAdjustmentRulesByPkArgs = {
  _set?: InputMaybe<AdjustmentRulesSetInput>;
  pkColumns: AdjustmentRulesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAdjustmentRulesManyArgs = {
  updates: Array<AdjustmentRulesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAppSettingsArgs = {
  _append?: InputMaybe<AppSettingsAppendInput>;
  _deleteAtPath?: InputMaybe<AppSettingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AppSettingsDeleteElemInput>;
  _deleteKey?: InputMaybe<AppSettingsDeleteKeyInput>;
  _prepend?: InputMaybe<AppSettingsPrependInput>;
  _set?: InputMaybe<AppSettingsSetInput>;
  where: AppSettingsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAppSettingsByPkArgs = {
  _append?: InputMaybe<AppSettingsAppendInput>;
  _deleteAtPath?: InputMaybe<AppSettingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AppSettingsDeleteElemInput>;
  _deleteKey?: InputMaybe<AppSettingsDeleteKeyInput>;
  _prepend?: InputMaybe<AppSettingsPrependInput>;
  _set?: InputMaybe<AppSettingsSetInput>;
  pkColumns: AppSettingsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAppSettingsManyArgs = {
  updates: Array<AppSettingsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAuditAuditLogArgs = {
  _append?: InputMaybe<AuditAuditLogAppendInput>;
  _deleteAtPath?: InputMaybe<AuditAuditLogDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditAuditLogDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditAuditLogDeleteKeyInput>;
  _prepend?: InputMaybe<AuditAuditLogPrependInput>;
  _set?: InputMaybe<AuditAuditLogSetInput>;
  where: AuditAuditLogBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAuditAuditLogByPkArgs = {
  _append?: InputMaybe<AuditAuditLogAppendInput>;
  _deleteAtPath?: InputMaybe<AuditAuditLogDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditAuditLogDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditAuditLogDeleteKeyInput>;
  _prepend?: InputMaybe<AuditAuditLogPrependInput>;
  _set?: InputMaybe<AuditAuditLogSetInput>;
  pkColumns: AuditAuditLogPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAuditAuditLogManyArgs = {
  updates: Array<AuditAuditLogUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAuditAuthEventsArgs = {
  _append?: InputMaybe<AuditAuthEventsAppendInput>;
  _deleteAtPath?: InputMaybe<AuditAuthEventsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditAuthEventsDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditAuthEventsDeleteKeyInput>;
  _prepend?: InputMaybe<AuditAuthEventsPrependInput>;
  _set?: InputMaybe<AuditAuthEventsSetInput>;
  where: AuditAuthEventsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAuditAuthEventsByPkArgs = {
  _append?: InputMaybe<AuditAuthEventsAppendInput>;
  _deleteAtPath?: InputMaybe<AuditAuthEventsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditAuthEventsDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditAuthEventsDeleteKeyInput>;
  _prepend?: InputMaybe<AuditAuthEventsPrependInput>;
  _set?: InputMaybe<AuditAuthEventsSetInput>;
  pkColumns: AuditAuthEventsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAuditAuthEventsManyArgs = {
  updates: Array<AuditAuthEventsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAuditDataAccessLogArgs = {
  _append?: InputMaybe<AuditDataAccessLogAppendInput>;
  _deleteAtPath?: InputMaybe<AuditDataAccessLogDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditDataAccessLogDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditDataAccessLogDeleteKeyInput>;
  _inc?: InputMaybe<AuditDataAccessLogIncInput>;
  _prepend?: InputMaybe<AuditDataAccessLogPrependInput>;
  _set?: InputMaybe<AuditDataAccessLogSetInput>;
  where: AuditDataAccessLogBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAuditDataAccessLogByPkArgs = {
  _append?: InputMaybe<AuditDataAccessLogAppendInput>;
  _deleteAtPath?: InputMaybe<AuditDataAccessLogDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditDataAccessLogDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditDataAccessLogDeleteKeyInput>;
  _inc?: InputMaybe<AuditDataAccessLogIncInput>;
  _prepend?: InputMaybe<AuditDataAccessLogPrependInput>;
  _set?: InputMaybe<AuditDataAccessLogSetInput>;
  pkColumns: AuditDataAccessLogPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAuditDataAccessLogManyArgs = {
  updates: Array<AuditDataAccessLogUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAuditPermissionChangesArgs = {
  _append?: InputMaybe<AuditPermissionChangesAppendInput>;
  _deleteAtPath?: InputMaybe<AuditPermissionChangesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditPermissionChangesDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditPermissionChangesDeleteKeyInput>;
  _prepend?: InputMaybe<AuditPermissionChangesPrependInput>;
  _set?: InputMaybe<AuditPermissionChangesSetInput>;
  where: AuditPermissionChangesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAuditPermissionChangesByPkArgs = {
  _append?: InputMaybe<AuditPermissionChangesAppendInput>;
  _deleteAtPath?: InputMaybe<AuditPermissionChangesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<AuditPermissionChangesDeleteElemInput>;
  _deleteKey?: InputMaybe<AuditPermissionChangesDeleteKeyInput>;
  _prepend?: InputMaybe<AuditPermissionChangesPrependInput>;
  _set?: InputMaybe<AuditPermissionChangesSetInput>;
  pkColumns: AuditPermissionChangesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAuditPermissionChangesManyArgs = {
  updates: Array<AuditPermissionChangesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAuditSlowQueriesArgs = {
  _set?: InputMaybe<AuditSlowQueriesSetInput>;
  where: AuditSlowQueriesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAuditSlowQueriesByPkArgs = {
  _set?: InputMaybe<AuditSlowQueriesSetInput>;
  pkColumns: AuditSlowQueriesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateAuditSlowQueriesManyArgs = {
  updates: Array<AuditSlowQueriesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateAuditUserAccessSummaryArgs = {
  _set?: InputMaybe<AuditUserAccessSummarySetInput>;
  where: AuditUserAccessSummaryBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateAuditUserAccessSummaryManyArgs = {
  updates: Array<AuditUserAccessSummaryUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateBillingEventLogArgs = {
  _set?: InputMaybe<BillingEventLogSetInput>;
  where: BillingEventLogBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateBillingEventLogByPkArgs = {
  _set?: InputMaybe<BillingEventLogSetInput>;
  pkColumns: BillingEventLogPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateBillingEventLogManyArgs = {
  updates: Array<BillingEventLogUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateBillingInvoiceArgs = {
  _inc?: InputMaybe<BillingInvoiceIncInput>;
  _set?: InputMaybe<BillingInvoiceSetInput>;
  where: BillingInvoiceBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateBillingInvoiceByPkArgs = {
  _inc?: InputMaybe<BillingInvoiceIncInput>;
  _set?: InputMaybe<BillingInvoiceSetInput>;
  pkColumns: BillingInvoicePkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateBillingInvoiceItemArgs = {
  _inc?: InputMaybe<BillingInvoiceItemIncInput>;
  _set?: InputMaybe<BillingInvoiceItemSetInput>;
  where: BillingInvoiceItemBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateBillingInvoiceItemByPkArgs = {
  _inc?: InputMaybe<BillingInvoiceItemIncInput>;
  _set?: InputMaybe<BillingInvoiceItemSetInput>;
  pkColumns: BillingInvoiceItemPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateBillingInvoiceItemManyArgs = {
  updates: Array<BillingInvoiceItemUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateBillingInvoiceManyArgs = {
  updates: Array<BillingInvoiceUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateBillingItemsArgs = {
  _inc?: InputMaybe<BillingItemsIncInput>;
  _set?: InputMaybe<BillingItemsSetInput>;
  where: BillingItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateBillingItemsByPkArgs = {
  _inc?: InputMaybe<BillingItemsIncInput>;
  _set?: InputMaybe<BillingItemsSetInput>;
  pkColumns: BillingItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateBillingItemsManyArgs = {
  updates: Array<BillingItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateBillingPeriodsArgs = {
  _append?: InputMaybe<BillingPeriodsAppendInput>;
  _deleteAtPath?: InputMaybe<BillingPeriodsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<BillingPeriodsDeleteElemInput>;
  _deleteKey?: InputMaybe<BillingPeriodsDeleteKeyInput>;
  _inc?: InputMaybe<BillingPeriodsIncInput>;
  _prepend?: InputMaybe<BillingPeriodsPrependInput>;
  _set?: InputMaybe<BillingPeriodsSetInput>;
  where: BillingPeriodsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateBillingPeriodsByPkArgs = {
  _append?: InputMaybe<BillingPeriodsAppendInput>;
  _deleteAtPath?: InputMaybe<BillingPeriodsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<BillingPeriodsDeleteElemInput>;
  _deleteKey?: InputMaybe<BillingPeriodsDeleteKeyInput>;
  _inc?: InputMaybe<BillingPeriodsIncInput>;
  _prepend?: InputMaybe<BillingPeriodsPrependInput>;
  _set?: InputMaybe<BillingPeriodsSetInput>;
  pkColumns: BillingPeriodsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateBillingPeriodsManyArgs = {
  updates: Array<BillingPeriodsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateClientExternalSystemsArgs = {
  _set?: InputMaybe<ClientExternalSystemsSetInput>;
  where: ClientExternalSystemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateClientExternalSystemsByPkArgs = {
  _set?: InputMaybe<ClientExternalSystemsSetInput>;
  pkColumns: ClientExternalSystemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateClientExternalSystemsManyArgs = {
  updates: Array<ClientExternalSystemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateClientServiceAgreementsArgs = {
  _append?: InputMaybe<ClientServiceAgreementsAppendInput>;
  _deleteAtPath?: InputMaybe<ClientServiceAgreementsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ClientServiceAgreementsDeleteElemInput>;
  _deleteKey?: InputMaybe<ClientServiceAgreementsDeleteKeyInput>;
  _inc?: InputMaybe<ClientServiceAgreementsIncInput>;
  _prepend?: InputMaybe<ClientServiceAgreementsPrependInput>;
  _set?: InputMaybe<ClientServiceAgreementsSetInput>;
  where: ClientServiceAgreementsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateClientServiceAgreementsByPkArgs = {
  _append?: InputMaybe<ClientServiceAgreementsAppendInput>;
  _deleteAtPath?: InputMaybe<ClientServiceAgreementsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ClientServiceAgreementsDeleteElemInput>;
  _deleteKey?: InputMaybe<ClientServiceAgreementsDeleteKeyInput>;
  _inc?: InputMaybe<ClientServiceAgreementsIncInput>;
  _prepend?: InputMaybe<ClientServiceAgreementsPrependInput>;
  _set?: InputMaybe<ClientServiceAgreementsSetInput>;
  pkColumns: ClientServiceAgreementsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateClientServiceAgreementsManyArgs = {
  updates: Array<ClientServiceAgreementsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateClientsArgs = {
  _set?: InputMaybe<ClientsSetInput>;
  where: ClientsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateClientsByPkArgs = {
  _set?: InputMaybe<ClientsSetInput>;
  pkColumns: ClientsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateClientsManyArgs = {
  updates: Array<ClientsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateDataBackupsArgs = {
  _append?: InputMaybe<DataBackupsAppendInput>;
  _deleteAtPath?: InputMaybe<DataBackupsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<DataBackupsDeleteElemInput>;
  _deleteKey?: InputMaybe<DataBackupsDeleteKeyInput>;
  _inc?: InputMaybe<DataBackupsIncInput>;
  _prepend?: InputMaybe<DataBackupsPrependInput>;
  _set?: InputMaybe<DataBackupsSetInput>;
  where: DataBackupsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateDataBackupsByPkArgs = {
  _append?: InputMaybe<DataBackupsAppendInput>;
  _deleteAtPath?: InputMaybe<DataBackupsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<DataBackupsDeleteElemInput>;
  _deleteKey?: InputMaybe<DataBackupsDeleteKeyInput>;
  _inc?: InputMaybe<DataBackupsIncInput>;
  _prepend?: InputMaybe<DataBackupsPrependInput>;
  _set?: InputMaybe<DataBackupsSetInput>;
  pkColumns: DataBackupsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateDataBackupsManyArgs = {
  updates: Array<DataBackupsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEmailDraftsArgs = {
  _append?: InputMaybe<EmailDraftsAppendInput>;
  _deleteAtPath?: InputMaybe<EmailDraftsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<EmailDraftsDeleteElemInput>;
  _deleteKey?: InputMaybe<EmailDraftsDeleteKeyInput>;
  _prepend?: InputMaybe<EmailDraftsPrependInput>;
  _set?: InputMaybe<EmailDraftsSetInput>;
  where: EmailDraftsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEmailDraftsByPkArgs = {
  _append?: InputMaybe<EmailDraftsAppendInput>;
  _deleteAtPath?: InputMaybe<EmailDraftsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<EmailDraftsDeleteElemInput>;
  _deleteKey?: InputMaybe<EmailDraftsDeleteKeyInput>;
  _prepend?: InputMaybe<EmailDraftsPrependInput>;
  _set?: InputMaybe<EmailDraftsSetInput>;
  pkColumns: EmailDraftsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEmailDraftsManyArgs = {
  updates: Array<EmailDraftsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEmailSendLogsArgs = {
  _append?: InputMaybe<EmailSendLogsAppendInput>;
  _deleteAtPath?: InputMaybe<EmailSendLogsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<EmailSendLogsDeleteElemInput>;
  _deleteKey?: InputMaybe<EmailSendLogsDeleteKeyInput>;
  _prepend?: InputMaybe<EmailSendLogsPrependInput>;
  _set?: InputMaybe<EmailSendLogsSetInput>;
  where: EmailSendLogsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEmailSendLogsByPkArgs = {
  _append?: InputMaybe<EmailSendLogsAppendInput>;
  _deleteAtPath?: InputMaybe<EmailSendLogsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<EmailSendLogsDeleteElemInput>;
  _deleteKey?: InputMaybe<EmailSendLogsDeleteKeyInput>;
  _prepend?: InputMaybe<EmailSendLogsPrependInput>;
  _set?: InputMaybe<EmailSendLogsSetInput>;
  pkColumns: EmailSendLogsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEmailSendLogsManyArgs = {
  updates: Array<EmailSendLogsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateEmailTemplatesArgs = {
  _append?: InputMaybe<EmailTemplatesAppendInput>;
  _deleteAtPath?: InputMaybe<EmailTemplatesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<EmailTemplatesDeleteElemInput>;
  _deleteKey?: InputMaybe<EmailTemplatesDeleteKeyInput>;
  _prepend?: InputMaybe<EmailTemplatesPrependInput>;
  _set?: InputMaybe<EmailTemplatesSetInput>;
  where: EmailTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateEmailTemplatesByPkArgs = {
  _append?: InputMaybe<EmailTemplatesAppendInput>;
  _deleteAtPath?: InputMaybe<EmailTemplatesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<EmailTemplatesDeleteElemInput>;
  _deleteKey?: InputMaybe<EmailTemplatesDeleteKeyInput>;
  _prepend?: InputMaybe<EmailTemplatesPrependInput>;
  _set?: InputMaybe<EmailTemplatesSetInput>;
  pkColumns: EmailTemplatesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateEmailTemplatesManyArgs = {
  updates: Array<EmailTemplatesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateExternalSystemsArgs = {
  _set?: InputMaybe<ExternalSystemsSetInput>;
  where: ExternalSystemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateExternalSystemsByPkArgs = {
  _set?: InputMaybe<ExternalSystemsSetInput>;
  pkColumns: ExternalSystemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateExternalSystemsManyArgs = {
  updates: Array<ExternalSystemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateFeatureFlagsArgs = {
  _append?: InputMaybe<FeatureFlagsAppendInput>;
  _deleteAtPath?: InputMaybe<FeatureFlagsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<FeatureFlagsDeleteElemInput>;
  _deleteKey?: InputMaybe<FeatureFlagsDeleteKeyInput>;
  _prepend?: InputMaybe<FeatureFlagsPrependInput>;
  _set?: InputMaybe<FeatureFlagsSetInput>;
  where: FeatureFlagsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateFeatureFlagsByPkArgs = {
  _append?: InputMaybe<FeatureFlagsAppendInput>;
  _deleteAtPath?: InputMaybe<FeatureFlagsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<FeatureFlagsDeleteElemInput>;
  _deleteKey?: InputMaybe<FeatureFlagsDeleteKeyInput>;
  _prepend?: InputMaybe<FeatureFlagsPrependInput>;
  _set?: InputMaybe<FeatureFlagsSetInput>;
  pkColumns: FeatureFlagsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateFeatureFlagsManyArgs = {
  updates: Array<FeatureFlagsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateFilesArgs = {
  _append?: InputMaybe<FilesAppendInput>;
  _deleteAtPath?: InputMaybe<FilesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<FilesDeleteElemInput>;
  _deleteKey?: InputMaybe<FilesDeleteKeyInput>;
  _inc?: InputMaybe<FilesIncInput>;
  _prepend?: InputMaybe<FilesPrependInput>;
  _set?: InputMaybe<FilesSetInput>;
  where: FilesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateFilesByPkArgs = {
  _append?: InputMaybe<FilesAppendInput>;
  _deleteAtPath?: InputMaybe<FilesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<FilesDeleteElemInput>;
  _deleteKey?: InputMaybe<FilesDeleteKeyInput>;
  _inc?: InputMaybe<FilesIncInput>;
  _prepend?: InputMaybe<FilesPrependInput>;
  _set?: InputMaybe<FilesSetInput>;
  pkColumns: FilesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateFilesManyArgs = {
  updates: Array<FilesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateHolidaysArgs = {
  _inc?: InputMaybe<HolidaysIncInput>;
  _set?: InputMaybe<HolidaysSetInput>;
  where: HolidaysBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateHolidaysByPkArgs = {
  _inc?: InputMaybe<HolidaysIncInput>;
  _set?: InputMaybe<HolidaysSetInput>;
  pkColumns: HolidaysPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateHolidaysManyArgs = {
  updates: Array<HolidaysUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLatestPayrollVersionResultsArgs = {
  _inc?: InputMaybe<LatestPayrollVersionResultsIncInput>;
  _set?: InputMaybe<LatestPayrollVersionResultsSetInput>;
  where: LatestPayrollVersionResultsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLatestPayrollVersionResultsByPkArgs = {
  _inc?: InputMaybe<LatestPayrollVersionResultsIncInput>;
  _set?: InputMaybe<LatestPayrollVersionResultsSetInput>;
  pkColumns: LatestPayrollVersionResultsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLatestPayrollVersionResultsManyArgs = {
  updates: Array<LatestPayrollVersionResultsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateLeaveArgs = {
  _set?: InputMaybe<LeaveSetInput>;
  where: LeaveBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateLeaveByPkArgs = {
  _set?: InputMaybe<LeaveSetInput>;
  pkColumns: LeavePkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateLeaveManyArgs = {
  updates: Array<LeaveUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateMonthlyBillingCompletionArgs = {
  _inc?: InputMaybe<MonthlyBillingCompletionIncInput>;
  _set?: InputMaybe<MonthlyBillingCompletionSetInput>;
  where: MonthlyBillingCompletionBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateMonthlyBillingCompletionByPkArgs = {
  _inc?: InputMaybe<MonthlyBillingCompletionIncInput>;
  _set?: InputMaybe<MonthlyBillingCompletionSetInput>;
  pkColumns: MonthlyBillingCompletionPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateMonthlyBillingCompletionManyArgs = {
  updates: Array<MonthlyBillingCompletionUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateNotesArgs = {
  _set?: InputMaybe<NotesSetInput>;
  where: NotesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateNotesByPkArgs = {
  _set?: InputMaybe<NotesSetInput>;
  pkColumns: NotesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateNotesManyArgs = {
  updates: Array<NotesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollActivationResultsArgs = {
  _inc?: InputMaybe<PayrollActivationResultsIncInput>;
  _set?: InputMaybe<PayrollActivationResultsSetInput>;
  where: PayrollActivationResultsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollActivationResultsByPkArgs = {
  _inc?: InputMaybe<PayrollActivationResultsIncInput>;
  _set?: InputMaybe<PayrollActivationResultsSetInput>;
  pkColumns: PayrollActivationResultsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollActivationResultsManyArgs = {
  updates: Array<PayrollActivationResultsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollAssignmentAuditArgs = {
  _set?: InputMaybe<PayrollAssignmentAuditSetInput>;
  where: PayrollAssignmentAuditBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollAssignmentAuditByPkArgs = {
  _set?: InputMaybe<PayrollAssignmentAuditSetInput>;
  pkColumns: PayrollAssignmentAuditPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollAssignmentAuditManyArgs = {
  updates: Array<PayrollAssignmentAuditUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollAssignmentsArgs = {
  _set?: InputMaybe<PayrollAssignmentsSetInput>;
  where: PayrollAssignmentsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollAssignmentsByPkArgs = {
  _set?: InputMaybe<PayrollAssignmentsSetInput>;
  pkColumns: PayrollAssignmentsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollAssignmentsManyArgs = {
  updates: Array<PayrollAssignmentsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollCyclesArgs = {
  _set?: InputMaybe<PayrollCyclesSetInput>;
  where: PayrollCyclesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollCyclesByPkArgs = {
  _set?: InputMaybe<PayrollCyclesSetInput>;
  pkColumns: PayrollCyclesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollCyclesManyArgs = {
  updates: Array<PayrollCyclesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDateTimeEntriesArgs = {
  _inc?: InputMaybe<PayrollDateTimeEntriesIncInput>;
  _set?: InputMaybe<PayrollDateTimeEntriesSetInput>;
  where: PayrollDateTimeEntriesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDateTimeEntriesByPkArgs = {
  _inc?: InputMaybe<PayrollDateTimeEntriesIncInput>;
  _set?: InputMaybe<PayrollDateTimeEntriesSetInput>;
  pkColumns: PayrollDateTimeEntriesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDateTimeEntriesManyArgs = {
  updates: Array<PayrollDateTimeEntriesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDateTypesArgs = {
  _set?: InputMaybe<PayrollDateTypesSetInput>;
  where: PayrollDateTypesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDateTypesByPkArgs = {
  _set?: InputMaybe<PayrollDateTypesSetInput>;
  pkColumns: PayrollDateTypesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDateTypesManyArgs = {
  updates: Array<PayrollDateTypesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDatesArgs = {
  _inc?: InputMaybe<PayrollDatesIncInput>;
  _set?: InputMaybe<PayrollDatesSetInput>;
  where: PayrollDatesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDatesByPkArgs = {
  _inc?: InputMaybe<PayrollDatesIncInput>;
  _set?: InputMaybe<PayrollDatesSetInput>;
  pkColumns: PayrollDatesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollDatesManyArgs = {
  updates: Array<PayrollDatesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollRequiredSkillsArgs = {
  _set?: InputMaybe<PayrollRequiredSkillsSetInput>;
  where: PayrollRequiredSkillsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollRequiredSkillsManyArgs = {
  updates: Array<PayrollRequiredSkillsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollServiceAgreementsArgs = {
  _append?: InputMaybe<PayrollServiceAgreementsAppendInput>;
  _deleteAtPath?: InputMaybe<PayrollServiceAgreementsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PayrollServiceAgreementsDeleteElemInput>;
  _deleteKey?: InputMaybe<PayrollServiceAgreementsDeleteKeyInput>;
  _inc?: InputMaybe<PayrollServiceAgreementsIncInput>;
  _prepend?: InputMaybe<PayrollServiceAgreementsPrependInput>;
  _set?: InputMaybe<PayrollServiceAgreementsSetInput>;
  where: PayrollServiceAgreementsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollServiceAgreementsByPkArgs = {
  _append?: InputMaybe<PayrollServiceAgreementsAppendInput>;
  _deleteAtPath?: InputMaybe<PayrollServiceAgreementsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PayrollServiceAgreementsDeleteElemInput>;
  _deleteKey?: InputMaybe<PayrollServiceAgreementsDeleteKeyInput>;
  _inc?: InputMaybe<PayrollServiceAgreementsIncInput>;
  _prepend?: InputMaybe<PayrollServiceAgreementsPrependInput>;
  _set?: InputMaybe<PayrollServiceAgreementsSetInput>;
  pkColumns: PayrollServiceAgreementsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollServiceAgreementsManyArgs = {
  updates: Array<PayrollServiceAgreementsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollVersionHistoryResultsArgs = {
  _inc?: InputMaybe<PayrollVersionHistoryResultsIncInput>;
  _set?: InputMaybe<PayrollVersionHistoryResultsSetInput>;
  where: PayrollVersionHistoryResultsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollVersionHistoryResultsByPkArgs = {
  _inc?: InputMaybe<PayrollVersionHistoryResultsIncInput>;
  _set?: InputMaybe<PayrollVersionHistoryResultsSetInput>;
  pkColumns: PayrollVersionHistoryResultsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollVersionHistoryResultsManyArgs = {
  updates: Array<PayrollVersionHistoryResultsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollVersionResultsArgs = {
  _inc?: InputMaybe<PayrollVersionResultsIncInput>;
  _set?: InputMaybe<PayrollVersionResultsSetInput>;
  where: PayrollVersionResultsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollVersionResultsByPkArgs = {
  _inc?: InputMaybe<PayrollVersionResultsIncInput>;
  _set?: InputMaybe<PayrollVersionResultsSetInput>;
  pkColumns: PayrollVersionResultsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollVersionResultsManyArgs = {
  updates: Array<PayrollVersionResultsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePayrollsArgs = {
  _inc?: InputMaybe<PayrollsIncInput>;
  _set?: InputMaybe<PayrollsSetInput>;
  where: PayrollsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePayrollsByPkArgs = {
  _inc?: InputMaybe<PayrollsIncInput>;
  _set?: InputMaybe<PayrollsSetInput>;
  pkColumns: PayrollsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePayrollsManyArgs = {
  updates: Array<PayrollsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePermissionAuditLogArgs = {
  _append?: InputMaybe<PermissionAuditLogAppendInput>;
  _deleteAtPath?: InputMaybe<PermissionAuditLogDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PermissionAuditLogDeleteElemInput>;
  _deleteKey?: InputMaybe<PermissionAuditLogDeleteKeyInput>;
  _prepend?: InputMaybe<PermissionAuditLogPrependInput>;
  _set?: InputMaybe<PermissionAuditLogSetInput>;
  where: PermissionAuditLogBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePermissionAuditLogByPkArgs = {
  _append?: InputMaybe<PermissionAuditLogAppendInput>;
  _deleteAtPath?: InputMaybe<PermissionAuditLogDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PermissionAuditLogDeleteElemInput>;
  _deleteKey?: InputMaybe<PermissionAuditLogDeleteKeyInput>;
  _prepend?: InputMaybe<PermissionAuditLogPrependInput>;
  _set?: InputMaybe<PermissionAuditLogSetInput>;
  pkColumns: PermissionAuditLogPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePermissionAuditLogManyArgs = {
  updates: Array<PermissionAuditLogUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePermissionOverridesArgs = {
  _append?: InputMaybe<PermissionOverridesAppendInput>;
  _deleteAtPath?: InputMaybe<PermissionOverridesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PermissionOverridesDeleteElemInput>;
  _deleteKey?: InputMaybe<PermissionOverridesDeleteKeyInput>;
  _prepend?: InputMaybe<PermissionOverridesPrependInput>;
  _set?: InputMaybe<PermissionOverridesSetInput>;
  where: PermissionOverridesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePermissionOverridesByPkArgs = {
  _append?: InputMaybe<PermissionOverridesAppendInput>;
  _deleteAtPath?: InputMaybe<PermissionOverridesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<PermissionOverridesDeleteElemInput>;
  _deleteKey?: InputMaybe<PermissionOverridesDeleteKeyInput>;
  _prepend?: InputMaybe<PermissionOverridesPrependInput>;
  _set?: InputMaybe<PermissionOverridesSetInput>;
  pkColumns: PermissionOverridesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePermissionOverridesManyArgs = {
  updates: Array<PermissionOverridesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePermissionsArgs = {
  _set?: InputMaybe<PermissionsSetInput>;
  where: PermissionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePermissionsByPkArgs = {
  _set?: InputMaybe<PermissionsSetInput>;
  pkColumns: PermissionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePermissionsManyArgs = {
  updates: Array<PermissionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdatePositionAdminDefaultsArgs = {
  _inc?: InputMaybe<PositionAdminDefaultsIncInput>;
  _set?: InputMaybe<PositionAdminDefaultsSetInput>;
  where: PositionAdminDefaultsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdatePositionAdminDefaultsByPkArgs = {
  _inc?: InputMaybe<PositionAdminDefaultsIncInput>;
  _set?: InputMaybe<PositionAdminDefaultsSetInput>;
  pkColumns: PositionAdminDefaultsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdatePositionAdminDefaultsManyArgs = {
  updates: Array<PositionAdminDefaultsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateQuoteConversionsArgs = {
  _append?: InputMaybe<QuoteConversionsAppendInput>;
  _deleteAtPath?: InputMaybe<QuoteConversionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<QuoteConversionsDeleteElemInput>;
  _deleteKey?: InputMaybe<QuoteConversionsDeleteKeyInput>;
  _inc?: InputMaybe<QuoteConversionsIncInput>;
  _prepend?: InputMaybe<QuoteConversionsPrependInput>;
  _set?: InputMaybe<QuoteConversionsSetInput>;
  where: QuoteConversionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateQuoteConversionsByPkArgs = {
  _append?: InputMaybe<QuoteConversionsAppendInput>;
  _deleteAtPath?: InputMaybe<QuoteConversionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<QuoteConversionsDeleteElemInput>;
  _deleteKey?: InputMaybe<QuoteConversionsDeleteKeyInput>;
  _inc?: InputMaybe<QuoteConversionsIncInput>;
  _prepend?: InputMaybe<QuoteConversionsPrependInput>;
  _set?: InputMaybe<QuoteConversionsSetInput>;
  pkColumns: QuoteConversionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateQuoteConversionsManyArgs = {
  updates: Array<QuoteConversionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateQuoteLineItemsArgs = {
  _inc?: InputMaybe<QuoteLineItemsIncInput>;
  _set?: InputMaybe<QuoteLineItemsSetInput>;
  where: QuoteLineItemsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateQuoteLineItemsByPkArgs = {
  _inc?: InputMaybe<QuoteLineItemsIncInput>;
  _set?: InputMaybe<QuoteLineItemsSetInput>;
  pkColumns: QuoteLineItemsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateQuoteLineItemsManyArgs = {
  updates: Array<QuoteLineItemsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateQuoteTemplatesArgs = {
  _append?: InputMaybe<QuoteTemplatesAppendInput>;
  _deleteAtPath?: InputMaybe<QuoteTemplatesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<QuoteTemplatesDeleteElemInput>;
  _deleteKey?: InputMaybe<QuoteTemplatesDeleteKeyInput>;
  _inc?: InputMaybe<QuoteTemplatesIncInput>;
  _prepend?: InputMaybe<QuoteTemplatesPrependInput>;
  _set?: InputMaybe<QuoteTemplatesSetInput>;
  where: QuoteTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateQuoteTemplatesByPkArgs = {
  _append?: InputMaybe<QuoteTemplatesAppendInput>;
  _deleteAtPath?: InputMaybe<QuoteTemplatesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<QuoteTemplatesDeleteElemInput>;
  _deleteKey?: InputMaybe<QuoteTemplatesDeleteKeyInput>;
  _inc?: InputMaybe<QuoteTemplatesIncInput>;
  _prepend?: InputMaybe<QuoteTemplatesPrependInput>;
  _set?: InputMaybe<QuoteTemplatesSetInput>;
  pkColumns: QuoteTemplatesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateQuoteTemplatesManyArgs = {
  updates: Array<QuoteTemplatesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateQuotesArgs = {
  _inc?: InputMaybe<QuotesIncInput>;
  _set?: InputMaybe<QuotesSetInput>;
  where: QuotesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateQuotesByPkArgs = {
  _inc?: InputMaybe<QuotesIncInput>;
  _set?: InputMaybe<QuotesSetInput>;
  pkColumns: QuotesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateQuotesManyArgs = {
  updates: Array<QuotesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateRateLimitsArgs = {
  _inc?: InputMaybe<RateLimitsIncInput>;
  _set?: InputMaybe<RateLimitsSetInput>;
  where: RateLimitsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateRateLimitsByPkArgs = {
  _inc?: InputMaybe<RateLimitsIncInput>;
  _set?: InputMaybe<RateLimitsSetInput>;
  pkColumns: RateLimitsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateRateLimitsManyArgs = {
  updates: Array<RateLimitsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateResourcesArgs = {
  _set?: InputMaybe<ResourcesSetInput>;
  where: ResourcesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateResourcesByPkArgs = {
  _set?: InputMaybe<ResourcesSetInput>;
  pkColumns: ResourcesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateResourcesManyArgs = {
  updates: Array<ResourcesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateRolePermissionsArgs = {
  _append?: InputMaybe<RolePermissionsAppendInput>;
  _deleteAtPath?: InputMaybe<RolePermissionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<RolePermissionsDeleteElemInput>;
  _deleteKey?: InputMaybe<RolePermissionsDeleteKeyInput>;
  _prepend?: InputMaybe<RolePermissionsPrependInput>;
  _set?: InputMaybe<RolePermissionsSetInput>;
  where: RolePermissionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateRolePermissionsByPkArgs = {
  _append?: InputMaybe<RolePermissionsAppendInput>;
  _deleteAtPath?: InputMaybe<RolePermissionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<RolePermissionsDeleteElemInput>;
  _deleteKey?: InputMaybe<RolePermissionsDeleteKeyInput>;
  _prepend?: InputMaybe<RolePermissionsPrependInput>;
  _set?: InputMaybe<RolePermissionsSetInput>;
  pkColumns: RolePermissionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateRolePermissionsManyArgs = {
  updates: Array<RolePermissionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateRolesArgs = {
  _inc?: InputMaybe<RolesIncInput>;
  _set?: InputMaybe<RolesSetInput>;
  where: RolesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateRolesByPkArgs = {
  _inc?: InputMaybe<RolesIncInput>;
  _set?: InputMaybe<RolesSetInput>;
  pkColumns: RolesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateRolesManyArgs = {
  updates: Array<RolesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSecurityAlertsArgs = {
  _append?: InputMaybe<SecurityAlertsAppendInput>;
  _deleteAtPath?: InputMaybe<SecurityAlertsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SecurityAlertsDeleteElemInput>;
  _deleteKey?: InputMaybe<SecurityAlertsDeleteKeyInput>;
  _prepend?: InputMaybe<SecurityAlertsPrependInput>;
  _set?: InputMaybe<SecurityAlertsSetInput>;
  where: SecurityAlertsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSecurityAlertsByPkArgs = {
  _append?: InputMaybe<SecurityAlertsAppendInput>;
  _deleteAtPath?: InputMaybe<SecurityAlertsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SecurityAlertsDeleteElemInput>;
  _deleteKey?: InputMaybe<SecurityAlertsDeleteKeyInput>;
  _prepend?: InputMaybe<SecurityAlertsPrependInput>;
  _set?: InputMaybe<SecurityAlertsSetInput>;
  pkColumns: SecurityAlertsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSecurityAlertsManyArgs = {
  updates: Array<SecurityAlertsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSecuritySettingsArgs = {
  _append?: InputMaybe<SecuritySettingsAppendInput>;
  _deleteAtPath?: InputMaybe<SecuritySettingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SecuritySettingsDeleteElemInput>;
  _deleteKey?: InputMaybe<SecuritySettingsDeleteKeyInput>;
  _prepend?: InputMaybe<SecuritySettingsPrependInput>;
  _set?: InputMaybe<SecuritySettingsSetInput>;
  where: SecuritySettingsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSecuritySettingsByPkArgs = {
  _append?: InputMaybe<SecuritySettingsAppendInput>;
  _deleteAtPath?: InputMaybe<SecuritySettingsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SecuritySettingsDeleteElemInput>;
  _deleteKey?: InputMaybe<SecuritySettingsDeleteKeyInput>;
  _prepend?: InputMaybe<SecuritySettingsPrependInput>;
  _set?: InputMaybe<SecuritySettingsSetInput>;
  pkColumns: SecuritySettingsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSecuritySettingsManyArgs = {
  updates: Array<SecuritySettingsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateServicePricingRulesArgs = {
  _append?: InputMaybe<ServicePricingRulesAppendInput>;
  _deleteAtPath?: InputMaybe<ServicePricingRulesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ServicePricingRulesDeleteElemInput>;
  _deleteKey?: InputMaybe<ServicePricingRulesDeleteKeyInput>;
  _inc?: InputMaybe<ServicePricingRulesIncInput>;
  _prepend?: InputMaybe<ServicePricingRulesPrependInput>;
  _set?: InputMaybe<ServicePricingRulesSetInput>;
  where: ServicePricingRulesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateServicePricingRulesByPkArgs = {
  _append?: InputMaybe<ServicePricingRulesAppendInput>;
  _deleteAtPath?: InputMaybe<ServicePricingRulesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ServicePricingRulesDeleteElemInput>;
  _deleteKey?: InputMaybe<ServicePricingRulesDeleteKeyInput>;
  _inc?: InputMaybe<ServicePricingRulesIncInput>;
  _prepend?: InputMaybe<ServicePricingRulesPrependInput>;
  _set?: InputMaybe<ServicePricingRulesSetInput>;
  pkColumns: ServicePricingRulesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateServicePricingRulesManyArgs = {
  updates: Array<ServicePricingRulesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateServiceTemplatesArgs = {
  _append?: InputMaybe<ServiceTemplatesAppendInput>;
  _deleteAtPath?: InputMaybe<ServiceTemplatesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ServiceTemplatesDeleteElemInput>;
  _deleteKey?: InputMaybe<ServiceTemplatesDeleteKeyInput>;
  _inc?: InputMaybe<ServiceTemplatesIncInput>;
  _prepend?: InputMaybe<ServiceTemplatesPrependInput>;
  _set?: InputMaybe<ServiceTemplatesSetInput>;
  where: ServiceTemplatesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateServiceTemplatesByPkArgs = {
  _append?: InputMaybe<ServiceTemplatesAppendInput>;
  _deleteAtPath?: InputMaybe<ServiceTemplatesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ServiceTemplatesDeleteElemInput>;
  _deleteKey?: InputMaybe<ServiceTemplatesDeleteKeyInput>;
  _inc?: InputMaybe<ServiceTemplatesIncInput>;
  _prepend?: InputMaybe<ServiceTemplatesPrependInput>;
  _set?: InputMaybe<ServiceTemplatesSetInput>;
  pkColumns: ServiceTemplatesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateServiceTemplatesManyArgs = {
  updates: Array<ServiceTemplatesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateServicesArgs = {
  _append?: InputMaybe<ServicesAppendInput>;
  _deleteAtPath?: InputMaybe<ServicesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ServicesDeleteElemInput>;
  _deleteKey?: InputMaybe<ServicesDeleteKeyInput>;
  _inc?: InputMaybe<ServicesIncInput>;
  _prepend?: InputMaybe<ServicesPrependInput>;
  _set?: InputMaybe<ServicesSetInput>;
  where: ServicesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateServicesByPkArgs = {
  _append?: InputMaybe<ServicesAppendInput>;
  _deleteAtPath?: InputMaybe<ServicesDeleteAtPathInput>;
  _deleteElem?: InputMaybe<ServicesDeleteElemInput>;
  _deleteKey?: InputMaybe<ServicesDeleteKeyInput>;
  _inc?: InputMaybe<ServicesIncInput>;
  _prepend?: InputMaybe<ServicesPrependInput>;
  _set?: InputMaybe<ServicesSetInput>;
  pkColumns: ServicesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateServicesManyArgs = {
  updates: Array<ServicesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSystemConfigurationArgs = {
  _append?: InputMaybe<SystemConfigurationAppendInput>;
  _deleteAtPath?: InputMaybe<SystemConfigurationDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SystemConfigurationDeleteElemInput>;
  _deleteKey?: InputMaybe<SystemConfigurationDeleteKeyInput>;
  _prepend?: InputMaybe<SystemConfigurationPrependInput>;
  _set?: InputMaybe<SystemConfigurationSetInput>;
  where: SystemConfigurationBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSystemConfigurationByPkArgs = {
  _append?: InputMaybe<SystemConfigurationAppendInput>;
  _deleteAtPath?: InputMaybe<SystemConfigurationDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SystemConfigurationDeleteElemInput>;
  _deleteKey?: InputMaybe<SystemConfigurationDeleteKeyInput>;
  _prepend?: InputMaybe<SystemConfigurationPrependInput>;
  _set?: InputMaybe<SystemConfigurationSetInput>;
  pkColumns: SystemConfigurationPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSystemConfigurationManyArgs = {
  updates: Array<SystemConfigurationUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateSystemHealthArgs = {
  _append?: InputMaybe<SystemHealthAppendInput>;
  _deleteAtPath?: InputMaybe<SystemHealthDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SystemHealthDeleteElemInput>;
  _deleteKey?: InputMaybe<SystemHealthDeleteKeyInput>;
  _inc?: InputMaybe<SystemHealthIncInput>;
  _prepend?: InputMaybe<SystemHealthPrependInput>;
  _set?: InputMaybe<SystemHealthSetInput>;
  where: SystemHealthBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateSystemHealthByPkArgs = {
  _append?: InputMaybe<SystemHealthAppendInput>;
  _deleteAtPath?: InputMaybe<SystemHealthDeleteAtPathInput>;
  _deleteElem?: InputMaybe<SystemHealthDeleteElemInput>;
  _deleteKey?: InputMaybe<SystemHealthDeleteKeyInput>;
  _inc?: InputMaybe<SystemHealthIncInput>;
  _prepend?: InputMaybe<SystemHealthPrependInput>;
  _set?: InputMaybe<SystemHealthSetInput>;
  pkColumns: SystemHealthPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateSystemHealthManyArgs = {
  updates: Array<SystemHealthUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateTimeEntriesArgs = {
  _inc?: InputMaybe<TimeEntriesIncInput>;
  _set?: InputMaybe<TimeEntriesSetInput>;
  where: TimeEntriesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateTimeEntriesByPkArgs = {
  _inc?: InputMaybe<TimeEntriesIncInput>;
  _set?: InputMaybe<TimeEntriesSetInput>;
  pkColumns: TimeEntriesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateTimeEntriesManyArgs = {
  updates: Array<TimeEntriesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserEmailTemplateFavoritesArgs = {
  _set?: InputMaybe<UserEmailTemplateFavoritesSetInput>;
  where: UserEmailTemplateFavoritesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserEmailTemplateFavoritesByPkArgs = {
  _set?: InputMaybe<UserEmailTemplateFavoritesSetInput>;
  pkColumns: UserEmailTemplateFavoritesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserEmailTemplateFavoritesManyArgs = {
  updates: Array<UserEmailTemplateFavoritesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserInvitationsArgs = {
  _append?: InputMaybe<UserInvitationsAppendInput>;
  _deleteAtPath?: InputMaybe<UserInvitationsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UserInvitationsDeleteElemInput>;
  _deleteKey?: InputMaybe<UserInvitationsDeleteKeyInput>;
  _prepend?: InputMaybe<UserInvitationsPrependInput>;
  _set?: InputMaybe<UserInvitationsSetInput>;
  where: UserInvitationsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserInvitationsByPkArgs = {
  _append?: InputMaybe<UserInvitationsAppendInput>;
  _deleteAtPath?: InputMaybe<UserInvitationsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UserInvitationsDeleteElemInput>;
  _deleteKey?: InputMaybe<UserInvitationsDeleteKeyInput>;
  _prepend?: InputMaybe<UserInvitationsPrependInput>;
  _set?: InputMaybe<UserInvitationsSetInput>;
  pkColumns: UserInvitationsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserInvitationsManyArgs = {
  updates: Array<UserInvitationsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserRateHistoryArgs = {
  _inc?: InputMaybe<UserRateHistoryIncInput>;
  _set?: InputMaybe<UserRateHistorySetInput>;
  where: UserRateHistoryBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserRateHistoryByPkArgs = {
  _inc?: InputMaybe<UserRateHistoryIncInput>;
  _set?: InputMaybe<UserRateHistorySetInput>;
  pkColumns: UserRateHistoryPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserRateHistoryManyArgs = {
  updates: Array<UserRateHistoryUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserRolesArgs = {
  _set?: InputMaybe<UserRolesSetInput>;
  where: UserRolesBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserRolesByPkArgs = {
  _set?: InputMaybe<UserRolesSetInput>;
  pkColumns: UserRolesPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserRolesManyArgs = {
  updates: Array<UserRolesUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserSessionsArgs = {
  _append?: InputMaybe<UserSessionsAppendInput>;
  _deleteAtPath?: InputMaybe<UserSessionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UserSessionsDeleteElemInput>;
  _deleteKey?: InputMaybe<UserSessionsDeleteKeyInput>;
  _prepend?: InputMaybe<UserSessionsPrependInput>;
  _set?: InputMaybe<UserSessionsSetInput>;
  where: UserSessionsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserSessionsByPkArgs = {
  _append?: InputMaybe<UserSessionsAppendInput>;
  _deleteAtPath?: InputMaybe<UserSessionsDeleteAtPathInput>;
  _deleteElem?: InputMaybe<UserSessionsDeleteElemInput>;
  _deleteKey?: InputMaybe<UserSessionsDeleteKeyInput>;
  _prepend?: InputMaybe<UserSessionsPrependInput>;
  _set?: InputMaybe<UserSessionsSetInput>;
  pkColumns: UserSessionsPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUserSessionsManyArgs = {
  updates: Array<UserSessionsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUserSkillsArgs = {
  _set?: InputMaybe<UserSkillsSetInput>;
  where: UserSkillsBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUserSkillsManyArgs = {
  updates: Array<UserSkillsUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsersArgs = {
  _inc?: InputMaybe<UsersIncInput>;
  _set?: InputMaybe<UsersSetInput>;
  where: UsersBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsersByPkArgs = {
  _inc?: InputMaybe<UsersIncInput>;
  _set?: InputMaybe<UsersSetInput>;
  pkColumns: UsersPkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateUsersManyArgs = {
  updates: Array<UsersUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateUsersRoleBackupArgs = {
  _set?: InputMaybe<UsersRoleBackupSetInput>;
  where: UsersRoleBackupBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateUsersRoleBackupManyArgs = {
  updates: Array<UsersRoleBackupUpdates>;
};


/** mutation root */
export type Mutation_RootUpdateWorkScheduleArgs = {
  _inc?: InputMaybe<WorkScheduleIncInput>;
  _set?: InputMaybe<WorkScheduleSetInput>;
  where: WorkScheduleBoolExp;
};


/** mutation root */
export type Mutation_RootUpdateWorkScheduleByPkArgs = {
  _inc?: InputMaybe<WorkScheduleIncInput>;
  _set?: InputMaybe<WorkScheduleSetInput>;
  pkColumns: WorkSchedulePkColumnsInput;
};


/** mutation root */
export type Mutation_RootUpdateWorkScheduleManyArgs = {
  updates: Array<WorkScheduleUpdates>;
};

export type NotesAggregateBoolExpBool_And = {
  arguments: NotesSelectColumnNotesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<NotesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type NotesAggregateBoolExpBool_Or = {
  arguments: NotesSelectColumnNotesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<NotesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type NotesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<NotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<NotesBoolExp>;
  predicate: IntComparisonExp;
};

export type PayrollAssignmentAuditAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollAssignmentAuditBoolExp>;
  predicate: IntComparisonExp;
};

export type PayrollAssignmentsAggregateBoolExpBool_And = {
  arguments: PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollAssignmentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PayrollAssignmentsAggregateBoolExpBool_Or = {
  arguments: PayrollAssignmentsSelectColumnPayrollAssignmentsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollAssignmentsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PayrollAssignmentsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollAssignmentsBoolExp>;
  predicate: IntComparisonExp;
};

export type PayrollDateTimeEntriesAggregateBoolExpBool_And = {
  arguments: PayrollDateTimeEntriesSelectColumnPayrollDateTimeEntriesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PayrollDateTimeEntriesAggregateBoolExpBool_Or = {
  arguments: PayrollDateTimeEntriesSelectColumnPayrollDateTimeEntriesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PayrollDateTimeEntriesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
  predicate: IntComparisonExp;
};

export type PayrollDatesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollDatesBoolExp>;
  predicate: IntComparisonExp;
};

export type PayrollRequiredSkillsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollRequiredSkillsBoolExp>;
  predicate: IntComparisonExp;
};

export type PayrollServiceAgreementsAggregateBoolExpBool_And = {
  arguments: PayrollServiceAgreementsSelectColumnPayrollServiceAgreementsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PayrollServiceAgreementsAggregateBoolExpBool_Or = {
  arguments: PayrollServiceAgreementsSelectColumnPayrollServiceAgreementsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PayrollServiceAgreementsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollServiceAgreementsBoolExp>;
  predicate: IntComparisonExp;
};

export type PayrollsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PayrollsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PayrollsBoolExp>;
  predicate: IntComparisonExp;
};

export type PermissionAuditLogAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PermissionAuditLogBoolExp>;
  predicate: IntComparisonExp;
};

export type PermissionOverridesAggregateBoolExpBool_And = {
  arguments: PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PermissionOverridesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PermissionOverridesAggregateBoolExpBool_Or = {
  arguments: PermissionOverridesSelectColumnPermissionOverridesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PermissionOverridesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type PermissionOverridesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PermissionOverridesBoolExp>;
  predicate: IntComparisonExp;
};

export type PermissionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<PermissionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<PermissionsBoolExp>;
  predicate: IntComparisonExp;
};

export type Query_Root = {
  __typename?: 'query_root';
  _service: _Service;
  /** An array relationship */
  adjustmentRules: Array<AdjustmentRules>;
  /** An aggregate relationship */
  adjustmentRulesAggregate: AdjustmentRulesAggregate;
  /** fetch data from the table: "adjustment_rules" using primary key columns */
  adjustmentRulesByPk?: Maybe<AdjustmentRules>;
  /** fetch data from the table: "app_settings" */
  appSettings: Array<AppSettings>;
  /** fetch aggregated fields from the table: "app_settings" */
  appSettingsAggregate: AppSettingsAggregate;
  /** fetch data from the table: "app_settings" using primary key columns */
  appSettingsByPk?: Maybe<AppSettings>;
  /** fetch data from the table: "audit.audit_log" */
  auditAuditLog: Array<AuditAuditLog>;
  /** fetch aggregated fields from the table: "audit.audit_log" */
  auditAuditLogAggregate: AuditAuditLogAggregate;
  /** fetch data from the table: "audit.audit_log" using primary key columns */
  auditAuditLogByPk?: Maybe<AuditAuditLog>;
  /** fetch data from the table: "audit.auth_events" */
  auditAuthEvents: Array<AuditAuthEvents>;
  /** fetch aggregated fields from the table: "audit.auth_events" */
  auditAuthEventsAggregate: AuditAuthEventsAggregate;
  /** fetch data from the table: "audit.auth_events" using primary key columns */
  auditAuthEventsByPk?: Maybe<AuditAuthEvents>;
  /** fetch data from the table: "audit.data_access_log" */
  auditDataAccessLog: Array<AuditDataAccessLog>;
  /** fetch aggregated fields from the table: "audit.data_access_log" */
  auditDataAccessLogAggregate: AuditDataAccessLogAggregate;
  /** fetch data from the table: "audit.data_access_log" using primary key columns */
  auditDataAccessLogByPk?: Maybe<AuditDataAccessLog>;
  /** fetch data from the table: "audit.permission_changes" */
  auditPermissionChanges: Array<AuditPermissionChanges>;
  /** fetch aggregated fields from the table: "audit.permission_changes" */
  auditPermissionChangesAggregate: AuditPermissionChangesAggregate;
  /** fetch data from the table: "audit.permission_changes" using primary key columns */
  auditPermissionChangesByPk?: Maybe<AuditPermissionChanges>;
  /** fetch data from the table: "audit.permission_usage_report" */
  auditPermissionUsageReport: Array<AuditPermissionUsageReport>;
  /** fetch aggregated fields from the table: "audit.permission_usage_report" */
  auditPermissionUsageReportAggregate: AuditPermissionUsageReportAggregate;
  /** fetch data from the table: "audit.slow_queries" */
  auditSlowQueries: Array<AuditSlowQueries>;
  /** fetch aggregated fields from the table: "audit.slow_queries" */
  auditSlowQueriesAggregate: AuditSlowQueriesAggregate;
  /** fetch data from the table: "audit.slow_queries" using primary key columns */
  auditSlowQueriesByPk?: Maybe<AuditSlowQueries>;
  /** fetch data from the table: "audit.user_access_summary" */
  auditUserAccessSummary: Array<AuditUserAccessSummary>;
  /** fetch aggregated fields from the table: "audit.user_access_summary" */
  auditUserAccessSummaryAggregate: AuditUserAccessSummaryAggregate;
  /** fetch data from the table: "billing_automation_metrics" */
  billingAutomationMetrics: Array<BillingAutomationMetrics>;
  /** fetch aggregated fields from the table: "billing_automation_metrics" */
  billingAutomationMetricsAggregate: BillingAutomationMetricsAggregate;
  /** fetch data from the table: "billing_event_log" */
  billingEventLog: Array<BillingEventLog>;
  /** fetch aggregated fields from the table: "billing_event_log" */
  billingEventLogAggregate: BillingEventLogAggregate;
  /** fetch data from the table: "billing_event_log" using primary key columns */
  billingEventLogByPk?: Maybe<BillingEventLog>;
  /** fetch data from the table: "billing_invoice" */
  billingInvoice: Array<BillingInvoice>;
  /** fetch aggregated fields from the table: "billing_invoice" */
  billingInvoiceAggregate: BillingInvoiceAggregate;
  /** fetch data from the table: "billing_invoice" using primary key columns */
  billingInvoiceByPk?: Maybe<BillingInvoice>;
  /** fetch data from the table: "billing_invoice_item" */
  billingInvoiceItem: Array<BillingInvoiceItem>;
  /** fetch aggregated fields from the table: "billing_invoice_item" */
  billingInvoiceItemAggregate: BillingInvoiceItemAggregate;
  /** fetch data from the table: "billing_invoice_item" using primary key columns */
  billingInvoiceItemByPk?: Maybe<BillingInvoiceItem>;
  /** An array relationship */
  billingItems: Array<BillingItems>;
  /** An aggregate relationship */
  billingItemsAggregate: BillingItemsAggregate;
  /** fetch data from the table: "billing_items" using primary key columns */
  billingItemsByPk?: Maybe<BillingItems>;
  /** An array relationship */
  billingPeriods: Array<BillingPeriods>;
  /** An aggregate relationship */
  billingPeriodsAggregate: BillingPeriodsAggregate;
  /** fetch data from the table: "billing_periods" using primary key columns */
  billingPeriodsByPk?: Maybe<BillingPeriods>;
  /** An array relationship */
  clientExternalSystems: Array<ClientExternalSystems>;
  /** An aggregate relationship */
  clientExternalSystemsAggregate: ClientExternalSystemsAggregate;
  /** fetch data from the table: "client_external_systems" using primary key columns */
  clientExternalSystemsByPk?: Maybe<ClientExternalSystems>;
  /** fetch data from the table: "client_service_agreements" */
  clientServiceAgreements: Array<ClientServiceAgreements>;
  /** fetch aggregated fields from the table: "client_service_agreements" */
  clientServiceAgreementsAggregate: ClientServiceAgreementsAggregate;
  /** fetch data from the table: "client_service_agreements" using primary key columns */
  clientServiceAgreementsByPk?: Maybe<ClientServiceAgreements>;
  /** fetch data from the table: "client_services_with_rates" */
  clientServicesWithRates: Array<ClientServicesWithRates>;
  /** fetch aggregated fields from the table: "client_services_with_rates" */
  clientServicesWithRatesAggregate: ClientServicesWithRatesAggregate;
  /** fetch data from the table: "clients" */
  clients: Array<Clients>;
  /** fetch aggregated fields from the table: "clients" */
  clientsAggregate: ClientsAggregate;
  /** fetch data from the table: "clients" using primary key columns */
  clientsByPk?: Maybe<Clients>;
  /** fetch data from the table: "consultant_capacity_overview" */
  consultantCapacityOverview: Array<ConsultantCapacityOverview>;
  /** fetch aggregated fields from the table: "consultant_capacity_overview" */
  consultantCapacityOverviewAggregate: ConsultantCapacityOverviewAggregate;
  /** fetch data from the table: "current_payrolls" */
  currentPayrolls: Array<CurrentPayrolls>;
  /** fetch aggregated fields from the table: "current_payrolls" */
  currentPayrollsAggregate: CurrentPayrollsAggregate;
  /** An array relationship */
  dataBackups: Array<DataBackups>;
  /** An aggregate relationship */
  dataBackupsAggregate: DataBackupsAggregate;
  /** fetch data from the table: "data_backups" using primary key columns */
  dataBackupsByPk?: Maybe<DataBackups>;
  /** An array relationship */
  emailDrafts: Array<EmailDrafts>;
  /** An aggregate relationship */
  emailDraftsAggregate: EmailDraftsAggregate;
  /** fetch data from the table: "email_drafts" using primary key columns */
  emailDraftsByPk?: Maybe<EmailDrafts>;
  /** An array relationship */
  emailSendLogs: Array<EmailSendLogs>;
  /** An aggregate relationship */
  emailSendLogsAggregate: EmailSendLogsAggregate;
  /** fetch data from the table: "email_send_logs" using primary key columns */
  emailSendLogsByPk?: Maybe<EmailSendLogs>;
  /** fetch data from the table: "email_templates" */
  emailTemplates: Array<EmailTemplates>;
  /** fetch aggregated fields from the table: "email_templates" */
  emailTemplatesAggregate: EmailTemplatesAggregate;
  /** fetch data from the table: "email_templates" using primary key columns */
  emailTemplatesByPk?: Maybe<EmailTemplates>;
  /** fetch data from the table: "external_systems" */
  externalSystems: Array<ExternalSystems>;
  /** fetch aggregated fields from the table: "external_systems" */
  externalSystemsAggregate: ExternalSystemsAggregate;
  /** fetch data from the table: "external_systems" using primary key columns */
  externalSystemsByPk?: Maybe<ExternalSystems>;
  /** fetch data from the table: "feature_flags" */
  featureFlags: Array<FeatureFlags>;
  /** fetch aggregated fields from the table: "feature_flags" */
  featureFlagsAggregate: FeatureFlagsAggregate;
  /** fetch data from the table: "feature_flags" using primary key columns */
  featureFlagsByPk?: Maybe<FeatureFlags>;
  /** An array relationship */
  files: Array<Files>;
  /** An aggregate relationship */
  filesAggregate: FilesAggregate;
  /** fetch data from the table: "files" using primary key columns */
  filesByPk?: Maybe<Files>;
  /** execute function "get_latest_payroll_version" which returns "latest_payroll_version_results" */
  getLatestPayrollVersion: Array<LatestPayrollVersionResults>;
  /** execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results" */
  getLatestPayrollVersionAggregate: LatestPayrollVersionResultsAggregate;
  /** execute function "get_payroll_version_history" which returns "payroll_version_history_results" */
  getPayrollVersionHistory: Array<PayrollVersionHistoryResults>;
  /** execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results" */
  getPayrollVersionHistoryAggregate: PayrollVersionHistoryResultsAggregate;
  /** fetch data from the table: "holidays" */
  holidays: Array<Holidays>;
  /** fetch aggregated fields from the table: "holidays" */
  holidaysAggregate: HolidaysAggregate;
  /** fetch data from the table: "holidays" using primary key columns */
  holidaysByPk?: Maybe<Holidays>;
  /** fetch data from the table: "latest_payroll_version_results" */
  latestPayrollVersionResults: Array<LatestPayrollVersionResults>;
  /** fetch aggregated fields from the table: "latest_payroll_version_results" */
  latestPayrollVersionResultsAggregate: LatestPayrollVersionResultsAggregate;
  /** fetch data from the table: "latest_payroll_version_results" using primary key columns */
  latestPayrollVersionResultsByPk?: Maybe<LatestPayrollVersionResults>;
  /** fetch data from the table: "leave" */
  leave: Array<Leave>;
  /** fetch aggregated fields from the table: "leave" */
  leaveAggregate: LeaveAggregate;
  /** fetch data from the table: "leave" using primary key columns */
  leaveByPk?: Maybe<Leave>;
  /** fetch data from the table: "monthly_billing_completion" */
  monthlyBillingCompletion: Array<MonthlyBillingCompletion>;
  /** fetch aggregated fields from the table: "monthly_billing_completion" */
  monthlyBillingCompletionAggregate: MonthlyBillingCompletionAggregate;
  /** fetch data from the table: "monthly_billing_completion" using primary key columns */
  monthlyBillingCompletionByPk?: Maybe<MonthlyBillingCompletion>;
  /** fetch data from the table: "monthly_billing_dashboard" */
  monthlyBillingDashboard: Array<MonthlyBillingDashboard>;
  /** fetch aggregated fields from the table: "monthly_billing_dashboard" */
  monthlyBillingDashboardAggregate: MonthlyBillingDashboardAggregate;
  /** fetch data from the table: "notes" */
  notes: Array<Notes>;
  /** fetch aggregated fields from the table: "notes" */
  notesAggregate: NotesAggregate;
  /** fetch data from the table: "notes" using primary key columns */
  notesByPk?: Maybe<Notes>;
  /** fetch data from the table: "payroll_activation_results" */
  payrollActivationResults: Array<PayrollActivationResults>;
  /** fetch aggregated fields from the table: "payroll_activation_results" */
  payrollActivationResultsAggregate: PayrollActivationResultsAggregate;
  /** fetch data from the table: "payroll_activation_results" using primary key columns */
  payrollActivationResultsByPk?: Maybe<PayrollActivationResults>;
  /** fetch data from the table: "payroll_assignment_audit" */
  payrollAssignmentAudit: Array<PayrollAssignmentAudit>;
  /** fetch aggregated fields from the table: "payroll_assignment_audit" */
  payrollAssignmentAuditAggregate: PayrollAssignmentAuditAggregate;
  /** fetch data from the table: "payroll_assignment_audit" using primary key columns */
  payrollAssignmentAuditByPk?: Maybe<PayrollAssignmentAudit>;
  /** fetch data from the table: "payroll_assignments" */
  payrollAssignments: Array<PayrollAssignments>;
  /** fetch aggregated fields from the table: "payroll_assignments" */
  payrollAssignmentsAggregate: PayrollAssignmentsAggregate;
  /** fetch data from the table: "payroll_assignments" using primary key columns */
  payrollAssignmentsByPk?: Maybe<PayrollAssignments>;
  /** fetch data from the table: "payroll_cost_analysis" */
  payrollCostAnalysis: Array<PayrollCostAnalysis>;
  /** fetch aggregated fields from the table: "payroll_cost_analysis" */
  payrollCostAnalysisAggregate: PayrollCostAnalysisAggregate;
  /** fetch data from the table: "payroll_cycles" */
  payrollCycles: Array<PayrollCycles>;
  /** fetch aggregated fields from the table: "payroll_cycles" */
  payrollCyclesAggregate: PayrollCyclesAggregate;
  /** fetch data from the table: "payroll_cycles" using primary key columns */
  payrollCyclesByPk?: Maybe<PayrollCycles>;
  /** fetch data from the table: "payroll_dashboard_stats" */
  payrollDashboardStats: Array<PayrollDashboardStats>;
  /** fetch aggregated fields from the table: "payroll_dashboard_stats" */
  payrollDashboardStatsAggregate: PayrollDashboardStatsAggregate;
  /** fetch data from the table: "payroll_date_completion_analytics" */
  payrollDateCompletionAnalytics: Array<PayrollDateCompletionAnalytics>;
  /** fetch aggregated fields from the table: "payroll_date_completion_analytics" */
  payrollDateCompletionAnalyticsAggregate: PayrollDateCompletionAnalyticsAggregate;
  /** An array relationship */
  payrollDateTimeEntries: Array<PayrollDateTimeEntries>;
  /** An aggregate relationship */
  payrollDateTimeEntriesAggregate: PayrollDateTimeEntriesAggregate;
  /** fetch data from the table: "payroll_date_time_entries" using primary key columns */
  payrollDateTimeEntriesByPk?: Maybe<PayrollDateTimeEntries>;
  /** fetch data from the table: "payroll_date_types" */
  payrollDateTypes: Array<PayrollDateTypes>;
  /** fetch aggregated fields from the table: "payroll_date_types" */
  payrollDateTypesAggregate: PayrollDateTypesAggregate;
  /** fetch data from the table: "payroll_date_types" using primary key columns */
  payrollDateTypesByPk?: Maybe<PayrollDateTypes>;
  /** An array relationship */
  payrollDates: Array<PayrollDates>;
  /** An aggregate relationship */
  payrollDatesAggregate: PayrollDatesAggregate;
  /** fetch data from the table: "payroll_dates" using primary key columns */
  payrollDatesByPk?: Maybe<PayrollDates>;
  /** fetch data from the table: "payroll_profitability" */
  payrollProfitability: Array<PayrollProfitability>;
  /** fetch aggregated fields from the table: "payroll_profitability" */
  payrollProfitabilityAggregate: PayrollProfitabilityAggregate;
  /** fetch data from the table: "payroll_required_skills" */
  payrollRequiredSkills: Array<PayrollRequiredSkills>;
  /** fetch aggregated fields from the table: "payroll_required_skills" */
  payrollRequiredSkillsAggregate: PayrollRequiredSkillsAggregate;
  /** An array relationship */
  payrollServiceAgreements: Array<PayrollServiceAgreements>;
  /** An aggregate relationship */
  payrollServiceAgreementsAggregate: PayrollServiceAgreementsAggregate;
  /** fetch data from the table: "payroll_service_agreements" using primary key columns */
  payrollServiceAgreementsByPk?: Maybe<PayrollServiceAgreements>;
  /** fetch data from the table: "payroll_triggers_status" */
  payrollTriggersStatus: Array<PayrollTriggersStatus>;
  /** fetch aggregated fields from the table: "payroll_triggers_status" */
  payrollTriggersStatusAggregate: PayrollTriggersStatusAggregate;
  /** fetch data from the table: "payroll_version_history_results" */
  payrollVersionHistoryResults: Array<PayrollVersionHistoryResults>;
  /** fetch aggregated fields from the table: "payroll_version_history_results" */
  payrollVersionHistoryResultsAggregate: PayrollVersionHistoryResultsAggregate;
  /** fetch data from the table: "payroll_version_history_results" using primary key columns */
  payrollVersionHistoryResultsByPk?: Maybe<PayrollVersionHistoryResults>;
  /** fetch data from the table: "payroll_version_results" */
  payrollVersionResults: Array<PayrollVersionResults>;
  /** fetch aggregated fields from the table: "payroll_version_results" */
  payrollVersionResultsAggregate: PayrollVersionResultsAggregate;
  /** fetch data from the table: "payroll_version_results" using primary key columns */
  payrollVersionResultsByPk?: Maybe<PayrollVersionResults>;
  /** fetch data from the table: "payroll_workload_distribution" */
  payrollWorkloadDistribution: Array<PayrollWorkloadDistribution>;
  /** fetch aggregated fields from the table: "payroll_workload_distribution" */
  payrollWorkloadDistributionAggregate: PayrollWorkloadDistributionAggregate;
  /** An array relationship */
  payrolls: Array<Payrolls>;
  /** An aggregate relationship */
  payrollsAggregate: PayrollsAggregate;
  /** fetch data from the table: "payrolls" using primary key columns */
  payrollsByPk?: Maybe<Payrolls>;
  /** fetch data from the table: "pending_billing_approvals" */
  pendingBillingApprovals: Array<PendingBillingApprovals>;
  /** fetch aggregated fields from the table: "pending_billing_approvals" */
  pendingBillingApprovalsAggregate: PendingBillingApprovalsAggregate;
  /** fetch data from the table: "permission_audit_log" */
  permissionAuditLog: Array<PermissionAuditLog>;
  /** fetch aggregated fields from the table: "permission_audit_log" */
  permissionAuditLogAggregate: PermissionAuditLogAggregate;
  /** fetch data from the table: "permission_audit_log" using primary key columns */
  permissionAuditLogByPk?: Maybe<PermissionAuditLog>;
  /** An array relationship */
  permissionOverrides: Array<PermissionOverrides>;
  /** An aggregate relationship */
  permissionOverridesAggregate: PermissionOverridesAggregate;
  /** fetch data from the table: "permission_overrides" using primary key columns */
  permissionOverridesByPk?: Maybe<PermissionOverrides>;
  /** An array relationship */
  permissions: Array<Permissions>;
  /** An aggregate relationship */
  permissionsAggregate: PermissionsAggregate;
  /** fetch data from the table: "permissions" using primary key columns */
  permissionsByPk?: Maybe<Permissions>;
  /** fetch data from the table: "position_admin_defaults" */
  positionAdminDefaults: Array<PositionAdminDefaults>;
  /** fetch aggregated fields from the table: "position_admin_defaults" */
  positionAdminDefaultsAggregate: PositionAdminDefaultsAggregate;
  /** fetch data from the table: "position_admin_defaults" using primary key columns */
  positionAdminDefaultsByPk?: Maybe<PositionAdminDefaults>;
  /** fetch data from the table: "quote_analytics" */
  quoteAnalytics: Array<QuoteAnalytics>;
  /** fetch aggregated fields from the table: "quote_analytics" */
  quoteAnalyticsAggregate: QuoteAnalyticsAggregate;
  /** An array relationship */
  quoteConversions: Array<QuoteConversions>;
  /** An aggregate relationship */
  quoteConversionsAggregate: QuoteConversionsAggregate;
  /** fetch data from the table: "quote_conversions" using primary key columns */
  quoteConversionsByPk?: Maybe<QuoteConversions>;
  /** An array relationship */
  quoteLineItems: Array<QuoteLineItems>;
  /** An aggregate relationship */
  quoteLineItemsAggregate: QuoteLineItemsAggregate;
  /** fetch data from the table: "quote_line_items" using primary key columns */
  quoteLineItemsByPk?: Maybe<QuoteLineItems>;
  /** An array relationship */
  quoteTemplates: Array<QuoteTemplates>;
  /** An aggregate relationship */
  quoteTemplatesAggregate: QuoteTemplatesAggregate;
  /** fetch data from the table: "quote_templates" using primary key columns */
  quoteTemplatesByPk?: Maybe<QuoteTemplates>;
  /** An array relationship */
  quotes: Array<Quotes>;
  /** An aggregate relationship */
  quotesAggregate: QuotesAggregate;
  /** fetch data from the table: "quotes" using primary key columns */
  quotesByPk?: Maybe<Quotes>;
  /** fetch data from the table: "rate_limits" */
  rateLimits: Array<RateLimits>;
  /** fetch aggregated fields from the table: "rate_limits" */
  rateLimitsAggregate: RateLimitsAggregate;
  /** fetch data from the table: "rate_limits" using primary key columns */
  rateLimitsByPk?: Maybe<RateLimits>;
  /** fetch data from the table: "resources" */
  resources: Array<Resources>;
  /** fetch aggregated fields from the table: "resources" */
  resourcesAggregate: ResourcesAggregate;
  /** fetch data from the table: "resources" using primary key columns */
  resourcesByPk?: Maybe<Resources>;
  /** An array relationship */
  rolePermissions: Array<RolePermissions>;
  /** An aggregate relationship */
  rolePermissionsAggregate: RolePermissionsAggregate;
  /** fetch data from the table: "role_permissions" using primary key columns */
  rolePermissionsByPk?: Maybe<RolePermissions>;
  /** fetch data from the table: "roles" */
  roles: Array<Roles>;
  /** fetch aggregated fields from the table: "roles" */
  rolesAggregate: RolesAggregate;
  /** fetch data from the table: "roles" using primary key columns */
  rolesByPk?: Maybe<Roles>;
  /** An array relationship */
  securityAlerts: Array<SecurityAlerts>;
  /** An aggregate relationship */
  securityAlertsAggregate: SecurityAlertsAggregate;
  /** fetch data from the table: "security_alerts" using primary key columns */
  securityAlertsByPk?: Maybe<SecurityAlerts>;
  /** An array relationship */
  securitySettings: Array<SecuritySettings>;
  /** An aggregate relationship */
  securitySettingsAggregate: SecuritySettingsAggregate;
  /** fetch data from the table: "security_settings" using primary key columns */
  securitySettingsByPk?: Maybe<SecuritySettings>;
  /** An array relationship */
  servicePricingRules: Array<ServicePricingRules>;
  /** An aggregate relationship */
  servicePricingRulesAggregate: ServicePricingRulesAggregate;
  /** fetch data from the table: "service_pricing_rules" using primary key columns */
  servicePricingRulesByPk?: Maybe<ServicePricingRules>;
  /** fetch data from the table: "service_templates" */
  serviceTemplates: Array<ServiceTemplates>;
  /** fetch aggregated fields from the table: "service_templates" */
  serviceTemplatesAggregate: ServiceTemplatesAggregate;
  /** fetch data from the table: "service_templates" using primary key columns */
  serviceTemplatesByPk?: Maybe<ServiceTemplates>;
  /** fetch data from the table: "services" */
  services: Array<Services>;
  /** fetch aggregated fields from the table: "services" */
  servicesAggregate: ServicesAggregate;
  /** fetch data from the table: "services" using primary key columns */
  servicesByPk?: Maybe<Services>;
  /** fetch data from the table: "staff_billing_performance" */
  staffBillingPerformance: Array<StaffBillingPerformance>;
  /** fetch aggregated fields from the table: "staff_billing_performance" */
  staffBillingPerformanceAggregate: StaffBillingPerformanceAggregate;
  /** fetch data from the table: "system_configuration" */
  systemConfiguration: Array<SystemConfiguration>;
  /** fetch aggregated fields from the table: "system_configuration" */
  systemConfigurationAggregate: SystemConfigurationAggregate;
  /** fetch data from the table: "system_configuration" using primary key columns */
  systemConfigurationByPk?: Maybe<SystemConfiguration>;
  /** fetch data from the table: "system_health" */
  systemHealth: Array<SystemHealth>;
  /** fetch aggregated fields from the table: "system_health" */
  systemHealthAggregate: SystemHealthAggregate;
  /** fetch data from the table: "system_health" using primary key columns */
  systemHealthByPk?: Maybe<SystemHealth>;
  /** fetch data from the table: "team_capacity_by_position" */
  teamCapacityByPosition: Array<TeamCapacityByPosition>;
  /** fetch aggregated fields from the table: "team_capacity_by_position" */
  teamCapacityByPositionAggregate: TeamCapacityByPositionAggregate;
  /** An array relationship */
  timeEntries: Array<TimeEntries>;
  /** An aggregate relationship */
  timeEntriesAggregate: TimeEntriesAggregate;
  /** fetch data from the table: "time_entries" using primary key columns */
  timeEntriesByPk?: Maybe<TimeEntries>;
  /** fetch data from the table: "time_tracking_summary" */
  timeTrackingSummary: Array<TimeTrackingSummary>;
  /** fetch aggregated fields from the table: "time_tracking_summary" */
  timeTrackingSummaryAggregate: TimeTrackingSummaryAggregate;
  /** fetch data from the table: "user_email_template_favorites" */
  userEmailTemplateFavorites: Array<UserEmailTemplateFavorites>;
  /** fetch aggregated fields from the table: "user_email_template_favorites" */
  userEmailTemplateFavoritesAggregate: UserEmailTemplateFavoritesAggregate;
  /** fetch data from the table: "user_email_template_favorites" using primary key columns */
  userEmailTemplateFavoritesByPk?: Maybe<UserEmailTemplateFavorites>;
  /** fetch data from the table: "user_invitations" */
  userInvitations: Array<UserInvitations>;
  /** fetch aggregated fields from the table: "user_invitations" */
  userInvitationsAggregate: UserInvitationsAggregate;
  /** fetch data from the table: "user_invitations" using primary key columns */
  userInvitationsByPk?: Maybe<UserInvitations>;
  /** fetch data from the table: "user_productivity_analysis" */
  userProductivityAnalysis: Array<UserProductivityAnalysis>;
  /** fetch aggregated fields from the table: "user_productivity_analysis" */
  userProductivityAnalysisAggregate: UserProductivityAnalysisAggregate;
  /** fetch data from the table: "user_rate_history" */
  userRateHistory: Array<UserRateHistory>;
  /** fetch aggregated fields from the table: "user_rate_history" */
  userRateHistoryAggregate: UserRateHistoryAggregate;
  /** fetch data from the table: "user_rate_history" using primary key columns */
  userRateHistoryByPk?: Maybe<UserRateHistory>;
  /** An array relationship */
  userRoles: Array<UserRoles>;
  /** An aggregate relationship */
  userRolesAggregate: UserRolesAggregate;
  /** fetch data from the table: "user_roles" using primary key columns */
  userRolesByPk?: Maybe<UserRoles>;
  /** An array relationship */
  userSessions: Array<UserSessions>;
  /** An aggregate relationship */
  userSessionsAggregate: UserSessionsAggregate;
  /** fetch data from the table: "user_sessions" using primary key columns */
  userSessionsByPk?: Maybe<UserSessions>;
  /** fetch data from the table: "user_skills" */
  userSkills: Array<UserSkills>;
  /** fetch aggregated fields from the table: "user_skills" */
  userSkillsAggregate: UserSkillsAggregate;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  usersAggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  /** fetch data from the table: "users_role_backup" */
  usersRoleBackup: Array<UsersRoleBackup>;
  /** fetch aggregated fields from the table: "users_role_backup" */
  usersRoleBackupAggregate: UsersRoleBackupAggregate;
  /** fetch data from the table: "work_schedule" */
  workSchedule: Array<WorkSchedule>;
  /** fetch aggregated fields from the table: "work_schedule" */
  workScheduleAggregate: WorkScheduleAggregate;
  /** fetch data from the table: "work_schedule" using primary key columns */
  workScheduleByPk?: Maybe<WorkSchedule>;
};


export type Query_RootAdjustmentRulesArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


export type Query_RootAdjustmentRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


export type Query_RootAdjustmentRulesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAppSettingsArgs = {
  distinctOn?: InputMaybe<Array<AppSettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AppSettingsOrderBy>>;
  where?: InputMaybe<AppSettingsBoolExp>;
};


export type Query_RootAppSettingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AppSettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AppSettingsOrderBy>>;
  where?: InputMaybe<AppSettingsBoolExp>;
};


export type Query_RootAppSettingsByPkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootAuditAuditLogArgs = {
  distinctOn?: InputMaybe<Array<AuditAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuditLogOrderBy>>;
  where?: InputMaybe<AuditAuditLogBoolExp>;
};


export type Query_RootAuditAuditLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuditLogOrderBy>>;
  where?: InputMaybe<AuditAuditLogBoolExp>;
};


export type Query_RootAuditAuditLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAuditAuthEventsArgs = {
  distinctOn?: InputMaybe<Array<AuditAuthEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuthEventsOrderBy>>;
  where?: InputMaybe<AuditAuthEventsBoolExp>;
};


export type Query_RootAuditAuthEventsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditAuthEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuthEventsOrderBy>>;
  where?: InputMaybe<AuditAuthEventsBoolExp>;
};


export type Query_RootAuditAuthEventsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAuditDataAccessLogArgs = {
  distinctOn?: InputMaybe<Array<AuditDataAccessLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditDataAccessLogOrderBy>>;
  where?: InputMaybe<AuditDataAccessLogBoolExp>;
};


export type Query_RootAuditDataAccessLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditDataAccessLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditDataAccessLogOrderBy>>;
  where?: InputMaybe<AuditDataAccessLogBoolExp>;
};


export type Query_RootAuditDataAccessLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAuditPermissionChangesArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionChangesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionChangesOrderBy>>;
  where?: InputMaybe<AuditPermissionChangesBoolExp>;
};


export type Query_RootAuditPermissionChangesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionChangesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionChangesOrderBy>>;
  where?: InputMaybe<AuditPermissionChangesBoolExp>;
};


export type Query_RootAuditPermissionChangesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAuditPermissionUsageReportArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionUsageReportSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionUsageReportOrderBy>>;
  where?: InputMaybe<AuditPermissionUsageReportBoolExp>;
};


export type Query_RootAuditPermissionUsageReportAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionUsageReportSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionUsageReportOrderBy>>;
  where?: InputMaybe<AuditPermissionUsageReportBoolExp>;
};


export type Query_RootAuditSlowQueriesArgs = {
  distinctOn?: InputMaybe<Array<AuditSlowQueriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditSlowQueriesOrderBy>>;
  where?: InputMaybe<AuditSlowQueriesBoolExp>;
};


export type Query_RootAuditSlowQueriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditSlowQueriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditSlowQueriesOrderBy>>;
  where?: InputMaybe<AuditSlowQueriesBoolExp>;
};


export type Query_RootAuditSlowQueriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootAuditUserAccessSummaryArgs = {
  distinctOn?: InputMaybe<Array<AuditUserAccessSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditUserAccessSummaryOrderBy>>;
  where?: InputMaybe<AuditUserAccessSummaryBoolExp>;
};


export type Query_RootAuditUserAccessSummaryAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditUserAccessSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditUserAccessSummaryOrderBy>>;
  where?: InputMaybe<AuditUserAccessSummaryBoolExp>;
};


export type Query_RootBillingAutomationMetricsArgs = {
  distinctOn?: InputMaybe<Array<BillingAutomationMetricsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingAutomationMetricsOrderBy>>;
  where?: InputMaybe<BillingAutomationMetricsBoolExp>;
};


export type Query_RootBillingAutomationMetricsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingAutomationMetricsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingAutomationMetricsOrderBy>>;
  where?: InputMaybe<BillingAutomationMetricsBoolExp>;
};


export type Query_RootBillingEventLogArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


export type Query_RootBillingEventLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


export type Query_RootBillingEventLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootBillingInvoiceArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


export type Query_RootBillingInvoiceAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


export type Query_RootBillingInvoiceByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootBillingInvoiceItemArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


export type Query_RootBillingInvoiceItemAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


export type Query_RootBillingInvoiceItemByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


export type Query_RootBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


export type Query_RootBillingItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootBillingPeriodsArgs = {
  distinctOn?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingPeriodsOrderBy>>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};


export type Query_RootBillingPeriodsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingPeriodsOrderBy>>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};


export type Query_RootBillingPeriodsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootClientExternalSystemsArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


export type Query_RootClientExternalSystemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


export type Query_RootClientExternalSystemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootClientServiceAgreementsArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


export type Query_RootClientServiceAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


export type Query_RootClientServiceAgreementsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootClientServicesWithRatesArgs = {
  distinctOn?: InputMaybe<Array<ClientServicesWithRatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServicesWithRatesOrderBy>>;
  where?: InputMaybe<ClientServicesWithRatesBoolExp>;
};


export type Query_RootClientServicesWithRatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientServicesWithRatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServicesWithRatesOrderBy>>;
  where?: InputMaybe<ClientServicesWithRatesBoolExp>;
};


export type Query_RootClientsArgs = {
  distinctOn?: InputMaybe<Array<ClientsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientsOrderBy>>;
  where?: InputMaybe<ClientsBoolExp>;
};


export type Query_RootClientsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientsOrderBy>>;
  where?: InputMaybe<ClientsBoolExp>;
};


export type Query_RootClientsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootConsultantCapacityOverviewArgs = {
  distinctOn?: InputMaybe<Array<ConsultantCapacityOverviewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultantCapacityOverviewOrderBy>>;
  where?: InputMaybe<ConsultantCapacityOverviewBoolExp>;
};


export type Query_RootConsultantCapacityOverviewAggregateArgs = {
  distinctOn?: InputMaybe<Array<ConsultantCapacityOverviewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultantCapacityOverviewOrderBy>>;
  where?: InputMaybe<ConsultantCapacityOverviewBoolExp>;
};


export type Query_RootCurrentPayrollsArgs = {
  distinctOn?: InputMaybe<Array<CurrentPayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CurrentPayrollsOrderBy>>;
  where?: InputMaybe<CurrentPayrollsBoolExp>;
};


export type Query_RootCurrentPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CurrentPayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CurrentPayrollsOrderBy>>;
  where?: InputMaybe<CurrentPayrollsBoolExp>;
};


export type Query_RootDataBackupsArgs = {
  distinctOn?: InputMaybe<Array<DataBackupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataBackupsOrderBy>>;
  where?: InputMaybe<DataBackupsBoolExp>;
};


export type Query_RootDataBackupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DataBackupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataBackupsOrderBy>>;
  where?: InputMaybe<DataBackupsBoolExp>;
};


export type Query_RootDataBackupsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootEmailDraftsArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


export type Query_RootEmailDraftsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


export type Query_RootEmailDraftsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootEmailSendLogsArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


export type Query_RootEmailSendLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


export type Query_RootEmailSendLogsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootEmailTemplatesArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


export type Query_RootEmailTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


export type Query_RootEmailTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootExternalSystemsArgs = {
  distinctOn?: InputMaybe<Array<ExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExternalSystemsOrderBy>>;
  where?: InputMaybe<ExternalSystemsBoolExp>;
};


export type Query_RootExternalSystemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExternalSystemsOrderBy>>;
  where?: InputMaybe<ExternalSystemsBoolExp>;
};


export type Query_RootExternalSystemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootFeatureFlagsArgs = {
  distinctOn?: InputMaybe<Array<FeatureFlagsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FeatureFlagsOrderBy>>;
  where?: InputMaybe<FeatureFlagsBoolExp>;
};


export type Query_RootFeatureFlagsAggregateArgs = {
  distinctOn?: InputMaybe<Array<FeatureFlagsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FeatureFlagsOrderBy>>;
  where?: InputMaybe<FeatureFlagsBoolExp>;
};


export type Query_RootFeatureFlagsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootFilesArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


export type Query_RootFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


export type Query_RootFilesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootGetLatestPayrollVersionArgs = {
  args: GetLatestPayrollVersionArgs;
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Query_RootGetLatestPayrollVersionAggregateArgs = {
  args: GetLatestPayrollVersionArgs;
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Query_RootGetPayrollVersionHistoryArgs = {
  args: GetPayrollVersionHistoryArgs;
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Query_RootGetPayrollVersionHistoryAggregateArgs = {
  args: GetPayrollVersionHistoryArgs;
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Query_RootHolidaysArgs = {
  distinctOn?: InputMaybe<Array<HolidaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<HolidaysOrderBy>>;
  where?: InputMaybe<HolidaysBoolExp>;
};


export type Query_RootHolidaysAggregateArgs = {
  distinctOn?: InputMaybe<Array<HolidaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<HolidaysOrderBy>>;
  where?: InputMaybe<HolidaysBoolExp>;
};


export type Query_RootHolidaysByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootLatestPayrollVersionResultsArgs = {
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Query_RootLatestPayrollVersionResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Query_RootLatestPayrollVersionResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootLeaveArgs = {
  distinctOn?: InputMaybe<Array<LeaveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeaveOrderBy>>;
  where?: InputMaybe<LeaveBoolExp>;
};


export type Query_RootLeaveAggregateArgs = {
  distinctOn?: InputMaybe<Array<LeaveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeaveOrderBy>>;
  where?: InputMaybe<LeaveBoolExp>;
};


export type Query_RootLeaveByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMonthlyBillingCompletionArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


export type Query_RootMonthlyBillingCompletionAggregateArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


export type Query_RootMonthlyBillingCompletionByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMonthlyBillingDashboardArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingDashboardSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingDashboardOrderBy>>;
  where?: InputMaybe<MonthlyBillingDashboardBoolExp>;
};


export type Query_RootMonthlyBillingDashboardAggregateArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingDashboardSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingDashboardOrderBy>>;
  where?: InputMaybe<MonthlyBillingDashboardBoolExp>;
};


export type Query_RootNotesArgs = {
  distinctOn?: InputMaybe<Array<NotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
  where?: InputMaybe<NotesBoolExp>;
};


export type Query_RootNotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
  where?: InputMaybe<NotesBoolExp>;
};


export type Query_RootNotesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollActivationResultsArgs = {
  distinctOn?: InputMaybe<Array<PayrollActivationResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollActivationResultsOrderBy>>;
  where?: InputMaybe<PayrollActivationResultsBoolExp>;
};


export type Query_RootPayrollActivationResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollActivationResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollActivationResultsOrderBy>>;
  where?: InputMaybe<PayrollActivationResultsBoolExp>;
};


export type Query_RootPayrollActivationResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollAssignmentAuditArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


export type Query_RootPayrollAssignmentAuditAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


export type Query_RootPayrollAssignmentAuditByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


export type Query_RootPayrollAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


export type Query_RootPayrollAssignmentsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollCostAnalysisArgs = {
  distinctOn?: InputMaybe<Array<PayrollCostAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCostAnalysisOrderBy>>;
  where?: InputMaybe<PayrollCostAnalysisBoolExp>;
};


export type Query_RootPayrollCostAnalysisAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollCostAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCostAnalysisOrderBy>>;
  where?: InputMaybe<PayrollCostAnalysisBoolExp>;
};


export type Query_RootPayrollCyclesArgs = {
  distinctOn?: InputMaybe<Array<PayrollCyclesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCyclesOrderBy>>;
  where?: InputMaybe<PayrollCyclesBoolExp>;
};


export type Query_RootPayrollCyclesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollCyclesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCyclesOrderBy>>;
  where?: InputMaybe<PayrollCyclesBoolExp>;
};


export type Query_RootPayrollCyclesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollDashboardStatsArgs = {
  distinctOn?: InputMaybe<Array<PayrollDashboardStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDashboardStatsOrderBy>>;
  where?: InputMaybe<PayrollDashboardStatsBoolExp>;
};


export type Query_RootPayrollDashboardStatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDashboardStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDashboardStatsOrderBy>>;
  where?: InputMaybe<PayrollDashboardStatsBoolExp>;
};


export type Query_RootPayrollDateCompletionAnalyticsArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateCompletionAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateCompletionAnalyticsOrderBy>>;
  where?: InputMaybe<PayrollDateCompletionAnalyticsBoolExp>;
};


export type Query_RootPayrollDateCompletionAnalyticsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateCompletionAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateCompletionAnalyticsOrderBy>>;
  where?: InputMaybe<PayrollDateCompletionAnalyticsBoolExp>;
};


export type Query_RootPayrollDateTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


export type Query_RootPayrollDateTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


export type Query_RootPayrollDateTimeEntriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollDateTypesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTypesOrderBy>>;
  where?: InputMaybe<PayrollDateTypesBoolExp>;
};


export type Query_RootPayrollDateTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTypesOrderBy>>;
  where?: InputMaybe<PayrollDateTypesBoolExp>;
};


export type Query_RootPayrollDateTypesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollDatesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


export type Query_RootPayrollDatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


export type Query_RootPayrollDatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollProfitabilityArgs = {
  distinctOn?: InputMaybe<Array<PayrollProfitabilitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollProfitabilityOrderBy>>;
  where?: InputMaybe<PayrollProfitabilityBoolExp>;
};


export type Query_RootPayrollProfitabilityAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollProfitabilitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollProfitabilityOrderBy>>;
  where?: InputMaybe<PayrollProfitabilityBoolExp>;
};


export type Query_RootPayrollRequiredSkillsArgs = {
  distinctOn?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollRequiredSkillsOrderBy>>;
  where?: InputMaybe<PayrollRequiredSkillsBoolExp>;
};


export type Query_RootPayrollRequiredSkillsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollRequiredSkillsOrderBy>>;
  where?: InputMaybe<PayrollRequiredSkillsBoolExp>;
};


export type Query_RootPayrollServiceAgreementsArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


export type Query_RootPayrollServiceAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


export type Query_RootPayrollServiceAgreementsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollTriggersStatusArgs = {
  distinctOn?: InputMaybe<Array<PayrollTriggersStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollTriggersStatusOrderBy>>;
  where?: InputMaybe<PayrollTriggersStatusBoolExp>;
};


export type Query_RootPayrollTriggersStatusAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollTriggersStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollTriggersStatusOrderBy>>;
  where?: InputMaybe<PayrollTriggersStatusBoolExp>;
};


export type Query_RootPayrollVersionHistoryResultsArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Query_RootPayrollVersionHistoryResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Query_RootPayrollVersionHistoryResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollVersionResultsArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};


export type Query_RootPayrollVersionResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};


export type Query_RootPayrollVersionResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPayrollWorkloadDistributionArgs = {
  distinctOn?: InputMaybe<Array<PayrollWorkloadDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollWorkloadDistributionOrderBy>>;
  where?: InputMaybe<PayrollWorkloadDistributionBoolExp>;
};


export type Query_RootPayrollWorkloadDistributionAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollWorkloadDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollWorkloadDistributionOrderBy>>;
  where?: InputMaybe<PayrollWorkloadDistributionBoolExp>;
};


export type Query_RootPayrollsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


export type Query_RootPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


export type Query_RootPayrollsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPendingBillingApprovalsArgs = {
  distinctOn?: InputMaybe<Array<PendingBillingApprovalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PendingBillingApprovalsOrderBy>>;
  where?: InputMaybe<PendingBillingApprovalsBoolExp>;
};


export type Query_RootPendingBillingApprovalsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PendingBillingApprovalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PendingBillingApprovalsOrderBy>>;
  where?: InputMaybe<PendingBillingApprovalsBoolExp>;
};


export type Query_RootPermissionAuditLogArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


export type Query_RootPermissionAuditLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


export type Query_RootPermissionAuditLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPermissionOverridesArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


export type Query_RootPermissionOverridesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


export type Query_RootPermissionOverridesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPermissionsArgs = {
  distinctOn?: InputMaybe<Array<PermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  where?: InputMaybe<PermissionsBoolExp>;
};


export type Query_RootPermissionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  where?: InputMaybe<PermissionsBoolExp>;
};


export type Query_RootPermissionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPositionAdminDefaultsArgs = {
  distinctOn?: InputMaybe<Array<PositionAdminDefaultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PositionAdminDefaultsOrderBy>>;
  where?: InputMaybe<PositionAdminDefaultsBoolExp>;
};


export type Query_RootPositionAdminDefaultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PositionAdminDefaultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PositionAdminDefaultsOrderBy>>;
  where?: InputMaybe<PositionAdminDefaultsBoolExp>;
};


export type Query_RootPositionAdminDefaultsByPkArgs = {
  position: Scalars['user_position']['input'];
};


export type Query_RootQuoteAnalyticsArgs = {
  distinctOn?: InputMaybe<Array<QuoteAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAnalyticsOrderBy>>;
  where?: InputMaybe<QuoteAnalyticsBoolExp>;
};


export type Query_RootQuoteAnalyticsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAnalyticsOrderBy>>;
  where?: InputMaybe<QuoteAnalyticsBoolExp>;
};


export type Query_RootQuoteConversionsArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


export type Query_RootQuoteConversionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


export type Query_RootQuoteConversionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootQuoteLineItemsArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


export type Query_RootQuoteLineItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


export type Query_RootQuoteLineItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootQuoteTemplatesArgs = {
  distinctOn?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteTemplatesOrderBy>>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};


export type Query_RootQuoteTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteTemplatesOrderBy>>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};


export type Query_RootQuoteTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootQuotesArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


export type Query_RootQuotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


export type Query_RootQuotesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootRateLimitsArgs = {
  distinctOn?: InputMaybe<Array<RateLimitsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RateLimitsOrderBy>>;
  where?: InputMaybe<RateLimitsBoolExp>;
};


export type Query_RootRateLimitsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RateLimitsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RateLimitsOrderBy>>;
  where?: InputMaybe<RateLimitsBoolExp>;
};


export type Query_RootRateLimitsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootResourcesArgs = {
  distinctOn?: InputMaybe<Array<ResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ResourcesOrderBy>>;
  where?: InputMaybe<ResourcesBoolExp>;
};


export type Query_RootResourcesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ResourcesOrderBy>>;
  where?: InputMaybe<ResourcesBoolExp>;
};


export type Query_RootResourcesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootRolePermissionsArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


export type Query_RootRolePermissionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


export type Query_RootRolePermissionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootRolesArgs = {
  distinctOn?: InputMaybe<Array<RolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  where?: InputMaybe<RolesBoolExp>;
};


export type Query_RootRolesAggregateArgs = {
  distinctOn?: InputMaybe<Array<RolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  where?: InputMaybe<RolesBoolExp>;
};


export type Query_RootRolesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSecurityAlertsArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


export type Query_RootSecurityAlertsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


export type Query_RootSecurityAlertsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSecuritySettingsArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


export type Query_RootSecuritySettingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


export type Query_RootSecuritySettingsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootServicePricingRulesArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


export type Query_RootServicePricingRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


export type Query_RootServicePricingRulesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootServiceTemplatesArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


export type Query_RootServiceTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


export type Query_RootServiceTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootServicesArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


export type Query_RootServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


export type Query_RootServicesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootStaffBillingPerformanceArgs = {
  distinctOn?: InputMaybe<Array<StaffBillingPerformanceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StaffBillingPerformanceOrderBy>>;
  where?: InputMaybe<StaffBillingPerformanceBoolExp>;
};


export type Query_RootStaffBillingPerformanceAggregateArgs = {
  distinctOn?: InputMaybe<Array<StaffBillingPerformanceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StaffBillingPerformanceOrderBy>>;
  where?: InputMaybe<StaffBillingPerformanceBoolExp>;
};


export type Query_RootSystemConfigurationArgs = {
  distinctOn?: InputMaybe<Array<SystemConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemConfigurationOrderBy>>;
  where?: InputMaybe<SystemConfigurationBoolExp>;
};


export type Query_RootSystemConfigurationAggregateArgs = {
  distinctOn?: InputMaybe<Array<SystemConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemConfigurationOrderBy>>;
  where?: InputMaybe<SystemConfigurationBoolExp>;
};


export type Query_RootSystemConfigurationByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSystemHealthArgs = {
  distinctOn?: InputMaybe<Array<SystemHealthSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemHealthOrderBy>>;
  where?: InputMaybe<SystemHealthBoolExp>;
};


export type Query_RootSystemHealthAggregateArgs = {
  distinctOn?: InputMaybe<Array<SystemHealthSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemHealthOrderBy>>;
  where?: InputMaybe<SystemHealthBoolExp>;
};


export type Query_RootSystemHealthByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootTeamCapacityByPositionArgs = {
  distinctOn?: InputMaybe<Array<TeamCapacityByPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamCapacityByPositionOrderBy>>;
  where?: InputMaybe<TeamCapacityByPositionBoolExp>;
};


export type Query_RootTeamCapacityByPositionAggregateArgs = {
  distinctOn?: InputMaybe<Array<TeamCapacityByPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamCapacityByPositionOrderBy>>;
  where?: InputMaybe<TeamCapacityByPositionBoolExp>;
};


export type Query_RootTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


export type Query_RootTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


export type Query_RootTimeEntriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootTimeTrackingSummaryArgs = {
  distinctOn?: InputMaybe<Array<TimeTrackingSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeTrackingSummaryOrderBy>>;
  where?: InputMaybe<TimeTrackingSummaryBoolExp>;
};


export type Query_RootTimeTrackingSummaryAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeTrackingSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeTrackingSummaryOrderBy>>;
  where?: InputMaybe<TimeTrackingSummaryBoolExp>;
};


export type Query_RootUserEmailTemplateFavoritesArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


export type Query_RootUserEmailTemplateFavoritesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


export type Query_RootUserEmailTemplateFavoritesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootUserInvitationsArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


export type Query_RootUserInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


export type Query_RootUserInvitationsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootUserProductivityAnalysisArgs = {
  distinctOn?: InputMaybe<Array<UserProductivityAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserProductivityAnalysisOrderBy>>;
  where?: InputMaybe<UserProductivityAnalysisBoolExp>;
};


export type Query_RootUserProductivityAnalysisAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserProductivityAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserProductivityAnalysisOrderBy>>;
  where?: InputMaybe<UserProductivityAnalysisBoolExp>;
};


export type Query_RootUserRateHistoryArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


export type Query_RootUserRateHistoryAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


export type Query_RootUserRateHistoryByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootUserRolesArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


export type Query_RootUserRolesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


export type Query_RootUserRolesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootUserSessionsArgs = {
  distinctOn?: InputMaybe<Array<UserSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSessionsOrderBy>>;
  where?: InputMaybe<UserSessionsBoolExp>;
};


export type Query_RootUserSessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSessionsOrderBy>>;
  where?: InputMaybe<UserSessionsBoolExp>;
};


export type Query_RootUserSessionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootUserSkillsArgs = {
  distinctOn?: InputMaybe<Array<UserSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSkillsOrderBy>>;
  where?: InputMaybe<UserSkillsBoolExp>;
};


export type Query_RootUserSkillsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSkillsOrderBy>>;
  where?: InputMaybe<UserSkillsBoolExp>;
};


export type Query_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Query_RootUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Query_RootUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootUsersRoleBackupArgs = {
  distinctOn?: InputMaybe<Array<UsersRoleBackupSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersRoleBackupOrderBy>>;
  where?: InputMaybe<UsersRoleBackupBoolExp>;
};


export type Query_RootUsersRoleBackupAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersRoleBackupSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersRoleBackupOrderBy>>;
  where?: InputMaybe<UsersRoleBackupBoolExp>;
};


export type Query_RootWorkScheduleArgs = {
  distinctOn?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkScheduleOrderBy>>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};


export type Query_RootWorkScheduleAggregateArgs = {
  distinctOn?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkScheduleOrderBy>>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};


export type Query_RootWorkScheduleByPkArgs = {
  id: Scalars['uuid']['input'];
};

export type QuoteConversionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<QuoteConversionsBoolExp>;
  predicate: IntComparisonExp;
};

export type QuoteLineItemsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<QuoteLineItemsBoolExp>;
  predicate: IntComparisonExp;
};

export type QuoteTemplatesAggregateBoolExpBool_And = {
  arguments: QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<QuoteTemplatesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type QuoteTemplatesAggregateBoolExpBool_Or = {
  arguments: QuoteTemplatesSelectColumnQuoteTemplatesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<QuoteTemplatesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type QuoteTemplatesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<QuoteTemplatesBoolExp>;
  predicate: IntComparisonExp;
};

export type QuotesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<QuotesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<QuotesBoolExp>;
  predicate: IntComparisonExp;
};

export type RolePermissionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<RolePermissionsBoolExp>;
  predicate: IntComparisonExp;
};

export type SecurityAlertsAggregateBoolExpBool_And = {
  arguments: SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SecurityAlertsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SecurityAlertsAggregateBoolExpBool_Or = {
  arguments: SecurityAlertsSelectColumnSecurityAlertsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SecurityAlertsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SecurityAlertsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SecurityAlertsBoolExp>;
  predicate: IntComparisonExp;
};

export type SecuritySettingsAggregateBoolExpBool_And = {
  arguments: SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SecuritySettingsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SecuritySettingsAggregateBoolExpBool_Or = {
  arguments: SecuritySettingsSelectColumnSecuritySettingsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SecuritySettingsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type SecuritySettingsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SecuritySettingsBoolExp>;
  predicate: IntComparisonExp;
};

export type ServicePricingRulesAggregateBoolExpBool_And = {
  arguments: ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServicePricingRulesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ServicePricingRulesAggregateBoolExpBool_Or = {
  arguments: ServicePricingRulesSelectColumnServicePricingRulesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServicePricingRulesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ServicePricingRulesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServicePricingRulesBoolExp>;
  predicate: IntComparisonExp;
};

export type ServiceTemplatesAggregateBoolExpBool_And = {
  arguments: ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServiceTemplatesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ServiceTemplatesAggregateBoolExpBool_Or = {
  arguments: ServiceTemplatesSelectColumnServiceTemplatesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServiceTemplatesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ServiceTemplatesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServiceTemplatesBoolExp>;
  predicate: IntComparisonExp;
};

export type ServicesAggregateBoolExpBool_And = {
  arguments: ServicesSelectColumnServicesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServicesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ServicesAggregateBoolExpBool_Or = {
  arguments: ServicesSelectColumnServicesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServicesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type ServicesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<ServicesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ServicesBoolExp>;
  predicate: IntComparisonExp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** An array relationship */
  adjustmentRules: Array<AdjustmentRules>;
  /** An aggregate relationship */
  adjustmentRulesAggregate: AdjustmentRulesAggregate;
  /** fetch data from the table: "adjustment_rules" using primary key columns */
  adjustmentRulesByPk?: Maybe<AdjustmentRules>;
  /** fetch data from the table in a streaming manner: "adjustment_rules" */
  adjustmentRulesStream: Array<AdjustmentRules>;
  /** fetch data from the table: "app_settings" */
  appSettings: Array<AppSettings>;
  /** fetch aggregated fields from the table: "app_settings" */
  appSettingsAggregate: AppSettingsAggregate;
  /** fetch data from the table: "app_settings" using primary key columns */
  appSettingsByPk?: Maybe<AppSettings>;
  /** fetch data from the table in a streaming manner: "app_settings" */
  appSettingsStream: Array<AppSettings>;
  /** fetch data from the table: "audit.audit_log" */
  auditAuditLog: Array<AuditAuditLog>;
  /** fetch aggregated fields from the table: "audit.audit_log" */
  auditAuditLogAggregate: AuditAuditLogAggregate;
  /** fetch data from the table: "audit.audit_log" using primary key columns */
  auditAuditLogByPk?: Maybe<AuditAuditLog>;
  /** fetch data from the table in a streaming manner: "audit.audit_log" */
  auditAuditLogStream: Array<AuditAuditLog>;
  /** fetch data from the table: "audit.auth_events" */
  auditAuthEvents: Array<AuditAuthEvents>;
  /** fetch aggregated fields from the table: "audit.auth_events" */
  auditAuthEventsAggregate: AuditAuthEventsAggregate;
  /** fetch data from the table: "audit.auth_events" using primary key columns */
  auditAuthEventsByPk?: Maybe<AuditAuthEvents>;
  /** fetch data from the table in a streaming manner: "audit.auth_events" */
  auditAuthEventsStream: Array<AuditAuthEvents>;
  /** fetch data from the table: "audit.data_access_log" */
  auditDataAccessLog: Array<AuditDataAccessLog>;
  /** fetch aggregated fields from the table: "audit.data_access_log" */
  auditDataAccessLogAggregate: AuditDataAccessLogAggregate;
  /** fetch data from the table: "audit.data_access_log" using primary key columns */
  auditDataAccessLogByPk?: Maybe<AuditDataAccessLog>;
  /** fetch data from the table in a streaming manner: "audit.data_access_log" */
  auditDataAccessLogStream: Array<AuditDataAccessLog>;
  /** fetch data from the table: "audit.permission_changes" */
  auditPermissionChanges: Array<AuditPermissionChanges>;
  /** fetch aggregated fields from the table: "audit.permission_changes" */
  auditPermissionChangesAggregate: AuditPermissionChangesAggregate;
  /** fetch data from the table: "audit.permission_changes" using primary key columns */
  auditPermissionChangesByPk?: Maybe<AuditPermissionChanges>;
  /** fetch data from the table in a streaming manner: "audit.permission_changes" */
  auditPermissionChangesStream: Array<AuditPermissionChanges>;
  /** fetch data from the table: "audit.permission_usage_report" */
  auditPermissionUsageReport: Array<AuditPermissionUsageReport>;
  /** fetch aggregated fields from the table: "audit.permission_usage_report" */
  auditPermissionUsageReportAggregate: AuditPermissionUsageReportAggregate;
  /** fetch data from the table in a streaming manner: "audit.permission_usage_report" */
  auditPermissionUsageReportStream: Array<AuditPermissionUsageReport>;
  /** fetch data from the table: "audit.slow_queries" */
  auditSlowQueries: Array<AuditSlowQueries>;
  /** fetch aggregated fields from the table: "audit.slow_queries" */
  auditSlowQueriesAggregate: AuditSlowQueriesAggregate;
  /** fetch data from the table: "audit.slow_queries" using primary key columns */
  auditSlowQueriesByPk?: Maybe<AuditSlowQueries>;
  /** fetch data from the table in a streaming manner: "audit.slow_queries" */
  auditSlowQueriesStream: Array<AuditSlowQueries>;
  /** fetch data from the table: "audit.user_access_summary" */
  auditUserAccessSummary: Array<AuditUserAccessSummary>;
  /** fetch aggregated fields from the table: "audit.user_access_summary" */
  auditUserAccessSummaryAggregate: AuditUserAccessSummaryAggregate;
  /** fetch data from the table in a streaming manner: "audit.user_access_summary" */
  auditUserAccessSummaryStream: Array<AuditUserAccessSummary>;
  /** fetch data from the table: "billing_automation_metrics" */
  billingAutomationMetrics: Array<BillingAutomationMetrics>;
  /** fetch aggregated fields from the table: "billing_automation_metrics" */
  billingAutomationMetricsAggregate: BillingAutomationMetricsAggregate;
  /** fetch data from the table in a streaming manner: "billing_automation_metrics" */
  billingAutomationMetricsStream: Array<BillingAutomationMetrics>;
  /** fetch data from the table: "billing_event_log" */
  billingEventLog: Array<BillingEventLog>;
  /** fetch aggregated fields from the table: "billing_event_log" */
  billingEventLogAggregate: BillingEventLogAggregate;
  /** fetch data from the table: "billing_event_log" using primary key columns */
  billingEventLogByPk?: Maybe<BillingEventLog>;
  /** fetch data from the table in a streaming manner: "billing_event_log" */
  billingEventLogStream: Array<BillingEventLog>;
  /** fetch data from the table: "billing_invoice" */
  billingInvoice: Array<BillingInvoice>;
  /** fetch aggregated fields from the table: "billing_invoice" */
  billingInvoiceAggregate: BillingInvoiceAggregate;
  /** fetch data from the table: "billing_invoice" using primary key columns */
  billingInvoiceByPk?: Maybe<BillingInvoice>;
  /** fetch data from the table: "billing_invoice_item" */
  billingInvoiceItem: Array<BillingInvoiceItem>;
  /** fetch aggregated fields from the table: "billing_invoice_item" */
  billingInvoiceItemAggregate: BillingInvoiceItemAggregate;
  /** fetch data from the table: "billing_invoice_item" using primary key columns */
  billingInvoiceItemByPk?: Maybe<BillingInvoiceItem>;
  /** fetch data from the table in a streaming manner: "billing_invoice_item" */
  billingInvoiceItemStream: Array<BillingInvoiceItem>;
  /** fetch data from the table in a streaming manner: "billing_invoice" */
  billingInvoiceStream: Array<BillingInvoice>;
  /** An array relationship */
  billingItems: Array<BillingItems>;
  /** An aggregate relationship */
  billingItemsAggregate: BillingItemsAggregate;
  /** fetch data from the table: "billing_items" using primary key columns */
  billingItemsByPk?: Maybe<BillingItems>;
  /** fetch data from the table in a streaming manner: "billing_items" */
  billingItemsStream: Array<BillingItems>;
  /** An array relationship */
  billingPeriods: Array<BillingPeriods>;
  /** An aggregate relationship */
  billingPeriodsAggregate: BillingPeriodsAggregate;
  /** fetch data from the table: "billing_periods" using primary key columns */
  billingPeriodsByPk?: Maybe<BillingPeriods>;
  /** fetch data from the table in a streaming manner: "billing_periods" */
  billingPeriodsStream: Array<BillingPeriods>;
  /** An array relationship */
  clientExternalSystems: Array<ClientExternalSystems>;
  /** An aggregate relationship */
  clientExternalSystemsAggregate: ClientExternalSystemsAggregate;
  /** fetch data from the table: "client_external_systems" using primary key columns */
  clientExternalSystemsByPk?: Maybe<ClientExternalSystems>;
  /** fetch data from the table in a streaming manner: "client_external_systems" */
  clientExternalSystemsStream: Array<ClientExternalSystems>;
  /** fetch data from the table: "client_service_agreements" */
  clientServiceAgreements: Array<ClientServiceAgreements>;
  /** fetch aggregated fields from the table: "client_service_agreements" */
  clientServiceAgreementsAggregate: ClientServiceAgreementsAggregate;
  /** fetch data from the table: "client_service_agreements" using primary key columns */
  clientServiceAgreementsByPk?: Maybe<ClientServiceAgreements>;
  /** fetch data from the table in a streaming manner: "client_service_agreements" */
  clientServiceAgreementsStream: Array<ClientServiceAgreements>;
  /** fetch data from the table: "client_services_with_rates" */
  clientServicesWithRates: Array<ClientServicesWithRates>;
  /** fetch aggregated fields from the table: "client_services_with_rates" */
  clientServicesWithRatesAggregate: ClientServicesWithRatesAggregate;
  /** fetch data from the table in a streaming manner: "client_services_with_rates" */
  clientServicesWithRatesStream: Array<ClientServicesWithRates>;
  /** fetch data from the table: "clients" */
  clients: Array<Clients>;
  /** fetch aggregated fields from the table: "clients" */
  clientsAggregate: ClientsAggregate;
  /** fetch data from the table: "clients" using primary key columns */
  clientsByPk?: Maybe<Clients>;
  /** fetch data from the table in a streaming manner: "clients" */
  clientsStream: Array<Clients>;
  /** fetch data from the table: "consultant_capacity_overview" */
  consultantCapacityOverview: Array<ConsultantCapacityOverview>;
  /** fetch aggregated fields from the table: "consultant_capacity_overview" */
  consultantCapacityOverviewAggregate: ConsultantCapacityOverviewAggregate;
  /** fetch data from the table in a streaming manner: "consultant_capacity_overview" */
  consultantCapacityOverviewStream: Array<ConsultantCapacityOverview>;
  /** fetch data from the table: "current_payrolls" */
  currentPayrolls: Array<CurrentPayrolls>;
  /** fetch aggregated fields from the table: "current_payrolls" */
  currentPayrollsAggregate: CurrentPayrollsAggregate;
  /** fetch data from the table in a streaming manner: "current_payrolls" */
  currentPayrollsStream: Array<CurrentPayrolls>;
  /** An array relationship */
  dataBackups: Array<DataBackups>;
  /** An aggregate relationship */
  dataBackupsAggregate: DataBackupsAggregate;
  /** fetch data from the table: "data_backups" using primary key columns */
  dataBackupsByPk?: Maybe<DataBackups>;
  /** fetch data from the table in a streaming manner: "data_backups" */
  dataBackupsStream: Array<DataBackups>;
  /** An array relationship */
  emailDrafts: Array<EmailDrafts>;
  /** An aggregate relationship */
  emailDraftsAggregate: EmailDraftsAggregate;
  /** fetch data from the table: "email_drafts" using primary key columns */
  emailDraftsByPk?: Maybe<EmailDrafts>;
  /** fetch data from the table in a streaming manner: "email_drafts" */
  emailDraftsStream: Array<EmailDrafts>;
  /** An array relationship */
  emailSendLogs: Array<EmailSendLogs>;
  /** An aggregate relationship */
  emailSendLogsAggregate: EmailSendLogsAggregate;
  /** fetch data from the table: "email_send_logs" using primary key columns */
  emailSendLogsByPk?: Maybe<EmailSendLogs>;
  /** fetch data from the table in a streaming manner: "email_send_logs" */
  emailSendLogsStream: Array<EmailSendLogs>;
  /** fetch data from the table: "email_templates" */
  emailTemplates: Array<EmailTemplates>;
  /** fetch aggregated fields from the table: "email_templates" */
  emailTemplatesAggregate: EmailTemplatesAggregate;
  /** fetch data from the table: "email_templates" using primary key columns */
  emailTemplatesByPk?: Maybe<EmailTemplates>;
  /** fetch data from the table in a streaming manner: "email_templates" */
  emailTemplatesStream: Array<EmailTemplates>;
  /** fetch data from the table: "external_systems" */
  externalSystems: Array<ExternalSystems>;
  /** fetch aggregated fields from the table: "external_systems" */
  externalSystemsAggregate: ExternalSystemsAggregate;
  /** fetch data from the table: "external_systems" using primary key columns */
  externalSystemsByPk?: Maybe<ExternalSystems>;
  /** fetch data from the table in a streaming manner: "external_systems" */
  externalSystemsStream: Array<ExternalSystems>;
  /** fetch data from the table: "feature_flags" */
  featureFlags: Array<FeatureFlags>;
  /** fetch aggregated fields from the table: "feature_flags" */
  featureFlagsAggregate: FeatureFlagsAggregate;
  /** fetch data from the table: "feature_flags" using primary key columns */
  featureFlagsByPk?: Maybe<FeatureFlags>;
  /** fetch data from the table in a streaming manner: "feature_flags" */
  featureFlagsStream: Array<FeatureFlags>;
  /** An array relationship */
  files: Array<Files>;
  /** An aggregate relationship */
  filesAggregate: FilesAggregate;
  /** fetch data from the table: "files" using primary key columns */
  filesByPk?: Maybe<Files>;
  /** fetch data from the table in a streaming manner: "files" */
  filesStream: Array<Files>;
  /** execute function "get_latest_payroll_version" which returns "latest_payroll_version_results" */
  getLatestPayrollVersion: Array<LatestPayrollVersionResults>;
  /** execute function "get_latest_payroll_version" and query aggregates on result of table type "latest_payroll_version_results" */
  getLatestPayrollVersionAggregate: LatestPayrollVersionResultsAggregate;
  /** execute function "get_payroll_version_history" which returns "payroll_version_history_results" */
  getPayrollVersionHistory: Array<PayrollVersionHistoryResults>;
  /** execute function "get_payroll_version_history" and query aggregates on result of table type "payroll_version_history_results" */
  getPayrollVersionHistoryAggregate: PayrollVersionHistoryResultsAggregate;
  /** fetch data from the table: "holidays" */
  holidays: Array<Holidays>;
  /** fetch aggregated fields from the table: "holidays" */
  holidaysAggregate: HolidaysAggregate;
  /** fetch data from the table: "holidays" using primary key columns */
  holidaysByPk?: Maybe<Holidays>;
  /** fetch data from the table in a streaming manner: "holidays" */
  holidaysStream: Array<Holidays>;
  /** fetch data from the table: "latest_payroll_version_results" */
  latestPayrollVersionResults: Array<LatestPayrollVersionResults>;
  /** fetch aggregated fields from the table: "latest_payroll_version_results" */
  latestPayrollVersionResultsAggregate: LatestPayrollVersionResultsAggregate;
  /** fetch data from the table: "latest_payroll_version_results" using primary key columns */
  latestPayrollVersionResultsByPk?: Maybe<LatestPayrollVersionResults>;
  /** fetch data from the table in a streaming manner: "latest_payroll_version_results" */
  latestPayrollVersionResultsStream: Array<LatestPayrollVersionResults>;
  /** fetch data from the table: "leave" */
  leave: Array<Leave>;
  /** fetch aggregated fields from the table: "leave" */
  leaveAggregate: LeaveAggregate;
  /** fetch data from the table: "leave" using primary key columns */
  leaveByPk?: Maybe<Leave>;
  /** fetch data from the table in a streaming manner: "leave" */
  leaveStream: Array<Leave>;
  /** fetch data from the table: "monthly_billing_completion" */
  monthlyBillingCompletion: Array<MonthlyBillingCompletion>;
  /** fetch aggregated fields from the table: "monthly_billing_completion" */
  monthlyBillingCompletionAggregate: MonthlyBillingCompletionAggregate;
  /** fetch data from the table: "monthly_billing_completion" using primary key columns */
  monthlyBillingCompletionByPk?: Maybe<MonthlyBillingCompletion>;
  /** fetch data from the table in a streaming manner: "monthly_billing_completion" */
  monthlyBillingCompletionStream: Array<MonthlyBillingCompletion>;
  /** fetch data from the table: "monthly_billing_dashboard" */
  monthlyBillingDashboard: Array<MonthlyBillingDashboard>;
  /** fetch aggregated fields from the table: "monthly_billing_dashboard" */
  monthlyBillingDashboardAggregate: MonthlyBillingDashboardAggregate;
  /** fetch data from the table in a streaming manner: "monthly_billing_dashboard" */
  monthlyBillingDashboardStream: Array<MonthlyBillingDashboard>;
  /** fetch data from the table: "notes" */
  notes: Array<Notes>;
  /** fetch aggregated fields from the table: "notes" */
  notesAggregate: NotesAggregate;
  /** fetch data from the table: "notes" using primary key columns */
  notesByPk?: Maybe<Notes>;
  /** fetch data from the table in a streaming manner: "notes" */
  notesStream: Array<Notes>;
  /** fetch data from the table: "payroll_activation_results" */
  payrollActivationResults: Array<PayrollActivationResults>;
  /** fetch aggregated fields from the table: "payroll_activation_results" */
  payrollActivationResultsAggregate: PayrollActivationResultsAggregate;
  /** fetch data from the table: "payroll_activation_results" using primary key columns */
  payrollActivationResultsByPk?: Maybe<PayrollActivationResults>;
  /** fetch data from the table in a streaming manner: "payroll_activation_results" */
  payrollActivationResultsStream: Array<PayrollActivationResults>;
  /** fetch data from the table: "payroll_assignment_audit" */
  payrollAssignmentAudit: Array<PayrollAssignmentAudit>;
  /** fetch aggregated fields from the table: "payroll_assignment_audit" */
  payrollAssignmentAuditAggregate: PayrollAssignmentAuditAggregate;
  /** fetch data from the table: "payroll_assignment_audit" using primary key columns */
  payrollAssignmentAuditByPk?: Maybe<PayrollAssignmentAudit>;
  /** fetch data from the table in a streaming manner: "payroll_assignment_audit" */
  payrollAssignmentAuditStream: Array<PayrollAssignmentAudit>;
  /** fetch data from the table: "payroll_assignments" */
  payrollAssignments: Array<PayrollAssignments>;
  /** fetch aggregated fields from the table: "payroll_assignments" */
  payrollAssignmentsAggregate: PayrollAssignmentsAggregate;
  /** fetch data from the table: "payroll_assignments" using primary key columns */
  payrollAssignmentsByPk?: Maybe<PayrollAssignments>;
  /** fetch data from the table in a streaming manner: "payroll_assignments" */
  payrollAssignmentsStream: Array<PayrollAssignments>;
  /** fetch data from the table: "payroll_cost_analysis" */
  payrollCostAnalysis: Array<PayrollCostAnalysis>;
  /** fetch aggregated fields from the table: "payroll_cost_analysis" */
  payrollCostAnalysisAggregate: PayrollCostAnalysisAggregate;
  /** fetch data from the table in a streaming manner: "payroll_cost_analysis" */
  payrollCostAnalysisStream: Array<PayrollCostAnalysis>;
  /** fetch data from the table: "payroll_cycles" */
  payrollCycles: Array<PayrollCycles>;
  /** fetch aggregated fields from the table: "payroll_cycles" */
  payrollCyclesAggregate: PayrollCyclesAggregate;
  /** fetch data from the table: "payroll_cycles" using primary key columns */
  payrollCyclesByPk?: Maybe<PayrollCycles>;
  /** fetch data from the table in a streaming manner: "payroll_cycles" */
  payrollCyclesStream: Array<PayrollCycles>;
  /** fetch data from the table: "payroll_dashboard_stats" */
  payrollDashboardStats: Array<PayrollDashboardStats>;
  /** fetch aggregated fields from the table: "payroll_dashboard_stats" */
  payrollDashboardStatsAggregate: PayrollDashboardStatsAggregate;
  /** fetch data from the table in a streaming manner: "payroll_dashboard_stats" */
  payrollDashboardStatsStream: Array<PayrollDashboardStats>;
  /** fetch data from the table: "payroll_date_completion_analytics" */
  payrollDateCompletionAnalytics: Array<PayrollDateCompletionAnalytics>;
  /** fetch aggregated fields from the table: "payroll_date_completion_analytics" */
  payrollDateCompletionAnalyticsAggregate: PayrollDateCompletionAnalyticsAggregate;
  /** fetch data from the table in a streaming manner: "payroll_date_completion_analytics" */
  payrollDateCompletionAnalyticsStream: Array<PayrollDateCompletionAnalytics>;
  /** An array relationship */
  payrollDateTimeEntries: Array<PayrollDateTimeEntries>;
  /** An aggregate relationship */
  payrollDateTimeEntriesAggregate: PayrollDateTimeEntriesAggregate;
  /** fetch data from the table: "payroll_date_time_entries" using primary key columns */
  payrollDateTimeEntriesByPk?: Maybe<PayrollDateTimeEntries>;
  /** fetch data from the table in a streaming manner: "payroll_date_time_entries" */
  payrollDateTimeEntriesStream: Array<PayrollDateTimeEntries>;
  /** fetch data from the table: "payroll_date_types" */
  payrollDateTypes: Array<PayrollDateTypes>;
  /** fetch aggregated fields from the table: "payroll_date_types" */
  payrollDateTypesAggregate: PayrollDateTypesAggregate;
  /** fetch data from the table: "payroll_date_types" using primary key columns */
  payrollDateTypesByPk?: Maybe<PayrollDateTypes>;
  /** fetch data from the table in a streaming manner: "payroll_date_types" */
  payrollDateTypesStream: Array<PayrollDateTypes>;
  /** An array relationship */
  payrollDates: Array<PayrollDates>;
  /** An aggregate relationship */
  payrollDatesAggregate: PayrollDatesAggregate;
  /** fetch data from the table: "payroll_dates" using primary key columns */
  payrollDatesByPk?: Maybe<PayrollDates>;
  /** fetch data from the table in a streaming manner: "payroll_dates" */
  payrollDatesStream: Array<PayrollDates>;
  /** fetch data from the table: "payroll_profitability" */
  payrollProfitability: Array<PayrollProfitability>;
  /** fetch aggregated fields from the table: "payroll_profitability" */
  payrollProfitabilityAggregate: PayrollProfitabilityAggregate;
  /** fetch data from the table in a streaming manner: "payroll_profitability" */
  payrollProfitabilityStream: Array<PayrollProfitability>;
  /** fetch data from the table: "payroll_required_skills" */
  payrollRequiredSkills: Array<PayrollRequiredSkills>;
  /** fetch aggregated fields from the table: "payroll_required_skills" */
  payrollRequiredSkillsAggregate: PayrollRequiredSkillsAggregate;
  /** fetch data from the table in a streaming manner: "payroll_required_skills" */
  payrollRequiredSkillsStream: Array<PayrollRequiredSkills>;
  /** An array relationship */
  payrollServiceAgreements: Array<PayrollServiceAgreements>;
  /** An aggregate relationship */
  payrollServiceAgreementsAggregate: PayrollServiceAgreementsAggregate;
  /** fetch data from the table: "payroll_service_agreements" using primary key columns */
  payrollServiceAgreementsByPk?: Maybe<PayrollServiceAgreements>;
  /** fetch data from the table in a streaming manner: "payroll_service_agreements" */
  payrollServiceAgreementsStream: Array<PayrollServiceAgreements>;
  /** fetch data from the table: "payroll_triggers_status" */
  payrollTriggersStatus: Array<PayrollTriggersStatus>;
  /** fetch aggregated fields from the table: "payroll_triggers_status" */
  payrollTriggersStatusAggregate: PayrollTriggersStatusAggregate;
  /** fetch data from the table in a streaming manner: "payroll_triggers_status" */
  payrollTriggersStatusStream: Array<PayrollTriggersStatus>;
  /** fetch data from the table: "payroll_version_history_results" */
  payrollVersionHistoryResults: Array<PayrollVersionHistoryResults>;
  /** fetch aggregated fields from the table: "payroll_version_history_results" */
  payrollVersionHistoryResultsAggregate: PayrollVersionHistoryResultsAggregate;
  /** fetch data from the table: "payroll_version_history_results" using primary key columns */
  payrollVersionHistoryResultsByPk?: Maybe<PayrollVersionHistoryResults>;
  /** fetch data from the table in a streaming manner: "payroll_version_history_results" */
  payrollVersionHistoryResultsStream: Array<PayrollVersionHistoryResults>;
  /** fetch data from the table: "payroll_version_results" */
  payrollVersionResults: Array<PayrollVersionResults>;
  /** fetch aggregated fields from the table: "payroll_version_results" */
  payrollVersionResultsAggregate: PayrollVersionResultsAggregate;
  /** fetch data from the table: "payroll_version_results" using primary key columns */
  payrollVersionResultsByPk?: Maybe<PayrollVersionResults>;
  /** fetch data from the table in a streaming manner: "payroll_version_results" */
  payrollVersionResultsStream: Array<PayrollVersionResults>;
  /** fetch data from the table: "payroll_workload_distribution" */
  payrollWorkloadDistribution: Array<PayrollWorkloadDistribution>;
  /** fetch aggregated fields from the table: "payroll_workload_distribution" */
  payrollWorkloadDistributionAggregate: PayrollWorkloadDistributionAggregate;
  /** fetch data from the table in a streaming manner: "payroll_workload_distribution" */
  payrollWorkloadDistributionStream: Array<PayrollWorkloadDistribution>;
  /** An array relationship */
  payrolls: Array<Payrolls>;
  /** An aggregate relationship */
  payrollsAggregate: PayrollsAggregate;
  /** fetch data from the table: "payrolls" using primary key columns */
  payrollsByPk?: Maybe<Payrolls>;
  /** fetch data from the table in a streaming manner: "payrolls" */
  payrollsStream: Array<Payrolls>;
  /** fetch data from the table: "pending_billing_approvals" */
  pendingBillingApprovals: Array<PendingBillingApprovals>;
  /** fetch aggregated fields from the table: "pending_billing_approvals" */
  pendingBillingApprovalsAggregate: PendingBillingApprovalsAggregate;
  /** fetch data from the table in a streaming manner: "pending_billing_approvals" */
  pendingBillingApprovalsStream: Array<PendingBillingApprovals>;
  /** fetch data from the table: "permission_audit_log" */
  permissionAuditLog: Array<PermissionAuditLog>;
  /** fetch aggregated fields from the table: "permission_audit_log" */
  permissionAuditLogAggregate: PermissionAuditLogAggregate;
  /** fetch data from the table: "permission_audit_log" using primary key columns */
  permissionAuditLogByPk?: Maybe<PermissionAuditLog>;
  /** fetch data from the table in a streaming manner: "permission_audit_log" */
  permissionAuditLogStream: Array<PermissionAuditLog>;
  /** An array relationship */
  permissionOverrides: Array<PermissionOverrides>;
  /** An aggregate relationship */
  permissionOverridesAggregate: PermissionOverridesAggregate;
  /** fetch data from the table: "permission_overrides" using primary key columns */
  permissionOverridesByPk?: Maybe<PermissionOverrides>;
  /** fetch data from the table in a streaming manner: "permission_overrides" */
  permissionOverridesStream: Array<PermissionOverrides>;
  /** An array relationship */
  permissions: Array<Permissions>;
  /** An aggregate relationship */
  permissionsAggregate: PermissionsAggregate;
  /** fetch data from the table: "permissions" using primary key columns */
  permissionsByPk?: Maybe<Permissions>;
  /** fetch data from the table in a streaming manner: "permissions" */
  permissionsStream: Array<Permissions>;
  /** fetch data from the table: "position_admin_defaults" */
  positionAdminDefaults: Array<PositionAdminDefaults>;
  /** fetch aggregated fields from the table: "position_admin_defaults" */
  positionAdminDefaultsAggregate: PositionAdminDefaultsAggregate;
  /** fetch data from the table: "position_admin_defaults" using primary key columns */
  positionAdminDefaultsByPk?: Maybe<PositionAdminDefaults>;
  /** fetch data from the table in a streaming manner: "position_admin_defaults" */
  positionAdminDefaultsStream: Array<PositionAdminDefaults>;
  /** fetch data from the table: "quote_analytics" */
  quoteAnalytics: Array<QuoteAnalytics>;
  /** fetch aggregated fields from the table: "quote_analytics" */
  quoteAnalyticsAggregate: QuoteAnalyticsAggregate;
  /** fetch data from the table in a streaming manner: "quote_analytics" */
  quoteAnalyticsStream: Array<QuoteAnalytics>;
  /** An array relationship */
  quoteConversions: Array<QuoteConversions>;
  /** An aggregate relationship */
  quoteConversionsAggregate: QuoteConversionsAggregate;
  /** fetch data from the table: "quote_conversions" using primary key columns */
  quoteConversionsByPk?: Maybe<QuoteConversions>;
  /** fetch data from the table in a streaming manner: "quote_conversions" */
  quoteConversionsStream: Array<QuoteConversions>;
  /** An array relationship */
  quoteLineItems: Array<QuoteLineItems>;
  /** An aggregate relationship */
  quoteLineItemsAggregate: QuoteLineItemsAggregate;
  /** fetch data from the table: "quote_line_items" using primary key columns */
  quoteLineItemsByPk?: Maybe<QuoteLineItems>;
  /** fetch data from the table in a streaming manner: "quote_line_items" */
  quoteLineItemsStream: Array<QuoteLineItems>;
  /** An array relationship */
  quoteTemplates: Array<QuoteTemplates>;
  /** An aggregate relationship */
  quoteTemplatesAggregate: QuoteTemplatesAggregate;
  /** fetch data from the table: "quote_templates" using primary key columns */
  quoteTemplatesByPk?: Maybe<QuoteTemplates>;
  /** fetch data from the table in a streaming manner: "quote_templates" */
  quoteTemplatesStream: Array<QuoteTemplates>;
  /** An array relationship */
  quotes: Array<Quotes>;
  /** An aggregate relationship */
  quotesAggregate: QuotesAggregate;
  /** fetch data from the table: "quotes" using primary key columns */
  quotesByPk?: Maybe<Quotes>;
  /** fetch data from the table in a streaming manner: "quotes" */
  quotesStream: Array<Quotes>;
  /** fetch data from the table: "rate_limits" */
  rateLimits: Array<RateLimits>;
  /** fetch aggregated fields from the table: "rate_limits" */
  rateLimitsAggregate: RateLimitsAggregate;
  /** fetch data from the table: "rate_limits" using primary key columns */
  rateLimitsByPk?: Maybe<RateLimits>;
  /** fetch data from the table in a streaming manner: "rate_limits" */
  rateLimitsStream: Array<RateLimits>;
  /** fetch data from the table: "resources" */
  resources: Array<Resources>;
  /** fetch aggregated fields from the table: "resources" */
  resourcesAggregate: ResourcesAggregate;
  /** fetch data from the table: "resources" using primary key columns */
  resourcesByPk?: Maybe<Resources>;
  /** fetch data from the table in a streaming manner: "resources" */
  resourcesStream: Array<Resources>;
  /** An array relationship */
  rolePermissions: Array<RolePermissions>;
  /** An aggregate relationship */
  rolePermissionsAggregate: RolePermissionsAggregate;
  /** fetch data from the table: "role_permissions" using primary key columns */
  rolePermissionsByPk?: Maybe<RolePermissions>;
  /** fetch data from the table in a streaming manner: "role_permissions" */
  rolePermissionsStream: Array<RolePermissions>;
  /** fetch data from the table: "roles" */
  roles: Array<Roles>;
  /** fetch aggregated fields from the table: "roles" */
  rolesAggregate: RolesAggregate;
  /** fetch data from the table: "roles" using primary key columns */
  rolesByPk?: Maybe<Roles>;
  /** fetch data from the table in a streaming manner: "roles" */
  rolesStream: Array<Roles>;
  /** An array relationship */
  securityAlerts: Array<SecurityAlerts>;
  /** An aggregate relationship */
  securityAlertsAggregate: SecurityAlertsAggregate;
  /** fetch data from the table: "security_alerts" using primary key columns */
  securityAlertsByPk?: Maybe<SecurityAlerts>;
  /** fetch data from the table in a streaming manner: "security_alerts" */
  securityAlertsStream: Array<SecurityAlerts>;
  /** An array relationship */
  securitySettings: Array<SecuritySettings>;
  /** An aggregate relationship */
  securitySettingsAggregate: SecuritySettingsAggregate;
  /** fetch data from the table: "security_settings" using primary key columns */
  securitySettingsByPk?: Maybe<SecuritySettings>;
  /** fetch data from the table in a streaming manner: "security_settings" */
  securitySettingsStream: Array<SecuritySettings>;
  /** An array relationship */
  servicePricingRules: Array<ServicePricingRules>;
  /** An aggregate relationship */
  servicePricingRulesAggregate: ServicePricingRulesAggregate;
  /** fetch data from the table: "service_pricing_rules" using primary key columns */
  servicePricingRulesByPk?: Maybe<ServicePricingRules>;
  /** fetch data from the table in a streaming manner: "service_pricing_rules" */
  servicePricingRulesStream: Array<ServicePricingRules>;
  /** fetch data from the table: "service_templates" */
  serviceTemplates: Array<ServiceTemplates>;
  /** fetch aggregated fields from the table: "service_templates" */
  serviceTemplatesAggregate: ServiceTemplatesAggregate;
  /** fetch data from the table: "service_templates" using primary key columns */
  serviceTemplatesByPk?: Maybe<ServiceTemplates>;
  /** fetch data from the table in a streaming manner: "service_templates" */
  serviceTemplatesStream: Array<ServiceTemplates>;
  /** fetch data from the table: "services" */
  services: Array<Services>;
  /** fetch aggregated fields from the table: "services" */
  servicesAggregate: ServicesAggregate;
  /** fetch data from the table: "services" using primary key columns */
  servicesByPk?: Maybe<Services>;
  /** fetch data from the table in a streaming manner: "services" */
  servicesStream: Array<Services>;
  /** fetch data from the table: "staff_billing_performance" */
  staffBillingPerformance: Array<StaffBillingPerformance>;
  /** fetch aggregated fields from the table: "staff_billing_performance" */
  staffBillingPerformanceAggregate: StaffBillingPerformanceAggregate;
  /** fetch data from the table in a streaming manner: "staff_billing_performance" */
  staffBillingPerformanceStream: Array<StaffBillingPerformance>;
  /** fetch data from the table: "system_configuration" */
  systemConfiguration: Array<SystemConfiguration>;
  /** fetch aggregated fields from the table: "system_configuration" */
  systemConfigurationAggregate: SystemConfigurationAggregate;
  /** fetch data from the table: "system_configuration" using primary key columns */
  systemConfigurationByPk?: Maybe<SystemConfiguration>;
  /** fetch data from the table in a streaming manner: "system_configuration" */
  systemConfigurationStream: Array<SystemConfiguration>;
  /** fetch data from the table: "system_health" */
  systemHealth: Array<SystemHealth>;
  /** fetch aggregated fields from the table: "system_health" */
  systemHealthAggregate: SystemHealthAggregate;
  /** fetch data from the table: "system_health" using primary key columns */
  systemHealthByPk?: Maybe<SystemHealth>;
  /** fetch data from the table in a streaming manner: "system_health" */
  systemHealthStream: Array<SystemHealth>;
  /** fetch data from the table: "team_capacity_by_position" */
  teamCapacityByPosition: Array<TeamCapacityByPosition>;
  /** fetch aggregated fields from the table: "team_capacity_by_position" */
  teamCapacityByPositionAggregate: TeamCapacityByPositionAggregate;
  /** fetch data from the table in a streaming manner: "team_capacity_by_position" */
  teamCapacityByPositionStream: Array<TeamCapacityByPosition>;
  /** An array relationship */
  timeEntries: Array<TimeEntries>;
  /** An aggregate relationship */
  timeEntriesAggregate: TimeEntriesAggregate;
  /** fetch data from the table: "time_entries" using primary key columns */
  timeEntriesByPk?: Maybe<TimeEntries>;
  /** fetch data from the table in a streaming manner: "time_entries" */
  timeEntriesStream: Array<TimeEntries>;
  /** fetch data from the table: "time_tracking_summary" */
  timeTrackingSummary: Array<TimeTrackingSummary>;
  /** fetch aggregated fields from the table: "time_tracking_summary" */
  timeTrackingSummaryAggregate: TimeTrackingSummaryAggregate;
  /** fetch data from the table in a streaming manner: "time_tracking_summary" */
  timeTrackingSummaryStream: Array<TimeTrackingSummary>;
  /** fetch data from the table: "user_email_template_favorites" */
  userEmailTemplateFavorites: Array<UserEmailTemplateFavorites>;
  /** fetch aggregated fields from the table: "user_email_template_favorites" */
  userEmailTemplateFavoritesAggregate: UserEmailTemplateFavoritesAggregate;
  /** fetch data from the table: "user_email_template_favorites" using primary key columns */
  userEmailTemplateFavoritesByPk?: Maybe<UserEmailTemplateFavorites>;
  /** fetch data from the table in a streaming manner: "user_email_template_favorites" */
  userEmailTemplateFavoritesStream: Array<UserEmailTemplateFavorites>;
  /** fetch data from the table: "user_invitations" */
  userInvitations: Array<UserInvitations>;
  /** fetch aggregated fields from the table: "user_invitations" */
  userInvitationsAggregate: UserInvitationsAggregate;
  /** fetch data from the table: "user_invitations" using primary key columns */
  userInvitationsByPk?: Maybe<UserInvitations>;
  /** fetch data from the table in a streaming manner: "user_invitations" */
  userInvitationsStream: Array<UserInvitations>;
  /** fetch data from the table: "user_productivity_analysis" */
  userProductivityAnalysis: Array<UserProductivityAnalysis>;
  /** fetch aggregated fields from the table: "user_productivity_analysis" */
  userProductivityAnalysisAggregate: UserProductivityAnalysisAggregate;
  /** fetch data from the table in a streaming manner: "user_productivity_analysis" */
  userProductivityAnalysisStream: Array<UserProductivityAnalysis>;
  /** fetch data from the table: "user_rate_history" */
  userRateHistory: Array<UserRateHistory>;
  /** fetch aggregated fields from the table: "user_rate_history" */
  userRateHistoryAggregate: UserRateHistoryAggregate;
  /** fetch data from the table: "user_rate_history" using primary key columns */
  userRateHistoryByPk?: Maybe<UserRateHistory>;
  /** fetch data from the table in a streaming manner: "user_rate_history" */
  userRateHistoryStream: Array<UserRateHistory>;
  /** An array relationship */
  userRoles: Array<UserRoles>;
  /** An aggregate relationship */
  userRolesAggregate: UserRolesAggregate;
  /** fetch data from the table: "user_roles" using primary key columns */
  userRolesByPk?: Maybe<UserRoles>;
  /** fetch data from the table in a streaming manner: "user_roles" */
  userRolesStream: Array<UserRoles>;
  /** An array relationship */
  userSessions: Array<UserSessions>;
  /** An aggregate relationship */
  userSessionsAggregate: UserSessionsAggregate;
  /** fetch data from the table: "user_sessions" using primary key columns */
  userSessionsByPk?: Maybe<UserSessions>;
  /** fetch data from the table in a streaming manner: "user_sessions" */
  userSessionsStream: Array<UserSessions>;
  /** fetch data from the table: "user_skills" */
  userSkills: Array<UserSkills>;
  /** fetch aggregated fields from the table: "user_skills" */
  userSkillsAggregate: UserSkillsAggregate;
  /** fetch data from the table in a streaming manner: "user_skills" */
  userSkillsStream: Array<UserSkills>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  usersAggregate: UsersAggregate;
  /** fetch data from the table: "users" using primary key columns */
  usersByPk?: Maybe<Users>;
  /** fetch data from the table: "users_role_backup" */
  usersRoleBackup: Array<UsersRoleBackup>;
  /** fetch aggregated fields from the table: "users_role_backup" */
  usersRoleBackupAggregate: UsersRoleBackupAggregate;
  /** fetch data from the table in a streaming manner: "users_role_backup" */
  usersRoleBackupStream: Array<UsersRoleBackup>;
  /** fetch data from the table in a streaming manner: "users" */
  usersStream: Array<Users>;
  /** fetch data from the table: "work_schedule" */
  workSchedule: Array<WorkSchedule>;
  /** fetch aggregated fields from the table: "work_schedule" */
  workScheduleAggregate: WorkScheduleAggregate;
  /** fetch data from the table: "work_schedule" using primary key columns */
  workScheduleByPk?: Maybe<WorkSchedule>;
  /** fetch data from the table in a streaming manner: "work_schedule" */
  workScheduleStream: Array<WorkSchedule>;
};


export type Subscription_RootAdjustmentRulesArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


export type Subscription_RootAdjustmentRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AdjustmentRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AdjustmentRulesOrderBy>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


export type Subscription_RootAdjustmentRulesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAdjustmentRulesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AdjustmentRulesStreamCursorInput>>;
  where?: InputMaybe<AdjustmentRulesBoolExp>;
};


export type Subscription_RootAppSettingsArgs = {
  distinctOn?: InputMaybe<Array<AppSettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AppSettingsOrderBy>>;
  where?: InputMaybe<AppSettingsBoolExp>;
};


export type Subscription_RootAppSettingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AppSettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AppSettingsOrderBy>>;
  where?: InputMaybe<AppSettingsBoolExp>;
};


export type Subscription_RootAppSettingsByPkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootAppSettingsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AppSettingsStreamCursorInput>>;
  where?: InputMaybe<AppSettingsBoolExp>;
};


export type Subscription_RootAuditAuditLogArgs = {
  distinctOn?: InputMaybe<Array<AuditAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuditLogOrderBy>>;
  where?: InputMaybe<AuditAuditLogBoolExp>;
};


export type Subscription_RootAuditAuditLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuditLogOrderBy>>;
  where?: InputMaybe<AuditAuditLogBoolExp>;
};


export type Subscription_RootAuditAuditLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAuditAuditLogStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AuditAuditLogStreamCursorInput>>;
  where?: InputMaybe<AuditAuditLogBoolExp>;
};


export type Subscription_RootAuditAuthEventsArgs = {
  distinctOn?: InputMaybe<Array<AuditAuthEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuthEventsOrderBy>>;
  where?: InputMaybe<AuditAuthEventsBoolExp>;
};


export type Subscription_RootAuditAuthEventsAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditAuthEventsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditAuthEventsOrderBy>>;
  where?: InputMaybe<AuditAuthEventsBoolExp>;
};


export type Subscription_RootAuditAuthEventsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAuditAuthEventsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AuditAuthEventsStreamCursorInput>>;
  where?: InputMaybe<AuditAuthEventsBoolExp>;
};


export type Subscription_RootAuditDataAccessLogArgs = {
  distinctOn?: InputMaybe<Array<AuditDataAccessLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditDataAccessLogOrderBy>>;
  where?: InputMaybe<AuditDataAccessLogBoolExp>;
};


export type Subscription_RootAuditDataAccessLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditDataAccessLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditDataAccessLogOrderBy>>;
  where?: InputMaybe<AuditDataAccessLogBoolExp>;
};


export type Subscription_RootAuditDataAccessLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAuditDataAccessLogStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AuditDataAccessLogStreamCursorInput>>;
  where?: InputMaybe<AuditDataAccessLogBoolExp>;
};


export type Subscription_RootAuditPermissionChangesArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionChangesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionChangesOrderBy>>;
  where?: InputMaybe<AuditPermissionChangesBoolExp>;
};


export type Subscription_RootAuditPermissionChangesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionChangesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionChangesOrderBy>>;
  where?: InputMaybe<AuditPermissionChangesBoolExp>;
};


export type Subscription_RootAuditPermissionChangesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAuditPermissionChangesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AuditPermissionChangesStreamCursorInput>>;
  where?: InputMaybe<AuditPermissionChangesBoolExp>;
};


export type Subscription_RootAuditPermissionUsageReportArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionUsageReportSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionUsageReportOrderBy>>;
  where?: InputMaybe<AuditPermissionUsageReportBoolExp>;
};


export type Subscription_RootAuditPermissionUsageReportAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditPermissionUsageReportSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditPermissionUsageReportOrderBy>>;
  where?: InputMaybe<AuditPermissionUsageReportBoolExp>;
};


export type Subscription_RootAuditPermissionUsageReportStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AuditPermissionUsageReportStreamCursorInput>>;
  where?: InputMaybe<AuditPermissionUsageReportBoolExp>;
};


export type Subscription_RootAuditSlowQueriesArgs = {
  distinctOn?: InputMaybe<Array<AuditSlowQueriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditSlowQueriesOrderBy>>;
  where?: InputMaybe<AuditSlowQueriesBoolExp>;
};


export type Subscription_RootAuditSlowQueriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditSlowQueriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditSlowQueriesOrderBy>>;
  where?: InputMaybe<AuditSlowQueriesBoolExp>;
};


export type Subscription_RootAuditSlowQueriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootAuditSlowQueriesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AuditSlowQueriesStreamCursorInput>>;
  where?: InputMaybe<AuditSlowQueriesBoolExp>;
};


export type Subscription_RootAuditUserAccessSummaryArgs = {
  distinctOn?: InputMaybe<Array<AuditUserAccessSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditUserAccessSummaryOrderBy>>;
  where?: InputMaybe<AuditUserAccessSummaryBoolExp>;
};


export type Subscription_RootAuditUserAccessSummaryAggregateArgs = {
  distinctOn?: InputMaybe<Array<AuditUserAccessSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuditUserAccessSummaryOrderBy>>;
  where?: InputMaybe<AuditUserAccessSummaryBoolExp>;
};


export type Subscription_RootAuditUserAccessSummaryStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<AuditUserAccessSummaryStreamCursorInput>>;
  where?: InputMaybe<AuditUserAccessSummaryBoolExp>;
};


export type Subscription_RootBillingAutomationMetricsArgs = {
  distinctOn?: InputMaybe<Array<BillingAutomationMetricsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingAutomationMetricsOrderBy>>;
  where?: InputMaybe<BillingAutomationMetricsBoolExp>;
};


export type Subscription_RootBillingAutomationMetricsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingAutomationMetricsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingAutomationMetricsOrderBy>>;
  where?: InputMaybe<BillingAutomationMetricsBoolExp>;
};


export type Subscription_RootBillingAutomationMetricsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BillingAutomationMetricsStreamCursorInput>>;
  where?: InputMaybe<BillingAutomationMetricsBoolExp>;
};


export type Subscription_RootBillingEventLogArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


export type Subscription_RootBillingEventLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingEventLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingEventLogOrderBy>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


export type Subscription_RootBillingEventLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBillingEventLogStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BillingEventLogStreamCursorInput>>;
  where?: InputMaybe<BillingEventLogBoolExp>;
};


export type Subscription_RootBillingInvoiceArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


export type Subscription_RootBillingInvoiceAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceOrderBy>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


export type Subscription_RootBillingInvoiceByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBillingInvoiceItemArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


export type Subscription_RootBillingInvoiceItemAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingInvoiceItemSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingInvoiceItemOrderBy>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


export type Subscription_RootBillingInvoiceItemByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBillingInvoiceItemStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BillingInvoiceItemStreamCursorInput>>;
  where?: InputMaybe<BillingInvoiceItemBoolExp>;
};


export type Subscription_RootBillingInvoiceStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BillingInvoiceStreamCursorInput>>;
  where?: InputMaybe<BillingInvoiceBoolExp>;
};


export type Subscription_RootBillingItemsArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


export type Subscription_RootBillingItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingItemsOrderBy>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


export type Subscription_RootBillingItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBillingItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BillingItemsStreamCursorInput>>;
  where?: InputMaybe<BillingItemsBoolExp>;
};


export type Subscription_RootBillingPeriodsArgs = {
  distinctOn?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingPeriodsOrderBy>>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};


export type Subscription_RootBillingPeriodsAggregateArgs = {
  distinctOn?: InputMaybe<Array<BillingPeriodsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BillingPeriodsOrderBy>>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};


export type Subscription_RootBillingPeriodsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBillingPeriodsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BillingPeriodsStreamCursorInput>>;
  where?: InputMaybe<BillingPeriodsBoolExp>;
};


export type Subscription_RootClientExternalSystemsArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


export type Subscription_RootClientExternalSystemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientExternalSystemsOrderBy>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


export type Subscription_RootClientExternalSystemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootClientExternalSystemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClientExternalSystemsStreamCursorInput>>;
  where?: InputMaybe<ClientExternalSystemsBoolExp>;
};


export type Subscription_RootClientServiceAgreementsArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


export type Subscription_RootClientServiceAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServiceAgreementsOrderBy>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


export type Subscription_RootClientServiceAgreementsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootClientServiceAgreementsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClientServiceAgreementsStreamCursorInput>>;
  where?: InputMaybe<ClientServiceAgreementsBoolExp>;
};


export type Subscription_RootClientServicesWithRatesArgs = {
  distinctOn?: InputMaybe<Array<ClientServicesWithRatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServicesWithRatesOrderBy>>;
  where?: InputMaybe<ClientServicesWithRatesBoolExp>;
};


export type Subscription_RootClientServicesWithRatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientServicesWithRatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientServicesWithRatesOrderBy>>;
  where?: InputMaybe<ClientServicesWithRatesBoolExp>;
};


export type Subscription_RootClientServicesWithRatesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClientServicesWithRatesStreamCursorInput>>;
  where?: InputMaybe<ClientServicesWithRatesBoolExp>;
};


export type Subscription_RootClientsArgs = {
  distinctOn?: InputMaybe<Array<ClientsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientsOrderBy>>;
  where?: InputMaybe<ClientsBoolExp>;
};


export type Subscription_RootClientsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ClientsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ClientsOrderBy>>;
  where?: InputMaybe<ClientsBoolExp>;
};


export type Subscription_RootClientsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootClientsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ClientsStreamCursorInput>>;
  where?: InputMaybe<ClientsBoolExp>;
};


export type Subscription_RootConsultantCapacityOverviewArgs = {
  distinctOn?: InputMaybe<Array<ConsultantCapacityOverviewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultantCapacityOverviewOrderBy>>;
  where?: InputMaybe<ConsultantCapacityOverviewBoolExp>;
};


export type Subscription_RootConsultantCapacityOverviewAggregateArgs = {
  distinctOn?: InputMaybe<Array<ConsultantCapacityOverviewSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConsultantCapacityOverviewOrderBy>>;
  where?: InputMaybe<ConsultantCapacityOverviewBoolExp>;
};


export type Subscription_RootConsultantCapacityOverviewStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ConsultantCapacityOverviewStreamCursorInput>>;
  where?: InputMaybe<ConsultantCapacityOverviewBoolExp>;
};


export type Subscription_RootCurrentPayrollsArgs = {
  distinctOn?: InputMaybe<Array<CurrentPayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CurrentPayrollsOrderBy>>;
  where?: InputMaybe<CurrentPayrollsBoolExp>;
};


export type Subscription_RootCurrentPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<CurrentPayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CurrentPayrollsOrderBy>>;
  where?: InputMaybe<CurrentPayrollsBoolExp>;
};


export type Subscription_RootCurrentPayrollsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CurrentPayrollsStreamCursorInput>>;
  where?: InputMaybe<CurrentPayrollsBoolExp>;
};


export type Subscription_RootDataBackupsArgs = {
  distinctOn?: InputMaybe<Array<DataBackupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataBackupsOrderBy>>;
  where?: InputMaybe<DataBackupsBoolExp>;
};


export type Subscription_RootDataBackupsAggregateArgs = {
  distinctOn?: InputMaybe<Array<DataBackupsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataBackupsOrderBy>>;
  where?: InputMaybe<DataBackupsBoolExp>;
};


export type Subscription_RootDataBackupsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootDataBackupsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DataBackupsStreamCursorInput>>;
  where?: InputMaybe<DataBackupsBoolExp>;
};


export type Subscription_RootEmailDraftsArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


export type Subscription_RootEmailDraftsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailDraftsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailDraftsOrderBy>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


export type Subscription_RootEmailDraftsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootEmailDraftsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<EmailDraftsStreamCursorInput>>;
  where?: InputMaybe<EmailDraftsBoolExp>;
};


export type Subscription_RootEmailSendLogsArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


export type Subscription_RootEmailSendLogsAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailSendLogsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailSendLogsOrderBy>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


export type Subscription_RootEmailSendLogsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootEmailSendLogsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<EmailSendLogsStreamCursorInput>>;
  where?: InputMaybe<EmailSendLogsBoolExp>;
};


export type Subscription_RootEmailTemplatesArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


export type Subscription_RootEmailTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<EmailTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailTemplatesOrderBy>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


export type Subscription_RootEmailTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootEmailTemplatesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<EmailTemplatesStreamCursorInput>>;
  where?: InputMaybe<EmailTemplatesBoolExp>;
};


export type Subscription_RootExternalSystemsArgs = {
  distinctOn?: InputMaybe<Array<ExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExternalSystemsOrderBy>>;
  where?: InputMaybe<ExternalSystemsBoolExp>;
};


export type Subscription_RootExternalSystemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<ExternalSystemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExternalSystemsOrderBy>>;
  where?: InputMaybe<ExternalSystemsBoolExp>;
};


export type Subscription_RootExternalSystemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootExternalSystemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ExternalSystemsStreamCursorInput>>;
  where?: InputMaybe<ExternalSystemsBoolExp>;
};


export type Subscription_RootFeatureFlagsArgs = {
  distinctOn?: InputMaybe<Array<FeatureFlagsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FeatureFlagsOrderBy>>;
  where?: InputMaybe<FeatureFlagsBoolExp>;
};


export type Subscription_RootFeatureFlagsAggregateArgs = {
  distinctOn?: InputMaybe<Array<FeatureFlagsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FeatureFlagsOrderBy>>;
  where?: InputMaybe<FeatureFlagsBoolExp>;
};


export type Subscription_RootFeatureFlagsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootFeatureFlagsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FeatureFlagsStreamCursorInput>>;
  where?: InputMaybe<FeatureFlagsBoolExp>;
};


export type Subscription_RootFilesArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


export type Subscription_RootFilesAggregateArgs = {
  distinctOn?: InputMaybe<Array<FilesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
  where?: InputMaybe<FilesBoolExp>;
};


export type Subscription_RootFilesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootFilesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FilesStreamCursorInput>>;
  where?: InputMaybe<FilesBoolExp>;
};


export type Subscription_RootGetLatestPayrollVersionArgs = {
  args: GetLatestPayrollVersionArgs;
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Subscription_RootGetLatestPayrollVersionAggregateArgs = {
  args: GetLatestPayrollVersionArgs;
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Subscription_RootGetPayrollVersionHistoryArgs = {
  args: GetPayrollVersionHistoryArgs;
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Subscription_RootGetPayrollVersionHistoryAggregateArgs = {
  args: GetPayrollVersionHistoryArgs;
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Subscription_RootHolidaysArgs = {
  distinctOn?: InputMaybe<Array<HolidaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<HolidaysOrderBy>>;
  where?: InputMaybe<HolidaysBoolExp>;
};


export type Subscription_RootHolidaysAggregateArgs = {
  distinctOn?: InputMaybe<Array<HolidaysSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<HolidaysOrderBy>>;
  where?: InputMaybe<HolidaysBoolExp>;
};


export type Subscription_RootHolidaysByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootHolidaysStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<HolidaysStreamCursorInput>>;
  where?: InputMaybe<HolidaysBoolExp>;
};


export type Subscription_RootLatestPayrollVersionResultsArgs = {
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Subscription_RootLatestPayrollVersionResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<LatestPayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LatestPayrollVersionResultsOrderBy>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Subscription_RootLatestPayrollVersionResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootLatestPayrollVersionResultsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<LatestPayrollVersionResultsStreamCursorInput>>;
  where?: InputMaybe<LatestPayrollVersionResultsBoolExp>;
};


export type Subscription_RootLeaveArgs = {
  distinctOn?: InputMaybe<Array<LeaveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeaveOrderBy>>;
  where?: InputMaybe<LeaveBoolExp>;
};


export type Subscription_RootLeaveAggregateArgs = {
  distinctOn?: InputMaybe<Array<LeaveSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LeaveOrderBy>>;
  where?: InputMaybe<LeaveBoolExp>;
};


export type Subscription_RootLeaveByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootLeaveStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<LeaveStreamCursorInput>>;
  where?: InputMaybe<LeaveBoolExp>;
};


export type Subscription_RootMonthlyBillingCompletionArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


export type Subscription_RootMonthlyBillingCompletionAggregateArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingCompletionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingCompletionOrderBy>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


export type Subscription_RootMonthlyBillingCompletionByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootMonthlyBillingCompletionStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MonthlyBillingCompletionStreamCursorInput>>;
  where?: InputMaybe<MonthlyBillingCompletionBoolExp>;
};


export type Subscription_RootMonthlyBillingDashboardArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingDashboardSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingDashboardOrderBy>>;
  where?: InputMaybe<MonthlyBillingDashboardBoolExp>;
};


export type Subscription_RootMonthlyBillingDashboardAggregateArgs = {
  distinctOn?: InputMaybe<Array<MonthlyBillingDashboardSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MonthlyBillingDashboardOrderBy>>;
  where?: InputMaybe<MonthlyBillingDashboardBoolExp>;
};


export type Subscription_RootMonthlyBillingDashboardStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MonthlyBillingDashboardStreamCursorInput>>;
  where?: InputMaybe<MonthlyBillingDashboardBoolExp>;
};


export type Subscription_RootNotesArgs = {
  distinctOn?: InputMaybe<Array<NotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
  where?: InputMaybe<NotesBoolExp>;
};


export type Subscription_RootNotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<NotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
  where?: InputMaybe<NotesBoolExp>;
};


export type Subscription_RootNotesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootNotesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<NotesStreamCursorInput>>;
  where?: InputMaybe<NotesBoolExp>;
};


export type Subscription_RootPayrollActivationResultsArgs = {
  distinctOn?: InputMaybe<Array<PayrollActivationResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollActivationResultsOrderBy>>;
  where?: InputMaybe<PayrollActivationResultsBoolExp>;
};


export type Subscription_RootPayrollActivationResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollActivationResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollActivationResultsOrderBy>>;
  where?: InputMaybe<PayrollActivationResultsBoolExp>;
};


export type Subscription_RootPayrollActivationResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollActivationResultsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollActivationResultsStreamCursorInput>>;
  where?: InputMaybe<PayrollActivationResultsBoolExp>;
};


export type Subscription_RootPayrollAssignmentAuditArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


export type Subscription_RootPayrollAssignmentAuditAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentAuditSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentAuditOrderBy>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


export type Subscription_RootPayrollAssignmentAuditByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollAssignmentAuditStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollAssignmentAuditStreamCursorInput>>;
  where?: InputMaybe<PayrollAssignmentAuditBoolExp>;
};


export type Subscription_RootPayrollAssignmentsArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


export type Subscription_RootPayrollAssignmentsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollAssignmentsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollAssignmentsOrderBy>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


export type Subscription_RootPayrollAssignmentsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollAssignmentsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollAssignmentsStreamCursorInput>>;
  where?: InputMaybe<PayrollAssignmentsBoolExp>;
};


export type Subscription_RootPayrollCostAnalysisArgs = {
  distinctOn?: InputMaybe<Array<PayrollCostAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCostAnalysisOrderBy>>;
  where?: InputMaybe<PayrollCostAnalysisBoolExp>;
};


export type Subscription_RootPayrollCostAnalysisAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollCostAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCostAnalysisOrderBy>>;
  where?: InputMaybe<PayrollCostAnalysisBoolExp>;
};


export type Subscription_RootPayrollCostAnalysisStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollCostAnalysisStreamCursorInput>>;
  where?: InputMaybe<PayrollCostAnalysisBoolExp>;
};


export type Subscription_RootPayrollCyclesArgs = {
  distinctOn?: InputMaybe<Array<PayrollCyclesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCyclesOrderBy>>;
  where?: InputMaybe<PayrollCyclesBoolExp>;
};


export type Subscription_RootPayrollCyclesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollCyclesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollCyclesOrderBy>>;
  where?: InputMaybe<PayrollCyclesBoolExp>;
};


export type Subscription_RootPayrollCyclesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollCyclesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollCyclesStreamCursorInput>>;
  where?: InputMaybe<PayrollCyclesBoolExp>;
};


export type Subscription_RootPayrollDashboardStatsArgs = {
  distinctOn?: InputMaybe<Array<PayrollDashboardStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDashboardStatsOrderBy>>;
  where?: InputMaybe<PayrollDashboardStatsBoolExp>;
};


export type Subscription_RootPayrollDashboardStatsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDashboardStatsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDashboardStatsOrderBy>>;
  where?: InputMaybe<PayrollDashboardStatsBoolExp>;
};


export type Subscription_RootPayrollDashboardStatsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollDashboardStatsStreamCursorInput>>;
  where?: InputMaybe<PayrollDashboardStatsBoolExp>;
};


export type Subscription_RootPayrollDateCompletionAnalyticsArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateCompletionAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateCompletionAnalyticsOrderBy>>;
  where?: InputMaybe<PayrollDateCompletionAnalyticsBoolExp>;
};


export type Subscription_RootPayrollDateCompletionAnalyticsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateCompletionAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateCompletionAnalyticsOrderBy>>;
  where?: InputMaybe<PayrollDateCompletionAnalyticsBoolExp>;
};


export type Subscription_RootPayrollDateCompletionAnalyticsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollDateCompletionAnalyticsStreamCursorInput>>;
  where?: InputMaybe<PayrollDateCompletionAnalyticsBoolExp>;
};


export type Subscription_RootPayrollDateTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


export type Subscription_RootPayrollDateTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTimeEntriesOrderBy>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


export type Subscription_RootPayrollDateTimeEntriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollDateTimeEntriesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollDateTimeEntriesStreamCursorInput>>;
  where?: InputMaybe<PayrollDateTimeEntriesBoolExp>;
};


export type Subscription_RootPayrollDateTypesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTypesOrderBy>>;
  where?: InputMaybe<PayrollDateTypesBoolExp>;
};


export type Subscription_RootPayrollDateTypesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDateTypesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDateTypesOrderBy>>;
  where?: InputMaybe<PayrollDateTypesBoolExp>;
};


export type Subscription_RootPayrollDateTypesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollDateTypesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollDateTypesStreamCursorInput>>;
  where?: InputMaybe<PayrollDateTypesBoolExp>;
};


export type Subscription_RootPayrollDatesArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


export type Subscription_RootPayrollDatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollDatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollDatesOrderBy>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


export type Subscription_RootPayrollDatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollDatesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollDatesStreamCursorInput>>;
  where?: InputMaybe<PayrollDatesBoolExp>;
};


export type Subscription_RootPayrollProfitabilityArgs = {
  distinctOn?: InputMaybe<Array<PayrollProfitabilitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollProfitabilityOrderBy>>;
  where?: InputMaybe<PayrollProfitabilityBoolExp>;
};


export type Subscription_RootPayrollProfitabilityAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollProfitabilitySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollProfitabilityOrderBy>>;
  where?: InputMaybe<PayrollProfitabilityBoolExp>;
};


export type Subscription_RootPayrollProfitabilityStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollProfitabilityStreamCursorInput>>;
  where?: InputMaybe<PayrollProfitabilityBoolExp>;
};


export type Subscription_RootPayrollRequiredSkillsArgs = {
  distinctOn?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollRequiredSkillsOrderBy>>;
  where?: InputMaybe<PayrollRequiredSkillsBoolExp>;
};


export type Subscription_RootPayrollRequiredSkillsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollRequiredSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollRequiredSkillsOrderBy>>;
  where?: InputMaybe<PayrollRequiredSkillsBoolExp>;
};


export type Subscription_RootPayrollRequiredSkillsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollRequiredSkillsStreamCursorInput>>;
  where?: InputMaybe<PayrollRequiredSkillsBoolExp>;
};


export type Subscription_RootPayrollServiceAgreementsArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


export type Subscription_RootPayrollServiceAgreementsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollServiceAgreementsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollServiceAgreementsOrderBy>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


export type Subscription_RootPayrollServiceAgreementsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollServiceAgreementsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollServiceAgreementsStreamCursorInput>>;
  where?: InputMaybe<PayrollServiceAgreementsBoolExp>;
};


export type Subscription_RootPayrollTriggersStatusArgs = {
  distinctOn?: InputMaybe<Array<PayrollTriggersStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollTriggersStatusOrderBy>>;
  where?: InputMaybe<PayrollTriggersStatusBoolExp>;
};


export type Subscription_RootPayrollTriggersStatusAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollTriggersStatusSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollTriggersStatusOrderBy>>;
  where?: InputMaybe<PayrollTriggersStatusBoolExp>;
};


export type Subscription_RootPayrollTriggersStatusStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollTriggersStatusStreamCursorInput>>;
  where?: InputMaybe<PayrollTriggersStatusBoolExp>;
};


export type Subscription_RootPayrollVersionHistoryResultsArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Subscription_RootPayrollVersionHistoryResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionHistoryResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionHistoryResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Subscription_RootPayrollVersionHistoryResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollVersionHistoryResultsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollVersionHistoryResultsStreamCursorInput>>;
  where?: InputMaybe<PayrollVersionHistoryResultsBoolExp>;
};


export type Subscription_RootPayrollVersionResultsArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};


export type Subscription_RootPayrollVersionResultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollVersionResultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollVersionResultsOrderBy>>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};


export type Subscription_RootPayrollVersionResultsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollVersionResultsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollVersionResultsStreamCursorInput>>;
  where?: InputMaybe<PayrollVersionResultsBoolExp>;
};


export type Subscription_RootPayrollWorkloadDistributionArgs = {
  distinctOn?: InputMaybe<Array<PayrollWorkloadDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollWorkloadDistributionOrderBy>>;
  where?: InputMaybe<PayrollWorkloadDistributionBoolExp>;
};


export type Subscription_RootPayrollWorkloadDistributionAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollWorkloadDistributionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollWorkloadDistributionOrderBy>>;
  where?: InputMaybe<PayrollWorkloadDistributionBoolExp>;
};


export type Subscription_RootPayrollWorkloadDistributionStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollWorkloadDistributionStreamCursorInput>>;
  where?: InputMaybe<PayrollWorkloadDistributionBoolExp>;
};


export type Subscription_RootPayrollsArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


export type Subscription_RootPayrollsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PayrollsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PayrollsOrderBy>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


export type Subscription_RootPayrollsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPayrollsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PayrollsStreamCursorInput>>;
  where?: InputMaybe<PayrollsBoolExp>;
};


export type Subscription_RootPendingBillingApprovalsArgs = {
  distinctOn?: InputMaybe<Array<PendingBillingApprovalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PendingBillingApprovalsOrderBy>>;
  where?: InputMaybe<PendingBillingApprovalsBoolExp>;
};


export type Subscription_RootPendingBillingApprovalsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PendingBillingApprovalsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PendingBillingApprovalsOrderBy>>;
  where?: InputMaybe<PendingBillingApprovalsBoolExp>;
};


export type Subscription_RootPendingBillingApprovalsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PendingBillingApprovalsStreamCursorInput>>;
  where?: InputMaybe<PendingBillingApprovalsBoolExp>;
};


export type Subscription_RootPermissionAuditLogArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


export type Subscription_RootPermissionAuditLogAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionAuditLogSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionAuditLogOrderBy>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


export type Subscription_RootPermissionAuditLogByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPermissionAuditLogStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PermissionAuditLogStreamCursorInput>>;
  where?: InputMaybe<PermissionAuditLogBoolExp>;
};


export type Subscription_RootPermissionOverridesArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


export type Subscription_RootPermissionOverridesAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionOverridesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionOverridesOrderBy>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


export type Subscription_RootPermissionOverridesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPermissionOverridesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PermissionOverridesStreamCursorInput>>;
  where?: InputMaybe<PermissionOverridesBoolExp>;
};


export type Subscription_RootPermissionsArgs = {
  distinctOn?: InputMaybe<Array<PermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  where?: InputMaybe<PermissionsBoolExp>;
};


export type Subscription_RootPermissionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  where?: InputMaybe<PermissionsBoolExp>;
};


export type Subscription_RootPermissionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPermissionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PermissionsStreamCursorInput>>;
  where?: InputMaybe<PermissionsBoolExp>;
};


export type Subscription_RootPositionAdminDefaultsArgs = {
  distinctOn?: InputMaybe<Array<PositionAdminDefaultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PositionAdminDefaultsOrderBy>>;
  where?: InputMaybe<PositionAdminDefaultsBoolExp>;
};


export type Subscription_RootPositionAdminDefaultsAggregateArgs = {
  distinctOn?: InputMaybe<Array<PositionAdminDefaultsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PositionAdminDefaultsOrderBy>>;
  where?: InputMaybe<PositionAdminDefaultsBoolExp>;
};


export type Subscription_RootPositionAdminDefaultsByPkArgs = {
  position: Scalars['user_position']['input'];
};


export type Subscription_RootPositionAdminDefaultsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PositionAdminDefaultsStreamCursorInput>>;
  where?: InputMaybe<PositionAdminDefaultsBoolExp>;
};


export type Subscription_RootQuoteAnalyticsArgs = {
  distinctOn?: InputMaybe<Array<QuoteAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAnalyticsOrderBy>>;
  where?: InputMaybe<QuoteAnalyticsBoolExp>;
};


export type Subscription_RootQuoteAnalyticsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteAnalyticsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAnalyticsOrderBy>>;
  where?: InputMaybe<QuoteAnalyticsBoolExp>;
};


export type Subscription_RootQuoteAnalyticsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<QuoteAnalyticsStreamCursorInput>>;
  where?: InputMaybe<QuoteAnalyticsBoolExp>;
};


export type Subscription_RootQuoteConversionsArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


export type Subscription_RootQuoteConversionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteConversionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteConversionsOrderBy>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


export type Subscription_RootQuoteConversionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootQuoteConversionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<QuoteConversionsStreamCursorInput>>;
  where?: InputMaybe<QuoteConversionsBoolExp>;
};


export type Subscription_RootQuoteLineItemsArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


export type Subscription_RootQuoteLineItemsAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteLineItemsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLineItemsOrderBy>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


export type Subscription_RootQuoteLineItemsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootQuoteLineItemsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<QuoteLineItemsStreamCursorInput>>;
  where?: InputMaybe<QuoteLineItemsBoolExp>;
};


export type Subscription_RootQuoteTemplatesArgs = {
  distinctOn?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteTemplatesOrderBy>>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};


export type Subscription_RootQuoteTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuoteTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteTemplatesOrderBy>>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};


export type Subscription_RootQuoteTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootQuoteTemplatesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<QuoteTemplatesStreamCursorInput>>;
  where?: InputMaybe<QuoteTemplatesBoolExp>;
};


export type Subscription_RootQuotesArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


export type Subscription_RootQuotesAggregateArgs = {
  distinctOn?: InputMaybe<Array<QuotesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  where?: InputMaybe<QuotesBoolExp>;
};


export type Subscription_RootQuotesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootQuotesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<QuotesStreamCursorInput>>;
  where?: InputMaybe<QuotesBoolExp>;
};


export type Subscription_RootRateLimitsArgs = {
  distinctOn?: InputMaybe<Array<RateLimitsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RateLimitsOrderBy>>;
  where?: InputMaybe<RateLimitsBoolExp>;
};


export type Subscription_RootRateLimitsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RateLimitsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RateLimitsOrderBy>>;
  where?: InputMaybe<RateLimitsBoolExp>;
};


export type Subscription_RootRateLimitsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootRateLimitsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<RateLimitsStreamCursorInput>>;
  where?: InputMaybe<RateLimitsBoolExp>;
};


export type Subscription_RootResourcesArgs = {
  distinctOn?: InputMaybe<Array<ResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ResourcesOrderBy>>;
  where?: InputMaybe<ResourcesBoolExp>;
};


export type Subscription_RootResourcesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ResourcesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ResourcesOrderBy>>;
  where?: InputMaybe<ResourcesBoolExp>;
};


export type Subscription_RootResourcesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootResourcesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ResourcesStreamCursorInput>>;
  where?: InputMaybe<ResourcesBoolExp>;
};


export type Subscription_RootRolePermissionsArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


export type Subscription_RootRolePermissionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<RolePermissionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolePermissionsOrderBy>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


export type Subscription_RootRolePermissionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootRolePermissionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<RolePermissionsStreamCursorInput>>;
  where?: InputMaybe<RolePermissionsBoolExp>;
};


export type Subscription_RootRolesArgs = {
  distinctOn?: InputMaybe<Array<RolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  where?: InputMaybe<RolesBoolExp>;
};


export type Subscription_RootRolesAggregateArgs = {
  distinctOn?: InputMaybe<Array<RolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  where?: InputMaybe<RolesBoolExp>;
};


export type Subscription_RootRolesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootRolesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<RolesStreamCursorInput>>;
  where?: InputMaybe<RolesBoolExp>;
};


export type Subscription_RootSecurityAlertsArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


export type Subscription_RootSecurityAlertsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecurityAlertsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecurityAlertsOrderBy>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


export type Subscription_RootSecurityAlertsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootSecurityAlertsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SecurityAlertsStreamCursorInput>>;
  where?: InputMaybe<SecurityAlertsBoolExp>;
};


export type Subscription_RootSecuritySettingsArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


export type Subscription_RootSecuritySettingsAggregateArgs = {
  distinctOn?: InputMaybe<Array<SecuritySettingsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SecuritySettingsOrderBy>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


export type Subscription_RootSecuritySettingsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootSecuritySettingsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SecuritySettingsStreamCursorInput>>;
  where?: InputMaybe<SecuritySettingsBoolExp>;
};


export type Subscription_RootServicePricingRulesArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


export type Subscription_RootServicePricingRulesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicePricingRulesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicePricingRulesOrderBy>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


export type Subscription_RootServicePricingRulesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootServicePricingRulesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ServicePricingRulesStreamCursorInput>>;
  where?: InputMaybe<ServicePricingRulesBoolExp>;
};


export type Subscription_RootServiceTemplatesArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


export type Subscription_RootServiceTemplatesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServiceTemplatesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServiceTemplatesOrderBy>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


export type Subscription_RootServiceTemplatesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootServiceTemplatesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ServiceTemplatesStreamCursorInput>>;
  where?: InputMaybe<ServiceTemplatesBoolExp>;
};


export type Subscription_RootServicesArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


export type Subscription_RootServicesAggregateArgs = {
  distinctOn?: InputMaybe<Array<ServicesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ServicesOrderBy>>;
  where?: InputMaybe<ServicesBoolExp>;
};


export type Subscription_RootServicesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootServicesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ServicesStreamCursorInput>>;
  where?: InputMaybe<ServicesBoolExp>;
};


export type Subscription_RootStaffBillingPerformanceArgs = {
  distinctOn?: InputMaybe<Array<StaffBillingPerformanceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StaffBillingPerformanceOrderBy>>;
  where?: InputMaybe<StaffBillingPerformanceBoolExp>;
};


export type Subscription_RootStaffBillingPerformanceAggregateArgs = {
  distinctOn?: InputMaybe<Array<StaffBillingPerformanceSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<StaffBillingPerformanceOrderBy>>;
  where?: InputMaybe<StaffBillingPerformanceBoolExp>;
};


export type Subscription_RootStaffBillingPerformanceStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<StaffBillingPerformanceStreamCursorInput>>;
  where?: InputMaybe<StaffBillingPerformanceBoolExp>;
};


export type Subscription_RootSystemConfigurationArgs = {
  distinctOn?: InputMaybe<Array<SystemConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemConfigurationOrderBy>>;
  where?: InputMaybe<SystemConfigurationBoolExp>;
};


export type Subscription_RootSystemConfigurationAggregateArgs = {
  distinctOn?: InputMaybe<Array<SystemConfigurationSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemConfigurationOrderBy>>;
  where?: InputMaybe<SystemConfigurationBoolExp>;
};


export type Subscription_RootSystemConfigurationByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootSystemConfigurationStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SystemConfigurationStreamCursorInput>>;
  where?: InputMaybe<SystemConfigurationBoolExp>;
};


export type Subscription_RootSystemHealthArgs = {
  distinctOn?: InputMaybe<Array<SystemHealthSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemHealthOrderBy>>;
  where?: InputMaybe<SystemHealthBoolExp>;
};


export type Subscription_RootSystemHealthAggregateArgs = {
  distinctOn?: InputMaybe<Array<SystemHealthSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemHealthOrderBy>>;
  where?: InputMaybe<SystemHealthBoolExp>;
};


export type Subscription_RootSystemHealthByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootSystemHealthStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SystemHealthStreamCursorInput>>;
  where?: InputMaybe<SystemHealthBoolExp>;
};


export type Subscription_RootTeamCapacityByPositionArgs = {
  distinctOn?: InputMaybe<Array<TeamCapacityByPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamCapacityByPositionOrderBy>>;
  where?: InputMaybe<TeamCapacityByPositionBoolExp>;
};


export type Subscription_RootTeamCapacityByPositionAggregateArgs = {
  distinctOn?: InputMaybe<Array<TeamCapacityByPositionSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TeamCapacityByPositionOrderBy>>;
  where?: InputMaybe<TeamCapacityByPositionBoolExp>;
};


export type Subscription_RootTeamCapacityByPositionStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TeamCapacityByPositionStreamCursorInput>>;
  where?: InputMaybe<TeamCapacityByPositionBoolExp>;
};


export type Subscription_RootTimeEntriesArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


export type Subscription_RootTimeEntriesAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeEntriesOrderBy>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


export type Subscription_RootTimeEntriesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootTimeEntriesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TimeEntriesStreamCursorInput>>;
  where?: InputMaybe<TimeEntriesBoolExp>;
};


export type Subscription_RootTimeTrackingSummaryArgs = {
  distinctOn?: InputMaybe<Array<TimeTrackingSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeTrackingSummaryOrderBy>>;
  where?: InputMaybe<TimeTrackingSummaryBoolExp>;
};


export type Subscription_RootTimeTrackingSummaryAggregateArgs = {
  distinctOn?: InputMaybe<Array<TimeTrackingSummarySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimeTrackingSummaryOrderBy>>;
  where?: InputMaybe<TimeTrackingSummaryBoolExp>;
};


export type Subscription_RootTimeTrackingSummaryStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TimeTrackingSummaryStreamCursorInput>>;
  where?: InputMaybe<TimeTrackingSummaryBoolExp>;
};


export type Subscription_RootUserEmailTemplateFavoritesArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


export type Subscription_RootUserEmailTemplateFavoritesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserEmailTemplateFavoritesOrderBy>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


export type Subscription_RootUserEmailTemplateFavoritesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUserEmailTemplateFavoritesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserEmailTemplateFavoritesStreamCursorInput>>;
  where?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
};


export type Subscription_RootUserInvitationsArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


export type Subscription_RootUserInvitationsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserInvitationsOrderBy>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


export type Subscription_RootUserInvitationsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUserInvitationsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserInvitationsStreamCursorInput>>;
  where?: InputMaybe<UserInvitationsBoolExp>;
};


export type Subscription_RootUserProductivityAnalysisArgs = {
  distinctOn?: InputMaybe<Array<UserProductivityAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserProductivityAnalysisOrderBy>>;
  where?: InputMaybe<UserProductivityAnalysisBoolExp>;
};


export type Subscription_RootUserProductivityAnalysisAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserProductivityAnalysisSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserProductivityAnalysisOrderBy>>;
  where?: InputMaybe<UserProductivityAnalysisBoolExp>;
};


export type Subscription_RootUserProductivityAnalysisStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserProductivityAnalysisStreamCursorInput>>;
  where?: InputMaybe<UserProductivityAnalysisBoolExp>;
};


export type Subscription_RootUserRateHistoryArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


export type Subscription_RootUserRateHistoryAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRateHistoryOrderBy>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


export type Subscription_RootUserRateHistoryByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUserRateHistoryStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserRateHistoryStreamCursorInput>>;
  where?: InputMaybe<UserRateHistoryBoolExp>;
};


export type Subscription_RootUserRolesArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


export type Subscription_RootUserRolesAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserRolesSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserRolesOrderBy>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


export type Subscription_RootUserRolesByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUserRolesStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserRolesStreamCursorInput>>;
  where?: InputMaybe<UserRolesBoolExp>;
};


export type Subscription_RootUserSessionsArgs = {
  distinctOn?: InputMaybe<Array<UserSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSessionsOrderBy>>;
  where?: InputMaybe<UserSessionsBoolExp>;
};


export type Subscription_RootUserSessionsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserSessionsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSessionsOrderBy>>;
  where?: InputMaybe<UserSessionsBoolExp>;
};


export type Subscription_RootUserSessionsByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUserSessionsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserSessionsStreamCursorInput>>;
  where?: InputMaybe<UserSessionsBoolExp>;
};


export type Subscription_RootUserSkillsArgs = {
  distinctOn?: InputMaybe<Array<UserSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSkillsOrderBy>>;
  where?: InputMaybe<UserSkillsBoolExp>;
};


export type Subscription_RootUserSkillsAggregateArgs = {
  distinctOn?: InputMaybe<Array<UserSkillsSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserSkillsOrderBy>>;
  where?: InputMaybe<UserSkillsBoolExp>;
};


export type Subscription_RootUserSkillsStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserSkillsStreamCursorInput>>;
  where?: InputMaybe<UserSkillsBoolExp>;
};


export type Subscription_RootUsersArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootUsersAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootUsersByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUsersRoleBackupArgs = {
  distinctOn?: InputMaybe<Array<UsersRoleBackupSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersRoleBackupOrderBy>>;
  where?: InputMaybe<UsersRoleBackupBoolExp>;
};


export type Subscription_RootUsersRoleBackupAggregateArgs = {
  distinctOn?: InputMaybe<Array<UsersRoleBackupSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersRoleBackupOrderBy>>;
  where?: InputMaybe<UsersRoleBackupBoolExp>;
};


export type Subscription_RootUsersRoleBackupStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UsersRoleBackupStreamCursorInput>>;
  where?: InputMaybe<UsersRoleBackupBoolExp>;
};


export type Subscription_RootUsersStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UsersStreamCursorInput>>;
  where?: InputMaybe<UsersBoolExp>;
};


export type Subscription_RootWorkScheduleArgs = {
  distinctOn?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkScheduleOrderBy>>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};


export type Subscription_RootWorkScheduleAggregateArgs = {
  distinctOn?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WorkScheduleOrderBy>>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};


export type Subscription_RootWorkScheduleByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootWorkScheduleStreamArgs = {
  batchSize: Scalars['Int']['input'];
  cursor: Array<InputMaybe<WorkScheduleStreamCursorInput>>;
  where?: InputMaybe<WorkScheduleBoolExp>;
};

export type TimeEntriesAggregateBoolExpBool_And = {
  arguments: TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TimeEntriesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type TimeEntriesAggregateBoolExpBool_Or = {
  arguments: TimeEntriesSelectColumnTimeEntriesAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TimeEntriesBoolExp>;
  predicate: BooleanComparisonExp;
};

export type TimeEntriesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<TimeEntriesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TimeEntriesBoolExp>;
  predicate: IntComparisonExp;
};

export type UserEmailTemplateFavoritesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserEmailTemplateFavoritesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserEmailTemplateFavoritesBoolExp>;
  predicate: IntComparisonExp;
};

export type UserInvitationsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserInvitationsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserInvitationsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserRateHistoryAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserRateHistorySelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserRateHistoryBoolExp>;
  predicate: IntComparisonExp;
};

export type UserRolesAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserRolesSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserRolesBoolExp>;
  predicate: IntComparisonExp;
};

export type UserSessionsAggregateBoolExpBool_And = {
  arguments: UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserSessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type UserSessionsAggregateBoolExpBool_Or = {
  arguments: UserSessionsSelectColumnUserSessionsAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserSessionsBoolExp>;
  predicate: BooleanComparisonExp;
};

export type UserSessionsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserSessionsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserSessionsBoolExp>;
  predicate: IntComparisonExp;
};

export type UserSkillsAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UserSkillsSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UserSkillsBoolExp>;
  predicate: IntComparisonExp;
};

export type UsersAggregateBoolExpBool_And = {
  arguments: UsersSelectColumnUsersAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type UsersAggregateBoolExpBool_Or = {
  arguments: UsersSelectColumnUsersAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UsersBoolExp>;
  predicate: BooleanComparisonExp;
};

export type UsersAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<UsersSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<UsersBoolExp>;
  predicate: IntComparisonExp;
};

export type WorkScheduleAggregateBoolExpBool_And = {
  arguments: WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_AndArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<WorkScheduleBoolExp>;
  predicate: BooleanComparisonExp;
};

export type WorkScheduleAggregateBoolExpBool_Or = {
  arguments: WorkScheduleSelectColumnWorkScheduleAggregateBoolExpBool_OrArgumentsColumns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<WorkScheduleBoolExp>;
  predicate: BooleanComparisonExp;
};

export type WorkScheduleAggregateBoolExpCount = {
  arguments?: InputMaybe<Array<WorkScheduleSelectColumn>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<WorkScheduleBoolExp>;
  predicate: IntComparisonExp;
};

export type UserMinimalFragment = { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string };

export type UserCoreSharedFragment = { __typename?: 'Users', role: any, isActive?: boolean | null, id: string, firstName: string, lastName: string, computedName?: string | null, email: string };

export type UserBasicFragment = { __typename?: 'Users', clerkUserId?: string | null, createdAt?: string | null, updatedAt?: string | null, role: any, isActive?: boolean | null, id: string, firstName: string, lastName: string, computedName?: string | null, email: string };

export type UserBaseFragment = { __typename?: 'Users', clerkUserId?: string | null, createdAt?: string | null, updatedAt?: string | null, role: any, isActive?: boolean | null, id: string, firstName: string, lastName: string, computedName?: string | null, email: string };

export type UserWithRoleFragment = { __typename?: 'Users', username?: string | null, isStaff?: boolean | null, clerkUserId?: string | null, createdAt?: string | null, updatedAt?: string | null, role: any, isActive?: boolean | null, id: string, firstName: string, lastName: string, computedName?: string | null, email: string };

export type UserProfileFragment = { __typename?: 'Users', clerkUserId?: string | null, image?: string | null, managerId?: string | null, deactivatedAt?: string | null, deactivatedBy?: string | null, username?: string | null, isStaff?: boolean | null, createdAt?: string | null, updatedAt?: string | null, role: any, isActive?: boolean | null, id: string, firstName: string, lastName: string, computedName?: string | null, email: string, manager?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null };

export type UserSearchResultFragment = { __typename?: 'Users', username?: string | null, isStaff?: boolean | null, role: any, isActive?: boolean | null, id: string, firstName: string, lastName: string, computedName?: string | null, email: string };

export type ClientMinimalFragment = { __typename?: 'Clients', id: string, name: string };

export type ClientBaseFragment = { __typename?: 'Clients', id: string, name: string, active?: boolean | null, contactEmail?: string | null, contactPerson?: string | null, contactPhone?: string | null, createdAt?: string | null };

export type ClientWithStatsFragment = { __typename?: 'Clients', id: string, name: string, active?: boolean | null, contactEmail?: string | null, contactPerson?: string | null, contactPhone?: string | null, createdAt?: string | null, currentEmployeeCount: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', sum?: { __typename?: 'PayrollsSumFields', employeeCount?: number | null } | null } | null }, activePayrollCount: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', count: number } | null } };

export type ClientListBaseFragment = { __typename?: 'Clients', id: string, name: string, active?: boolean | null, contactEmail?: string | null, contactPerson?: string | null, contactPhone?: string | null, createdAt?: string | null, payrollCount: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', count: number } | null } };

export type PayrollMinimalFragment = { __typename?: 'Payrolls', id: string, name: string, employeeCount?: number | null, status: any };

export type PayrollBaseFragment = { __typename?: 'Payrolls', id: string, name: string, employeeCount?: number | null, status: any, payrollSystem?: string | null, processingTime: number, processingDaysBeforeEft: number, versionNumber?: number | null, supersededDate?: string | null, createdAt?: string | null, updatedAt?: string | null };

export type PayrollWithClientFragment = { __typename?: 'Payrolls', clientId: string, id: string, name: string, employeeCount?: number | null, status: any, payrollSystem?: string | null, processingTime: number, processingDaysBeforeEft: number, versionNumber?: number | null, supersededDate?: string | null, createdAt?: string | null, updatedAt?: string | null, client: { __typename?: 'Clients', id: string, name: string, active?: boolean | null } };

export type PayrollListItemFragment = { __typename?: 'Payrolls', primaryConsultantUserId?: string | null, backupConsultantUserId?: string | null, managerUserId?: string | null, createdByUserId?: string | null, cycleId: string, dateTypeId: string, dateValue?: number | null, clientId: string, id: string, name: string, employeeCount?: number | null, status: any, payrollSystem?: string | null, processingTime: number, processingDaysBeforeEft: number, versionNumber?: number | null, supersededDate?: string | null, createdAt?: string | null, updatedAt?: string | null, payrollCycle: { __typename?: 'PayrollCycles', id: string, name: any, description?: string | null }, payrollDateType: { __typename?: 'PayrollDateTypes', id: string, name: any, description?: string | null }, primaryConsultant?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null, backupConsultant?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null, assignedManager?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null, client: { __typename?: 'Clients', id: string, name: string, active?: boolean | null } };

export type PayrollWithDatesFragment = { __typename?: 'Payrolls', goLiveDate?: string | null, id: string, name: string, employeeCount?: number | null, status: any, payrollSystem?: string | null, processingTime: number, processingDaysBeforeEft: number, versionNumber?: number | null, supersededDate?: string | null, createdAt?: string | null, updatedAt?: string | null, payrollDates: Array<{ __typename?: 'PayrollDates', id: string, originalEftDate: string, adjustedEftDate: string, notes?: string | null }> };

export type PayrollFullDetailFragment = { __typename?: 'Payrolls', dateTypeId: string, cycleId: string, dateValue?: number | null, versionReason?: string | null, supersededDate?: string | null, parentPayrollId?: string | null, goLiveDate?: string | null, clientId: string, id: string, name: string, employeeCount?: number | null, status: any, payrollSystem?: string | null, processingTime: number, processingDaysBeforeEft: number, versionNumber?: number | null, createdAt?: string | null, updatedAt?: string | null, parentPayroll?: { __typename?: 'Payrolls', id: string, versionNumber?: number | null } | null, childPayrolls: Array<{ __typename?: 'Payrolls', id: string, versionNumber?: number | null, versionReason?: string | null, createdAt?: string | null }>, primaryConsultant?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null, backupConsultant?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null, assignedManager?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null, payrollDates: Array<{ __typename?: 'PayrollDates', id: string, originalEftDate: string, adjustedEftDate: string, notes?: string | null }>, client: { __typename?: 'Clients', id: string, name: string, active?: boolean | null } };

export type NoteWithAuthorFragment = { __typename?: 'Notes', id: string, content: string, isImportant?: boolean | null, createdAt?: any | null, entityId: string, entityType: string, author?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null };

export type PermissionBaseFragment = { __typename?: 'Permissions', id: string, resourceId: string, description?: string | null, legacyPermissionName?: string | null, action: any };

export type RoleWithPermissionsFragment = { __typename?: 'Roles', id: string, name: string, displayName: string, description?: string | null, isSystemRole: boolean, priority: number, rolePermissions: Array<{ __typename?: 'RolePermissions', permission: { __typename?: 'Permissions', id: string, resourceId: string, description?: string | null, legacyPermissionName?: string | null, action: any } }> };

export type AuditLogEntryFragment = { __typename?: 'AuditAuditLog', id: string, userId?: string | null, userEmail?: string | null, userRole?: string | null, action: string, resourceType: string, resourceId?: string | null, eventTime: string, success?: boolean | null, errorMessage?: string | null, ipAddress?: any | null, userAgent?: string | null, requestId?: string | null, sessionId?: string | null, metadata?: any | null, oldValues?: any | null, newValues?: any | null, createdAt?: string | null };

export type AuthEventFragment = { __typename?: 'AuditAuthEvents', id: string, userId?: string | null, userEmail?: string | null, eventType: string, eventTime: string, success?: boolean | null, failureReason?: string | null, ipAddress?: any | null, userAgent?: string | null, metadata?: any | null };

export type DataAccessLogFragment = { __typename?: 'AuditDataAccessLog', id: string, userId: string, resourceType: string, resourceId?: string | null, accessType: string, accessedAt: string, dataClassification?: string | null, fieldsAccessed?: Array<string> | null, rowCount?: number | null, ipAddress?: any | null, metadata?: any | null };

export type PermissionChangeFragment = { __typename?: 'AuditPermissionChanges', id: string, changedAt: string, changedByUserId: string, targetUserId?: string | null, targetRoleId?: string | null, changeType: string, permissionType?: string | null, oldPermissions?: any | null, newPermissions?: any | null, reason?: string | null, approvedByUserId?: string | null };

export type PayrollDateInfoFragment = { __typename?: 'PayrollDates', id: string, originalEftDate: string, adjustedEftDate: string, notes?: string | null, createdAt?: string | null };

export type PermissionOverrideInfoFragment = { __typename?: 'PermissionOverrides', id: string, userId?: string | null, role?: string | null, resource: string, operation: string, granted: boolean, reason?: string | null, conditions?: any | null, expiresAt?: string | null, createdBy?: string | null, createdAt: string };

export type LogAuditEventMutationVariables = Exact<{
  input: AuditAuditLogInsertInput;
}>;


export type LogAuditEventMutation = { __typename?: 'mutation_root', insertAuditAuditLog?: { __typename?: 'AuditAuditLogMutationResponse', returning: Array<{ __typename?: 'AuditAuditLog', id: string, eventTime: string }> } | null };

export type InsertFileMutationVariables = Exact<{
  input: FilesInsertInput;
}>;


export type InsertFileMutation = { __typename?: 'mutation_root', insertFiles?: { __typename?: 'FilesMutationResponse', returning: Array<{ __typename?: 'Files', id: string, filename: string, bucket: string, objectKey: string, size?: number | null, mimetype?: string | null, url?: string | null, clientId?: string | null, payrollId?: string | null, uploadedBy?: string | null, category?: string | null, isPublic?: boolean | null, metadata?: any | null, fileType?: string | null, createdAt?: string | null }> } | null };

export type UpdateFileMetadataMutationVariables = Exact<{
  id: Scalars['uuid']['input'];
  updates: FilesSetInput;
}>;


export type UpdateFileMetadataMutation = { __typename?: 'mutation_root', updateFilesByPk?: { __typename?: 'Files', id: string, filename: string, bucket: string, objectKey: string, size?: number | null, mimetype?: string | null, url?: string | null, clientId?: string | null, payrollId?: string | null, uploadedBy?: string | null, category?: string | null, isPublic?: boolean | null, metadata?: any | null, fileType?: string | null, createdAt?: string | null } | null };

export type DeleteFileMutationVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type DeleteFileMutation = { __typename?: 'mutation_root', deleteFilesByPk?: { __typename?: 'Files', id: string, filename: string, objectKey: string } | null };

export type RefreshDataMutationVariables = Exact<{ [key: string]: never; }>;


export type RefreshDataMutation = { __typename: 'mutation_root' };

export type GetDashboardMetricsQueryVariables = Exact<{
  userId: Scalars['uuid']['input'];
}>;


export type GetDashboardMetricsQuery = { __typename?: 'query_root', clientsAggregate: { __typename?: 'ClientsAggregate', aggregate?: { __typename?: 'ClientsAggregateFields', count: number } | null }, activePayrollsAggregate: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', count: number } | null }, totalEmployeesAggregate: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', sum?: { __typename?: 'PayrollsSumFields', employeeCount?: number | null } | null } | null }, upcomingPayrolls: Array<{ __typename?: 'Payrolls', id: string, name: string, employeeCount?: number | null, status: any, client: { __typename?: 'Clients', id: string, name: string } }> };

export type GetDashboardStatsOptimizedQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type GetDashboardStatsOptimizedQuery = { __typename?: 'query_root', clientsAggregate: { __typename?: 'ClientsAggregate', aggregate?: { __typename?: 'ClientsAggregateFields', count: number } | null }, totalPayrolls: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', count: number } | null }, activePayrolls: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', count: number } | null }, upcomingPayrolls: Array<{ __typename?: 'Payrolls', id: string, name: string, status: any, client: { __typename?: 'Clients', id: string, name: string }, nextEftDate: Array<{ __typename?: 'PayrollDates', originalEftDate: string, adjustedEftDate: string, processingDate: string }> }> };

export type GetClientsDashboardStatsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetClientsDashboardStatsQuery = { __typename?: 'query_root', activeClientsCount: { __typename?: 'ClientsAggregate', aggregate?: { __typename?: 'ClientsAggregateFields', count: number } | null }, totalPayrollsCount: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', count: number } | null }, totalEmployeesSum: { __typename?: 'PayrollsAggregate', aggregate?: { __typename?: 'PayrollsAggregateFields', sum?: { __typename?: 'PayrollsSumFields', employeeCount?: number | null } | null } | null }, clientsNeedingAttention: Array<{ __typename?: 'Clients', id: string, name: string }> };

export type GetCurrentUserQueryVariables = Exact<{
  userId: Scalars['uuid']['input'];
}>;


export type GetCurrentUserQuery = { __typename?: 'query_root', user?: { __typename?: 'Users', clerkUserId?: string | null, image?: string | null, managerId?: string | null, deactivatedAt?: string | null, deactivatedBy?: string | null, username?: string | null, isStaff?: boolean | null, createdAt?: string | null, updatedAt?: string | null, role: any, isActive?: boolean | null, id: string, firstName: string, lastName: string, computedName?: string | null, email: string, manager?: { __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string } | null } | null };

export type GetUsersForDropdownQueryVariables = Exact<{
  role?: InputMaybe<Scalars['user_role']['input']>;
}>;


export type GetUsersForDropdownQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string }> };

export type GetSystemHealthQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSystemHealthQuery = { __typename?: 'query_root', databaseHealth: Array<{ __typename?: 'Users', id: string }>, recentActivity: { __typename?: 'AuditAuditLogAggregate', aggregate?: { __typename?: 'AuditAuditLogAggregateFields', count: number } | null } };

export type GlobalSearchQueryVariables = Exact<{
  searchTerm: Scalars['String']['input'];
}>;


export type GlobalSearchQuery = { __typename?: 'query_root', clients: Array<{ __typename?: 'Clients', id: string, name: string }>, users: Array<{ __typename?: 'Users', id: string, firstName: string, lastName: string, computedName?: string | null, email: string }>, payrolls: Array<{ __typename?: 'Payrolls', id: string, name: string, employeeCount?: number | null, status: any, client: { __typename?: 'Clients', id: string, name: string } }> };

export type GetFileByIdQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetFileByIdQuery = { __typename?: 'query_root', filesByPk?: { __typename?: 'Files', id: string, filename: string, bucket: string, objectKey: string, size?: number | null, mimetype?: string | null, url?: string | null, clientId?: string | null, payrollId?: string | null, uploadedBy?: string | null, category?: string | null, isPublic?: boolean | null, metadata?: any | null, fileType?: string | null, createdAt?: string | null, client?: { __typename?: 'Clients', name: string } | null, payroll?: { __typename?: 'Payrolls', name: string } | null } | null };

export type ListFilesQueryVariables = Exact<{
  where?: InputMaybe<FilesBoolExp>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy> | FilesOrderBy>;
}>;


export type ListFilesQuery = { __typename?: 'query_root', files: Array<{ __typename?: 'Files', id: string, filename: string, bucket: string, objectKey: string, size?: number | null, mimetype?: string | null, url?: string | null, clientId?: string | null, payrollId?: string | null, uploadedBy?: string | null, category?: string | null, isPublic?: boolean | null, metadata?: any | null, fileType?: string | null, createdAt?: string | null, client?: { __typename?: 'Clients', name: string } | null, payroll?: { __typename?: 'Payrolls', name: string } | null }>, filesAggregate: { __typename?: 'FilesAggregate', aggregate?: { __typename?: 'FilesAggregateFields', count: number } | null } };

export type RecentActivitySubscriptionVariables = Exact<{
  resourceTypes?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type RecentActivitySubscription = { __typename?: 'subscription_root', auditAuditLog: Array<{ __typename?: 'AuditAuditLog', id: string, userId?: string | null, userEmail?: string | null, userRole?: string | null, action: string, resourceType: string, resourceId?: string | null, eventTime: string, success?: boolean | null, errorMessage?: string | null, ipAddress?: any | null, userAgent?: string | null, requestId?: string | null, sessionId?: string | null, metadata?: any | null, oldValues?: any | null, newValues?: any | null, createdAt?: string | null }> };

export type AuthenticationEventsSubscriptionVariables = Exact<{
  userId?: InputMaybe<Scalars['uuid']['input']>;
}>;


export type AuthenticationEventsSubscription = { __typename?: 'subscription_root', auditAuthEvents: Array<{ __typename?: 'AuditAuthEvents', id: string, userId?: string | null, userEmail?: string | null, eventType: string, eventTime: string, success?: boolean | null, failureReason?: string | null, ipAddress?: any | null, userAgent?: string | null, metadata?: any | null }> };

export type SensitiveDataAccessSubscriptionVariables = Exact<{
  resourceTypes: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type SensitiveDataAccessSubscription = { __typename?: 'subscription_root', auditDataAccessLog: Array<{ __typename?: 'AuditDataAccessLog', id: string, userId: string, resourceType: string, resourceId?: string | null, accessType: string, accessedAt: string, dataClassification?: string | null, fieldsAccessed?: Array<string> | null, rowCount?: number | null, ipAddress?: any | null, metadata?: any | null }> };

export type PermissionChangeStreamSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type PermissionChangeStreamSubscription = { __typename?: 'subscription_root', auditPermissionChanges: Array<{ __typename?: 'AuditPermissionChanges', id: string, changedAt: string, changedByUserId: string, targetUserId?: string | null, targetRoleId?: string | null, changeType: string, permissionType?: string | null, oldPermissions?: any | null, newPermissions?: any | null, reason?: string | null, approvedByUserId?: string | null }> };

export const UserMinimalFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}}]} as unknown as DocumentNode<UserMinimalFragment, unknown>;
export const UserCoreSharedFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserCoreShared"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"isActive"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}}]} as unknown as DocumentNode<UserCoreSharedFragment, unknown>;
export const UserBasicFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserBasic"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserCoreShared"}},{"kind":"Field","name":{"kind":"Name","value":"clerkUserId"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserCoreShared"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"isActive"}}]}}]} as unknown as DocumentNode<UserBasicFragment, unknown>;
export const UserBaseFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserBasic"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserCoreShared"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"isActive"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserBasic"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserCoreShared"}},{"kind":"Field","name":{"kind":"Name","value":"clerkUserId"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}}]} as unknown as DocumentNode<UserBaseFragment, unknown>;
export const UserWithRoleFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserWithRole"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserBasic"}},{"kind":"Field","name":{"kind":"Name","value":"username"}},{"kind":"Field","name":{"kind":"Name","value":"isStaff"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserCoreShared"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"isActive"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserBasic"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserCoreShared"}},{"kind":"Field","name":{"kind":"Name","value":"clerkUserId"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}}]} as unknown as DocumentNode<UserWithRoleFragment, unknown>;
export const UserProfileFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserProfile"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserWithRole"}},{"kind":"Field","name":{"kind":"Name","value":"clerkUserId"}},{"kind":"Field","name":{"kind":"Name","value":"image"}},{"kind":"Field","name":{"kind":"Name","value":"managerId"}},{"kind":"Field","name":{"kind":"Name","value":"deactivatedAt"}},{"kind":"Field","name":{"kind":"Name","value":"deactivatedBy"}},{"kind":"Field","name":{"kind":"Name","value":"manager"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserCoreShared"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"isActive"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserBasic"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserCoreShared"}},{"kind":"Field","name":{"kind":"Name","value":"clerkUserId"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserWithRole"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserBasic"}},{"kind":"Field","name":{"kind":"Name","value":"username"}},{"kind":"Field","name":{"kind":"Name","value":"isStaff"}}]}}]} as unknown as DocumentNode<UserProfileFragment, unknown>;
export const UserSearchResultFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserSearchResult"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserCoreShared"}},{"kind":"Field","name":{"kind":"Name","value":"username"}},{"kind":"Field","name":{"kind":"Name","value":"isStaff"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserCoreShared"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"isActive"}}]}}]} as unknown as DocumentNode<UserSearchResultFragment, unknown>;
export const ClientMinimalFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]} as unknown as DocumentNode<ClientMinimalFragment, unknown>;
export const ClientBaseFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"active"}},{"kind":"Field","name":{"kind":"Name","value":"contactEmail"}},{"kind":"Field","name":{"kind":"Name","value":"contactPerson"}},{"kind":"Field","name":{"kind":"Name","value":"contactPhone"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]} as unknown as DocumentNode<ClientBaseFragment, unknown>;
export const ClientWithStatsFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientWithStats"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ClientBase"}},{"kind":"Field","alias":{"kind":"Name","value":"currentEmployeeCount"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sum"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}}]}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"activePayrollCount"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"status"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"StringValue","value":"Active","block":false}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"active"}},{"kind":"Field","name":{"kind":"Name","value":"contactEmail"}},{"kind":"Field","name":{"kind":"Name","value":"contactPerson"}},{"kind":"Field","name":{"kind":"Name","value":"contactPhone"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]} as unknown as DocumentNode<ClientWithStatsFragment, unknown>;
export const ClientListBaseFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientListBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ClientBase"}},{"kind":"Field","alias":{"kind":"Name","value":"payrollCount"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"active"}},{"kind":"Field","name":{"kind":"Name","value":"contactEmail"}},{"kind":"Field","name":{"kind":"Name","value":"contactPerson"}},{"kind":"Field","name":{"kind":"Name","value":"contactPhone"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]} as unknown as DocumentNode<ClientListBaseFragment, unknown>;
export const PayrollMinimalFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}}]}}]} as unknown as DocumentNode<PayrollMinimalFragment, unknown>;
export const PayrollBaseFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"payrollSystem"}},{"kind":"Field","name":{"kind":"Name","value":"processingTime"}},{"kind":"Field","name":{"kind":"Name","value":"processingDaysBeforeEft"}},{"kind":"Field","name":{"kind":"Name","value":"versionNumber"}},{"kind":"Field","name":{"kind":"Name","value":"supersededDate"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}}]} as unknown as DocumentNode<PayrollBaseFragment, unknown>;
export const PayrollWithClientFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollWithClient"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollBase"}},{"kind":"Field","name":{"kind":"Name","value":"clientId"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"active"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"payrollSystem"}},{"kind":"Field","name":{"kind":"Name","value":"processingTime"}},{"kind":"Field","name":{"kind":"Name","value":"processingDaysBeforeEft"}},{"kind":"Field","name":{"kind":"Name","value":"versionNumber"}},{"kind":"Field","name":{"kind":"Name","value":"supersededDate"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}}]} as unknown as DocumentNode<PayrollWithClientFragment, unknown>;
export const PayrollListItemFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollListItem"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollWithClient"}},{"kind":"Field","name":{"kind":"Name","value":"primaryConsultantUserId"}},{"kind":"Field","name":{"kind":"Name","value":"backupConsultantUserId"}},{"kind":"Field","name":{"kind":"Name","value":"managerUserId"}},{"kind":"Field","name":{"kind":"Name","value":"createdByUserId"}},{"kind":"Field","name":{"kind":"Name","value":"cycleId"}},{"kind":"Field","name":{"kind":"Name","value":"dateTypeId"}},{"kind":"Field","name":{"kind":"Name","value":"dateValue"}},{"kind":"Field","name":{"kind":"Name","value":"payrollCycle"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}},{"kind":"Field","name":{"kind":"Name","value":"payrollDateType"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}},{"kind":"Field","name":{"kind":"Name","value":"primaryConsultant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}},{"kind":"Field","name":{"kind":"Name","value":"backupConsultant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}},{"kind":"Field","name":{"kind":"Name","value":"assignedManager"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"payrollSystem"}},{"kind":"Field","name":{"kind":"Name","value":"processingTime"}},{"kind":"Field","name":{"kind":"Name","value":"processingDaysBeforeEft"}},{"kind":"Field","name":{"kind":"Name","value":"versionNumber"}},{"kind":"Field","name":{"kind":"Name","value":"supersededDate"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollWithClient"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollBase"}},{"kind":"Field","name":{"kind":"Name","value":"clientId"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"active"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}}]} as unknown as DocumentNode<PayrollListItemFragment, unknown>;
export const PayrollWithDatesFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollWithDates"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollBase"}},{"kind":"Field","name":{"kind":"Name","value":"goLiveDate"}},{"kind":"Field","name":{"kind":"Name","value":"payrollDates"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"originalEftDate"},"value":{"kind":"EnumValue","value":"ASC"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"originalEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"adjustedEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"notes"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"payrollSystem"}},{"kind":"Field","name":{"kind":"Name","value":"processingTime"}},{"kind":"Field","name":{"kind":"Name","value":"processingDaysBeforeEft"}},{"kind":"Field","name":{"kind":"Name","value":"versionNumber"}},{"kind":"Field","name":{"kind":"Name","value":"supersededDate"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}}]} as unknown as DocumentNode<PayrollWithDatesFragment, unknown>;
export const PayrollFullDetailFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollFullDetail"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollWithDates"}},{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollWithClient"}},{"kind":"Field","name":{"kind":"Name","value":"dateTypeId"}},{"kind":"Field","name":{"kind":"Name","value":"cycleId"}},{"kind":"Field","name":{"kind":"Name","value":"dateValue"}},{"kind":"Field","name":{"kind":"Name","value":"versionReason"}},{"kind":"Field","name":{"kind":"Name","value":"supersededDate"}},{"kind":"Field","name":{"kind":"Name","value":"parentPayrollId"}},{"kind":"Field","name":{"kind":"Name","value":"parentPayroll"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"versionNumber"}}]}},{"kind":"Field","name":{"kind":"Name","value":"childPayrolls"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"versionNumber"},"value":{"kind":"EnumValue","value":"DESC"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"versionNumber"}},{"kind":"Field","name":{"kind":"Name","value":"versionReason"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}},{"kind":"Field","name":{"kind":"Name","value":"primaryConsultant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}},{"kind":"Field","name":{"kind":"Name","value":"backupConsultant"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}},{"kind":"Field","name":{"kind":"Name","value":"assignedManager"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"payrollSystem"}},{"kind":"Field","name":{"kind":"Name","value":"processingTime"}},{"kind":"Field","name":{"kind":"Name","value":"processingDaysBeforeEft"}},{"kind":"Field","name":{"kind":"Name","value":"versionNumber"}},{"kind":"Field","name":{"kind":"Name","value":"supersededDate"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollWithDates"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollBase"}},{"kind":"Field","name":{"kind":"Name","value":"goLiveDate"}},{"kind":"Field","name":{"kind":"Name","value":"payrollDates"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"originalEftDate"},"value":{"kind":"EnumValue","value":"ASC"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"originalEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"adjustedEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"notes"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollWithClient"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollBase"}},{"kind":"Field","name":{"kind":"Name","value":"clientId"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"active"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}}]} as unknown as DocumentNode<PayrollFullDetailFragment, unknown>;
export const NoteWithAuthorFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"NoteWithAuthor"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Notes"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"content"}},{"kind":"Field","name":{"kind":"Name","value":"isImportant"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"entityId"}},{"kind":"Field","name":{"kind":"Name","value":"entityType"}},{"kind":"Field","name":{"kind":"Name","value":"author"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}}]} as unknown as DocumentNode<NoteWithAuthorFragment, unknown>;
export const PermissionBaseFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PermissionBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Permissions"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"resourceId"}},{"kind":"Field","name":{"kind":"Name","value":"description"}},{"kind":"Field","name":{"kind":"Name","value":"legacyPermissionName"}},{"kind":"Field","name":{"kind":"Name","value":"action"}}]}}]} as unknown as DocumentNode<PermissionBaseFragment, unknown>;
export const RoleWithPermissionsFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"RoleWithPermissions"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Roles"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"displayName"}},{"kind":"Field","name":{"kind":"Name","value":"description"}},{"kind":"Field","name":{"kind":"Name","value":"isSystemRole"}},{"kind":"Field","name":{"kind":"Name","value":"priority"}},{"kind":"Field","name":{"kind":"Name","value":"rolePermissions"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"permission"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PermissionBase"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PermissionBase"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Permissions"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"resourceId"}},{"kind":"Field","name":{"kind":"Name","value":"description"}},{"kind":"Field","name":{"kind":"Name","value":"legacyPermissionName"}},{"kind":"Field","name":{"kind":"Name","value":"action"}}]}}]} as unknown as DocumentNode<RoleWithPermissionsFragment, unknown>;
export const AuditLogEntryFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"AuditLogEntry"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditAuditLog"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userId"}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"userRole"}},{"kind":"Field","name":{"kind":"Name","value":"action"}},{"kind":"Field","name":{"kind":"Name","value":"resourceType"}},{"kind":"Field","name":{"kind":"Name","value":"resourceId"}},{"kind":"Field","name":{"kind":"Name","value":"eventTime"}},{"kind":"Field","name":{"kind":"Name","value":"success"}},{"kind":"Field","name":{"kind":"Name","value":"errorMessage"}},{"kind":"Field","name":{"kind":"Name","value":"ipAddress"}},{"kind":"Field","name":{"kind":"Name","value":"userAgent"}},{"kind":"Field","name":{"kind":"Name","value":"requestId"}},{"kind":"Field","name":{"kind":"Name","value":"sessionId"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"oldValues"}},{"kind":"Field","name":{"kind":"Name","value":"newValues"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]} as unknown as DocumentNode<AuditLogEntryFragment, unknown>;
export const AuthEventFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"AuthEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditAuthEvents"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userId"}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"eventType"}},{"kind":"Field","name":{"kind":"Name","value":"eventTime"}},{"kind":"Field","name":{"kind":"Name","value":"success"}},{"kind":"Field","name":{"kind":"Name","value":"failureReason"}},{"kind":"Field","name":{"kind":"Name","value":"ipAddress"}},{"kind":"Field","name":{"kind":"Name","value":"userAgent"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}}]}}]} as unknown as DocumentNode<AuthEventFragment, unknown>;
export const DataAccessLogFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"DataAccessLog"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditDataAccessLog"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userId"}},{"kind":"Field","name":{"kind":"Name","value":"resourceType"}},{"kind":"Field","name":{"kind":"Name","value":"resourceId"}},{"kind":"Field","name":{"kind":"Name","value":"accessType"}},{"kind":"Field","name":{"kind":"Name","value":"accessedAt"}},{"kind":"Field","name":{"kind":"Name","value":"dataClassification"}},{"kind":"Field","name":{"kind":"Name","value":"fieldsAccessed"}},{"kind":"Field","name":{"kind":"Name","value":"rowCount"}},{"kind":"Field","name":{"kind":"Name","value":"ipAddress"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}}]}}]} as unknown as DocumentNode<DataAccessLogFragment, unknown>;
export const PermissionChangeFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PermissionChange"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditPermissionChanges"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"changedAt"}},{"kind":"Field","name":{"kind":"Name","value":"changedByUserId"}},{"kind":"Field","name":{"kind":"Name","value":"targetUserId"}},{"kind":"Field","name":{"kind":"Name","value":"targetRoleId"}},{"kind":"Field","name":{"kind":"Name","value":"changeType"}},{"kind":"Field","name":{"kind":"Name","value":"permissionType"}},{"kind":"Field","name":{"kind":"Name","value":"oldPermissions"}},{"kind":"Field","name":{"kind":"Name","value":"newPermissions"}},{"kind":"Field","name":{"kind":"Name","value":"reason"}},{"kind":"Field","name":{"kind":"Name","value":"approvedByUserId"}}]}}]} as unknown as DocumentNode<PermissionChangeFragment, unknown>;
export const PayrollDateInfoFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollDateInfo"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"PayrollDates"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"originalEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"adjustedEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"notes"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]} as unknown as DocumentNode<PayrollDateInfoFragment, unknown>;
export const PermissionOverrideInfoFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PermissionOverrideInfo"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"PermissionOverrides"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userId"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"resource"}},{"kind":"Field","name":{"kind":"Name","value":"operation"}},{"kind":"Field","name":{"kind":"Name","value":"granted"}},{"kind":"Field","name":{"kind":"Name","value":"reason"}},{"kind":"Field","name":{"kind":"Name","value":"conditions"}},{"kind":"Field","name":{"kind":"Name","value":"expiresAt"}},{"kind":"Field","name":{"kind":"Name","value":"createdBy"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]} as unknown as DocumentNode<PermissionOverrideInfoFragment, unknown>;
export const LogAuditEventDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"LogAuditEvent"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AuditAuditLogInsertInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"insertAuditAuditLog"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"objects"},"value":{"kind":"ListValue","values":[{"kind":"Variable","name":{"kind":"Name","value":"input"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"returning"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"eventTime"}}]}}]}}]}}]} as unknown as DocumentNode<LogAuditEventMutation, LogAuditEventMutationVariables>;
export const InsertFileDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"InsertFile"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"FilesInsertInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"insertFiles"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"objects"},"value":{"kind":"ListValue","values":[{"kind":"Variable","name":{"kind":"Name","value":"input"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"returning"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"filename"}},{"kind":"Field","name":{"kind":"Name","value":"bucket"}},{"kind":"Field","name":{"kind":"Name","value":"objectKey"}},{"kind":"Field","name":{"kind":"Name","value":"size"}},{"kind":"Field","name":{"kind":"Name","value":"mimetype"}},{"kind":"Field","name":{"kind":"Name","value":"url"}},{"kind":"Field","name":{"kind":"Name","value":"clientId"}},{"kind":"Field","name":{"kind":"Name","value":"payrollId"}},{"kind":"Field","name":{"kind":"Name","value":"uploadedBy"}},{"kind":"Field","name":{"kind":"Name","value":"category"}},{"kind":"Field","name":{"kind":"Name","value":"isPublic"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"fileType"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]}}]}}]} as unknown as DocumentNode<InsertFileMutation, InsertFileMutationVariables>;
export const UpdateFileMetadataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"UpdateFileMetadata"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"uuid"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"updates"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"FilesSetInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"updateFilesByPk"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"pkColumns"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}]}},{"kind":"Argument","name":{"kind":"Name","value":"_set"},"value":{"kind":"Variable","name":{"kind":"Name","value":"updates"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"filename"}},{"kind":"Field","name":{"kind":"Name","value":"bucket"}},{"kind":"Field","name":{"kind":"Name","value":"objectKey"}},{"kind":"Field","name":{"kind":"Name","value":"size"}},{"kind":"Field","name":{"kind":"Name","value":"mimetype"}},{"kind":"Field","name":{"kind":"Name","value":"url"}},{"kind":"Field","name":{"kind":"Name","value":"clientId"}},{"kind":"Field","name":{"kind":"Name","value":"payrollId"}},{"kind":"Field","name":{"kind":"Name","value":"uploadedBy"}},{"kind":"Field","name":{"kind":"Name","value":"category"}},{"kind":"Field","name":{"kind":"Name","value":"isPublic"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"fileType"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]}}]} as unknown as DocumentNode<UpdateFileMetadataMutation, UpdateFileMetadataMutationVariables>;
export const DeleteFileDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"DeleteFile"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"uuid"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"deleteFilesByPk"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"filename"}},{"kind":"Field","name":{"kind":"Name","value":"objectKey"}}]}}]}}]} as unknown as DocumentNode<DeleteFileMutation, DeleteFileMutationVariables>;
export const RefreshDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"RefreshData"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"__typename"}}]}}]} as unknown as DocumentNode<RefreshDataMutation, RefreshDataMutationVariables>;
export const GetDashboardMetricsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetDashboardMetrics"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"userId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"uuid"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"clientsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"active"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"activePayrollsAggregate"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"status"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_nin"},"value":{"kind":"ListValue","values":[{"kind":"StringValue","value":"Completed","block":false},{"kind":"StringValue","value":"Failed","block":false}]}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"totalEmployeesAggregate"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sum"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}}]}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"upcomingPayrolls"},"name":{"kind":"Name","value":"payrolls"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"status"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_nin"},"value":{"kind":"ListValue","values":[{"kind":"StringValue","value":"Completed","block":false},{"kind":"StringValue","value":"Failed","block":false},{"kind":"StringValue","value":"Cancelled","block":false}]}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"updatedAt"},"value":{"kind":"EnumValue","value":"DESC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"5"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ClientMinimal"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]} as unknown as DocumentNode<GetDashboardMetricsQuery, GetDashboardMetricsQueryVariables>;
export const GetDashboardStatsOptimizedDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetDashboardStatsOptimized"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"limit"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}},"defaultValue":{"kind":"IntValue","value":"10"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"clientsAggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"totalPayrolls"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"activePayrolls"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"status"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"StringValue","value":"Active","block":false}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"upcomingPayrolls"},"name":{"kind":"Name","value":"payrolls"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"status"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"StringValue","value":"Active","block":false}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"payrollDates"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"adjustedEftDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_gte"},"value":{"kind":"StringValue","value":"now()","block":false}}]}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"updatedAt"},"value":{"kind":"EnumValue","value":"DESC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"Variable","name":{"kind":"Name","value":"limit"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"status"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","alias":{"kind":"Name","value":"nextEftDate"},"name":{"kind":"Name","value":"payrollDates"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"adjustedEftDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_gte"},"value":{"kind":"StringValue","value":"now()","block":false}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"adjustedEftDate"},"value":{"kind":"EnumValue","value":"ASC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"1"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"originalEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"adjustedEftDate"}},{"kind":"Field","name":{"kind":"Name","value":"processingDate"}}]}}]}}]}}]} as unknown as DocumentNode<GetDashboardStatsOptimizedQuery, GetDashboardStatsOptimizedQueryVariables>;
export const GetClientsDashboardStatsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetClientsDashboardStats"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"activeClientsCount"},"name":{"kind":"Name","value":"clientsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"active"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"totalPayrollsCount"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"totalEmployeesSum"},"name":{"kind":"Name","value":"payrollsAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"sum"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}}]}}]}}]}},{"kind":"Field","alias":{"kind":"Name","value":"clientsNeedingAttention"},"name":{"kind":"Name","value":"clients"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"active"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"_not"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"payrolls"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ClientMinimal"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}}]} as unknown as DocumentNode<GetClientsDashboardStatsQuery, GetClientsDashboardStatsQueryVariables>;
export const GetCurrentUserDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetCurrentUser"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"userId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"uuid"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"user"},"name":{"kind":"Name","value":"usersByPk"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"userId"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserProfile"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserCoreShared"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"role"}},{"kind":"Field","name":{"kind":"Name","value":"isActive"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserBasic"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserCoreShared"}},{"kind":"Field","name":{"kind":"Name","value":"clerkUserId"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"updatedAt"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserWithRole"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserBasic"}},{"kind":"Field","name":{"kind":"Name","value":"username"}},{"kind":"Field","name":{"kind":"Name","value":"isStaff"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserProfile"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserWithRole"}},{"kind":"Field","name":{"kind":"Name","value":"clerkUserId"}},{"kind":"Field","name":{"kind":"Name","value":"image"}},{"kind":"Field","name":{"kind":"Name","value":"managerId"}},{"kind":"Field","name":{"kind":"Name","value":"deactivatedAt"}},{"kind":"Field","name":{"kind":"Name","value":"deactivatedBy"}},{"kind":"Field","name":{"kind":"Name","value":"manager"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}}]}}]} as unknown as DocumentNode<GetCurrentUserQuery, GetCurrentUserQueryVariables>;
export const GetUsersForDropdownDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetUsersForDropdown"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"role"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"user_role"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"users"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"isActive"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"BooleanValue","value":true}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"role"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"Variable","name":{"kind":"Name","value":"role"}}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"computedName"},"value":{"kind":"EnumValue","value":"ASC"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}}]} as unknown as DocumentNode<GetUsersForDropdownQuery, GetUsersForDropdownQueryVariables>;
export const GetSystemHealthDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetSystemHealth"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"databaseHealth"},"name":{"kind":"Name","value":"users"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"1"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}}]}},{"kind":"Field","alias":{"kind":"Name","value":"recentActivity"},"name":{"kind":"Name","value":"auditAuditLogAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"eventTime"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_gte"},"value":{"kind":"StringValue","value":"now() - interval '1 hour'","block":false}}]}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}}]}}]} as unknown as DocumentNode<GetSystemHealthQuery, GetSystemHealthQueryVariables>;
export const GlobalSearchDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GlobalSearch"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"clients"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_or"},"value":{"kind":"ListValue","values":[{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"name"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_ilike"},"value":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}}}]}}]},{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"contactEmail"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_ilike"},"value":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}}}]}}]}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"5"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ClientMinimal"}}]}},{"kind":"Field","name":{"kind":"Name","value":"users"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_or"},"value":{"kind":"ListValue","values":[{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"computedName"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_ilike"},"value":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}}}]}}]},{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"firstName"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_ilike"},"value":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}}}]}}]},{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"lastName"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_ilike"},"value":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}}}]}}]},{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"email"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_ilike"},"value":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}}}]}}]}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"5"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"UserMinimal"}}]}},{"kind":"Field","name":{"kind":"Name","value":"payrolls"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"client"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"name"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_ilike"},"value":{"kind":"Variable","name":{"kind":"Name","value":"searchTerm"}}}]}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"supersededDate"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_isNull"},"value":{"kind":"BooleanValue","value":true}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"5"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PayrollMinimal"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"ClientMinimal"}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"ClientMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Clients"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"UserMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Users"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}},{"kind":"Field","name":{"kind":"Name","value":"computedName"}},{"kind":"Field","name":{"kind":"Name","value":"email"}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PayrollMinimal"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Payrolls"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"employeeCount"}},{"kind":"Field","name":{"kind":"Name","value":"status"}}]}}]} as unknown as DocumentNode<GlobalSearchQuery, GlobalSearchQueryVariables>;
export const GetFileByIdDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetFileById"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"uuid"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"filesByPk"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"filename"}},{"kind":"Field","name":{"kind":"Name","value":"bucket"}},{"kind":"Field","name":{"kind":"Name","value":"objectKey"}},{"kind":"Field","name":{"kind":"Name","value":"size"}},{"kind":"Field","name":{"kind":"Name","value":"mimetype"}},{"kind":"Field","name":{"kind":"Name","value":"url"}},{"kind":"Field","name":{"kind":"Name","value":"clientId"}},{"kind":"Field","name":{"kind":"Name","value":"payrollId"}},{"kind":"Field","name":{"kind":"Name","value":"uploadedBy"}},{"kind":"Field","name":{"kind":"Name","value":"category"}},{"kind":"Field","name":{"kind":"Name","value":"isPublic"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"fileType"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"payroll"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"uploadedBy"}}]}}]}}]} as unknown as DocumentNode<GetFileByIdQuery, GetFileByIdQueryVariables>;
export const ListFilesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"ListFiles"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"where"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"FilesBoolExp"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"limit"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"offset"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"FilesOrderBy"}}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"files"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"Variable","name":{"kind":"Name","value":"limit"}}},{"kind":"Argument","name":{"kind":"Name","value":"offset"},"value":{"kind":"Variable","name":{"kind":"Name","value":"offset"}}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"Variable","name":{"kind":"Name","value":"orderBy"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"filename"}},{"kind":"Field","name":{"kind":"Name","value":"bucket"}},{"kind":"Field","name":{"kind":"Name","value":"objectKey"}},{"kind":"Field","name":{"kind":"Name","value":"size"}},{"kind":"Field","name":{"kind":"Name","value":"mimetype"}},{"kind":"Field","name":{"kind":"Name","value":"url"}},{"kind":"Field","name":{"kind":"Name","value":"clientId"}},{"kind":"Field","name":{"kind":"Name","value":"payrollId"}},{"kind":"Field","name":{"kind":"Name","value":"uploadedBy"}},{"kind":"Field","name":{"kind":"Name","value":"category"}},{"kind":"Field","name":{"kind":"Name","value":"isPublic"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"fileType"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}},{"kind":"Field","name":{"kind":"Name","value":"client"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"payroll"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"uploadedBy"}}]}},{"kind":"Field","name":{"kind":"Name","value":"filesAggregate"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"Variable","name":{"kind":"Name","value":"where"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"aggregate"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"count"}}]}}]}}]}}]} as unknown as DocumentNode<ListFilesQuery, ListFilesQueryVariables>;
export const RecentActivityDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"RecentActivity"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"resourceTypes"}},"type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"auditAuditLog"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"resourceType"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_in"},"value":{"kind":"Variable","name":{"kind":"Name","value":"resourceTypes"}}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"eventTime"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_gte"},"value":{"kind":"StringValue","value":"now() - interval '5 minutes'","block":false}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"eventTime"},"value":{"kind":"EnumValue","value":"DESC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"20"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"AuditLogEntry"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"AuditLogEntry"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditAuditLog"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userId"}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"userRole"}},{"kind":"Field","name":{"kind":"Name","value":"action"}},{"kind":"Field","name":{"kind":"Name","value":"resourceType"}},{"kind":"Field","name":{"kind":"Name","value":"resourceId"}},{"kind":"Field","name":{"kind":"Name","value":"eventTime"}},{"kind":"Field","name":{"kind":"Name","value":"success"}},{"kind":"Field","name":{"kind":"Name","value":"errorMessage"}},{"kind":"Field","name":{"kind":"Name","value":"ipAddress"}},{"kind":"Field","name":{"kind":"Name","value":"userAgent"}},{"kind":"Field","name":{"kind":"Name","value":"requestId"}},{"kind":"Field","name":{"kind":"Name","value":"sessionId"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"oldValues"}},{"kind":"Field","name":{"kind":"Name","value":"newValues"}},{"kind":"Field","name":{"kind":"Name","value":"createdAt"}}]}}]} as unknown as DocumentNode<RecentActivitySubscription, RecentActivitySubscriptionVariables>;
export const AuthenticationEventsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"AuthenticationEvents"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"userId"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"uuid"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"auditAuthEvents"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"userId"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_eq"},"value":{"kind":"Variable","name":{"kind":"Name","value":"userId"}}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"eventTime"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_gte"},"value":{"kind":"StringValue","value":"now() - interval '10 minutes'","block":false}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"eventTime"},"value":{"kind":"EnumValue","value":"DESC"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"AuthEvent"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"AuthEvent"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditAuthEvents"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userId"}},{"kind":"Field","name":{"kind":"Name","value":"userEmail"}},{"kind":"Field","name":{"kind":"Name","value":"eventType"}},{"kind":"Field","name":{"kind":"Name","value":"eventTime"}},{"kind":"Field","name":{"kind":"Name","value":"success"}},{"kind":"Field","name":{"kind":"Name","value":"failureReason"}},{"kind":"Field","name":{"kind":"Name","value":"ipAddress"}},{"kind":"Field","name":{"kind":"Name","value":"userAgent"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}}]}}]} as unknown as DocumentNode<AuthenticationEventsSubscription, AuthenticationEventsSubscriptionVariables>;
export const SensitiveDataAccessDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"SensitiveDataAccess"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"resourceTypes"}},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"auditDataAccessLog"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"where"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"resourceType"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_in"},"value":{"kind":"Variable","name":{"kind":"Name","value":"resourceTypes"}}}]}},{"kind":"ObjectField","name":{"kind":"Name","value":"accessedAt"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"_gte"},"value":{"kind":"StringValue","value":"now() - interval '10 minutes'","block":false}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"accessedAt"},"value":{"kind":"EnumValue","value":"DESC"}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"DataAccessLog"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"DataAccessLog"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditDataAccessLog"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"userId"}},{"kind":"Field","name":{"kind":"Name","value":"resourceType"}},{"kind":"Field","name":{"kind":"Name","value":"resourceId"}},{"kind":"Field","name":{"kind":"Name","value":"accessType"}},{"kind":"Field","name":{"kind":"Name","value":"accessedAt"}},{"kind":"Field","name":{"kind":"Name","value":"dataClassification"}},{"kind":"Field","name":{"kind":"Name","value":"fieldsAccessed"}},{"kind":"Field","name":{"kind":"Name","value":"rowCount"}},{"kind":"Field","name":{"kind":"Name","value":"ipAddress"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}}]}}]} as unknown as DocumentNode<SensitiveDataAccessSubscription, SensitiveDataAccessSubscriptionVariables>;
export const PermissionChangeStreamDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"subscription","name":{"kind":"Name","value":"PermissionChangeStream"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"auditPermissionChanges"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"changedAt"},"value":{"kind":"EnumValue","value":"DESC"}}]}},{"kind":"Argument","name":{"kind":"Name","value":"limit"},"value":{"kind":"IntValue","value":"10"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"PermissionChange"}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"PermissionChange"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"AuditPermissionChanges"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"changedAt"}},{"kind":"Field","name":{"kind":"Name","value":"changedByUserId"}},{"kind":"Field","name":{"kind":"Name","value":"targetUserId"}},{"kind":"Field","name":{"kind":"Name","value":"targetRoleId"}},{"kind":"Field","name":{"kind":"Name","value":"changeType"}},{"kind":"Field","name":{"kind":"Name","value":"permissionType"}},{"kind":"Field","name":{"kind":"Name","value":"oldPermissions"}},{"kind":"Field","name":{"kind":"Name","value":"newPermissions"}},{"kind":"Field","name":{"kind":"Name","value":"reason"}},{"kind":"Field","name":{"kind":"Name","value":"approvedByUserId"}}]}}]} as unknown as DocumentNode<PermissionChangeStreamSubscription, PermissionChangeStreamSubscriptionVariables>;